<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>바이낸스 선물 USDT 페어 15분봉 스캐너 (MA7/25/99 조건)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { --fg:#111; --bg:#fff; --muted:#666; --ok:#087f5b; --bad:#c92a2a; --chip:#f1f3f5; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", sans-serif; color:var(--fg); background:var(--bg); margin:0; }
        header { padding:16px 20px; border-bottom:1px solid #e9ecef; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
        h1 { font-size:18px; margin:0; }
        .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
        button, .chip { border:1px solid #dee2e6; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
        button:hover { background:#f8f9fa; }
        .chip { background:var(--chip); cursor:default; }
        .ok { color:var(--ok); font-weight:600; }
        .bad { color:var(--bad); font-weight:600; }
        main { padding:14px 20px 40px; }
        table { width:100%; border-collapse:collapse; font-size:14px; }
        th, td { padding:10px 8px; border-bottom:1px solid #f1f3f5; text-align:right; }
        th { position:sticky; top:0; background:#fff; z-index:1; }
        td.symbol, th.symbol { text-align:left; }
        .muted { color:var(--muted); }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        .row-ok { background: #f8fff9; }
        .small { font-size:12px; }
        .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f3f5; }
        .right { margin-left:auto; }
        .footer { padding:10px 20px; font-size:12px; color:#666; border-top:1px solid #e9ecef; }
    </style>
</head>
<body>
<header>
    <h1>USDT-M PERP 15분봉 스캐너 · MA7/25/99 조건</h1>
    <div class="controls">
        <button id="scanNowBtn">지금 스캔</button>
        <button id="toggleAutoBtn">자동 스캔: 켜짐</button>
        <span class="chip" id="nextScanChip">다음 스캔까지 —</span>
        <span class="chip" id="statusChip">상태: 준비</span>
        <span class="chip" id="countChip">결과 0개</span>
        <label class="chip"><input id="sortByVol" type="checkbox" checked /> 거래량순 정렬</label>
    </div>
</header>

<main>
    <div class="small muted" id="lastRunInfo">마지막 스캔: —</div>
    <div style="overflow:auto; margin-top:8px;">
        <table id="resultTable">
            <thead>
                <tr>
                    <th class="symbol">심볼</th>
                    <th>직전봉 종가</th>
                    <th>MA7 (t-1)</th>
                    <th>MA25 (t-1)</th>
                    <th>MA99 (t-1)</th>
                    <th>MA7↑</th>
                    <th>MA25↑</th>
                    <th>MA99↑</th>
                    <th>직전봉 거래량</th>
                </tr>
            </thead>
            <tbody id="tbody">
                <tr><td colspan="9" class="muted">스캔 대기 중…</td></tr>
            </tbody>
        </table>
    </div>
</main>

<div class="footer">
    * 조건: 직전봉 종가 &gt; MA7/25/99 (모두), 그리고 각 MA가 2봉전 대비 상승(MA[t-2] &lt; MA[t-1]).<br/>
    * 봉 마감 직후 API 반영이 1-3초 지연될 수 있어, 실행 시점은 마감 후 약간의 딜레이(기본 3초)를 둡니다. <br/>
    * 투자 책임은 본인에게 있으며, 본 도구는 보조 지표용 참고 자료입니다.
</div>

<script>
(() => {
    "use strict";

    // ======== 설정값 ========
    const INTERVAL = "15m";
    const INTERVAL_MS = 15 * 60 * 1000;
    const KLINE_LIMIT = 150; // MA99 계산 + 여유
    const CONCURRENCY = 8;   // 동시 요청 개수 (레이트 리밋 고려)
    const AUTO_DELAY_MS = 3000; // 봉 마감 후 지연 실행(ms)

    // ======== DOM ========
    const scanNowBtn = document.getElementById("scanNowBtn");
    const toggleAutoBtn = document.getElementById("toggleAutoBtn");
    const nextScanChip = document.getElementById("nextScanChip");
    const statusChip = document.getElementById("statusChip");
    const countChip = document.getElementById("countChip");
    const lastRunInfo = document.getElementById("lastRunInfo");
    const sortByVol = document.getElementById("sortByVol");
    const tbody = document.getElementById("tbody");

    // ======== 상태 ========
    let symbols = [];
    let autoScan = true;
    let intervalTimer = null;
    let countdownTimer = null;

    // ======== 유틸 ========
    function fmtNum(n, d = 8) {
        if (Number.isNaN(n) || n === null || n === undefined) return "-";
        const s = Number(n);
        // 자리수 과도 방지: 큰 값은 2~4자리, 작은 값은 유효숫자 표시
        if (Math.abs(s) >= 100) return s.toLocaleString();
        return s.toLocaleString(undefined, { maximumFractionDigits: d });
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchJSON(url, tries = 3) {
        for (let i = 0; i < tries; i++) {
            try {
                const res = await fetch(url, { cache: "no-store" });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return await res.json();
            } catch (err) {
                if (i === tries - 1) throw err;
                await sleep(250 * (i + 1));
            }
        }
    }

    function sma(values, endIndex, length) {
        const start = endIndex - length + 1;
        if (start < 0) return null;
        let sum = 0;
        for (let i = start; i <= endIndex; i++) sum += values[i];
        return sum / length;
    }

    function nextCandleCloseMs(now = Date.now()) {
        // 다음 15분 경계(봉 마감 시점) + 딜레이
        const next = Math.ceil(now / INTERVAL_MS) * INTERVAL_MS + AUTO_DELAY_MS;
        return next;
    }

    function startCountdown() {
        stopCountdown();
        countdownTimer = setInterval(() => {
            const now = Date.now();
            const next = nextCandleCloseMs(now);
            const remain = next - now;
            const s = Math.max(0, Math.floor(remain / 1000));
            const mm = String(Math.floor(s / 60)).padStart(2, "0");
            const ss = String(s % 60).padStart(2, "0");
            nextScanChip.textContent = `다음 스캔까지 ${mm}:${ss}`;
        }, 250);
    }

    function stopCountdown() {
        if (countdownTimer) clearInterval(countdownTimer);
        countdownTimer = null;
    }

    function setStatus(txt) { statusChip.textContent = `상태: ${txt}`; }

    // 심볼 목록(USDT-M 무기한, 거래중) 로드
    async function loadSymbols() {
        setStatus("심볼 로딩");
        const info = await fetchJSON("https://fapi.binance.com/fapi/v1/exchangeInfo");
        const list = (info.symbols || [])
            .filter(s =>
                s.quoteAsset === "USDT" &&
                s.contractType === "PERPETUAL" &&
                s.status === "TRADING"
            )
            .map(s => s.symbol)
            .sort();
        symbols = list;
        setStatus(`심볼 ${symbols.length}개`);
    }

    // 개별 심볼 스캔
    async function scanSymbol(symbol) {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${KLINE_LIMIT}`;
        const data = await fetchJSON(url);
        if (!Array.isArray(data) || data.length < 120) return null; // 데이터 부족 심볼 스킵

        // kline: [0]openTime,[1]open,[2]high,[3]low,[4]close,[5]volume,[6]closeTime,... 
        const closes = data.map(k => parseFloat(k[4]));
        const vols = data.map(k => parseFloat(k[5]));
        const n = closes.length;

        // 마지막 원소는 진행중인 현재봉일 수 있으므로 직전봉은 n-2, 2봉전은 n-3
        const prev = n - 2;
        const twoAgo = n - 3;
        if (twoAgo < 0) return null;

        const prevClose = closes[prev];

        const ma7_prev = sma(closes, prev, 7);
        const ma25_prev = sma(closes, prev, 25);
        const ma99_prev = sma(closes, prev, 99);

        const ma7_two = sma(closes, twoAgo, 7);
        const ma25_two = sma(closes, twoAgo, 25);
        const ma99_two = sma(closes, twoAgo, 99);

        if ([ma7_prev, ma25_prev, ma99_prev, ma7_two, ma25_two, ma99_two].some(v => v === null)) {
            return null; // 충분한 히스토리 없음
        }

        const condCloseOver = (prevClose > ma7_prev) && (prevClose > ma25_prev) && (prevClose > ma99_prev);
        const condSlopeUp = (ma7_two < ma7_prev) && (ma25_two < ma25_prev) && (ma99_two < ma99_prev);

        if (condCloseOver && condSlopeUp) {
            const prevVol = vols[prev];
            return {
                symbol,
                prevClose,
                ma7_prev, ma25_prev, ma99_prev,
                up7: true, up25: true, up99: true,
                prevVol
            };
        }
        return null;
    }

    // 풀(동시성) 스캔
    async function scanAll() {
        if (!symbols.length) await loadSymbols();

        setStatus("스캔 중");
        tbody.innerHTML = `<tr><td colspan="9" class="muted">스캔 중… (총 ${symbols.length}개)</td></tr>`;

        const results = [];
        let processed = 0;

        async function worker(idxStart) {
            for (let i = idxStart; i < symbols.length; i += CONCURRENCY) {
                try {
                    const r = await scanSymbol(symbols[i]);
                    if (r) results.push(r);
                } catch (e) {
                    // 개별 심볼 오류는 무시하고 진행
                } finally {
                    processed++;
                    statusChip.textContent = `상태: 스캔 ${processed}/${symbols.length}`;
                }
            }
        }

        // 워커 시작
        const workers = [];
        const workerCount = Math.min(CONCURRENCY, symbols.length);
        for (let w = 0; w < workerCount; w++) workers.push(worker(w));
        await Promise.all(workers);

        // 정렬(선택): 거래량 내림차순
        if (sortByVol.checked) {
            results.sort((a, b) => (b.prevVol ?? 0) - (a.prevVol ?? 0));
        } else {
            results.sort((a, b) => a.symbol.localeCompare(b.symbol));
        }

        render(results);
        setStatus("완료");
        const now = new Date();
        lastRunInfo.textContent = `마지막 스캔: ${now.toLocaleString()} (로컬시간)`;
        countChip.textContent = `결과 ${results.length}개`;
    }

    function render(rows) {
        if (!rows.length) {
            tbody.innerHTML = `<tr><td colspan="9" class="muted">조건을 만족하는 심볼이 없습니다.</td></tr>`;
            return;
        }
        const html = rows.map(r => {
            return `
            <tr class="row-ok">
                <td class="symbol"><span class="pill">${r.symbol}</span></td>
                <td class="mono">${fmtNum(r.prevClose, 6)}</td>
                <td class="mono">${fmtNum(r.ma7_prev, 6)}</td>
                <td class="mono">${fmtNum(r.ma25_prev, 6)}</td>
                <td class="mono">${fmtNum(r.ma99_prev, 6)}</td>
                <td class="ok">↑</td>
                <td class="ok">↑</td>
                <td class="ok">↑</td>
                <td class="mono">${fmtNum(r.prevVol, 2)}</td>
            </tr>`;
        }).join("");
        tbody.innerHTML = html;
    }

    function scheduleAuto() {
        // 1) 다음 봉 마감까지 대기 후 스캔 2) 이후 15분마다 반복
        if (intervalTimer) { clearInterval(intervalTimer); intervalTimer = null; }
        const now = Date.now();
        const firstAt = nextCandleCloseMs(now);
        const wait = Math.max(0, firstAt - now);

        setStatus("자동 대기");
        startCountdown();

        setTimeout(async () => {
            if (!autoScan) return;
            await scanAll();
            if (!autoScan) return;

            intervalTimer = setInterval(async () => {
                if (!autoScan) return;
                await scanAll();
            }, INTERVAL_MS);

        }, wait);
    }

    // ======== 이벤트 ========
    scanNowBtn.addEventListener("click", async () => {
        stopCountdown();
        await scanAll();
        if (autoScan) startCountdown();
    });

    toggleAutoBtn.addEventListener("click", () => {
        autoScan = !autoScan;
        toggleAutoBtn.textContent = `자동 스캔: ${autoScan ? "켜짐" : "꺼짐"}`;
        if (autoScan) {
            scheduleAuto();
        } else {
            if (intervalTimer) clearInterval(intervalTimer);
            intervalTimer = null;
            stopCountdown();
            nextScanChip.textContent = "자동 스캔 꺼짐";
            setStatus("수동 모드");
        }
    });

    // ======== 시작 ========
    (async function init() {
        try {
            await loadSymbols();
            // 첫 실행 한 번 즉시 스캔
            await scanAll();
        } catch (e) {
            setStatus("에러");
            tbody.innerHTML = `<tr><td colspan="9" class="bad">초기화 실패: ${String(e && e.message || e)}</td></tr>`;
            return;
        }
        // 자동 스케줄 시작
        scheduleAuto();
    })();
})();
</script>
</body>
</html>
