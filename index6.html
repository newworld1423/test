<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT-M Perp 15m Scanner (Prev 15m Close vs Today 1D Open)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { --bg:#0b1020; --card:#121a33; --accent:#6ea8fe; --text:#eaf0ff; --muted:#9fb2d8; --bad:#ff6b6b; --good:#1dd1a1; }
        * { box-sizing: border-box; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; }
        header { padding: 20px; border-bottom: 1px solid #1c274b; }
        h1 { margin: 0 0 6px 0; font-size: 20px; font-weight: 700; }
        .sub { color: var(--muted); font-size: 13px; }
        .wrap { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .panel { background: var(--card); border: 1px solid #1c274b; border-radius: 16px; padding: 16px; box-shadow: 0 2px 24px rgba(0,0,0,0.25); }
        .controls { display: grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap: 12px; align-items: end; }
        .controls .field { display: flex; flex-direction: column; gap: 6px; }
        label { font-size: 12px; color: var(--muted); }
        input[type="number"], input[type="text"], select {
            background: #0c142b; color: var(--text); border: 1px solid #1f2a52; border-radius: 12px; padding: 10px 12px; outline: none;
        }
        input[type="checkbox"] { transform: translateY(1px); }
        button {
            background: var(--accent); color: #0b1020; border: 0; border-radius: 12px; padding: 12px 14px; font-weight: 700; cursor: pointer;
        }
        button:disabled { opacity: .6; cursor: not-allowed; }
        .stats { display: flex; gap: 16px; flex-wrap: wrap; margin-top: 12px; color: var(--muted); font-size: 13px; }
        .badge { background: #0c142b; border: 1px solid #1f2a52; border-radius: 999px; padding: 6px 10px; color: var(--text); }
        table { width: 100%; border-collapse: collapse; margin-top: 16px; }
        th, td { padding: 12px 10px; border-bottom: 1px solid #1c274b; font-size: 14px; }
        th { text-align: left; color: var(--muted); user-select: none; cursor: pointer; }
        tr:hover { background: rgba(255,255,255,0.03); }
        .right { text-align: right; }
        .pct { font-variant-numeric: tabular-nums; }
        .pct.pos { color: var(--good); font-weight: 700; }
        .pct.neg { color: var(--bad); font-weight: 700; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; letter-spacing: .2px; }
        .muted { color: var(--muted); }
        footer { padding: 16px 20px; font-size: 12px; color: var(--muted); }
        @media (max-width:960px){
            .controls { grid-template-columns: repeat(2, minmax(0,1fr)); }
            th.hide-sm, td.hide-sm { display: none; }
        }
    </style>
</head>
<body>
    <header>
        <div class="wrap">
            <h1>USDT-M Perp 스캐너 · (Prev 15m Close − Today 1D Open) / Prev 15m Close</h1>
            <div class="sub">바이낸스 서버시간·UTC 기준. 15분봉 시작 시 자동 스캔 옵션 제공.</div>
        </div>
    </header>

    <main class="wrap">
        <section class="panel">
            <div class="controls">
                <div class="field">
                    <label for="threshold">임계값(%) · ≥</label>
                    <input id="threshold" type="number" step="0.1" value="8" />
                </div>
                <div class="field">
                    <label for="limitSymbols">스캔 심볼 수 제한(선택)</label>
                    <input id="limitSymbols" type="number" min="1" placeholder="비우면 전체 USDT 페어" />
                </div>
                <div class="field">
                    <label for="concurrency">동시 요청 수(안전)</label>
                    <input id="concurrency" type="number" min="1" value="12" />
                </div>
                <div class="field">
                    <label>자동 스캔(15분봉 경계)</label>
                    <div>
                        <input id="autoScan" type="checkbox" checked />
                        <label for="autoScan">켜기</label>
                    </div>
                </div>
                <div class="field">
                    <label>&nbsp;</label>
                    <button id="scanBtn">지금 스캔</button>
                </div>
                <div class="field">
                    <label>&nbsp;</label>
                    <button id="exportBtn" title="표 데이터를 CSV로 저장">CSV 내보내기</button>
                </div>
            </div>

            <div class="stats" id="stats">
                <span class="badge" id="exInfo">심볼 로딩중…</span>
                <span class="badge" id="lastScan">마지막 스캔: -</span>
                <span class="badge" id="nextScan">다음 자동 스캔: -</span>
                <span class="badge" id="countInfo">표시 0 / 전체 0</span>
            </div>

            <div style="overflow:auto;">
                <table id="resultTable">
                    <thead>
                        <tr>
                            <th style="width:80px;">순위</th>
                            <th>심볼</th>
                            <th class="hide-sm right">이전 15m 종가</th>
                            <th class="hide-sm right">오늘(UTC) 1D 시가</th>
                            <th class="right" data-sortkey="pct">상승률(%) ▲</th>
                        </tr>
                    </thead>
                    <tbody id="tbody">
                        <tr><td colspan="5" class="muted">스캔을 실행하세요.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
    </main>

    <footer>
        데이터 출처: Binance Futures API (USDT-M). 네트워크/레이트리밋 상황에 따라 일부 심볼이 누락될 수 있습니다.
    </footer>

    <script>
        // ===== 설정/상수 =====
        const API_BASE = "https://fapi.binance.com";
        const ENDPOINTS = {
            time: "/fapi/v1/time",
            exchangeInfo: "/fapi/v1/exchangeInfo",
            klines: "/fapi/v1/klines"
        };

        // DOM 참조
        const exInfoEl   = document.getElementById("exInfo");
        const lastScanEl = document.getElementById("lastScan");
        const nextScanEl = document.getElementById("nextScan");
        const countInfoEl= document.getElementById("countInfo");
        const scanBtn    = document.getElementById("scanBtn");
        const exportBtn  = document.getElementById("exportBtn");
        const thresholdEl= document.getElementById("threshold");
        const limitEl    = document.getElementById("limitSymbols");
        const concEl     = document.getElementById("concurrency");
        const autoScanEl = document.getElementById("autoScan");
        const tbody      = document.getElementById("tbody");
        const table      = document.getElementById("resultTable");

        // 상태
        let SYMBOLS = []; // {symbol, pair, contractType, quoteAsset, status}
        let DAILY_OPEN_CACHE = new Map(); // key: symbol|YYYY-MM-DD(UTC) -> number
        let lastResults = []; // 표 데이터 캐시
        let countdownTimer = null;
        let nextScanTimer = null;
        let currentSort = { key: "pct", dir: "desc" };

        // 유틸
        function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
        function fmtPct(v){ return (v*100).toFixed(2); }
        function fmtNum(v){ return Number(v).toLocaleString(undefined, { maximumFractionDigits: 8 }); }
        function utcDateString(ms){
            const d = new Date(ms);
            const y = d.getUTCFullYear();
            const m = String(d.getUTCMonth()+1).padStart(2,"0");
            const day = String(d.getUTCDate()).padStart(2,"0");
            return `${y}-${m}-${day}`;
        }
        function nowLocalString(){ return new Date().toLocaleString(); }

        async function fetchJSON(url){
            const res = await fetch(url);
            if(!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
            return res.json();
        }

        async function getServerTimeMs(){
            const j = await fetchJSON(API_BASE + ENDPOINTS.time);
            return j.serverTime; // ms
        }

        async function loadExchangeInfo(){
            const data = await fetchJSON(API_BASE + ENDPOINTS.exchangeInfo);
            const all = data.symbols || [];
            SYMBOLS = all.filter(s =>
                s.contractType === "PERPETUAL" &&
                s.quoteAsset === "USDT" &&
                s.status === "TRADING"
            ).map(s => ({ symbol: s.symbol, pair: s.pair, contractType: s.contractType, quoteAsset: s.quoteAsset, status: s.status }));

            exInfoEl.textContent = `USDT-M 무기한 심볼: ${SYMBOLS.length.toLocaleString()}개`;
        }

        // Klines
        async function getPrev15mClose(symbol){
            // limit=2 -> [previous closed, current forming]
            const url = `${API_BASE}${ENDPOINTS.klines}?symbol=${symbol}&interval=15m&limit=2`;
            const k = await fetchJSON(url);
            if(!Array.isArray(k) || k.length < 2) throw new Error(`15m klines 부족: ${symbol}`);
            const prev = k[k.length - 2]; // [openTime, open, high, low, close, ...]
            return parseFloat(prev[4]);
        }

        async function getTodayDailyOpen(symbol, serverTimeMs){
            // 1d 최신 봉의 open이 "오늘(UTC) 시가"
            const url = `${API_BASE}${ENDPOINTS.klines}?symbol=${symbol}&interval=1d&limit=1`;
            const k = await fetchJSON(url);
            if(!Array.isArray(k) || k.length < 1) throw new Error(`1d klines 부족: ${symbol}`);
            const last = k[0];
            const openTime = last[0]; // ms
            const dayKey = utcDateString(serverTimeMs);
            const candleDay = utcDateString(openTime);

            // 캐시 키
            const cacheKey = `${symbol}|${dayKey}`;

            // 만약 최근 봉 날짜가 오늘(UTC)이 아니면(드문 경우) 최신 2개를 다시 요청
            if(candleDay !== dayKey){
                const url2 = `${API_BASE}${ENDPOINTS.klines}?symbol=${symbol}&interval=1d&limit=2`;
                const k2 = await fetchJSON(url2);
                const latest = k2[k2.length - 1];
                DAILY_OPEN_CACHE.set(cacheKey, parseFloat(latest[1]));
                return parseFloat(latest[1]);
            }

            const open = parseFloat(last[1]);
            DAILY_OPEN_CACHE.set(cacheKey, open);
            return open;
        }

        // 제한 동시성 실행
        async function runPool(items, limit, worker){
            const ret = [];
            let idx = 0, active = 0;
            return new Promise((resolve) => {
                const next = () => {
                    if(idx >= items.length){
                        if(active === 0) resolve(ret);
                        return;
                    }
                    const i = idx++;
                    active++;
                    Promise.resolve(worker(items[i], i))
                        .then(v => { ret[i] = v; })
                        .catch(e => { ret[i] = { error: e?.message || String(e) }; })
                        .finally(() => { active--; next(); });
                };
                for(let c=0; c<Math.min(limit, items.length); c++) next();
            });
        }

        function msToNext15mBoundary(serverMs){
            const step = 15 * 60 * 1000;
            const rem = serverMs % step;
            return step - rem;
        }

        function scheduleAutoScanLoop(){
            clearTimeout(nextScanTimer);
            clearInterval(countdownTimer);

            if(!autoScanEl.checked){
                nextScanEl.textContent = "다음 자동 스캔: 꺼짐";
                return;
            }

            (async () => {
                const server = await getServerTimeMs();
                let remain = msToNext15mBoundary(server) + 2500; // 2.5s 안전 버퍼
                const targetAt = Date.now() + remain;
                updateCountdown(remain);

                countdownTimer = setInterval(() => {
                    const left = targetAt - Date.now();
                    updateCountdown(Math.max(left, 0));
                }, 250);

                nextScanTimer = setTimeout(async () => {
                    clearInterval(countdownTimer);
                    await doScan(); // 경계 도달 즉시 스캔
                    // 다음 라운드 예약(재귀)
                    scheduleAutoScanLoop();
                }, remain);
            })().catch(err => {
                nextScanEl.textContent = `다음 자동 스캔: 오류 ${err?.message || err}`;
            });
        }

        function updateCountdown(ms){
            const s = Math.ceil(ms / 1000);
            const m = Math.floor(s / 60);
            const ss = String(s % 60).padStart(2, "0");
            nextScanEl.textContent = `다음 자동 스캔: ${m}:${ss}`;
        }

        function setScanning(on){
            scanBtn.disabled = on;
            scanBtn.textContent = on ? "스캔 중…" : "지금 스캔";
        }

        // 메인 스캔
        async function doScan(){
            setScanning(true);
            try{
                const serverMs = await getServerTimeMs();
                const dayKey = utcDateString(serverMs);
                const thresholdPct = (parseFloat(thresholdEl.value) || 8) / 100;
                const limit = parseInt(limitEl.value || "", 10);
                const concurrency = Math.max(1, parseInt(concEl.value || "12", 10));

                // 필요시 심볼 목록 로드
                if(SYMBOLS.length === 0){
                    await loadExchangeInfo();
                }

                const symbols = SYMBOLS.map(s => s.symbol);
                const symbolsLimited = Number.isFinite(limit) ? symbols.slice(0, limit) : symbols;

                // 워커: 심볼별로 prev15 close & today 1d open
                const results = await runPool(symbolsLimited, concurrency, async (symbol) => {
                    try{
                        const [prevClose, dailyOpen] = await Promise.all([
                            getPrev15mClose(symbol),
                            (async () => {
                                const cacheKey = `${symbol}|${dayKey}`;
                                if(DAILY_OPEN_CACHE.has(cacheKey)) return DAILY_OPEN_CACHE.get(cacheKey);
                                return getTodayDailyOpen(symbol, serverMs);
                            })()
                        ]);
                        const pct = (prevClose - dailyOpen) / prevClose;
                        if(!Number.isFinite(pct)) return null;
                        return { symbol, prevClose, dailyOpen, pct };
                    }catch(e){
                        // 개별 심볼 실패는 무시
                        return null;
                    }
                });

                // 필터 & 정렬
                lastResults = (results.filter(Boolean))
                    .filter(r => r.pct >= thresholdPct)
                    .sort((a, b) => b.pct - a.pct);

                renderTable(lastResults);
                lastScanEl.textContent = `마지막 스캔: ${nowLocalString()} (로컬)`;
                countInfoEl.textContent = `표시 ${lastResults.length.toLocaleString()} / 전체 ${symbolsLimited.length.toLocaleString()}`;
            }catch(err){
                alert(`스캔 오류: ${err?.message || err}`);
            }finally{
                setScanning(false);
            }
        }

        function renderTable(rows){
            // 정렬 상태 표시 업데이트
            const ths = table.querySelectorAll("th[data-sortkey]");
            ths.forEach(th => {
                const key = th.getAttribute("data-sortkey");
                const arrow = (currentSort.key === key) ? (currentSort.dir === "asc" ? "▼" : "▲") : "▲";
                th.innerHTML = (key === "pct") ? `상승률(%) ${arrow}` : th.textContent;
            });

            if(rows.length === 0){
                tbody.innerHTML = `<tr><td colspan="5" class="muted">조건을 만족하는 결과가 없습니다.</td></tr>`;
                return;
            }
            const html = rows.map((r, i) => {
                const cls = r.pct >= 0 ? "pct pos" : "pct neg";
                return `
                <tr>
                    <td>${i+1}</td>
                    <td class="mono">${r.symbol}</td>
                    <td class="hide-sm right mono">${fmtNum(r.prevClose)}</td>
                    <td class="hide-sm right mono">${fmtNum(r.dailyOpen)}</td>
                    <td class="right mono ${cls}">${fmtPct(r.pct)}</td>
                </tr>`;
            }).join("");
            tbody.innerHTML = html;
        }

        // 헤더 클릭 정렬(현재는 상승률만 제공)
        table.querySelectorAll("th[data-sortkey]").forEach(th => {
            th.addEventListener("click", () => {
                const key = th.getAttribute("data-sortkey");
                if(currentSort.key === key){
                    currentSort.dir = (currentSort.dir === "asc" ? "desc" : "asc");
                }else{
                    currentSort.key = key;
                    currentSort.dir = "desc";
                }
                const sorted = [...lastResults].sort((a,b) => {
                    const vA = a[key], vB = b[key];
                    return (currentSort.dir === "asc") ? (vA - vB) : (vB - vA);
                });
                renderTable(sorted);
            });
        });

        // CSV 내보내기
        function exportCSV(){
            if(!lastResults.length){
                alert("내보낼 데이터가 없습니다. 먼저 스캔하세요.");
                return;
            }
            const header = ["rank","symbol","prev15m_close","today_1d_open_utc","pct"];
            const rows = lastResults.map((r, i) => [i+1, r.symbol, r.prevClose, r.dailyOpen, (r.pct*100).toFixed(4)]);
            const csv = [header, ...rows].map(line => line.join(",")).join("\n");
            const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `usdtm_scanner_${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        // 이벤트 바인딩
        scanBtn.addEventListener("click", () => doScan());
        exportBtn.addEventListener("click", exportCSV);
        autoScanEl.addEventListener("change", scheduleAutoScanLoop);

        // 초기화
        (async () => {
            try{
                await loadExchangeInfo();      // 심볼 목록 캐싱
                scheduleAutoScanLoop();        // 자동 스캔 루프(카운트다운 포함)
            }catch(err){
                exInfoEl.textContent = `심볼 로딩 오류: ${err?.message || err}`;
            }
        })();
    </script>
</body>
</html>
