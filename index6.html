<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT Perp 롱 스캐너 (자동 15m/1h)</title>
    <style>
        :root {
            --bg: #0f1115; --panel:#161a23; --panel2:#1a2030; --text:#e6eaf2; --muted:#9aa3b2;
            --ok:#71d1b2; --warn:#ffb86b; --bad:#ff6b6b; --accent:#5aa9ff; --radius:12px;
            --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
        }
        * { box-sizing: border-box; }
        html,body { height:100%; }
        body { margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial; }
        header { padding:16px 18px; display:flex; gap:14px; align-items:center; justify-content:space-between; background:linear-gradient(180deg,rgba(90,169,255,.08),transparent); }
        h1 { margin:0; font-size:18px; letter-spacing:-0.02em; }
        .badge { font-size:12px; color:var(--muted); border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:2px 8px; }
        main { padding:16px 18px 28px; display:grid; grid-template-columns: 360px 1fr; gap:16px; }
        @media (max-width: 1080px) { main { grid-template-columns: 1fr; } }
        .panel { background:linear-gradient(180deg,var(--panel),var(--panel2)); border:1px solid rgba(255,255,255,.08); border-radius:var(--radius); padding:14px; }
        .panel h2 { margin:0 0 10px; font-size:16px; }
        .row { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
        .row3 { display:grid; grid-template-columns: repeat(3,1fr); gap:8px; }
        label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
        input, select { width:100%; padding:10px 12px; border-radius:10px; background:rgba(255,255,255,.04); color:var(--text); border:1px solid rgba(255,255,255,.10); }
        .btn { border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--text); border-radius:10px; padding:10px 12px; cursor:pointer; }
        .btn.primary { background:linear-gradient(135deg,rgba(90,169,255,.2),rgba(125,227,154,.2)); }
        .btn.warn { background:linear-gradient(135deg,rgba(255,184,107,.2),rgba(255,107,107,.2)); }
        .help { color:var(--muted); font-size:12px; }
        table { width:100%; border-collapse:collapse; font-size:13px; border-radius:10px; overflow:hidden; }
        thead th { text-align:left; padding:10px 8px; position:sticky; top:0; background:rgba(0,0,0,.35); border-bottom:1px solid rgba(255,255,255,.1); }
        tbody td { padding:8px; border-top:1px solid rgba(255,255,255,.06); vertical-align:top; }
        tbody tr:hover { background:rgba(255,255,255,.04); }
        .mono { font-family: var(--mono); }
        .tag { display:inline-block; font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.16); }
        .tag.ok { color:var(--ok); border-color:rgba(113,209,178,.45); background:rgba(113,209,178,.10); }
        .tag.warn { color:var(--warn); border-color:rgba(255,184,107,.45); background:rgba(255,184,107,.10); }
        .tag.bad { color:var(--bad); border-color:rgba(255,107,107,.45); background:rgba(255,107,107,.10); }
        .toolbar { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:10px; }
        .muted { color: var(--muted); }
        .pill { padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); font-size:12px; }
        .flex { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
        .right { display:flex; gap:8px; align-items:center; }
        .footer-note { margin-top:10px; font-size:12px; color:var(--muted); }
    </style>
</head>
<body>
    <header>
        <div class="flex">
            <h1>Binance USDT Perp 롱 스캐너</h1>
            <span class="badge">Candles-Only · 15m/1h Auto</span>
        </div>
        <div class="flex muted">
            <span id="chosenInterval" class="pill">interval: -</span>
            <span id="noiseInfo" class="pill">noise: -</span>
            <span id="nextRun" class="pill">next: -</span>
        </div>
    </header>

    <main>
        <section class="panel">
            <h2>설정</h2>
            <div class="row3">
                <div>
                    <label>시드(USDT)</label>
                    <input id="equity" type="number" value="10000" step="10" min="0" />
                </div>
                <div>
                    <label>트레이드당 리스크(%)</label>
                    <input id="riskPct" type="number" value="1" step="0.1" min="0.1" max="5" />
                </div>
                <div>
                    <label>증거금 사용 비율(%)</label>
                    <input id="marginPct" type="number" value="20" step="1" min="1" max="100" />
                </div>
            </div>
            <div class="row3" style="margin-top:8px;">
                <div>
                    <label>최대 레버리지(배)</label>
                    <input id="maxLev" type="number" value="5" step="1" min="1" max="125" />
                </div>
                <div>
                    <label>패턴 최소 등급</label>
                    <select id="minTier">
                        <option value="A" selected>A (강한)</option>
                        <option value="B">B (중간)</option>
                        <option value="ALL">모두</option>
                    </select>
                </div>
                <div>
                    <label>타임프레임 모드</label>
                    <select id="tfMode">
                        <option value="auto" selected>자동(15m/1h)</option>
                        <option value="15m">강제 15m</option>
                        <option value="1h">강제 1h</option>
                    </select>
                </div>
            </div>
            <details style="margin-top:8px;">
                <summary class="muted">감지할 패턴 선택 (클릭하여 펼치기)</summary>
                <div class="row" style="margin-top:8px;">
                    <label><input type="checkbox" class="pat" value="kicker" checked /> 강세 키커(A)</label>
                    <label><input type="checkbox" class="pat" value="engulf" checked /> 강세 장악(A)</label>
                    <label><input type="checkbox" class="pat" value="morning" checked /> 샛별형(A)</label>
                    <label><input type="checkbox" class="pat" value="hammer" checked /> 망치형(A)</label>
                    <label><input type="checkbox" class="pat" value="r3m" checked /> 상승 삼법(A)</label>
                    <label><input type="checkbox" class="pat" value="soldiers" checked /> 백삼병(A)</label>
                    <label><input type="checkbox" class="pat" value="piercing" checked /> 관통형(B)</label>
                    <label><input type="checkbox" class="pat" value="harami" checked /> 불리시 하라미(B)</label>
                    <label><input type="checkbox" class="pat" value="tweezer" checked /> 트위저 바닥(B)</label>
                    <label><input type="checkbox" class="pat" value="belt" checked /> 상승 벨트홀드(B)</label>
                </div>
                <div class="help" style="margin-top:6px;">암호화폐 특성상 갭 조건은 무시(24/7). 전부 “캔들만”으로 판별합니다.</div>
            </details>
            <div class="flex" style="margin-top:12px;">
                <button id="btnScanNow" class="btn primary">지금 스캔</button>
                <button id="btnToggleAuto" class="btn">자동스캔: ON</button>
            </div>
            <div class="footer-note">⛑ 교육용 데모. 실계좌 적용 전 테스트 필수.</div>
        </section>

        <section class="panel">
            <div class="toolbar">
                <h2 style="margin:0;">즉시 진입 가능 신호(USDT Perp)</h2>
                <div class="right">
                    <span id="summary" class="help">-</span>
                </div>
            </div>
            <div style="overflow:auto; max-height:70vh;">
                <table id="tbl">
                    <thead>
                        <tr>
                            <th>심볼</th>
                            <th>패턴</th>
                            <th>상태</th>
                            <th class="mono">현재가</th>
                            <th class="mono">엔트리</th>
                            <th class="mono">스톱</th>
                            <th class="mono">폭</th>
                            <th class="mono">추천 레버리지</th>
                            <th class="mono">증거금%</th>
                            <th class="mono">명목가%</th>
                            <th class="mono">수량</th>
                            <th class="mono">1R</th>
                            <th class="mono">2R</th>
                            <th class="mono">3R</th>
                            <th>메모</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </section>
    </main>

<script>
/* ========= 유틸 ========= */
const API = "https://fapi.binance.com";
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
function fmt(n, d=6){ return (typeof n==="number" && isFinite(n)) ? n.toLocaleString(undefined,{maximumFractionDigits:d}) : "-"; }
function pct(n, d=2){ return (typeof n==="number" && isFinite(n)) ? (n*100).toFixed(d)+"%" : "-"; }
function nowMs(){ return Date.now(); }

/* ========= Binance 데이터 ========= */
async function fetchJSON(url, {retries=2, backoff=500}={}) {
    for (let i=0;i<=retries;i++){
        try {
            const r = await fetch(url);
            if (!r.ok) throw new Error("HTTP "+r.status);
            return await r.json();
        } catch(e){
            if (i===retries) throw e;
            await sleep(backoff * (i+1));
        }
    }
}

async function getUSDTPerpSymbols() {
    const info = await fetchJSON(`${API}/fapi/v1/exchangeInfo`);
    return info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => ({ symbol: s.symbol, pricePrecision: s.pricePrecision, quantityPrecision: s.quantityPrecision, filters: s.filters }));
}

async function getAllPricesMap() {
    const arr = await fetchJSON(`${API}/fapi/v1/ticker/price`);
    const map = new Map();
    for (const x of arr) map.set(x.symbol, Number(x.price));
    return map;
}

async function getKlines(symbol, interval, limit=60) {
    const url = `${API}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    const arr = await fetchJSON(url);
    // [ openTime, open, high, low, close, volume, closeTime, ... ]
    return arr.map(k => ({
        t: new Date(k[0]),
        o: Number(k[1]),
        h: Number(k[2]),
        l: Number(k[3]),
        c: Number(k[4])
    }));
}

/* ========= 캔들 연산 ========= */
const isBull = c => c.c > c.o;
const isBear = c => c.c < c.o;
const body = c => Math.abs(c.c - c.o);
const range = c => c.h - c.l;
const upperWick = c => c.h - Math.max(c.o, c.c);
const lowerWick = c => Math.min(c.o, c.c) - c.l;
const midpoint = c => (c.o + c.c) / 2;
const nearlyEq = (a,b,tol) => Math.abs(a-b) <= tol;

/* ========= 패턴 ========= */
const PAT_META = {
    kicker:   { name: "강세 키커", tier: "A" },
    engulf:   { name: "강세 장악", tier: "A" },
    morning:  { name: "샛별형", tier: "A" },
    hammer:   { name: "망치형", tier: "A" },
    r3m:      { name: "상승 삼법", tier: "A" },
    soldiers: { name: "백삼병", tier: "A" },
    piercing: { name: "관통형", tier: "B" },
    harami:   { name: "불리시 하라미", tier: "B" },
    tweezer:  { name: "트위저 바닥", tier: "B" },
    belt:     { name: "상승 벨트홀드", tier: "B" }
};
const TIER_ORDER = { "A":3, "B":2, "ALL":0 };

function detectLatestLongSetup(c) {
    // c: sorted ascending; focus last closed bar index i = n-1
    const n = c.length;
    if (n < 5) return null;
    const i = n - 1;
    const a = c[i-1], b = c[i], c0 = c[i-2], d0 = c[i-3], e0 = c[i-4];
    if (!b || !a) return null;

    const out = [];

    // 1) Bullish Engulfing
    if (isBear(a) && isBull(b) && b.c > a.o && b.o < a.c && body(b) >= body(a)*0.7) {
        out.push({ key:"engulf", entry:b.h, stop:Math.min(a.l,b.l), note:"몸통 장악" });
    }
    // 2) Morning Star
    if (c0 && d0) {
        const c1 = d0, c2 = c0, c3 = a, c4 = b; // shift by one (마지막이 b)
        const longBear = isBear(c1) && body(c1) >= range(c1)*0.5;
        const small2   = body(c2) <= range(c1)*0.5 && body(c2) <= range(c2)*0.4;
        const strong4  = isBull(c4) && c4.c >= midpoint(c1);
        if (longBear && small2 && strong4) {
            out.push({ key:"morning", entry:c4.h, stop:Math.min(c1.l,c2.l,c3.l,c4.l), note:"3캔들 반전" });
        }
    }
    // 3) Hammer
    {
        const wL = lowerWick(b), wU = upperWick(b), bod = body(b);
        let downCtx = false;
        if (a && c0 && d0) {
            const arrC = [d0, c0, a];
            const downCnt = arrC.filter(x => x.c < x.o).length;
            downCtx = downCnt >= 2 || (a.c < d0.c);
        }
        if (wL >= bod*2 && wU <= bod*0.6 && downCtx) {
            out.push({ key:"hammer", entry:b.h, stop:b.l, note:"아랫꼬리 강조" });
        }
    }
    // 4) Rising Three Methods (5 bars)
    if (a && c0 && d0 && e0) {
        const c1=e0,c2=d0,c3=c0,c4=a,c5=b;
        const long1 = isBull(c1) && body(c1) >= range(c1)*0.5;
        const midIn1 = [c2,c3,c4].every(x => body(x) <= body(c1)*0.6 && x.h <= c1.h && x.l >= c1.l);
        const smallDowns = [c2,c3,c4].filter(x => isBear(x)).length >= 2;
        const lastBreak = isBull(c5) && c5.c > c1.h;
        if (long1 && midIn1 && smallDowns && lastBreak) {
            out.push({ key:"r3m", entry:c5.h, stop:Math.min(c2.l,c3.l,c4.l), note:"지속형" });
        }
    }
    // 5) Three White Soldiers
    if (c0) {
        const c1=c0,c2=a,c3=b;
        const cond = isBull(c1)&&isBull(c2)&&isBull(c3)
            && c2.c>c1.c && c3.c>c2.c
            && upperWick(c1)<=range(c1)*0.3
            && upperWick(c2)<=range(c2)*0.3
            && upperWick(c3)<=range(c3)*0.3
            && c2.o >= midpoint(c1) && c3.o >= midpoint(c2);
        if (cond) {
            out.push({ key:"soldiers", entry:c3.h, stop:Math.min(c1.l,c2.l,c3.l), note:"연속 강세" });
        }
    }
    // 6) Piercing
    if (isBear(a) && isBull(b) && b.c >= midpoint(a)) {
        out.push({ key:"piercing", entry:b.h, stop:Math.min(a.l,b.l), note:"몸통 50% 관통" });
    }
    // 7) Harami
    {
        const aTop = Math.max(a.o, a.c), aBot = Math.min(a.o, a.c);
        const cond = isBear(a) && body(a) >= range(a)*0.3 &&
                     body(b) <= body(a)*0.6 &&
                     (Math.max(b.o,b.c) <= aTop) && (Math.min(b.o,b.c) >= aBot);
        if (cond) out.push({ key:"harami", entry:b.h, stop:Math.min(a.l,b.l), note:"작은 몸통 내부" });
    }
    // 8) Tweezer Bottom
    {
        const tol = (a.l + b.l)/2 * 0.002;
        const lowsNear = nearlyEq(a.l, b.l, tol);
        if (lowsNear && isBull(b)) {
            out.push({ key:"tweezer", entry:b.h, stop:Math.min(a.l,b.l), note:"저가 동일·반등" });
        }
    }
    // 9) Belt Hold
    {
        const isLong = isBull(b) && body(b) >= range(b)*0.7;
        const lowerIsSmall = (b.o - b.l) <= range(b)*0.1;
        if (isLong && lowerIsSmall) out.push({ key:"belt", entry:b.h, stop:b.l, note:"장대양봉·하단꼬리 짧음" });
    }

    if (!out.length) return null;
    // 가장 보수적: entry>stop만 남기고, 우선순위 A > B, 그 다음 폭이 좁은 것 우선
    const pri = k => (PAT_META[k].tier==="A"?2:1);
    const filtered = out.filter(x => x.entry > x.stop);
    if (!filtered.length) return null;
    filtered.sort((x,y) => {
        const p = pri(y.key) - pri(x.key);
        if (p !== 0) return p;
        // 폭이 더 좁은게 우선(리스크 대비 수익 좋아지기 쉬움)
        return (x.entry - x.stop) - (y.entry - y.stop);
    });
    return filtered[0];
}

/* ========= 포지션 제안 ========= */
function positionSuggestion({ equity, riskPct, marginPct, maxLev, entry, stop }) {
    const E  = equity, r = riskPct/100, f = marginPct/100;
    const P  = entry,   S = stop;
    const width = P - S;
    if (!(E>0 && r>0 && f>0 && maxLev>=1) || !(P>S)) return null;

    const N_risk = (E * r) / width;
    const notional_need = N_risk * P;
    const L_need = notional_need / (E * f);

    let L = clamp(L_need, 1, maxLev);
    let notional = notional_need;
    let N = N_risk;

    if (L_need > maxLev) {
        notional = E * f * maxLev;
        N = notional / P;
    }
    const effLoss = N * width;
    const effRiskPct = effLoss / E;
    const marginUsed = notional / L;
    const marginPctUsed = marginUsed / E;

    return { N, notional, L, effRiskPct, marginUsed, marginPctUsed, width };
}

/* ========= 노이즈 측정 & 타임프레임 결정 =========
   15m 상에서 상위 30개(24h 거래규모 기준) 샘플의 중앙값 wick/body 비율이 2.2 이상이면 1h 선택
*/
async function decideIntervalAuto(symbolsAll) {
    try {
        const stats = await fetchJSON(`${API}/fapi/v1/ticker/24hr`);
        const setUSDT = new Set(symbolsAll.map(s=>s.symbol));
        const usdtStats = stats.filter(x => setUSDT.has(x.symbol));
        usdtStats.sort((a,b) => Number(b.quoteVolume) - Number(a.quoteVolume));
        const sample = usdtStats.slice(0, 30).map(x => x.symbol);

        const ratios = [];
        for (let i=0;i<sample.length;i++){
            const s = sample[i];
            const kl = await getKlines(s, "15m", 50);
            if (kl.length < 20) continue;
            const recent = kl.slice(-20);
            for (const c of recent) {
                const bod = body(c);
                if (bod <= 0) continue;
                const r = (upperWick(c)+lowerWick(c)) / bod;
                ratios.push(r);
            }
            if (i % 6 === 5) await sleep(120); // 약한 간격
        }
        if (!ratios.length) return { interval:"15m", noise: NaN };
        ratios.sort((a,b)=>a-b);
        const med = ratios[Math.floor(ratios.length/2)];
        const interval = (med >= 2.2) ? "1h" : "15m";
        return { interval, noise: med };
    } catch(e){
        console.warn("auto decide failed, fallback 15m:", e);
        return { interval:"15m", noise: NaN };
    }
}

/* ========= 스캔 루프 ========= */
function nextBoundaryTs(interval){
    const ms = interval==="1h" ? 3600000 : 900000;
    const now = nowMs();
    return Math.floor(now/ms)*ms + ms;
}

async function scanOnce(state){
    const tbody = document.querySelector("#tbl tbody");
    tbody.innerHTML = "";
    const enabled = new Set(Array.from(document.querySelectorAll(".pat:checked")).map(x=>x.value));
    const minTier = document.getElementById("minTier").value;
    const tierOK = (key) => {
        if (minTier === "ALL") return true;
        const need = TIER_ORDER[minTier];
        const t = TIER_ORDER[PAT_META[key].tier] || 0;
        return t >= need;
    };

    const symInfo = state.symbols; // {symbol, pricePrecision, quantityPrecision}
    const priceMap = await getAllPricesMap();

    // 동시성 제어
    const concurrency = 6;
    let idx = 0;
    const results = [];

    async function worker(){
        while(idx < symInfo.length){
            const me = symInfo[idx++];
            try {
                const kl = await getKlines(me.symbol, state.interval, 60);
                if (kl.length < 5) continue;
                const setup = detectLatestLongSetup(kl);
                if (!setup || !enabled.has(setup.key) || !tierOK(setup.key)) continue;

                const entry = setup.entry;
                const stop  = setup.stop;
                const cur   = priceMap.get(me.symbol);
                if (!isFinite(cur)) continue;

                // "바로 진입 가능": 현재가 >= 엔트리
                if (cur >= entry) {
                    const ps = positionSuggestion({
                        equity: Number(document.getElementById("equity").value),
                        riskPct: Number(document.getElementById("riskPct").value),
                        marginPct: Number(document.getElementById("marginPct").value),
                        maxLev: Number(document.getElementById("maxLev").value),
                        entry, stop
                    });
                    const oneR = entry + (entry - stop);
                    const twoR = entry + 2*(entry - stop);
                    const threeR = entry + 3*(entry - stop);
                    results.push({
                        symbol: me.symbol,
                        key: setup.key,
                        status: "TRIGGERED",
                        cur, entry, stop, width: entry-stop,
                        pos: ps, oneR, twoR, threeR, note: setup.note
                    });
                }
            } catch(e){
                // 개별 심볼 에러는 스킵
                // console.warn(me.symbol, e);
            }
            await sleep(60); // 아주 약한 페이싱
        }
    }
    const workers = Array.from({length:concurrency}, ()=>worker());
    await Promise.all(workers);

    // 정렬: 우선 A등급 > B등급, 그 다음 폭이 좁은 순
    results.sort((x,y)=>{
        const t = (PAT_META[y.key].tier==="A") - (PAT_META[x.key].tier==="A");
        if (t !== 0) return t;
        return x.width - y.width;
    });

    // 렌더
    for (const r of results){
        const tr = document.createElement("tr");
        tr.innerHTML = `
            <td class="mono">${r.symbol}</td>
            <td>${PAT_META[r.key].name}</td>
            <td><span class="tag ok">트리거</span></td>
            <td class="mono">${fmt(r.cur)}</td>
            <td class="mono">${fmt(r.entry)}</td>
            <td class="mono">${fmt(r.stop)}</td>
            <td class="mono">${fmt(r.width)}</td>
            <td class="mono">${r.pos ? r.pos.L.toFixed(2)+"x" : "-"}</td>
            <td class="mono">${r.pos ? pct(r.pos.marginPctUsed) : "-"}</td>
            <td class="mono">${r.pos ? pct(r.pos.notional / Number(document.getElementById("equity").value)) : "-"}</td>
            <td class="mono">${r.pos ? fmt(r.pos.N, 6) : "-"}</td>
            <td class="mono">${fmt(r.oneR)}</td>
            <td class="mono">${fmt(r.twoR)}</td>
            <td class="mono">${fmt(r.threeR)}</td>
            <td class="help">${r.note || ""}</td>
        `;
        tbody.appendChild(tr);
    }
    document.getElementById("summary").textContent =
        `${results.length}종목 · interval=${state.interval}`;
    return results.length;
}

async function initAndMaybeDecideInterval(state){
    if (!state.symbols) {
        state.symbols = await getUSDTPerpSymbols();
    }
    const tfMode = document.getElementById("tfMode").value;
    if (tfMode === "15m" || tfMode === "1h") {
        state.interval = tfMode;
        document.getElementById("chosenInterval").textContent = `interval: ${state.interval}`;
        document.getElementById("noiseInfo").textContent = `noise: manual`;
        return;
    }
    const { interval, noise } = await decideIntervalAuto(state.symbols);
    state.interval = interval;
    document.getElementById("chosenInterval").textContent = `interval: ${interval}`;
    document.getElementById("noiseInfo").textContent = `noise: ${isFinite(noise)? noise.toFixed(2): "-"}`;
}

function scheduleNext(state){
    const nextTs = nextBoundaryTs(state.interval);
    const left = Math.max(0, nextTs - nowMs());
    clearTimeout(state.timer);
    state.timer = setTimeout(async ()=>{
        if (!state.auto) return;
        // 새 봉 시작 직후 약간 대기(캔들 클로즈 데이터 보장)
        await sleep(1500);
        await scanOnce(state);
        scheduleNext(state);
    }, left);
    const d = new Date(nextTs);
    document.getElementById("nextRun").textContent = `next: ${d.toISOString().replace('T',' ').slice(0,16)} (loc)`;
}

/* ========= 앱 시작 ========= */
const appState = { auto: true, interval: "15m", symbols: null, timer: null };

document.getElementById("btnToggleAuto").addEventListener("click", (e)=>{
    appState.auto = !appState.auto;
    e.target.textContent = `자동스캔: ${appState.auto ? "ON" : "OFF"}`;
    if (appState.auto) scheduleNext(appState);
    else clearTimeout(appState.timer);
});

document.getElementById("btnScanNow").addEventListener("click", async ()=>{
    await initAndMaybeDecideInterval(appState);
    await scanOnce(appState);
    if (appState.auto) scheduleNext(appState);
});

document.getElementById("tfMode").addEventListener("change", async ()=>{
    await initAndMaybeDecideInterval(appState);
    await scanOnce(appState);
    if (appState.auto) scheduleNext(appState);
});

// 최초 실행
(async function start(){
    await initAndMaybeDecideInterval(appState);
    await scanOnce(appState);
    scheduleNext(appState);
})();
</script>
</body>
</html>
