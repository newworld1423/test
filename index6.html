<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>USDT-M 15분봉 스캐너 · C[-1]&gt;MA7/25/99 & MA상승 & C[-2]&lt;MA(임의)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { --fg:#111; --bg:#fff; --muted:#666; --ok:#087f5b; --bad:#c92a2a; --chip:#f1f3f5; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", sans-serif; color:var(--fg); background:var(--bg); margin:0; }
        header { padding:16px 20px; border-bottom:1px solid #e9ecef; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
        h1 { font-size:18px; margin:0; }
        .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
        button, .chip { border:1px solid #dee2e6; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
        button:hover { background:#f8f9fa; }
        .chip { background:var(--chip); cursor:default; }
        .ok { color:var(--ok); font-weight:600; }
        .bad { color:var(--bad); font-weight:600; }
        main { padding:14px 20px 40px; }
        table { width:100%; border-collapse:collapse; font-size:14px; }
        th, td { padding:10px 8px; border-bottom:1px solid #f1f3f5; text-align:right; }
        th { position:sticky; top:0; background:#fff; z-index:1; }
        td.symbol, th.symbol { text-align:left; }
        .muted { color:var(--muted); }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        .row-ok { background:#f8fff9; }
        .small { font-size:12px; }
        .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f3f5; }
    </style>
</head>
<body>
<header>
    <h1>USDT-M PERP 15분봉 스캐너 · C[-1]&gt;MA7/25/99 & MA상승 & C[-2]&lt;MA(임의)</h1>
    <div class="controls">
        <button id="scanNowBtn">지금 스캔</button>
        <button id="toggleAutoBtn">자동 스캔: 켜짐</button>
        <span class="chip" id="nextScanChip">다음 스캔까지 —</span>
        <span class="chip" id="statusChip">상태: 준비</span>
        <span class="chip" id="countChip">결과 0개</span>
        <label class="chip"><input id="sortByVol" type="checkbox" checked /> 거래량순 정렬</label>
    </div>
</header>

<main>
    <div class="small muted" id="lastRunInfo">마지막 스캔: —</div>
    <div style="overflow:auto; margin-top:8px;">
        <table id="resultTable">
            <thead>
                <tr>
                    <th class="symbol">심볼</th>
                    <th>직전봉 종가</th>
                    <th>MA7 (t-1)</th>
                    <th>MA25 (t-1)</th>
                    <th>MA99 (t-1)</th>
                    <th>MA7↑</th>
                    <th>MA25↑</th>
                    <th>MA99↑</th>
                    <th>C[-2]&lt;7</th>
                    <th>C[-2]&lt;25</th>
                    <th>C[-2]&lt;99</th>
                    <th>직전봉 거래량</th>
                </tr>
            </thead>
            <tbody id="tbody">
                <tr><td colspan="12" class="muted">스캔 대기 중…</td></tr>
            </tbody>
        </table>
    </div>
</main>

<footer class="small muted" style="padding:10px 20px; border-top:1px solid #e9ecef;">
    조건: (1) C[-1] &gt; MA7/25/99 (모두) (2) MA7/25/99 각각 2봉전 대비 상승 (3) C[-2] &lt; MA7 또는 MA25 또는 MA99.<br/>
    봉 마감 직후 1~3초 API 지연이 있을 수 있어 마감 +3초에 실행합니다(AUTO_DELAY_MS로 변경 가능).
</footer>

<script>
(() => {
    "use strict";

    // ===== 설정 =====
    const INTERVAL = "15m";
    const INTERVAL_MS = 15 * 60 * 1000;
    const KLINE_LIMIT = 150;    // MA99 계산 + 여유
    const CONCURRENCY = 8;      // 동시 요청 개수
    const AUTO_DELAY_MS = 3000; // 봉 마감 후 지연(ms)

    // ===== DOM =====
    const scanNowBtn = document.getElementById("scanNowBtn");
    const toggleAutoBtn = document.getElementById("toggleAutoBtn");
    const nextScanChip = document.getElementById("nextScanChip");
    const statusChip = document.getElementById("statusChip");
    const countChip = document.getElementById("countChip");
    const lastRunInfo = document.getElementById("lastRunInfo");
    const sortByVol = document.getElementById("sortByVol");
    const tbody = document.getElementById("tbody");

    // ===== 상태 =====
    let symbols = [];
    let autoScan = true;
    let intervalTimer = null;
    let countdownTimer = null;

    // ===== 유틸 =====
    function fmtNum(n, d = 8) {
        if (Number.isNaN(n) || n === null || n === undefined) return "-";
        const v = Number(n);
        if (Math.abs(v) >= 100) return v.toLocaleString();
        return v.toLocaleString(undefined, { maximumFractionDigits: d });
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchJSON(url, tries = 3) {
        for (let i = 0; i < tries; i++) {
            try {
                const res = await fetch(url, { cache: "no-store" });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return await res.json();
            } catch (err) {
                if (i === tries - 1) throw err;
                await sleep(250 * (i + 1));
            }
        }
    }

    function sma(values, endIndex, length) {
        const start = endIndex - length + 1;
        if (start < 0) return null;
        let sum = 0;
        for (let i = start; i <= endIndex; i++) sum += values[i];
        return sum / length;
    }

    function nextCandleCloseMs(now = Date.now()) {
        return Math.ceil(now / INTERVAL_MS) * INTERVAL_MS + AUTO_DELAY_MS;
    }

    function startCountdown() {
        stopCountdown();
        countdownTimer = setInterval(() => {
            const now = Date.now();
            const next = nextCandleCloseMs(now);
            const remain = next - now;
            const s = Math.max(0, Math.floor(remain / 1000));
            const mm = String(Math.floor(s / 60)).padStart(2, "0");
            const ss = String(s % 60).padStart(2, "0");
            nextScanChip.textContent = `다음 스캔까지 ${mm}:${ss}`;
        }, 250);
    }

    function stopCountdown() {
        if (countdownTimer) clearInterval(countdownTimer);
        countdownTimer = null;
    }

    function setStatus(txt) { statusChip.textContent = `상태: ${txt}`; }

    // USDT-M 무기한(TRADING) 심볼 로드
    async function loadSymbols() {
        setStatus("심볼 로딩");
        const info = await fetchJSON("https://fapi.binance.com/fapi/v1/exchangeInfo");
        symbols = (info.symbols || [])
            .filter(s => s.quoteAsset === "USDT" && s.contractType === "PERPETUAL" && s.status === "TRADING")
            .map(s => s.symbol)
            .sort();
        setStatus(`심볼 ${symbols.length}개`);
    }

    // 개별 심볼 스캔
    async function scanSymbol(symbol) {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${KLINE_LIMIT}`;
        const data = await fetchJSON(url);
        if (!Array.isArray(data) || data.length < 120) return null;

        // kline: [0]openTime,[1]open,[2]high,[3]low,[4]close,[5]volume,[6]closeTime,...
        const closes = data.map(k => parseFloat(k[4]));
        const vols = data.map(k => parseFloat(k[5]));
        const n = closes.length;

        // 진행 중 봉 제외: prev = n-2, twoAgo = n-3
        const prev = n - 2;
        const twoAgo = n - 3;
        if (twoAgo < 0) return null;

        const prevClose = closes[prev];
        const twoAgoClose = closes[twoAgo];

        // MA 계산 (t-1, t-2 각각)
        const ma7_prev  = sma(closes, prev, 7);
        const ma25_prev = sma(closes, prev, 25);
        const ma99_prev = sma(closes, prev, 99);

        const ma7_two   = sma(closes, twoAgo, 7);
        const ma25_two  = sma(closes, twoAgo, 25);
        const ma99_two  = sma(closes, twoAgo, 99);

        if ([ma7_prev, ma25_prev, ma99_prev, ma7_two, ma25_two, ma99_two].some(v => v === null)) return null;

        // (1) 직전봉 종가 > MA7/25/99 모두
        const condCloseOverAll = (prevClose > ma7_prev) && (prevClose > ma25_prev) && (prevClose > ma99_prev);

        // (2)(3)(4) 기울기 상승
        const condSlopeUp = (ma7_two < ma7_prev) && (ma25_two < ma25_prev) && (ma99_two < ma99_prev);

        // (5) 2봉전 종가가 2봉전 MA 중 하나보다 아래
        const c2_lt7  = twoAgoClose < ma7_two;
        const c2_lt25 = twoAgoClose < ma25_two;
        const c2_lt99 = twoAgoClose < ma99_two;
        const condTwoAgoBelowAny = c2_lt7 || c2_lt25 || c2_lt99;

        if (condCloseOverAll && condSlopeUp && condTwoAgoBelowAny) {
            const prevVol = vols[prev];
            return {
                symbol,
                prevClose,
                ma7_prev, ma25_prev, ma99_prev,
                up7: true, up25: true, up99: true,
                c2_lt7, c2_lt25, c2_lt99,
                prevVol
            };
        }
        return null;
    }

    // 전체 스캔(동시성)
    async function scanAll() {
        if (!symbols.length) await loadSymbols();

        setStatus("스캔 중");
        tbody.innerHTML = `<tr><td colspan="12" class="muted">스캔 중… (총 ${symbols.length}개)</td></tr>`;

        const results = [];
        let processed = 0;

        async function worker(startIdx) {
            for (let i = startIdx; i < symbols.length; i += CONCURRENCY) {
                try {
                    const r = await scanSymbol(symbols[i]);
                    if (r) results.push(r);
                } catch (_) {
                    // 심볼별 오류 무시
                } finally {
                    processed++;
                    statusChip.textContent = `상태: 스캔 ${processed}/${symbols.length}`;
                }
            }
        }

        const workerCount = Math.min(CONCURRENCY, symbols.length);
        const workers = [];
        for (let w = 0; w < workerCount; w++) workers.push(worker(w));
        await Promise.all(workers);

        if (sortByVol.checked) {
            results.sort((a, b) => (b.prevVol ?? 0) - (a.prevVol ?? 0));
        } else {
            results.sort((a, b) => a.symbol.localeCompare(b.symbol));
        }

        render(results);
        setStatus("완료");
        const now = new Date();
        lastRunInfo.textContent = `마지막 스캔: ${now.toLocaleString()} (로컬시간)`;
        countChip.textContent = `결과 ${results.length}개`;
    }

    function render(rows) {
        if (!rows.length) {
            tbody.innerHTML = `<tr><td colspan="12" class="muted">조건을 만족하는 심볼이 없습니다.</td></tr>`;
            return;
        }
        tbody.innerHTML = rows.map(r => `
            <tr class="row-ok">
                <td class="symbol"><span class="pill">${r.symbol}</span></td>
                <td class="mono">${fmtNum(r.prevClose, 6)}</td>
                <td class="mono">${fmtNum(r.ma7_prev, 6)}</td>
                <td class="mono">${fmtNum(r.ma25_prev, 6)}</td>
                <td class="mono">${fmtNum(r.ma99_prev, 6)}</td>
                <td class="ok">↑</td>
                <td class="ok">↑</td>
                <td class="ok">↑</td>
                <td class="mono">${r.c2_lt7 ? "●" : "—"}</td>
                <td class="mono">${r.c2_lt25 ? "●" : "—"}</td>
                <td class="mono">${r.c2_lt99 ? "●" : "—"}</td>
                <td class="mono">${fmtNum(r.prevVol, 2)}</td>
            </tr>
        `).join("");
    }

    function scheduleAuto() {
        if (intervalTimer) { clearInterval(intervalTimer); intervalTimer = null; }
        const now = Date.now();
        const firstAt = nextCandleCloseMs(now);
        const wait = Math.max(0, firstAt - now);

        setStatus("자동 대기");
        startCountdown();

        setTimeout(async () => {
            if (!autoScan) return;
            await scanAll();
            if (!autoScan) return;

            intervalTimer = setInterval(async () => {
                if (!autoScan) return;
                await scanAll();
            }, INTERVAL_MS);
        }, wait);
    }

    // 이벤트
    scanNowBtn.addEventListener("click", async () => {
        stopCountdown();
        await scanAll();
        if (autoScan) startCountdown();
    });

    toggleAutoBtn.addEventListener("click", () => {
        autoScan = !autoScan;
        toggleAutoBtn.textContent = `자동 스캔: ${autoScan ? "켜짐" : "꺼짐"}`;
        if (autoScan) {
            scheduleAuto();
        } else {
            if (intervalTimer) clearInterval(intervalTimer);
            intervalTimer = null;
            stopCountdown();
            nextScanChip.textContent = "자동 스캔 꺼짐";
            setStatus("수동 모드");
        }
    });

    // 시작
    (async function init() {
        try {
            await loadSymbols();
            await scanAll();     // 최초 1회 즉시 실행
        } catch (e) {
            setStatus("에러");
            tbody.innerHTML = `<tr><td colspan="12" class="bad">초기화 실패: ${String(e && e.message || e)}</td></tr>`;
            return;
        }
        scheduleAuto();          // 이후 봉 마감마다 자동
    })();
})();
</script>
</body>
</html>
