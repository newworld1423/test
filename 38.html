<!DOCTYPE html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT-P ERP 1D V-저점 + 스윙고/저 스캐너</title>

        <!-- Chart.js (UMD) -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

        <!-- Hammer.js (핀치 제스처 인식용) -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

        <!-- chartjs-plugin-zoom -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.2.0/chartjs-plugin-zoom.min.js"></script>

        <style>
            :root {
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", Arial, "맑은 고딕", sans-serif;
            }

            body {
                margin: 0;
                background: #0b0f19;
                color: #e6e9f2;
            }

            .wrap {
                max-width: 1200px;
                margin: 0 auto;
                padding: 16px;
            }

            .card {
                background: #121a2b;
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 12px;
                padding: 12px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }

            .row > * {
                flex: 0 0 auto;
            }

            .grow {
                flex: 1 1 auto;
            }

            button {
                cursor: pointer;
                border: 1px solid rgba(255, 255, 255, 0.12);
                background: #1a2540;
                color: #e6e9f2;
                border-radius: 10px;
                padding: 10px 12px;
                font-weight: 600;
            }

            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            input,
            select {
                border: 1px solid rgba(255, 255, 255, 0.12);
                background: #0f172a;
                color: #e6e9f2;
                border-radius: 10px;
                padding: 10px 12px;
                outline: none;
                width: 100%;
                max-width: 340px;
            }

            .muted {
                color: rgba(230, 233, 242, 0.7);
                font-size: 12px;
                line-height: 1.4;
            }

            .status {
                white-space: pre-wrap;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 12px;
                color: rgba(230, 233, 242, 0.75);
                background: rgba(0, 0, 0, 0.25);
                border-radius: 10px;
                padding: 10px;
                border: 1px solid rgba(255, 255, 255, 0.08);
                margin-top: 10px;
                max-height: 220px;
                overflow: auto;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
                overflow: hidden;
                border-radius: 12px;
            }

            th,
            td {
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                padding: 10px 10px;
                text-align: left;
                font-size: 13px;
            }

            th {
                background: rgba(255, 255, 255, 0.06);
                position: sticky;
                top: 0;
                z-index: 1;
            }

            tr:hover td {
                background: rgba(255, 255, 255, 0.04);
            }

            .pill {
                display: inline-block;
                padding: 3px 8px;
                border-radius: 999px;
                font-size: 12px;
                border: 1px solid rgba(255, 255, 255, 0.12);
                background: rgba(255, 255, 255, 0.06);
            }

            .chartWrap {
                margin-top: 12px;
            }

            .chartHead {
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
                flex-wrap: wrap;
                margin-bottom: 8px;
            }

            .chartTitle {
                font-weight: 800;
                letter-spacing: 0.2px;
            }

            canvas {
                width: 100% !important;
                height: 420px !important;
                background: #0f172a;
                border-radius: 12px;
                border: 1px solid rgba(255, 255, 255, 0.08);
                touch-action: none;
            }

            .hint {
                font-size: 12px;
                color: rgba(230, 233, 242, 0.75);
            }
        </style>
    </head>

    <body>
        <div class="wrap">
            <div class="card">
                <div class="row">
                    <button id="btnStart">스캔 시작</button>
                    <button id="btnStop" disabled>중지</button>

                    <select id="sortSelect" title="정렬 기준">
                        <option value="score_desc" selected>추천순(Score) ↓ (기본)</option>
                        <option value="rr_desc">RR(보상/위험) ↓</option>
                        <option value="qv_desc">24h 거래대금(Quote Volume) ↓</option>
                        <option value="sym_asc">심볼 A→Z</option>
                    </select>

                    <input id="searchInput" class="grow" placeholder="결과 검색 (예: BTC, ETH...)" />

                    <button id="btnCsv" disabled>CSV 다운로드</button>
                </div>

                <div class="muted" style="margin-top: 10px;">
                    - USDT 무기한(Perpetual)만 대상. `/fapi/v1/exchangeInfo`로 심볼 목록을 가져오고, 1D 캔들은 `/fapi/v1/klines`로 조회. :contentReference[oaicite:4]{index=4}<br />
                    - 24h 거래대금은 `/fapi/v1/ticker/24hr`(심볼 미지정 시 전체 배열) 사용. :contentReference[oaicite:5]{index=5}<br />
                    - API 레이트리밋(특히 klines LIMIT에 따른 weight) 때문에 브라우저에서 “전 종목” 스캔은 느릴 수 있어. (필요하면 동시요청 수를 줄이는 게 안전) :contentReference[oaicite:6]{index=6}
                </div>

                <div id="status" class="status">대기 중...</div>
            </div>

            <div class="card" style="margin-top: 12px;">
                <div class="row" style="justify-content: space-between;">
                    <div>
                        <span class="pill" id="countPill">매칭: 0</span>
                        <span class="pill" id="progressPill">진행: 0 / 0</span>
                    </div>
                    <div class="hint">
                        줌/이동: 휠=확대, Shift+드래그=박스줌, Alt+드래그=이동, Reset 버튼=원복
                    </div>
                </div>

                <div style="max-height: 420px; overflow: auto; margin-top: 10px;">
                    <table id="resultTable">
                        <thead>
                            <tr>
                                <th style="width: 56px;">#</th>
                                <th style="width: 120px;">Symbol</th>
                                <th style="width: 110px;">Score</th>
                                <th style="width: 90px;">RR</th>
                                <th style="width: 160px;">24h QuoteVol</th>
                                <th style="width: 110px;">Close</th>
                                <th>최근 스윙저점</th>
                                <th>타겟 스윙고점</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>

                <div class="chartWrap">
                    <div class="chartHead">
                        <div class="chartTitle" id="chartTitle">차트: (심볼을 클릭하세요)</div>
                        <div class="row">
                            <button id="btnResetZoom" disabled>Reset Zoom</button>
                            <a id="binanceLink" class="pill" href="#" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit; display: none;">
                                Binance 열기
                            </a>
                        </div>
                    </div>
                    <canvas id="chartCanvas"></canvas>
                </div>
            </div>
        </div>

        <script>
            // -------------------------------
            // Utilities
            // -------------------------------
            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

            const fmtNumber = (v, digits = 2) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString(undefined, { maximumFractionDigits: digits });
            };

            const fmtDate = (ms) => {
                const d = new Date(ms);
                const yyyy = d.getFullYear();
                const mm = String(d.getMonth() + 1).padStart(2, "0");
                const dd = String(d.getDate()).padStart(2, "0");
                return `${yyyy}-${mm}-${dd}`;
            };

            const toKline = (raw) => {
                // Binance kline format:
                // [ openTime, open, high, low, close, volume, closeTime, quoteVolume, ... ]
                return {
                    openTime: Number(raw[0]),
                    open: Number(raw[1]),
                    high: Number(raw[2]),
                    low: Number(raw[3]),
                    close: Number(raw[4]),
                    volume: Number(raw[5]),
                    closeTime: Number(raw[6]),
                    quoteVolume: Number(raw[7]),
                };
            };

            const safeJson = async (res) => {
                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status}: ${text.slice(0, 200)}`);
                }
                return res.json();
            };

            // -------------------------------
            // Binance endpoints (USD-M Futures)
            // -------------------------------
            const BASE = "https://fapi.binance.com";
            const ENDPOINTS = {
                exchangeInfo: `${BASE}/fapi/v1/exchangeInfo`,
                klines: (symbol, interval, limit) => `${BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`,
                ticker24hAll: `${BASE}/fapi/v1/ticker/24hr`,
            };

            // -------------------------------
            // Scan logic
            // -------------------------------
            const state = {
                abortControllers: [],
                running: false,
                symbols: [],
                tickerMap: new Map(),
                results: [],
                filteredResults: [],
                chart: null,
                selectedSymbol: null,
            };

            const log = (msg) => {
                const el = document.getElementById("status");
                el.textContent = `${msg}\n${el.textContent}`.slice(0, 20000);
            };

            const setStatusTop = (msg) => {
                const el = document.getElementById("status");
                el.textContent = msg;
            };

            const setProgress = (done, total) => {
                document.getElementById("progressPill").textContent = `진행: ${done} / ${total}`;
            };

            const setCount = (n) => {
                document.getElementById("countPill").textContent = `매칭: ${n}`;
            };

            const getUSDTPerpSymbols = async () => {
                const controller = new AbortController();
                state.abortControllers.push(controller);

                const res = await fetch(ENDPOINTS.exchangeInfo, { signal: controller.signal });
                const data = await safeJson(res);

                const list = (data.symbols || [])
                    .filter((s) => s.contractType === "PERPETUAL")
                    .filter((s) => s.quoteAsset === "USDT")
                    .filter((s) => s.status === "TRADING")
                    .map((s) => s.symbol);

                return list;
            };

            const loadTicker24hAll = async () => {
                const controller = new AbortController();
                state.abortControllers.push(controller);

                const res = await fetch(ENDPOINTS.ticker24hAll, { signal: controller.signal });
                const arr = await safeJson(res);

                const map = new Map();
                for (const t of arr) {
                    if (!t || !t.symbol) continue;
                    map.set(t.symbol, {
                        quoteVolume: Number(t.quoteVolume),
                        lastPrice: Number(t.lastPrice),
                    });
                }
                state.tickerMap = map;
            };

            const fetchDailyKlines = async (symbol, limit = 210) => {
                const controller = new AbortController();
                state.abortControllers.push(controller);

                const url = ENDPOINTS.klines(symbol, "1d", limit);
                const res = await fetch(url, { signal: controller.signal });
                const raw = await safeJson(res);
                return raw.map(toKline);
            };

            // Condition:
            // a[-5].low > a[-4].low > a[-3].low < a[-2].low < a[-1].low
            // where a is "current candle" and [-1..-5] are last closed 5 candles.
            const matchVLowPattern = (klines) => {
                if (!klines || klines.length < 7) return false;

                const idxCurrent = klines.length - 1;          // (likely) forming candle
                const idxLastClosed = idxCurrent - 1;          // last closed candle

                if (idxLastClosed - 4 < 0) return false;

                const k1 = klines[idxLastClosed];
                const k2 = klines[idxLastClosed - 1];
                const k3 = klines[idxLastClosed - 2];
                const k4 = klines[idxLastClosed - 3];
                const k5 = klines[idxLastClosed - 4];

                return (k5.low > k4.low) && (k4.low > k3.low) && (k3.low < k2.low) && (k2.low < k1.low);
            };

            // Swing definitions on windowed array W:
            // swingHigh at i:
            // W[i-2].high < W[i-1].high < W[i].high > W[i+1].high > W[i+2].high
            // swingLow at i:
            // W[i-2].low > W[i-1].low > W[i].low < W[i+1].low < W[i+2].low
            const detectSwings = (windowKlines) => {
                const swingHighs = [];
                const swingLows = [];

                for (let i = 2; i < windowKlines.length - 2; i += 1) {
                    const b2 = windowKlines[i - 2];
                    const b1 = windowKlines[i - 1];
                    const b0 = windowKlines[i];
                    const f1 = windowKlines[i + 1];
                    const f2 = windowKlines[i + 2];

                    const isHigh = (b2.high < b1.high) && (b1.high < b0.high) && (b0.high > f1.high) && (f1.high > f2.high);
                    const isLow = (b2.low > b1.low) && (b1.low > b0.low) && (b0.low < f1.low) && (f1.low < f2.low);

                    if (isHigh) {
                        swingHighs.push({ index: i, time: b0.openTime, price: b0.high });
                    }
                    if (isLow) {
                        swingLows.push({ index: i, time: b0.openTime, price: b0.low });
                    }
                }

                return { swingHighs, swingLows };
            };

            // Sorting:
            // 기본 추천 Score = RR * log10(quoteVol + 1)
            // RR = (targetHigh - close) / (close - lastSwingLow)
            const buildMetrics = ({ symbol, windowKlines, swings }) => {
                const ticker = state.tickerMap.get(symbol);
                const qv = ticker ? ticker.quoteVolume : 0;

                const close = windowKlines[windowKlines.length - 1].close;

                const lastSwingLow = swings.swingLows.length > 0 ? swings.swingLows[swings.swingLows.length - 1] : null;

                let targetHigh = null;
                if (swings.swingHighs.length > 0) {
                    const candidates = swings.swingHighs
                        .filter((h) => h.price > close)
                        .filter((h) => (lastSwingLow ? h.time >= lastSwingLow.time : true));

                    if (candidates.length > 0) {
                        // "가격 기준으로 가장 가까운 위쪽 스윙고점"
                        candidates.sort((a, b) => a.price - b.price);
                        targetHigh = candidates[0];
                    } else {
                        // fallback: 윈도우 내 최고 스윙고점
                        let best = swings.swingHighs[0];
                        for (const h of swings.swingHighs) {
                            if (h.price > best.price) best = h;
                        }
                        targetHigh = best;
                    }
                }

                const lowPrice = lastSwingLow ? lastSwingLow.price : NaN;
                const highPrice = targetHigh ? targetHigh.price : NaN;

                const risk = close - lowPrice;
                const reward = highPrice - close;

                const rr = (Number.isFinite(risk) && Number.isFinite(reward) && risk > 0 && reward > 0) ? (reward / risk) : 0;

                const score = rr * Math.log10((Number.isFinite(qv) ? qv : 0) + 1);

                return {
                    symbol,
                    close,
                    quoteVolume: qv,
                    rr,
                    score,
                    lastSwingLow,
                    targetHigh,
                };
            };

            // -------------------------------
            // Concurrency pool
            // -------------------------------
            const asyncPool = async (poolLimit, array, iteratorFn, onProgress) => {
                const ret = [];
                const executing = [];

                for (let i = 0; i < array.length; i += 1) {
                    const item = array[i];
                    const p = Promise.resolve().then(() => iteratorFn(item, i));
                    ret.push(p);

                    if (poolLimit <= array.length) {
                        const e = p.then(() => executing.splice(executing.indexOf(e), 1)).catch(() => executing.splice(executing.indexOf(e), 1));
                        executing.push(e);
                        if (executing.length >= poolLimit) {
                            await Promise.race(executing);
                        }
                    }

                    if (typeof onProgress === "function") onProgress(i + 1, array.length);
                }

                return Promise.allSettled(ret);
            };

            // -------------------------------
            // Rendering
            // -------------------------------
            const applySortAndFilter = () => {
                const q = document.getElementById("searchInput").value.trim().toUpperCase();
                const sortKey = document.getElementById("sortSelect").value;

                let arr = [...state.results];

                if (q) {
                    arr = arr.filter((r) => r.symbol.includes(q));
                }

                const by = {
                    score_desc: (a, b) => (b.metrics.score - a.metrics.score) || (b.metrics.quoteVolume - a.metrics.quoteVolume),
                    rr_desc: (a, b) => (b.metrics.rr - a.metrics.rr) || (b.metrics.quoteVolume - a.metrics.quoteVolume),
                    qv_desc: (a, b) => (b.metrics.quoteVolume - a.metrics.quoteVolume) || (b.metrics.score - a.metrics.score),
                    sym_asc: (a, b) => a.symbol.localeCompare(b.symbol),
                }[sortKey];

                if (by) arr.sort(by);

                state.filteredResults = arr;
                renderTable();
            };

            const renderTable = () => {
                const tbody = document.querySelector("#resultTable tbody");
                tbody.innerHTML = "";

                state.filteredResults.forEach((r, idx) => {
                    const tr = document.createElement("tr");
                    tr.style.cursor = "pointer";

                    const m = r.metrics;

                    const cells = [
                        String(idx + 1),
                        r.symbol,
                        fmtNumber(m.score, 4),
                        fmtNumber(m.rr, 2),
                        fmtNumber(m.quoteVolume, 0),
                        fmtNumber(m.close, 6),
                        m.lastSwingLow ? `${fmtDate(m.lastSwingLow.time)} (${fmtNumber(m.lastSwingLow.price, 6)})` : "-",
                        m.targetHigh ? `${fmtDate(m.targetHigh.time)} (${fmtNumber(m.targetHigh.price, 6)})` : "-",
                    ];

                    for (const c of cells) {
                        const td = document.createElement("td");
                        td.textContent = c;
                        tr.appendChild(td);
                    }

                    tr.addEventListener("click", () => {
                        selectSymbol(r.symbol);
                    });

                    tbody.appendChild(tr);
                });

                setCount(state.filteredResults.length);
                document.getElementById("btnCsv").disabled = state.filteredResults.length === 0;
            };

            const downloadCsv = () => {
                const headers = [
                    "rank",
                    "symbol",
                    "score",
                    "rr",
                    "quoteVolume",
                    "close",
                    "lastSwingLowDate",
                    "lastSwingLowPrice",
                    "targetHighDate",
                    "targetHighPrice",
                ];

                const rows = state.filteredResults.map((r, i) => {
                    const m = r.metrics;
                    const lDate = m.lastSwingLow ? fmtDate(m.lastSwingLow.time) : "";
                    const lPrice = m.lastSwingLow ? m.lastSwingLow.price : "";
                    const tDate = m.targetHigh ? fmtDate(m.targetHigh.time) : "";
                    const tPrice = m.targetHigh ? m.targetHigh.price : "";

                    return [
                        i + 1,
                        r.symbol,
                        m.score,
                        m.rr,
                        m.quoteVolume,
                        m.close,
                        lDate,
                        lPrice,
                        tDate,
                        tPrice,
                    ];
                });

                const csv = [
                    headers.join(","),
                    ...rows.map((row) => row.map((v) => `"${String(v).replaceAll('"', '""')}"`).join(",")),
                ].join("\n");

                const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `binance_vlow_swings_${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            };

            // -------------------------------
            // Chart (Zoom/Pan enabled)
            // -------------------------------
            const ensureChart = () => {
                const canvas = document.getElementById("chartCanvas");

                // Register zoom plugin if available
                if (window.ChartZoom && typeof Chart !== "undefined" && typeof Chart.register === "function") {
                    try {
                        Chart.register(window.ChartZoom);
                    } catch (_) {
                        // ignore double-register
                    }
                }

                if (state.chart) return state.chart;

                state.chart = new Chart(canvas.getContext("2d"), {
                    type: "line",
                    data: {
                        datasets: [],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        parsing: false,
                        interaction: { mode: "nearest", intersect: false },
                        plugins: {
                            legend: { display: true },
                            tooltip: {
                                callbacks: {
                                    title: (items) => {
                                        const it = items && items[0];
                                        if (!it) return "";
                                        const x = it.parsed.x;
                                        const meta = state.selectedSymbol ? state.results.find((r) => r.symbol === state.selectedSymbol) : null;
                                        if (!meta) return `Index ${x}`;
                                        const w = meta.windowKlines;
                                        const idx = Math.round(x);
                                        if (!w[idx]) return `Index ${x}`;
                                        return fmtDate(w[idx].openTime);
                                    },
                                },
                            },
                            zoom: {
                                limits: {
                                    x: { min: "original", max: "original" },
                                    y: { min: "original", max: "original" },
                                },
                                pan: {
                                    enabled: true,
                                    mode: "x",
                                    modifierKey: "alt",
                                },
                                zoom: {
                                    wheel: {
                                        enabled: true,
                                    },
                                    pinch: {
                                        enabled: true,
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: "shift",
                                        threshold: 2,
                                    },
                                    mode: "x",
                                },
                            },
                        },
                        scales: {
                            x: {
                                type: "linear",
                                min: 0,
                                max: 199,
                                ticks: {
                                    callback: (value) => {
                                        const meta = state.selectedSymbol ? state.results.find((r) => r.symbol === state.selectedSymbol) : null;
                                        if (!meta) return value;
                                        const idx = Math.round(Number(value));
                                        const w = meta.windowKlines;
                                        if (!w[idx]) return "";
                                        // 너무 빽빽하면 일부만 표시
                                        if (idx % 20 !== 0 && idx !== 0 && idx !== w.length - 1) return "";
                                        return fmtDate(w[idx].openTime);
                                    },
                                },
                                grid: { color: "rgba(255,255,255,0.06)" },
                            },
                            y: {
                                grid: { color: "rgba(255,255,255,0.06)" },
                            },
                        },
                    },
                });

                return state.chart;
            };

            const updateChart = (symbol) => {
                const meta = state.results.find((r) => r.symbol === symbol);
                if (!meta) return;

                state.selectedSymbol = symbol;

                const chart = ensureChart();
                const w = meta.windowKlines;
                const swings = meta.swings;

                const closeSeries = w.map((k, i) => ({ x: i, y: k.close }));
                const swingHighPoints = swings.swingHighs.map((p) => ({ x: p.index, y: p.price }));
                const swingLowPoints = swings.swingLows.map((p) => ({ x: p.index, y: p.price }));

                chart.data.datasets = [
                    {
                        label: "Close (200 bars)",
                        data: closeSeries,
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.15,
                    },
                    {
                        label: "Swing High",
                        data: swingHighPoints,
                        showLine: false,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                    },
                    {
                        label: "Swing Low",
                        data: swingLowPoints,
                        showLine: false,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                    },
                ];

                chart.options.scales.x.min = 0;
                chart.options.scales.x.max = Math.max(0, w.length - 1);

                chart.update("none");

                if (typeof chart.resetZoom === "function") {
                    chart.resetZoom();
                }

                document.getElementById("chartTitle").textContent = `차트: ${symbol} (최근 200봉 Close + 스윙고/저점)`;
                const link = document.getElementById("binanceLink");
                link.href = `https://www.binance.com/en/futures/${encodeURIComponent(symbol)}`;
                link.style.display = "inline-block";

                document.getElementById("btnResetZoom").disabled = false;
            };

            const selectSymbol = (symbol) => {
                updateChart(symbol);
            };

            // -------------------------------
            // Main scan
            // -------------------------------
            const startScan = async () => {
                if (state.running) return;

                state.running = true;
                state.abortControllers = [];
                state.results = [];
                state.filteredResults = [];
                state.selectedSymbol = null;

                document.getElementById("btnStart").disabled = true;
                document.getElementById("btnStop").disabled = false;
                document.getElementById("btnCsv").disabled = true;
                document.getElementById("btnResetZoom").disabled = true;
                document.getElementById("binanceLink").style.display = "none";
                document.getElementById("chartTitle").textContent = "차트: (심볼을 클릭하세요)";
                setStatusTop("준비 중...");

                try {
                    setStatusTop("1) 심볼 로딩 중...");
                    const symbols = await getUSDTPerpSymbols(); // /exchangeInfo :contentReference[oaicite:7]{index=7}
                    state.symbols = symbols;

                    setStatusTop("2) 24h 티커 로딩 중...");
                    await loadTicker24hAll(); // /ticker/24hr :contentReference[oaicite:8]{index=8}

                    setStatusTop(`3) 스캔 시작... (총 ${symbols.length}개)`);
                    setProgress(0, symbols.length);
                    setCount(0);

                    const CONCURRENCY = 3; // 필요하면 1~2로 낮춰서 안정적으로
                    let done = 0;

                    const scanOne = async (symbol) => {
                        if (!state.running) return;

                        try {
                            const klines = await fetchDailyKlines(symbol, 210); // /klines :contentReference[oaicite:9]{index=9}
                            // 200개 미만이면 제외 (요청사항)
                            // "마지막 200개(닫힌 봉) + 최근 5개 패턴 체크"까지 안정적으로 하려면 최소 206개 이상이 필요
                            if (klines.length < 206) return;

                            if (!matchVLowPattern(klines)) return;

                            // 최근 닫힌 봉 기준 200개 윈도우
                            const idxCurrent = klines.length - 1;
                            const idxLastClosed = idxCurrent - 1;
                            const start = idxLastClosed - 199;
                            const end = idxLastClosed;

                            if (start < 0) return;

                            const windowKlines = klines.slice(start, end + 1);
                            if (windowKlines.length !== 200) return;

                            const swings = detectSwings(windowKlines);
                            const metrics = buildMetrics({ symbol, windowKlines, swings });

                            state.results.push({ symbol, windowKlines, swings, metrics });
                        } catch (e) {
                            // 레이트리밋/네트워크 에러 대비: 조용히 넘기되 로그는 남김
                            log(`[${symbol}] 실패: ${String(e.message || e)}`);
                        } finally {
                            done += 1;
                            setProgress(done, symbols.length);
                        }

                        // 살짝 쉬어주면 레이트리밋에 덜 걸림
                        await sleep(60);
                    };

                    await asyncPool(CONCURRENCY, symbols, scanOne);

                    // 정렬/필터 적용 후 렌더
                    applySortAndFilter();

                    setStatusTop(`완료! 매칭 ${state.results.length}개\n- 정렬: 추천순(Score)\n- 테이블에서 심볼 클릭하면 차트 표시\n- CSV 다운로드 가능`);
                } catch (e) {
                    setStatusTop(`에러: ${String(e.message || e)}`);
                } finally {
                    state.running = false;
                    state.abortControllers = [];
                    document.getElementById("btnStart").disabled = false;
                    document.getElementById("btnStop").disabled = true;
                }
            };

            const stopScan = () => {
                state.running = false;
                for (const c of state.abortControllers) {
                    try {
                        c.abort();
                    } catch (_) {}
                }
                state.abortControllers = [];
                setStatusTop("중지됨.");
                document.getElementById("btnStart").disabled = false;
                document.getElementById("btnStop").disabled = true;
            };

            // -------------------------------
            // Events
            // -------------------------------
            document.getElementById("btnStart").addEventListener("click", startScan);
            document.getElementById("btnStop").addEventListener("click", stopScan);

            document.getElementById("sortSelect").addEventListener("change", applySortAndFilter);
            document.getElementById("searchInput").addEventListener("input", applySortAndFilter);

            document.getElementById("btnCsv").addEventListener("click", downloadCsv);

            document.getElementById("btnResetZoom").addEventListener("click", () => {
                if (!state.chart) return;
                if (typeof state.chart.resetZoom === "function") {
                    state.chart.resetZoom();
                }
            });

            // Initial chart create (so zoom plugin is ready)
            ensureChart();
            setStatusTop("대기 중... (스캔 시작을 누르세요)");
        </script>
    </body>
</html>
