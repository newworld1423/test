<!DOCTYPE html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp 1D V-Low + Swing Scanner</title>

        <!-- Chart.js -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
        <!-- Time scale adapter -->
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
        <!-- Hammer.js (pinch support) -->
        <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
        <!-- chartjs zoom plugin -->
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.umd.min.js"></script>

        <style>
            body {
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
                margin: 0;
                padding: 16px;
                background: #0b0f17;
                color: #e7eaf0;
            }

            .wrap {
                max-width: 1240px;
                margin: 0 auto;
            }

            .card {
                background: #121a2a;
                border: 1px solid #1e2a44;
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 16px;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }

            label {
                font-size: 13px;
                opacity: 0.9;
            }

            input, select, button {
                border-radius: 10px;
                border: 1px solid #2a3a5f;
                background: #0f1524;
                color: #e7eaf0;
                padding: 10px 12px;
                font-size: 14px;
            }

            button {
                cursor: pointer;
                background: #1a2640;
            }

            button:hover {
                background: #223255;
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            .muted {
                opacity: 0.75;
                font-size: 13px;
                line-height: 1.5;
            }

            .status {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
                font-size: 12px;
                white-space: pre-wrap;
                background: #0a0f1c;
                border: 1px solid #1e2a44;
                border-radius: 10px;
                padding: 12px;
                margin-top: 12px;
                max-height: 240px;
                overflow: auto;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 12px;
                font-size: 14px;
            }

            th, td {
                border-bottom: 1px solid #1e2a44;
                padding: 10px 8px;
                text-align: left;
                white-space: nowrap;
            }

            th {
                opacity: 0.9;
                font-weight: 700;
                position: sticky;
                top: 0;
                background: #121a2a;
                z-index: 1;
            }

            tr:hover {
                background: rgba(255, 255, 255, 0.04);
                cursor: pointer;
            }

            .pill {
                display: inline-block;
                padding: 2px 8px;
                border-radius: 999px;
                border: 1px solid #2a3a5f;
                font-size: 12px;
                opacity: 0.92;
            }

            .ok {
                color: #7cff9b;
            }

            .danger {
                color: #ff6b6b;
            }

            canvas {
                width: 100% !important;
                height: 560px !important;
            }

            .right {
                margin-left: auto;
            }

            .grow {
                flex: 1 1 auto;
                min-width: 220px;
            }
        </style>
    </head>

    <body>
        <div class="wrap">
            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <div>
                        <div style="font-size: 18px; font-weight: 800;">Binance USDT 무기한 1D V-저점 + 스윙 스캐너</div>
                        <div class="muted" style="margin-top: 6px;">
                            1) 최근 5개 1D 완성봉 저점: <span class="pill">a[-5] &gt; a[-4] &gt; a[-3] &lt; a[-2] &lt; a[-1]</span><br />
                            2) 통과 심볼만 최근 <span class="pill">200개 1D 완성봉</span>에서 스윙 탐지(5봉 패턴)<br />
                            3) Close 라인 + ZigZag + 스윙고점 연결선 + 스윙저점 연결선 + V구간 하이라이트 + 트렌드라인 + 줌/팬
                        </div>
                        <div class="muted" style="margin-top: 6px;">
                            <span class="pill">줌/팬</span> 휠=줌, Shift+드래그=박스줌, Alt+드래그=팬, Reset 버튼=원복
                        </div>
                    </div>
                    <div class="row">
                        <button id="btnStart">스캔 시작</button>
                        <button id="btnStop" disabled>중지</button>
                    </div>
                </div>

                <div class="row" style="margin-top: 12px;">
                    <div>
                        <label>동시 요청(Concurrency)</label><br />
                        <input id="inpConcurrency" type="number" min="1" max="20" value="4" style="width: 140px;" />
                    </div>
                    <div>
                        <label>요청 타임아웃(ms)</label><br />
                        <input id="inpTimeout" type="number" min="2000" max="60000" value="12000" style="width: 140px;" />
                    </div>
                    <div>
                        <label>재시도 횟수</label><br />
                        <input id="inpRetries" type="number" min="0" max="10" value="3" style="width: 140px;" />
                    </div>

                    <div class="right row" style="gap: 8px;">
                        <label>정렬</label>
                        <select id="selSort">
                            <option value="score_desc" selected>추천순(Score) ↓</option>
                            <option value="qv_desc">24h 거래대금(QuoteVol) ↓</option>
                            <option value="support_asc">SupportDist% ↑(가까운 저점)</option>
                            <option value="upside_desc">Upside% ↓(위공간 큰)</option>
                            <option value="sym_asc">심볼 A→Z</option>
                        </select>

                        <input id="inpSearch" class="grow" placeholder="검색: BTC, ETH..." />
                        <button id="btnCsv" disabled>CSV</button>
                    </div>
                </div>

                <div id="status" class="status">대기 중…</div>
            </div>

            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <div style="font-size: 16px; font-weight: 800;">결과</div>
                    <div class="row">
                        <label>심볼 선택</label>
                        <select id="selSymbol" style="min-width: 220px;">
                            <option value="">(스캔 후 선택)</option>
                        </select>
                    </div>
                </div>

                <div class="muted" id="resultSummary" style="margin-top: 8px;">아직 결과가 없어.</div>

                <div style="overflow: auto; max-height: 420px; border: 1px solid #1e2a44; border-radius: 12px; margin-top: 10px;">
                    <table id="tblResults">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Symbol</th>
                                <th>Score</th>
                                <th>24h QuoteVol(USDT)</th>
                                <th>SupportDist%</th>
                                <th>Upside%</th>
                                <th>LowAge(d)</th>
                                <th>SwH</th>
                                <th>SwL</th>
                                <th>마지막 완성봉(UTC)</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <div style="font-size: 16px; font-weight: 800;">차트</div>
                    <div class="row">
                        <button id="btnResetZoom" disabled>Reset Zoom</button>
                        <a id="btnBinance" class="pill" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit; display: none;">Binance</a>
                    </div>
                </div>

                <div class="muted" style="margin-top: 8px;">
                    - <span class="pill">Close</span> 최근 200개 1D 종가<br />
                    - <span class="pill">ZigZag</span> 스윙고/저 번갈아 연결(선형)<br />
                    - <span class="pill">Swing Highs Line</span> 스윙고점끼리 연결선<br />
                    - <span class="pill">Swing Lows Line</span> 스윙저점끼리 연결선<br />
                    - <span class="pill">Trendline</span> 최근 2개 저점/고점 기반 지지/저항선(연장)<br />
                    - <span class="pill">V Highlight</span> 최근 5봉 구간 배경 + Low 점 표시
                </div>

                <canvas id="chart"></canvas>
            </div>
        </div>

        <script>
            "use strict";

            const BINANCE_FAPI = "https://fapi.binance.com";

            const $ = (sel) => document.querySelector(sel);

            const btnStart = $("#btnStart");
            const btnStop = $("#btnStop");
            const btnCsv = $("#btnCsv");
            const btnResetZoom = $("#btnResetZoom");
            const btnBinance = $("#btnBinance");

            const statusEl = $("#status");
            const resultSummary = $("#resultSummary");
            const tblBody = $("#tblResults tbody");
            const selSymbol = $("#selSymbol");
            const selSort = $("#selSort");
            const inpSearch = $("#inpSearch");

            let globalAbortController = null;
            let chart = null;

            const state = {
                serverTime: 0,
                symbols: [],
                tickers: new Map(),       // symbol -> { lastPrice, quoteVolume }
                results: [],              // array of result objects
                resultsMap: new Map(),    // symbol -> result
                filtered: [],             // filtered + sorted view for UI
            };

            // -----------------------------
            // Helpers
            // -----------------------------
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

            const toNumber = (v) => {
                const n = Number(v);
                return Number.isFinite(n) ? n : NaN;
            };

            const isoDate = (ms) => new Date(ms).toISOString().slice(0, 10);

            const fmtNum = (n) => {
                if (!Number.isFinite(n)) return "-";
                const abs = Math.abs(n);
                if (abs >= 1e9) return (n / 1e9).toFixed(2) + "B";
                if (abs >= 1e6) return (n / 1e6).toFixed(2) + "M";
                if (abs >= 1e3) return (n / 1e3).toFixed(2) + "K";
                return n.toFixed(2);
            };

            const fmtPct = (v) => {
                if (!Number.isFinite(v)) return "-";
                return (v * 100).toFixed(2) + "%";
            };

            const logStatus = (lines) => {
                statusEl.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines);
            };

            const anySignal = (signals) => {
                const controller = new AbortController();

                const onAbort = () => {
                    controller.abort();
                    for (const s of signals) {
                        if (s) s.removeEventListener("abort", onAbort);
                    }
                };

                for (const s of signals) {
                    if (!s) continue;
                    if (s.aborted) {
                        controller.abort();
                        return controller.signal;
                    }
                    s.addEventListener("abort", onAbort, { once: true });
                }

                return controller.signal;
            };

            const fetchJson = async (url, { timeoutMs = 12000, signal = null } = {}) => {
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), timeoutMs);
                const mergedSignal = signal ? anySignal([signal, controller.signal]) : controller.signal;

                try {
                    const res = await fetch(url, { signal: mergedSignal });
                    const text = await res.text();

                    if (!res.ok) {
                        const err = new Error(`HTTP ${res.status} ${res.statusText} - ${text.slice(0, 160)}`);
                        err.status = res.status;
                        throw err;
                    }

                    return JSON.parse(text);
                } finally {
                    clearTimeout(timer);
                }
            };

            const fetchJsonWithRetry = async (url, { timeoutMs, signal, retries = 3 } = {}) => {
                let lastErr = null;

                for (let attempt = 0; attempt <= retries; attempt += 1) {
                    try {
                        return await fetchJson(url, { timeoutMs, signal });
                    } catch (err) {
                        lastErr = err;

                        if (signal && signal.aborted) throw err;

                        const status = err && typeof err.status === "number" ? err.status : 0;
                        const isRateLimited = status === 429 || status === 418;

                        if (attempt === retries) break;

                        const backoff = isRateLimited ? (900 + attempt * 650) : (350 + attempt * 300);
                        await sleep(backoff);
                    }
                }

                throw lastErr;
            };

            const getServerTime = async ({ timeoutMs, signal, retries }) => {
                const data = await fetchJsonWithRetry(`${BINANCE_FAPI}/fapi/v1/time`, { timeoutMs, signal, retries });
                return data.serverTime;
            };

            const getExchangeInfo = async ({ timeoutMs, signal, retries }) => {
                return await fetchJsonWithRetry(`${BINANCE_FAPI}/fapi/v1/exchangeInfo`, { timeoutMs, signal, retries });
            };

            const getAll24hTickers = async ({ timeoutMs, signal, retries }) => {
                return await fetchJsonWithRetry(`${BINANCE_FAPI}/fapi/v1/ticker/24hr`, { timeoutMs, signal, retries });
            };

            const getKlines = async (symbol, interval, limit, { timeoutMs, signal, retries }) => {
                const url = `${BINANCE_FAPI}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
                return await fetchJsonWithRetry(url, { timeoutMs, signal, retries });
            };

            const normalizeKlines = (rawKlines, serverTime) => {
                const candles = rawKlines.map((k) => {
                    return {
                        openTime: toNumber(k[0]),
                        open: toNumber(k[1]),
                        high: toNumber(k[2]),
                        low: toNumber(k[3]),
                        close: toNumber(k[4]),
                        volume: toNumber(k[5]),
                        closeTime: toNumber(k[6]),
                    };
                });

                // 진행 중(완성 전) 일봉 제거: closeTime이 서버시간보다 미래면 pop
                if (candles.length > 0) {
                    const last = candles[candles.length - 1];
                    if (Number.isFinite(last.closeTime) && last.closeTime > serverTime) {
                        candles.pop();
                    }
                }

                return candles;
            };

            // -----------------------------
            // Conditions / Swing detection
            // -----------------------------
            const passesVShapeLast5Lows = (candles) => {
                // a[-5].low > a[-4].low > a[-3].low < a[-2].low < a[-1].low
                if (!candles || candles.length < 5) return false;

                const m = candles.length;

                const l5 = candles[m - 5].low;
                const l4 = candles[m - 4].low;
                const l3 = candles[m - 3].low;
                const l2 = candles[m - 2].low;
                const l1 = candles[m - 1].low;

                if (![l5, l4, l3, l2, l1].every(Number.isFinite)) return false;

                return (l5 > l4) && (l4 > l3) && (l3 < l2) && (l2 < l1);
            };

            const detectSwings = (candles200) => {
                const swingHighs = [];
                const swingLows = [];

                for (let i = 2; i <= candles200.length - 3; i += 1) {
                    const h2 = candles200[i - 2].high;
                    const h1 = candles200[i - 1].high;
                    const h0 = candles200[i].high;
                    const hP1 = candles200[i + 1].high;
                    const hP2 = candles200[i + 2].high;

                    const l2 = candles200[i - 2].low;
                    const l1 = candles200[i - 1].low;
                    const l0 = candles200[i].low;
                    const lP1 = candles200[i + 1].low;
                    const lP2 = candles200[i + 2].low;

                    const isSwingHigh =
                        [h2, h1, h0, hP1, hP2].every(Number.isFinite) &&
                        (h2 < h1) &&
                        (h1 < h0) &&
                        (h0 > hP1) &&
                        (hP1 > hP2);

                    const isSwingLow =
                        [l2, l1, l0, lP1, lP2].every(Number.isFinite) &&
                        (l2 > l1) &&
                        (l1 > l0) &&
                        (l0 < lP1) &&
                        (lP1 < lP2);

                    if (isSwingHigh) {
                        swingHighs.push({
                            t: candles200[i].openTime,
                            price: h0,
                            idx: i,
                            type: "H",
                        });
                    }

                    if (isSwingLow) {
                        swingLows.push({
                            t: candles200[i].openTime,
                            price: l0,
                            idx: i,
                            type: "L",
                        });
                    }
                }

                return { swingHighs, swingLows };
            };

            const buildZigZag = (swingHighs, swingLows) => {
                // 시간순 합치고, 같은 타입 연속은 더 극단값으로 치환 후 번갈아 배열 생성
                const swings = [...swingHighs, ...swingLows].sort((a, b) => a.t - b.t);

                const out = [];
                for (const p of swings) {
                    if (out.length === 0) {
                        out.push(p);
                        continue;
                    }

                    const last = out[out.length - 1];

                    if (p.type === last.type) {
                        if (p.type === "H" && p.price > last.price) out[out.length - 1] = p;
                        if (p.type === "L" && p.price < last.price) out[out.length - 1] = p;
                    } else {
                        out.push(p);
                    }
                }

                return out;
            };

            const latestOfTypeFromEnd = (points, type) => {
                for (let i = points.length - 1; i >= 0; i -= 1) {
                    if (points[i].type === type) return points[i];
                }
                return null;
            };

            const buildTrendlineFromLastTwo = (pointsOfType, endTime) => {
                if (!Array.isArray(pointsOfType) || pointsOfType.length < 2) return null;

                const p1 = pointsOfType[pointsOfType.length - 2];
                const p2 = pointsOfType[pointsOfType.length - 1];

                const dt = p2.t - p1.t;
                if (!Number.isFinite(dt) || dt === 0) return null;

                const slope = (p2.price - p1.price) / dt;
                const yEnd = p2.price + slope * (endTime - p2.t);

                return [
                    { x: p1.t, y: p1.price },
                    { x: p2.t, y: p2.price },
                    { x: endTime, y: yEnd },
                ];
            };

            const computeScore = ({ quoteVolume, supportDistPct, upsidePct, lowAgeDays }) => {
                // 유동성(로그 스케일)
                const liqScore = clamp(Math.log10((quoteVolume || 0) + 1) / 8, 0, 1);

                // 지지거리: 8% 이내면 높은 점수
                const supportScore = Number.isFinite(supportDistPct) ? (1 - clamp(supportDistPct / 0.08, 0, 1)) : 0;

                // 업사이드: 20% 이상이면 상한
                const upScore = Number.isFinite(upsidePct) ? clamp(upsidePct / 0.20, 0, 1) : 0;

                // 저점 신선도: 60일 이내면 가점
                const ageScore = Number.isFinite(lowAgeDays) ? (1 - clamp(lowAgeDays / 60, 0, 1)) : 0;

                // 가중치(실전 우선순위)
                return (0.40 * liqScore) + (0.35 * supportScore) + (0.20 * upScore) + (0.05 * ageScore);
            };

            // -----------------------------
            // Concurrency mapper
            // -----------------------------
            const mapWithConcurrency = async (items, concurrency, mapper, onProgress, signal) => {
                const results = new Array(items.length);
                let index = 0;
                let done = 0;

                const worker = async () => {
                    while (true) {
                        if (signal && signal.aborted) return;

                        const i = index;
                        index += 1;

                        if (i >= items.length) return;

                        try {
                            results[i] = await mapper(items[i], i);
                        } catch (err) {
                            results[i] = { __error: err };
                        } finally {
                            done += 1;
                            if (typeof onProgress === "function") onProgress(done, items.length);
                        }
                    }
                };

                const actual = Math.max(1, Math.min(concurrency, items.length));
                const workers = [];
                for (let i = 0; i < actual; i += 1) {
                    workers.push(worker());
                }

                await Promise.all(workers);
                return results;
            };

            // -----------------------------
            // UI: table / sort / filter / csv
            // -----------------------------
            const setUiRunning = (running) => {
                btnStart.disabled = running;
                btnStop.disabled = !running;

                $("#inpConcurrency").disabled = running;
                $("#inpTimeout").disabled = running;
                $("#inpRetries").disabled = running;

                selSort.disabled = running;
                inpSearch.disabled = running;
            };

            const setSymbolSelect = (symbols) => {
                selSymbol.innerHTML = `<option value="">(선택)</option>`;
                for (const s of symbols) {
                    const opt = document.createElement("option");
                    opt.value = s;
                    opt.textContent = s;
                    selSymbol.appendChild(opt);
                }
            };

            const applySortAndFilter = () => {
                const q = (inpSearch.value || "").trim().toUpperCase();
                const sortKey = selSort.value;

                let arr = [...state.results];

                if (q) {
                    arr = arr.filter((r) => r.symbol.toUpperCase().includes(q));
                }

                const getSafe = (v, fallback) => (Number.isFinite(v) ? v : fallback);

                arr.sort((a, b) => {
                    if (sortKey === "sym_asc") return a.symbol.localeCompare(b.symbol);

                    if (sortKey === "qv_desc") {
                        const d = (b.quoteVolume - a.quoteVolume);
                        if (Math.abs(d) > 1e-12) return d;
                        return (b.score - a.score);
                    }

                    if (sortKey === "support_asc") {
                        const ad = getSafe(a.supportDistPct, 1e9);
                        const bd = getSafe(b.supportDistPct, 1e9);
                        const d = ad - bd;
                        if (Math.abs(d) > 1e-12) return d;
                        return (b.score - a.score);
                    }

                    if (sortKey === "upside_desc") {
                        const ad = getSafe(a.upsidePct, -1e9);
                        const bd = getSafe(b.upsidePct, -1e9);
                        const d = bd - ad;
                        if (Math.abs(d) > 1e-12) return d;
                        return (b.score - a.score);
                    }

                    // default: score_desc
                    const d1 = (b.score - a.score);
                    if (Math.abs(d1) > 1e-12) return d1;

                    const d2 = (b.quoteVolume - a.quoteVolume);
                    if (Math.abs(d2) > 1e-12) return d2;

                    const ad = getSafe(a.supportDistPct, 1e9);
                    const bd = getSafe(b.supportDistPct, 1e9);
                    return ad - bd;
                });

                state.filtered = arr;
                renderTable();
                setSymbolSelect(arr.map((r) => r.symbol));

                btnCsv.disabled = arr.length === 0;
            };

            const renderTable = () => {
                tblBody.innerHTML = "";

                state.filtered.forEach((r, idx) => {
                    const tr = document.createElement("tr");
                    tr.dataset.symbol = r.symbol;

                    tr.innerHTML = `
                        <td>${idx + 1}</td>
                        <td><strong>${r.symbol}</strong></td>
                        <td>${r.score.toFixed(4)}</td>
                        <td>${fmtNum(r.quoteVolume)}</td>
                        <td>${fmtPct(r.supportDistPct)}</td>
                        <td>${fmtPct(r.upsidePct)}</td>
                        <td>${Number.isFinite(r.lowAgeDays) ? r.lowAgeDays.toFixed(0) : "-"}</td>
                        <td>${r.swingHighs.length}</td>
                        <td>${r.swingLows.length}</td>
                        <td>${isoDate(r.candles[r.candles.length - 1].openTime)}</td>
                    `;

                    tr.addEventListener("click", () => {
                        selSymbol.value = r.symbol;
                        drawSymbolChart(r.symbol);
                    });

                    tblBody.appendChild(tr);
                });

                resultSummary.innerHTML = `
                    최종 매칭: <strong class="ok">${state.results.length}개</strong>
                    (현재 표시: ${state.filtered.length}개)
                `;
            };

            const downloadCsv = () => {
                const headers = [
                    "rank",
                    "symbol",
                    "score",
                    "quoteVolumeUSDT",
                    "supportDistPct",
                    "upsidePct",
                    "lowAgeDays",
                    "swingHighCount",
                    "swingLowCount",
                    "lastClosedUTC",
                ];

                const rows = state.filtered.map((r, i) => {
                    return [
                        i + 1,
                        r.symbol,
                        r.score,
                        r.quoteVolume,
                        r.supportDistPct,
                        r.upsidePct,
                        r.lowAgeDays,
                        r.swingHighs.length,
                        r.swingLows.length,
                        isoDate(r.candles[r.candles.length - 1].openTime),
                    ];
                });

                const escape = (v) => `"${String(v).replaceAll('"', '""')}"`;
                const csv = [
                    headers.join(","),
                    ...rows.map((row) => row.map(escape).join(",")),
                ].join("\n");

                const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `binance_swing_scan_${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            };

            // -----------------------------
            // Chart: highlight plugin + zoom
            // -----------------------------
            const vHighlightPlugin = {
                id: "vHighlight",
                beforeDatasetsDraw(chartInstance, args, pluginOptions) {
                    const opts = pluginOptions || {};
                    const start = opts.start;
                    const end = opts.end;

                    if (!Number.isFinite(start) || !Number.isFinite(end)) return;

                    const { ctx, chartArea, scales } = chartInstance;
                    if (!chartArea) return;

                    const xScale = scales.x;
                    if (!xScale) return;

                    const x1 = xScale.getPixelForValue(start);
                    const x2 = xScale.getPixelForValue(end);

                    const left = Math.min(x1, x2);
                    const right = Math.max(x1, x2);

                    ctx.save();
                    ctx.fillStyle = "rgba(255, 255, 255, 0.06)";
                    ctx.fillRect(left, chartArea.top, right - left, chartArea.bottom - chartArea.top);
                    ctx.restore();
                },
            };

            const ensureChart = () => {
                if (chart) return chart;

                // plugin register (safe)
                try {
                    if (window.ChartZoom) {
                        Chart.register(window.ChartZoom);
                    }
                } catch (_) {}

                try {
                    Chart.register(vHighlightPlugin);
                } catch (_) {}

                const ctx = $("#chart").getContext("2d");

                chart = new Chart(ctx, {
                    type: "line",
                    data: {
                        datasets: [],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: "nearest",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                labels: { color: "#e7eaf0" },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (c) => {
                                        const y = c.parsed && typeof c.parsed.y === "number" ? c.parsed.y : null;
                                        if (y === null) return c.dataset.label || "";
                                        return `${c.dataset.label}: ${y}`;
                                    },
                                },
                            },
                            vHighlight: {
                                start: NaN,
                                end: NaN,
                            },
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: "x",
                                    modifierKey: "alt",
                                },
                                zoom: {
                                    wheel: {
                                        enabled: true,
                                    },
                                    pinch: {
                                        enabled: true,
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: "shift",
                                        threshold: 2,
                                    },
                                    mode: "x",
                                },
                                limits: {
                                    x: { min: "original", max: "original" },
                                    y: { min: "original", max: "original" },
                                },
                            },
                        },
                        scales: {
                            x: {
                                type: "time",
                                time: { unit: "month" },
                                ticks: { color: "#cfd6e6" },
                                grid: { color: "rgba(255,255,255,0.08)" },
                            },
                            y: {
                                ticks: { color: "#cfd6e6" },
                                grid: { color: "rgba(255,255,255,0.08)" },
                            },
                        },
                    },
                });

                return chart;
            };

            const drawSymbolChart = (symbol) => {
                const data = state.resultsMap.get(symbol);
                if (!data) return;

                const c = ensureChart();

                const candles = data.candles;
                const last = candles[candles.length - 1];
                const endTime = last.openTime;

                // V highlight range
                c.options.plugins.vHighlight.start = data.vRangeStart;
                c.options.plugins.vHighlight.end = data.vRangeEnd;

                // datasets
                const closeLine = candles.map((k) => ({ x: k.openTime, y: k.close }));

                // ZigZag line (alternating swings)
                const zigzagLine = data.zigzag.map((p) => ({ x: p.t, y: p.price }));

                // Swing points
                const swingHighPoints = data.swingHighs.map((p) => ({ x: p.t, y: p.price }));
                const swingLowPoints = data.swingLows.map((p) => ({ x: p.t, y: p.price }));

                // 요청: 스윙고점끼리 연결선 / 스윙저점끼리 연결선
                const swingHighLine = data.swingHighs.map((p) => ({ x: p.t, y: p.price }));
                const swingLowLine = data.swingLows.map((p) => ({ x: p.t, y: p.price }));

                // V low points (last 5 bars lows)
                const vLowPoints = data.vLows.map((p) => ({ x: p.t, y: p.price }));

                // Trendlines (last 2 highs/lows, extended)
                const supportLine = buildTrendlineFromLastTwo(data.swingLows, endTime);
                const resistanceLine = buildTrendlineFromLastTwo(data.swingHighs, endTime);

                c.data.datasets = [
                    {
                        label: `${symbol} Close`,
                        data: closeLine,
                        borderWidth: 1.5,
                        pointRadius: 0,
                        tension: 0.15,
                    },
                    {
                        label: `${symbol} ZigZag`,
                        data: zigzagLine,
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0,
                    },
                    {
                        label: "Swing Highs Line",
                        data: swingHighLine,
                        borderWidth: 2,
                        pointRadius: 2,
                        pointHoverRadius: 5,
                        tension: 0,
                    },
                    {
                        label: "Swing Lows Line",
                        data: swingLowLine,
                        borderWidth: 2,
                        pointRadius: 2,
                        pointHoverRadius: 5,
                        tension: 0,
                    },
                    {
                        label: "Support Trendline (last 2 Swing Lows)",
                        data: supportLine || [],
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0,
                        borderDash: [6, 6],
                    },
                    {
                        label: "Resistance Trendline (last 2 Swing Highs)",
                        data: resistanceLine || [],
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0,
                        borderDash: [6, 6],
                    },
                    {
                        label: "Swing High (points)",
                        type: "scatter",
                        data: swingHighPoints,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                    },
                    {
                        label: "Swing Low (points)",
                        type: "scatter",
                        data: swingLowPoints,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                    },
                    {
                        label: "V-Lows (last 5 bars)",
                        type: "scatter",
                        data: vLowPoints,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                    },
                ];

                c.update();

                // Reset zoom enable
                btnResetZoom.disabled = false;

                // Binance link
                btnBinance.href = `https://www.binance.com/en/futures/${encodeURIComponent(symbol)}`;
                btnBinance.style.display = "inline-block";
            };

            // -----------------------------
            // Main scan
            // -----------------------------
            const scan = async () => {
                const concurrency = Math.max(1, Math.min(20, Number($("#inpConcurrency").value) || 4));
                const timeoutMs = Math.max(2000, Math.min(60000, Number($("#inpTimeout").value) || 12000));
                const retries = Math.max(0, Math.min(10, Number($("#inpRetries").value) || 3));

                globalAbortController = new AbortController();
                const signal = globalAbortController.signal;

                // reset state
                state.symbols = [];
                state.tickers.clear();
                state.results = [];
                state.resultsMap.clear();
                state.filtered = [];

                tblBody.innerHTML = "";
                setSymbolSelect([]);
                btnCsv.disabled = true;
                btnResetZoom.disabled = true;
                btnBinance.style.display = "none";

                resultSummary.textContent = "스캔 중…";
                setUiRunning(true);

                try {
                    logStatus(["서버시간 가져오는 중…"]);
                    state.serverTime = await getServerTime({ timeoutMs, signal, retries });

                    logStatus(["exchangeInfo 가져오는 중…"]);
                    const info = await getExchangeInfo({ timeoutMs, signal, retries });

                    const symbols = (info.symbols || [])
                        .filter((s) => s.contractType === "PERPETUAL")
                        .filter((s) => s.quoteAsset === "USDT")
                        .filter((s) => s.status === "TRADING")
                        .map((s) => s.symbol);

                    state.symbols = symbols;

                    logStatus([
                        `USDT PERP 심볼: ${symbols.length}`,
                        "",
                        "24h ticker 전체 가져오는 중(거래대금/현재가)…",
                    ]);

                    const allTickers = await getAll24hTickers({ timeoutMs, signal, retries });
                    state.tickers.clear();
                    if (Array.isArray(allTickers)) {
                        for (const t of allTickers) {
                            if (!t || !t.symbol) continue;
                            state.tickers.set(String(t.symbol), {
                                lastPrice: toNumber(t.lastPrice),
                                quoteVolume: toNumber(t.quoteVolume),
                            });
                        }
                    }

                    logStatus([
                        `USDT PERP 심볼: ${symbols.length}`,
                        "",
                        "1단계: 최근 1D 완성봉 5개 저점 V-패턴 필터링…",
                    ]);

                    // Stage1: each symbol fetch 1d 10 bars, check V pattern
                    const stage1 = await mapWithConcurrency(
                        symbols,
                        concurrency,
                        async (symbol) => {
                            // small delay to reduce rate-limit bursts
                            await sleep(40);

                            const raw = await getKlines(symbol, "1d", 10, { timeoutMs, signal, retries });
                            const candles = normalizeKlines(raw, state.serverTime);

                            if (candles.length < 5) return { symbol, pass: false };
                            const pass = passesVShapeLast5Lows(candles);

                            return { symbol, pass };
                        },
                        (done, total) => {
                            logStatus([
                                `USDT PERP 심볼: ${symbols.length}`,
                                "",
                                `1단계 진행: ${done}/${total}`,
                            ]);
                        },
                        signal
                    );

                    if (signal.aborted) throw new Error("사용자 중지");

                    const filteredSymbols = stage1
                        .filter((r) => r && r.pass === true)
                        .map((r) => r.symbol);

                    logStatus([
                        `1단계 통과: ${filteredSymbols.length} / ${symbols.length}`,
                        "",
                        "2단계: 통과 심볼만 1D 260봉 조회 → (완성봉 기준) 최근 200봉 스윙 계산…",
                        "200봉 미만 심볼은 제외됨.",
                    ]);

                    // Stage2: for filtered symbols, fetch more bars, require >=200 closed
                    const stage2 = await mapWithConcurrency(
                        filteredSymbols,
                        concurrency,
                        async (symbol) => {
                            await sleep(60);

                            const raw = await getKlines(symbol, "1d", 260, { timeoutMs, signal, retries });
                            const allClosed = normalizeKlines(raw, state.serverTime);

                            if (allClosed.length < 200) {
                                return { symbol, excluded: true, reason: "candles<200" };
                            }

                            const candles200 = allClosed.slice(-200);

                            // V-range highlight: last 5 bars within these 200
                            const m = candles200.length;
                            const vRangeStart = candles200[m - 5].openTime;
                            const vRangeEnd = candles200[m - 1].closeTime;
                            const vLows = candles200.slice(m - 5).map((c) => ({ t: c.openTime, price: c.low }));

                            const { swingHighs, swingLows } = detectSwings(candles200);
                            const zigzag = buildZigZag(swingHighs, swingLows);

                            const lastClose = candles200[candles200.length - 1].close;

                            const latestLow = latestOfTypeFromEnd(zigzag, "L");
                            const latestHigh = latestOfTypeFromEnd(zigzag, "H");

                            const supportDistPct = latestLow ? (lastClose - latestLow.price) / lastClose : NaN;
                            const upsidePct = latestHigh ? (latestHigh.price - lastClose) / lastClose : NaN;

                            const lowAgeDays = latestLow
                                ? (candles200[candles200.length - 1].openTime - latestLow.t) / 86400000
                                : NaN;

                            const t = state.tickers.get(symbol) || { quoteVolume: 0, lastPrice: NaN };
                            const quoteVolume = Number.isFinite(t.quoteVolume) ? t.quoteVolume : 0;

                            const score = computeScore({ quoteVolume, supportDistPct, upsidePct, lowAgeDays });

                            const result = {
                                symbol,
                                candles: candles200,
                                swingHighs,
                                swingLows,
                                zigzag,

                                vRangeStart,
                                vRangeEnd,
                                vLows,

                                quoteVolume,
                                lastClose,
                                supportDistPct,
                                upsidePct,
                                lowAgeDays,
                                score,
                            };

                            return result;
                        },
                        (done, total) => {
                            logStatus([
                                `1단계 통과: ${filteredSymbols.length} / ${symbols.length}`,
                                "",
                                `2단계 진행: ${done}/${total}`,
                                `최종 누적(200봉 충족): ${state.results.length}`,
                            ]);
                        },
                        signal
                    );

                    if (signal.aborted) throw new Error("사용자 중지");

                    const finalResults = stage2
                        .filter((r) => r && !r.__error && !r.excluded && r.candles && r.candles.length === 200);

                    // store
                    state.results = finalResults;
                    state.resultsMap.clear();
                    for (const r of finalResults) {
                        state.resultsMap.set(r.symbol, r);
                    }

                    applySortAndFilter();

                    logStatus([
                        "완료!",
                        `총 심볼: ${symbols.length}`,
                        `1단계 통과: ${filteredSymbols.length}`,
                        `최종(200봉 충족): ${finalResults.length}`,
                        "",
                        "테이블 클릭 또는 심볼 선택으로 차트 확인 가능",
                    ]);

                    // auto draw first
                    if (state.filtered.length > 0) {
                        selSymbol.value = state.filtered[0].symbol;
                        drawSymbolChart(state.filtered[0].symbol);
                    }
                } catch (err) {
                    const msg = err && err.message ? err.message : String(err);
                    logStatus([
                        "중단/오류:",
                        msg.includes("사용자 중지") ? "사용자가 중지했어." : msg,
                        "",
                        "CORS 이슈면 로컬 서버(http://localhost)로 열어줘.",
                    ]);
                    resultSummary.innerHTML = `<span class="danger">중단/오류: ${msg}</span>`;
                } finally {
                    setUiRunning(false);
                    globalAbortController = null;
                }
            };

            // -----------------------------
            // Events
            // -----------------------------
            btnStart.addEventListener("click", () => {
                scan();
            });

            btnStop.addEventListener("click", () => {
                if (globalAbortController) globalAbortController.abort();
            });

            selSymbol.addEventListener("change", () => {
                const symbol = selSymbol.value;
                if (!symbol) return;
                drawSymbolChart(symbol);
            });

            selSort.addEventListener("change", () => {
                applySortAndFilter();
            });

            inpSearch.addEventListener("input", () => {
                applySortAndFilter();
            });

            btnCsv.addEventListener("click", () => {
                downloadCsv();
            });

            btnResetZoom.addEventListener("click", () => {
                if (!chart) return;
                if (typeof chart.resetZoom === "function") chart.resetZoom();
            });

            // init chart
            ensureChart();
        </script>
    </body>
</html>
