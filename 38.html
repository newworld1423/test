<!DOCTYPE html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp Swing Scanner (TF Select, No 1M)</title>

        <!-- Chart.js -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
        <!-- Time scale adapter -->
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
        <!-- Hammer.js (pinch support) -->
        <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
        <!-- chartjs zoom plugin -->
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.umd.min.js"></script>

        <style>
            body {
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
                margin: 0;
                padding: 16px;
                background: #0b0f17;
                color: #e7eaf0;
            }

            .wrap {
                max-width: 1240px;
                margin: 0 auto;
            }

            .card {
                background: #121a2a;
                border: 1px solid #1e2a44;
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 16px;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }

            label {
                font-size: 13px;
                opacity: 0.9;
            }

            input,
            select,
            button {
                border-radius: 10px;
                border: 1px solid #2a3a5f;
                background: #0f1524;
                color: #e7eaf0;
                padding: 10px 12px;
                font-size: 14px;
            }

            button {
                cursor: pointer;
                background: #1a2640;
            }

            button:hover {
                background: #223255;
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            .muted {
                opacity: 0.75;
                font-size: 13px;
                line-height: 1.5;
            }

            .status {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
                    monospace;
                font-size: 12px;
                white-space: pre-wrap;
                background: #0a0f1c;
                border: 1px solid #1e2a44;
                border-radius: 10px;
                padding: 12px;
                margin-top: 12px;
                max-height: 240px;
                overflow: auto;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 12px;
                font-size: 14px;
            }

            th,
            td {
                border-bottom: 1px solid #1e2a44;
                padding: 10px 8px;
                text-align: left;
                white-space: nowrap;
            }

            th {
                opacity: 0.9;
                font-weight: 700;
                position: sticky;
                top: 0;
                background: #121a2a;
                z-index: 1;
            }

            tr:hover {
                background: rgba(255, 255, 255, 0.04);
                cursor: pointer;
            }

            .pill {
                display: inline-block;
                padding: 2px 8px;
                border-radius: 999px;
                border: 1px solid #2a3a5f;
                font-size: 12px;
                opacity: 0.92;
            }

            .ok {
                color: #7cff9b;
            }

            .danger {
                color: #ff6b6b;
            }

            .chartBox {
                width: 100%;
                height: 560px;
            }

            canvas {
                width: 100% !important;
                height: 100% !important;
                display: block;
            }

            #chart {
                touch-action: none;
            }

            .right {
                margin-left: auto;
            }

            .grow {
                flex: 1 1 auto;
                min-width: 220px;
            }

            /* th 클릭 정렬 UI */
            th.sortable {
                cursor: pointer;
                user-select: none;
            }

            th.sortable:hover {
                background: rgba(255, 255, 255, 0.04);
            }

            .thLabel {
                display: inline-flex;
                align-items: center;
                gap: 6px;
            }

            .sortMark {
                opacity: 0.9;
                font-size: 12px;
            }
        </style>
    </head>

    <body>
        <div class="wrap">
            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <div>
                        <div style="font-size: 18px; font-weight: 800;">
                            Binance USDT 무기한 스윙 스캐너 (TF 선택 / 1M 제외)
                        </div>
                        <div class="muted" style="margin-top: 6px;">
                            1) 선택 TF 최근 5개 완성봉 저점:
                            <span class="pill">a[-5] &gt; a[-4] &gt; a[-3] &lt; a[-2] &lt; a[-1]</span
                            ><br />
                            2) 통과 심볼만 최근 <span class="pill">200개 완성봉</span>에서 스윙 탐지(5봉)<br />
                            - 스윙고점:
                            <span class="pill">b[-2].H &lt; b[-1].H &lt; b.H &gt; b[1].H &gt; b[2].H</span
                            ><br />
                            - 스윙저점:
                            <span class="pill">b[-2].L &gt; b[-1].L &gt; b.L &lt; b[1].L &lt; b[2].L</span
                            ><br />
                            3) 차트:
                            <span class="pill">스윙고점 연결선</span> + <span class="pill">스윙저점 연결선</span> + 점 표시만
                        </div>
                        <div class="muted" style="margin-top: 6px;">
                            <span class="pill">줌/팬</span> 휠=줌, Shift+드래그=박스줌, Alt+드래그=팬, Reset 버튼=원복
                        </div>
                        <div class="muted" style="margin-top: 6px;">
                            <span class="pill">2단계 추가조건</span>
                            ① 1단계 스윙저점이 이전 스윙저점보다 높음(Higher Low)
                            ② 최근 스윙고점이 이전 스윙고점보다 높음(Higher High)
                        </div>
                    </div>
                    <div class="row">
                        <button id="btnStart">스캔 시작</button>
                        <button id="btnStop" disabled>중지</button>
                    </div>
                </div>

                <div class="row" style="margin-top: 12px;">
                    <div>
                        <label>타임프레임</label><br />
                        <select id="selTf" style="width: 160px;">
                            <option value="15m">15m</option>
                            <option value="1h">1h</option>
                            <option value="4h" selected>4h</option>
                            <option value="1d">1d</option>
                            <option value="1w">1w</option>
                        </select>
                    </div>
                    <div>
                        <label>동시 요청(Concurrency)</label><br />
                        <input
                            id="inpConcurrency"
                            type="number"
                            min="1"
                            max="20"
                            value="4"
                            style="width: 140px;"
                        />
                    </div>
                    <div>
                        <label>요청 타임아웃(ms)</label><br />
                        <input
                            id="inpTimeout"
                            type="number"
                            min="2000"
                            max="60000"
                            value="12000"
                            style="width: 140px;"
                        />
                    </div>
                    <div>
                        <label>재시도 횟수</label><br />
                        <input
                            id="inpRetries"
                            type="number"
                            min="0"
                            max="10"
                            value="3"
                            style="width: 140px;"
                        />
                    </div>

                    <div class="right row" style="gap: 8px;">
                        <label>정렬</label>
                        <select id="selSort">
                            <option value="custom">TH 클릭 정렬</option>
                            <option value="score_desc" selected>추천순(Score) ↓</option>
                            <option value="qv_desc">24h 거래대금(QuoteVol) ↓</option>
                            <option value="support_asc">SupportDist% ↑(저점 가까운)</option>
                            <option value="upside_desc">Upside% ↓(위공간 큰)</option>
                            <option value="sym_asc">심볼 A→Z</option>
                        </select>

                        <input id="inpSearch" class="grow" placeholder="검색: BTC, ETH..." />
                        <button id="btnCsv" disabled>CSV</button>
                    </div>
                </div>

                <div id="status" class="status">대기 중…</div>
            </div>

            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <div style="font-size: 16px; font-weight: 800;">결과</div>
                    <div class="row">
                        <label>심볼 선택</label>
                        <select id="selSymbol" style="min-width: 220px;">
                            <option value="">(스캔 후 선택)</option>
                        </select>
                    </div>
                </div>

                <div class="muted" id="resultSummary" style="margin-top: 8px;">아직 결과가 없어.</div>

                <div
                    style="
                        overflow: auto;
                        max-height: 420px;
                        border: 1px solid #1e2a44;
                        border-radius: 12px;
                        margin-top: 10px;
                    "
                >
                    <table id="tblResults">
                        <thead>
                            <tr>
                                <th>#</th>

                                <th class="sortable" data-sort-key="symbol">
                                    <span class="thLabel"
                                        >Symbol <span class="sortMark" data-sort-mark="symbol"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="tf">
                                    <span class="thLabel">TF <span class="sortMark" data-sort-mark="tf"></span></span>
                                </th>

                                <th class="sortable" data-sort-key="score">
                                    <span class="thLabel"
                                        >Score <span class="sortMark" data-sort-mark="score"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="quoteVolume">
                                    <span class="thLabel"
                                        >24h QuoteVol(USDT)
                                        <span class="sortMark" data-sort-mark="quoteVolume"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="supportDistPct">
                                    <span class="thLabel"
                                        >SupportDist%
                                        <span class="sortMark" data-sort-mark="supportDistPct"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="upsidePct">
                                    <span class="thLabel"
                                        >Upside% <span class="sortMark" data-sort-mark="upsidePct"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="lowAgeDays">
                                    <span class="thLabel"
                                        >LowAge(d) <span class="sortMark" data-sort-mark="lowAgeDays"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="lowRisePct">
                                    <span class="thLabel"
                                        >LowRise%
                                        <span class="sortMark" data-sort-mark="lowRisePct"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="swH">
                                    <span class="thLabel">SwH <span class="sortMark" data-sort-mark="swH"></span></span>
                                </th>

                                <th class="sortable" data-sort-key="swL">
                                    <span class="thLabel">SwL <span class="sortMark" data-sort-mark="swL"></span></span>
                                </th>

                                <th class="sortable" data-sort-key="highRisePct">
                                    <span class="thLabel"
                                        >HighRise%
                                        <span class="sortMark" data-sort-mark="highRisePct"></span
                                    ></span>
                                </th>

                                <th class="sortable" data-sort-key="lastOpenTime">
                                    <span class="thLabel"
                                        >마지막 완성봉(UTC)
                                        <span class="sortMark" data-sort-mark="lastOpenTime"></span
                                    ></span>
                                </th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <div style="font-size: 16px; font-weight: 800;">차트</div>
                    <div class="row">
                        <button id="btnZoomIn" disabled>Zoom In</button>
                        <button id="btnZoomOut" disabled>Zoom Out</button>
                        <button id="btnResetZoom" disabled>Reset Zoom</button>
                        <a
                            id="btnBinance"
                            class="pill"
                            target="_blank"
                            rel="noopener noreferrer"
                            style="text-decoration: none; color: inherit; display: none;"
                            >Binance</a
                        >
                    </div>
                </div>

                <div class="muted" style="margin-top: 8px;">
                    - <span class="pill">Swing Highs Line</span> 스윙고점끼리 연결선<br />
                    - <span class="pill">Swing Lows Line</span> 스윙저점끼리 연결선<br />
                    - (종가/지그재그/추세선/V-lows 없음)
                </div>

                <div class="chartBox">
                    <canvas id="chart"></canvas>
                </div>
            </div>
        </div>

        <script>
            "use strict";

            const BINANCE_FAPI = "https://fapi.binance.com";

            const $ = (sel) => document.querySelector(sel);

            const btnStart = $("#btnStart");
            const btnStop = $("#btnStop");
            const btnCsv = $("#btnCsv");
            const btnZoomIn = $("#btnZoomIn");
            const btnZoomOut = $("#btnZoomOut");
            const btnResetZoom = $("#btnResetZoom");
            const btnBinance = $("#btnBinance");

            const selTf = $("#selTf");
            const inpConcurrency = $("#inpConcurrency");
            const inpTimeout = $("#inpTimeout");
            const inpRetries = $("#inpRetries");

            const statusEl = $("#status");
            const resultSummary = $("#resultSummary");
            const tblBody = $("#tblResults tbody");
            const selSymbol = $("#selSymbol");
            const selSort = $("#selSort");
            const inpSearch = $("#inpSearch");

            let globalAbortController = null;
            let chart = null;

            const state = {
                serverTime: 0,
                symbols: [],
                tickers: new Map(),
                results: [],
                resultsMap: new Map(),
                filtered: [],
                selectedTf: "4h",

                // TH 클릭 정렬 상태
                sort: { key: "score", dir: "desc" },
            };

            // -----------------------------
            // Helpers
            // -----------------------------
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

            const toNumber = (v) => {
                const n = Number(v);
                return Number.isFinite(n) ? n : NaN;
            };

            const isoDate = (ms) => new Date(ms).toISOString().slice(0, 10);

            const fmtUtc = (ms) => {
                if (!Number.isFinite(ms)) return "-";
                const d = new Date(ms);
                const yyyy = d.getUTCFullYear();
                const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
                const dd = String(d.getUTCDate()).padStart(2, "0");
                const hh = String(d.getUTCHours()).padStart(2, "0");
                const mi = String(d.getUTCMinutes()).padStart(2, "0");
                return `${yyyy}-${mm}-${dd} ${hh}:${mi} UTC`;
            };

            const fmtPrice = (p) => {
                if (!Number.isFinite(p)) return "-";
                const abs = Math.abs(p);
                if (abs >= 1000) return p.toFixed(2);
                if (abs >= 100) return p.toFixed(3);
                if (abs >= 1) return p.toFixed(4);
                if (abs >= 0.01) return p.toFixed(6);
                return p.toFixed(8);
            };

            const fmtNum = (n) => {
                if (!Number.isFinite(n)) return "-";
                const abs = Math.abs(n);
                if (abs >= 1e9) return (n / 1e9).toFixed(2) + "B";
                if (abs >= 1e6) return (n / 1e6).toFixed(2) + "M";
                if (abs >= 1e3) return (n / 1e3).toFixed(2) + "K";
                return n.toFixed(2);
            };

            const fmtPct = (v) => {
                if (!Number.isFinite(v)) return "-";
                return (v * 100).toFixed(2) + "%";
            };

            const logStatus = (lines) => {
                statusEl.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines);
            };

            const getTimeUnitForTf = (tf) => {
                if (tf === "15m") return "day";
                if (tf === "1h") return "day";
                if (tf === "4h") return "week";
                if (tf === "1d") return "month";
                if (tf === "1w") return "quarter";
                return "month";
            };

            const getIntervalMs = (tf) => {
                if (tf === "15m") return 15 * 60 * 1000;
                if (tf === "1h") return 60 * 60 * 1000;
                if (tf === "4h") return 4 * 60 * 60 * 1000;
                if (tf === "1d") return 24 * 60 * 60 * 1000;
                if (tf === "1w") return 7 * 24 * 60 * 60 * 1000;
                return 60 * 60 * 1000;
            };

            const anySignal = (signals) => {
                const controller = new AbortController();

                const onAbort = () => {
                    controller.abort();
                    for (const s of signals) {
                        if (s) s.removeEventListener("abort", onAbort);
                    }
                };

                for (const s of signals) {
                    if (!s) continue;
                    if (s.aborted) {
                        controller.abort();
                        return controller.signal;
                    }
                    s.addEventListener("abort", onAbort, { once: true });
                }

                return controller.signal;
            };

            const fetchJson = async (url, { timeoutMs = 12000, signal = null } = {}) => {
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), timeoutMs);
                const mergedSignal = signal ? anySignal([signal, controller.signal]) : controller.signal;

                try {
                    const res = await fetch(url, { signal: mergedSignal });
                    const text = await res.text();

                    if (!res.ok) {
                        const err = new Error(`HTTP ${res.status} ${res.statusText} - ${text.slice(0, 160)}`);
                        err.status = res.status;
                        throw err;
                    }

                    return JSON.parse(text);
                } finally {
                    clearTimeout(timer);
                }
            };

            const fetchJsonWithRetry = async (url, { timeoutMs, signal, retries = 3 } = {}) => {
                let lastErr = null;

                for (let attempt = 0; attempt <= retries; attempt += 1) {
                    try {
                        return await fetchJson(url, { timeoutMs, signal });
                    } catch (err) {
                        lastErr = err;

                        if (signal && signal.aborted) throw err;

                        const status = err && typeof err.status === "number" ? err.status : 0;
                        const isRateLimited = status === 429 || status === 418;

                        if (attempt === retries) break;

                        const backoff = isRateLimited ? (900 + attempt * 650) : (350 + attempt * 300);
                        await sleep(backoff);
                    }
                }

                throw lastErr;
            };

            const getServerTime = async ({ timeoutMs, signal, retries }) => {
                const data = await fetchJsonWithRetry(`${BINANCE_FAPI}/fapi/v1/time`, { timeoutMs, signal, retries });
                return data.serverTime;
            };

            const getExchangeInfo = async ({ timeoutMs, signal, retries }) => {
                return await fetchJsonWithRetry(`${BINANCE_FAPI}/fapi/v1/exchangeInfo`, { timeoutMs, signal, retries });
            };

            const getAll24hTickers = async ({ timeoutMs, signal, retries }) => {
                return await fetchJsonWithRetry(`${BINANCE_FAPI}/fapi/v1/ticker/24hr`, { timeoutMs, signal, retries });
            };

            const getKlines = async (symbol, interval, limit, { timeoutMs, signal, retries }) => {
                const url = `${BINANCE_FAPI}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
                return await fetchJsonWithRetry(url, { timeoutMs, signal, retries });
            };

            const normalizeKlines = (rawKlines, serverTime) => {
                const candles = rawKlines.map((k) => {
                    return {
                        openTime: toNumber(k[0]),
                        open: toNumber(k[1]),
                        high: toNumber(k[2]),
                        low: toNumber(k[3]),
                        close: toNumber(k[4]),
                        volume: toNumber(k[5]),
                        closeTime: toNumber(k[6]),
                    };
                });

                // 진행 중(완성 전) 캔들 제거
                if (candles.length > 0) {
                    const last = candles[candles.length - 1];
                    if (Number.isFinite(last.closeTime) && last.closeTime > serverTime) {
                        candles.pop();
                    }
                }

                return candles;
            };

            // -----------------------------
            // Conditions / Swing detection
            // -----------------------------
            const passesVShapeLast5Lows = (candles) => {
                if (!candles || candles.length < 5) return false;

                const m = candles.length;

                const l5 = candles[m - 5].low;
                const l4 = candles[m - 4].low;
                const l3 = candles[m - 3].low;
                const l2 = candles[m - 2].low;
                const l1 = candles[m - 1].low;

                if (![l5, l4, l3, l2, l1].every(Number.isFinite)) return false;

                return (l5 > l4) && (l4 > l3) && (l3 < l2) && (l2 < l1);
            };

            // 1단계 스윙저점: a[-3]
            const getStage1SwingLowFromLast5 = (candles) => {
                if (!candles || candles.length < 5) return null;
                const m = candles.length;
                const c = candles[m - 3];
                if (!c || !Number.isFinite(c.openTime) || !Number.isFinite(c.low)) return null;
                return { t: c.openTime, price: c.low };
            };

            const detectSwings = (candles200) => {
                const swingHighs = [];
                const swingLows = [];

                for (let i = 2; i <= candles200.length - 3; i += 1) {
                    const h2 = candles200[i - 2].high;
                    const h1 = candles200[i - 1].high;
                    const h0 = candles200[i].high;
                    const hP1 = candles200[i + 1].high;
                    const hP2 = candles200[i + 2].high;

                    const l2 = candles200[i - 2].low;
                    const l1 = candles200[i - 1].low;
                    const l0 = candles200[i].low;
                    const lP1 = candles200[i + 1].low;
                    const lP2 = candles200[i + 2].low;

                    const isSwingHigh =
                        [h2, h1, h0, hP1, hP2].every(Number.isFinite) &&
                        (h2 < h1) &&
                        (h1 < h0) &&
                        (h0 > hP1) &&
                        (hP1 > hP2);

                    const isSwingLow =
                        [l2, l1, l0, lP1, lP2].every(Number.isFinite) &&
                        (l2 > l1) &&
                        (l1 > l0) &&
                        (l0 < lP1) &&
                        (lP1 < lP2);

                    if (isSwingHigh) {
                        swingHighs.push({ t: candles200[i].openTime, price: h0, idx: i, type: "H" });
                    }

                    if (isSwingLow) {
                        swingLows.push({ t: candles200[i].openTime, price: l0, idx: i, type: "L" });
                    }
                }

                return { swingHighs, swingLows };
            };

            const findClosestSwingLowByTime = (swingLows, targetTime, tfIntervalMs) => {
                if (!Array.isArray(swingLows) || swingLows.length === 0) return null;
                if (!Number.isFinite(targetTime)) return null;

                // 1) 정확히 같은 시간 우선
                for (let i = swingLows.length - 1; i >= 0; i -= 1) {
                    if (swingLows[i].t === targetTime) return swingLows[i];
                }

                // 2) 근접 매칭
                const tol = Math.max(1, Math.floor(tfIntervalMs * 0.6));
                let best = null;
                let bestAbs = Infinity;

                for (const p of swingLows) {
                    if (!Number.isFinite(p.t)) continue;
                    const d = Math.abs(p.t - targetTime);
                    if (d < bestAbs) {
                        bestAbs = d;
                        best = p;
                    }
                }

                if (best && bestAbs <= tol) return best;
                return null;
            };

            const findTargetHighAbove = (swingHighs, lastClose, afterTime) => {
                if (!Array.isArray(swingHighs) || swingHighs.length === 0) return null;

                const candidates = swingHighs
                    .filter((h) => Number.isFinite(h.price) && h.price > lastClose)
                    .filter((h) => (Number.isFinite(afterTime) ? h.t >= afterTime : true))
                    .sort((a, b) => a.price - b.price);

                if (candidates.length > 0) return candidates[0];

                let max = swingHighs[0];
                for (const h of swingHighs) {
                    if (h.price > max.price) max = h;
                }
                return max;
            };

            const computeScore = ({ quoteVolume, supportDistPct, upsidePct, lowAgeDays }) => {
                const liqScore = clamp(Math.log10((quoteVolume || 0) + 1) / 8, 0, 1);
                const supportScore = Number.isFinite(supportDistPct) ? (1 - clamp(supportDistPct / 0.08, 0, 1)) : 0;
                const upScore = Number.isFinite(upsidePct) ? clamp(upsidePct / 0.20, 0, 1) : 0;
                const ageScore = Number.isFinite(lowAgeDays) ? (1 - clamp(lowAgeDays / 60, 0, 1)) : 0;

                return (0.40 * liqScore) + (0.35 * supportScore) + (0.20 * upScore) + (0.05 * ageScore);
            };

            // -----------------------------
            // Concurrency mapper
            // -----------------------------
            const mapWithConcurrency = async (items, concurrency, mapper, onProgress, signal) => {
                const results = new Array(items.length);
                let index = 0;
                let done = 0;

                const worker = async () => {
                    while (true) {
                        if (signal && signal.aborted) return;

                        const i = index;
                        index += 1;

                        if (i >= items.length) return;

                        try {
                            results[i] = await mapper(items[i], i);
                        } catch (err) {
                            results[i] = { __error: err };
                        } finally {
                            done += 1;
                            if (typeof onProgress === "function") onProgress(done, items.length);
                        }
                    }
                };

                const actual = Math.max(1, Math.min(concurrency, items.length));
                const workers = [];
                for (let i = 0; i < actual; i += 1) {
                    workers.push(worker());
                }

                await Promise.all(workers);
                return results;
            };

            // -----------------------------
            // UI + Sorting
            // -----------------------------
            const setUiRunning = (running) => {
                btnStart.disabled = running;
                btnStop.disabled = !running;

                selTf.disabled = running;
                inpConcurrency.disabled = running;
                inpTimeout.disabled = running;
                inpRetries.disabled = running;

                selSort.disabled = running;
                inpSearch.disabled = running;
            };

            const setChartControlsEnabled = (enabled) => {
                btnZoomIn.disabled = !enabled;
                btnZoomOut.disabled = !enabled;
                btnResetZoom.disabled = !enabled;
            };

            const setSymbolSelect = (symbols) => {
                selSymbol.innerHTML = `<option value="">(선택)</option>`;
                for (const s of symbols) {
                    const opt = document.createElement("option");
                    opt.value = s;
                    opt.textContent = s;
                    selSymbol.appendChild(opt);
                }
            };

            const setSort = (key) => {
                if (!key) return;

                if (state.sort.key === key) {
                    state.sort.dir = (state.sort.dir === "asc") ? "desc" : "asc";
                } else {
                    state.sort.key = key;

                    if (key === "symbol" || key === "tf") {
                        state.sort.dir = "asc";
                    } else if (key === "supportDistPct") {
                        state.sort.dir = "asc";
                    } else {
                        state.sort.dir = "desc";
                    }
                }

                selSort.value = "custom";
                updateSortMarks();
                applySortAndFilter();
            };

            const updateSortMarks = () => {
                const marks = document.querySelectorAll("[data-sort-mark]");
                for (const el of marks) {
                    el.textContent = "";
                }

                const key = state.sort.key;
                const dir = state.sort.dir;
                const target = document.querySelector(`[data-sort-mark="${CSS.escape(key)}"]`);
                if (!target) return;

                target.textContent = dir === "asc" ? "▲" : "▼";
            };

            const getSortValue = (r, key) => {
                if (key === "symbol") return String(r.symbol || "");
                if (key === "tf") return String(r.tf || "");
                if (key === "score") return r.score;
                if (key === "quoteVolume") return r.quoteVolume;
                if (key === "supportDistPct") return r.supportDistPct;
                if (key === "upsidePct") return r.upsidePct;
                if (key === "lowAgeDays") return r.lowAgeDays;
                if (key === "lowRisePct") return r.lowRisePct;
                if (key === "swH") return (r.swingHighs ? r.swingHighs.length : 0);
                if (key === "swL") return (r.swingLows ? r.swingLows.length : 0);
                if (key === "highRisePct") return r.highRisePct;
                if (key === "lastOpenTime") return r.lastOpenTime;
                return null;
            };

            const compareValues = (a, b, dir) => {
                const asc = dir === "asc";

                const aNum = (typeof a === "number") && Number.isFinite(a);
                const bNum = (typeof b === "number") && Number.isFinite(b);

                if (aNum && bNum) {
                    const d = a - b;
                    return asc ? d : -d;
                }

                if ((a === null || a === undefined || (typeof a === "number" && !Number.isFinite(a))) &&
                    (b === null || b === undefined || (typeof b === "number" && !Number.isFinite(b)))) {
                    return 0;
                }
                if (a === null || a === undefined || (typeof a === "number" && !Number.isFinite(a))) return 1;
                if (b === null || b === undefined || (typeof b === "number" && !Number.isFinite(b))) return -1;

                const as = String(a);
                const bs = String(b);
                const d = as.localeCompare(bs);
                return asc ? d : -d;
            };

            const applySortAndFilter = () => {
                const q = (inpSearch.value || "").trim().toUpperCase();

                let arr = [...state.results];

                if (q) {
                    arr = arr.filter((r) => String(r.symbol || "").toUpperCase().includes(q));
                }

                const key = state.sort.key;
                const dir = state.sort.dir;

                arr.sort((ra, rb) => {
                    const va = getSortValue(ra, key);
                    const vb = getSortValue(rb, key);

                    const primary = compareValues(va, vb, dir);
                    if (Math.abs(primary) > 1e-12) return primary;

                    const s = compareValues(ra.score, rb.score, "desc");
                    if (Math.abs(s) > 1e-12) return s;

                    const qv = compareValues(ra.quoteVolume, rb.quoteVolume, "desc");
                    if (Math.abs(qv) > 1e-12) return qv;

                    return String(ra.symbol || "").localeCompare(String(rb.symbol || ""));
                });

                state.filtered = arr;
                renderTable();
                setSymbolSelect(arr.map((r) => r.symbol));

                btnCsv.disabled = arr.length === 0;

                updateSortMarks();
            };

            const renderTable = () => {
                tblBody.innerHTML = "";

                state.filtered.forEach((r, idx) => {
                    const tr = document.createElement("tr");
                    tr.dataset.symbol = r.symbol;

                    tr.innerHTML = `
                        <td>${idx + 1}</td>
                        <td><strong>${r.symbol}</strong></td>
                        <td>${r.tf}</td>
                        <td>${r.score.toFixed(4)}</td>
                        <td>${fmtNum(r.quoteVolume)}</td>
                        <td>${fmtPct(r.supportDistPct)}</td>
                        <td>${fmtPct(r.upsidePct)}</td>
                        <td>${Number.isFinite(r.lowAgeDays) ? r.lowAgeDays.toFixed(1) : "-"}</td>
                        <td>${fmtPct(r.lowRisePct)}</td>
                        <td>${r.swingHighs.length}</td>
                        <td>${r.swingLows.length}</td>
                        <td>${fmtPct(r.highRisePct)}</td>
                        <td>${isoDate(r.lastOpenTime)}</td>
                    `;

                    tr.addEventListener("click", () => {
                        selSymbol.value = r.symbol;
                        drawSymbolChart(r.symbol);
                    });

                    tblBody.appendChild(tr);
                });

                resultSummary.innerHTML = `
                    TF: <strong class="pill">${state.selectedTf}</strong>
                    최종 매칭: <strong class="ok">${state.results.length}개</strong>
                    (현재 표시: ${state.filtered.length}개)
                `;
            };

            const downloadCsv = () => {
                const headers = [
                    "rank",
                    "symbol",
                    "tf",
                    "score",
                    "quoteVolumeUSDT",
                    "supportDistPct",
                    "upsidePct",
                    "lowAgeDays",
                    "stage1LowRisePct",
                    "swingHighCount",
                    "swingLowCount",
                    "lastHighRisePct",
                    "lastClosedUTC",
                ];

                const rows = state.filtered.map((r, i) => {
                    return [
                        i + 1,
                        r.symbol,
                        r.tf,
                        r.score,
                        r.quoteVolume,
                        r.supportDistPct,
                        r.upsidePct,
                        r.lowAgeDays,
                        r.lowRisePct,
                        r.swingHighs.length,
                        r.swingLows.length,
                        r.highRisePct,
                        isoDate(r.lastOpenTime),
                    ];
                });

                const escape = (v) => `"${String(v).replaceAll('"', '""')}"`;
                const csv = [
                    headers.join(","),
                    ...rows.map((row) => row.map(escape).join(",")),
                ].join("\n");

                const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `binance_swing_scan_${state.selectedTf}_${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            };

            // -----------------------------
            // Chart + Zoom + 정확한 포인트 툴팁
            // -----------------------------
            const resolveZoomPlugin = () => {
                const cand =
                    window.ChartZoom ||
                    window.zoomPlugin ||
                    window.ZoomPlugin ||
                    window["chartjs-plugin-zoom"];

                if (!cand) return null;

                const plugin = cand.default ? cand.default : cand;
                return plugin && typeof plugin === "object" ? plugin : null;
            };

            const ensureChart = () => {
                if (chart) return chart;

                const zoomPlugin = resolveZoomPlugin();

                try {
                    if (zoomPlugin && zoomPlugin.id) {
                        Chart.register(zoomPlugin);
                    }
                } catch (_) {}

                const ctx = $("#chart").getContext("2d");

                chart = new Chart(ctx, {
                    type: "line",
                    plugins: zoomPlugin ? [zoomPlugin] : [],
                    data: {
                        datasets: [],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: "nearest",
                            intersect: true,
                        },
                        hover: {
                            mode: "nearest",
                            intersect: true,
                        },
                        onHover: (evt, elements) => {
                            const canvas = evt && evt.native && evt.native.target ? evt.native.target : null;
                            if (!canvas) return;
                            canvas.style.cursor = (elements && elements.length) ? "pointer" : "default";
                        },
                        plugins: {
                            legend: {
                                labels: { color: "#e7eaf0" },
                            },
                            tooltip: {
                                enabled: true,
                                mode: "nearest",
                                intersect: true,
                                filter: (item) => {
                                    return item && item.dataset && item.dataset.type === "scatter";
                                },
                                callbacks: {
                                    title: (items) => {
                                        const it = items && items[0] ? items[0] : null;
                                        const x = it && it.parsed ? it.parsed.x : NaN;
                                        return fmtUtc(x);
                                    },
                                    label: (c) => {
                                        const y = c && c.parsed ? c.parsed.y : NaN;
                                        const name = c && c.dataset && c.dataset.label ? c.dataset.label : "";
                                        return `${name}: ${fmtPrice(y)}`;
                                    },
                                },
                            },
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: "x",
                                    modifierKey: "alt",
                                },
                                zoom: {
                                    wheel: { enabled: true },
                                    pinch: { enabled: true },
                                    drag: {
                                        enabled: true,
                                        modifierKey: "shift",
                                        threshold: 2,
                                    },
                                    mode: "x",
                                },
                                limits: {
                                    x: { min: "original", max: "original" },
                                    y: { min: "original", max: "original" },
                                },
                            },
                        },
                        scales: {
                            x: {
                                type: "time",
                                time: { unit: "week" },
                                ticks: { color: "#cfd6e6" },
                                grid: { color: "rgba(255,255,255,0.08)" },
                            },
                            y: {
                                ticks: { color: "#cfd6e6" },
                                grid: { color: "rgba(255,255,255,0.08)" },
                            },
                        },
                    },
                });

                return chart;
            };

            const drawSymbolChart = (symbol) => {
                const data = state.resultsMap.get(symbol);
                if (!data) return;

                const c = ensureChart();
                c.options.scales.x.time.unit = getTimeUnitForTf(state.selectedTf);

                const swingHighLine = data.swingHighs.map((p) => ({ x: p.t, y: p.price }));
                const swingLowLine = data.swingLows.map((p) => ({ x: p.t, y: p.price }));

                const swingHighPoints = data.swingHighs.map((p) => ({ x: p.t, y: p.price }));
                const swingLowPoints = data.swingLows.map((p) => ({ x: p.t, y: p.price }));

                c.data.datasets = [
                    {
                        label: `Swing Highs Line (${symbol})`,
                        data: swingHighLine,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        pointHitRadius: 0,
                        tension: 0,
                    },
                    {
                        label: `Swing Lows Line (${symbol})`,
                        data: swingLowLine,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        pointHitRadius: 0,
                        tension: 0,
                    },
                    {
                        label: "Swing High",
                        type: "scatter",
                        data: swingHighPoints,
                        pointRadius: 4,
                        pointHoverRadius: 7,
                        hitRadius: 10,
                    },
                    {
                        label: "Swing Low",
                        type: "scatter",
                        data: swingLowPoints,
                        pointRadius: 4,
                        pointHoverRadius: 7,
                        hitRadius: 10,
                    },
                ];

                c.update();

                requestAnimationFrame(() => {
                    if (c && typeof c.resize === "function") c.resize();
                });

                setChartControlsEnabled(true);

                btnBinance.href = `https://www.binance.com/en/futures/${encodeURIComponent(symbol)}`;
                btnBinance.style.display = "inline-block";
            };

            // -----------------------------
            // Main scan
            // -----------------------------
            const scan = async () => {
                const tf = String(selTf.value || "4h");
                state.selectedTf = tf;

                const concurrency = Math.max(1, Math.min(20, Number(inpConcurrency.value) || 4));
                const timeoutMs = Math.max(2000, Math.min(60000, Number(inpTimeout.value) || 12000));
                const retries = Math.max(0, Math.min(10, Number(inpRetries.value) || 3));

                const tfIntervalMs = getIntervalMs(tf);

                globalAbortController = new AbortController();
                const signal = globalAbortController.signal;

                state.symbols = [];
                state.tickers.clear();
                state.results = [];
                state.resultsMap.clear();
                state.filtered = [];

                tblBody.innerHTML = "";
                setSymbolSelect([]);
                btnCsv.disabled = true;

                setChartControlsEnabled(false);
                btnBinance.style.display = "none";

                resultSummary.textContent = "스캔 중…";
                setUiRunning(true);

                try {
                    logStatus([`TF=${tf}`, "서버시간 가져오는 중…"]);
                    state.serverTime = await getServerTime({ timeoutMs, signal, retries });

                    logStatus([`TF=${tf}`, "exchangeInfo 가져오는 중…"]);
                    const info = await getExchangeInfo({ timeoutMs, signal, retries });

                    const symbols = (info.symbols || [])
                        .filter((s) => s.contractType === "PERPETUAL")
                        .filter((s) => s.quoteAsset === "USDT")
                        .filter((s) => s.status === "TRADING")
                        .map((s) => s.symbol);

                    state.symbols = symbols;

                    logStatus([
                        `TF=${tf}`,
                        `USDT PERP 심볼: ${symbols.length}`,
                        "",
                        "24h ticker 전체 가져오는 중(거래대금)…",
                    ]);

                    const allTickers = await getAll24hTickers({ timeoutMs, signal, retries });
                    state.tickers.clear();
                    if (Array.isArray(allTickers)) {
                        for (const t of allTickers) {
                            if (!t || !t.symbol) continue;
                            state.tickers.set(String(t.symbol), {
                                lastPrice: toNumber(t.lastPrice),
                                quoteVolume: toNumber(t.quoteVolume),
                            });
                        }
                    }

                    logStatus([
                        `TF=${tf}`,
                        `USDT PERP 심볼: ${symbols.length}`,
                        "",
                        "1단계: 최근 5개 완성봉 저점 V-패턴 필터링…",
                    ]);

                    // Stage1
                    const stage1 = await mapWithConcurrency(
                        symbols,
                        concurrency,
                        async (symbol) => {
                            await sleep(35);
                            const raw = await getKlines(symbol, tf, 12, { timeoutMs, signal, retries });
                            const candles = normalizeKlines(raw, state.serverTime);

                            if (candles.length < 5) return { symbol, pass: false, stage1Low: null };

                            const pass = passesVShapeLast5Lows(candles);
                            if (!pass) return { symbol, pass: false, stage1Low: null };

                            const stage1Low = getStage1SwingLowFromLast5(candles);
                            return { symbol, pass: true, stage1Low };
                        },
                        (done, total) => {
                            logStatus([
                                `TF=${tf}`,
                                `USDT PERP 심볼: ${symbols.length}`,
                                "",
                                `1단계 진행: ${done}/${total}`,
                            ]);
                        },
                        signal
                    );

                    if (signal.aborted) throw new Error("사용자 중지");

                    const stage1Passed = stage1
                        .filter((r) => r && r.pass === true && r.stage1Low && Number.isFinite(r.stage1Low.t))
                        .map((r) => r);

                    const stage1Map = new Map();
                    for (const r of stage1Passed) {
                        stage1Map.set(r.symbol, r.stage1Low);
                    }

                    const filteredSymbols = stage1Passed.map((r) => r.symbol);

                    logStatus([
                        `TF=${tf}`,
                        `1단계 통과: ${filteredSymbols.length} / ${symbols.length}`,
                        "",
                        "2단계: 통과 심볼만 최근 200개 완성봉 확보 후 스윙 계산…",
                        "추가조건: Higher Low + Higher High",
                        "200봉 미만 심볼은 제외됨.",
                    ]);

                    const stage2Limit = 600;

                    const stage2 = await mapWithConcurrency(
                        filteredSymbols,
                        concurrency,
                        async (symbol) => {
                            await sleep(55);

                            const raw = await getKlines(symbol, tf, stage2Limit, { timeoutMs, signal, retries });
                            const allClosed = normalizeKlines(raw, state.serverTime);

                            if (allClosed.length < 200) {
                                return { symbol, excluded: true, reason: "candles<200" };
                            }

                            const candles200 = allClosed.slice(-200);

                            const { swingHighs, swingLows } = detectSwings(candles200);

                            const lastCandle = candles200[candles200.length - 1];
                            const lastClose = lastCandle.close;
                            const lastOpenTime = lastCandle.openTime;

                            // ---- (A) Higher Low 조건: stage1Low(a[-3])가 prev swing low 보다 높아야 함
                            const stage1Low = stage1Map.get(symbol);
                            if (!stage1Low) return { symbol, excluded: true, reason: "no_stage1Low" };

                            const stage1SwingLow = findClosestSwingLowByTime(swingLows, stage1Low.t, tfIntervalMs);
                            if (!stage1SwingLow) {
                                return { symbol, excluded: true, reason: "stage1Low_not_found_in_swings" };
                            }

                            let prevSwingLow = null;
                            for (let i = swingLows.length - 1; i >= 0; i -= 1) {
                                if (swingLows[i].t < stage1SwingLow.t) {
                                    prevSwingLow = swingLows[i];
                                    break;
                                }
                            }
                            if (!prevSwingLow) return { symbol, excluded: true, reason: "no_prev_swingLow" };

                            if (!Number.isFinite(stage1SwingLow.price) || !Number.isFinite(prevSwingLow.price)) {
                                return { symbol, excluded: true, reason: "invalid_swingLow_price" };
                            }

                            if (!(stage1SwingLow.price > prevSwingLow.price)) {
                                return { symbol, excluded: true, reason: "not_higher_low" };
                            }

                            const lowRisePct =
                                prevSwingLow.price > 0
                                    ? (stage1SwingLow.price - prevSwingLow.price) / prevSwingLow.price
                                    : NaN;

                            // ---- (B) Higher High 조건: 가장 최근 스윙고점이 이전 스윙고점보다 높아야 함
                            if (!Array.isArray(swingHighs) || swingHighs.length < 2) {
                                return { symbol, excluded: true, reason: "not_enough_swingHighs" };
                            }

                            const lastSwingHigh = swingHighs[swingHighs.length - 1];
                            const prevSwingHigh = swingHighs[swingHighs.length - 2];

                            if (!Number.isFinite(lastSwingHigh.price) || !Number.isFinite(prevSwingHigh.price)) {
                                return { symbol, excluded: true, reason: "invalid_swingHigh_price" };
                            }

                            if (!(lastSwingHigh.price > prevSwingHigh.price)) {
                                return { symbol, excluded: true, reason: "not_higher_high" };
                            }

                            const highRisePct =
                                prevSwingHigh.price > 0
                                    ? (lastSwingHigh.price - prevSwingHigh.price) / prevSwingHigh.price
                                    : NaN;

                            // ---- metrics/scoring (support는 stage1SwingLow 기준)
                            const supportDistPct = (lastClose - stage1SwingLow.price) / lastClose;
                            const lowAgeDays = (lastOpenTime - stage1SwingLow.t) / 86400000;

                            const targetHigh = findTargetHighAbove(
                                swingHighs,
                                lastClose,
                                stage1SwingLow.t
                            );

                            let upsidePct = NaN;
                            if (targetHigh && Number.isFinite(targetHigh.price) && targetHigh.price > lastClose) {
                                upsidePct = (targetHigh.price - lastClose) / lastClose;
                            } else {
                                upsidePct = 0;
                            }

                            const t = state.tickers.get(symbol) || { quoteVolume: 0, lastPrice: NaN };
                            const quoteVolume = Number.isFinite(t.quoteVolume) ? t.quoteVolume : 0;

                            const score = computeScore({ quoteVolume, supportDistPct, upsidePct, lowAgeDays });

                            return {
                                symbol,
                                tf,
                                candles: candles200,
                                swingHighs,
                                swingLows,
                                quoteVolume,
                                lastClose,
                                supportDistPct,
                                upsidePct,
                                lowAgeDays,
                                lowRisePct,
                                highRisePct,
                                score,
                                lastOpenTime,

                                // 확인용
                                stage1SwingLow,
                                prevSwingLow,
                                lastSwingHigh,
                                prevSwingHigh,
                            };
                        },
                        (done, total) => {
                            logStatus([
                                `TF=${tf}`,
                                `1단계 통과: ${filteredSymbols.length} / ${symbols.length}`,
                                "",
                                `2단계 진행: ${done}/${total}`,
                            ]);
                        },
                        signal
                    );

                    if (signal.aborted) throw new Error("사용자 중지");

                    const finalResults = stage2
                        .filter((r) => r && !r.__error && !r.excluded && r.candles && r.candles.length === 200);

                    state.results = finalResults;
                    state.resultsMap.clear();
                    for (const r of finalResults) {
                        state.resultsMap.set(r.symbol, r);
                    }

                    // 스캔 후 기본 정렬 상태 리셋
                    state.sort = { key: "score", dir: "desc" };
                    selSort.value = "score_desc";
                    updateSortMarks();
                    applySortAndFilter();

                    logStatus([
                        "완료!",
                        `TF=${tf}`,
                        `총 심볼: ${symbols.length}`,
                        `1단계 통과: ${filteredSymbols.length}`,
                        `최종(Higher Low + Higher High + 200봉 충족): ${finalResults.length}`,
                        "",
                        "테이블 클릭 또는 심볼 선택으로 차트 확인 가능",
                    ]);

                    if (state.filtered.length > 0) {
                        selSymbol.value = state.filtered[0].symbol;
                        drawSymbolChart(state.filtered[0].symbol);
                    }
                } catch (err) {
                    const msg = err && err.message ? err.message : String(err);
                    logStatus([
                        "중단/오류:",
                        msg.includes("사용자 중지") ? "사용자가 중지했어." : msg,
                        "",
                        "CORS 이슈면 로컬 서버(http://localhost)로 열어줘.",
                    ]);
                    resultSummary.innerHTML = `<span class="danger">중단/오류: ${msg}</span>`;
                } finally {
                    setUiRunning(false);
                    globalAbortController = null;
                }
            };

            // -----------------------------
            // Events
            // -----------------------------
            btnStart.addEventListener("click", () => {
                scan();
            });

            btnStop.addEventListener("click", () => {
                if (globalAbortController) globalAbortController.abort();
            });

            selSymbol.addEventListener("change", () => {
                const symbol = selSymbol.value;
                if (!symbol) return;
                drawSymbolChart(symbol);
            });

            selSort.addEventListener("change", () => {
                const v = selSort.value;

                if (v === "custom") {
                    updateSortMarks();
                    applySortAndFilter();
                    return;
                }

                if (v === "sym_asc") state.sort = { key: "symbol", dir: "asc" };
                else if (v === "qv_desc") state.sort = { key: "quoteVolume", dir: "desc" };
                else if (v === "support_asc") state.sort = { key: "supportDistPct", dir: "asc" };
                else if (v === "upside_desc") state.sort = { key: "upsidePct", dir: "desc" };
                else state.sort = { key: "score", dir: "desc" };

                updateSortMarks();
                applySortAndFilter();
            });

            inpSearch.addEventListener("input", () => {
                applySortAndFilter();
            });

            btnCsv.addEventListener("click", () => {
                downloadCsv();
            });

            btnZoomIn.addEventListener("click", () => {
                if (!chart) return;
                if (typeof chart.zoom === "function") chart.zoom({ x: 1.1 });
            });

            btnZoomOut.addEventListener("click", () => {
                if (!chart) return;
                if (typeof chart.zoom === "function") chart.zoom({ x: 0.9 });
            });

            btnResetZoom.addEventListener("click", () => {
                if (!chart) return;
                if (typeof chart.resetZoom === "function") chart.resetZoom();
            });

            $("#chart").addEventListener("dblclick", () => {
                if (!chart) return;
                if (typeof chart.resetZoom === "function") chart.resetZoom();
            });

            // TH 클릭 정렬 이벤트 바인딩
            const bindThSort = () => {
                const ths = document.querySelectorAll("th.sortable[data-sort-key]");
                for (const th of ths) {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-sort-key");
                        setSort(key);
                    });
                }
            };

            // init
            ensureChart();
            bindThSort();
            updateSortMarks();
        </script>
    </body>
</html>
