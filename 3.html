<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>KRX 전일봉 → 다음날 양·음 바이어스 스크리너</title>
    <style>
        :root {
            --bg: #0b0d12;
            --panel: #141824;
            --text: #e7eaf3;
            --muted: #97a0b3;
            --green: #3ecf8e;
            --red: #ff6b6b;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 24px; background: var(--bg); color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Pretendard Variable", Pretendard, Noto Sans KR, Apple SD Gothic Neo, "Malgun Gothic", sans-serif;
        }
        h1 { font-size: 20px; margin: 0 0 12px; }
        .wrap { max-width: 1200px; margin: 0 auto; }
        .card { background: var(--panel); border-radius: 16px; padding: 16px; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin: 12px 0; }
        .control { display: flex; flex-direction: column; gap: 6px; }
        label { font-size: 12px; color: var(--muted); }
        input[type="number"], input[type="file"], select {
            background: #0f1320; border: 1px solid #2a3042; color: var(--text);
            border-radius: 10px; padding: 10px 12px; outline: none;
        }
        input[type="file"] { padding: 8px; }
        button {
            background: linear-gradient(180deg, #3b82f6, #2563eb); border: none; color: white;
            padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600;
            box-shadow: 0 6px 14px rgba(37, 99, 235, .35);
        }
        button:disabled { opacity: .6; cursor: not-allowed; }
        .btn-secondary { background: #2a3042; box-shadow: none; }
        .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .hint { color: var(--muted); font-size: 12px; }

        table { width: 100%; border-collapse: collapse; margin-top: 14px; font-size: 13px; }
        th, td { padding: 10px 8px; border-bottom: 1px solid #212739; text-align: right; }
        th { position: sticky; top: 0; background: #161b2a; z-index: 1; cursor: pointer; }
        td:first-child, th:first-child { text-align: left; }
        .badge { padding: 2px 8px; border-radius: 999px; font-size: 12px; font-weight: 700; }
        .badge.up { background: rgba(62,207,142,.15); color: var(--green); }
        .badge.down { background: rgba(255,107,107,.15); color: var(--red); }
        .badge.neutral { background: #2a3042; color: var(--muted); }
        .sticky-top { position: sticky; top: 0; background: var(--panel); padding-bottom: 8px; }
        .hr { height: 1px; background: #212739; margin: 12px 0; }
        .scroll { max-height: 65vh; overflow: auto; border-radius: 12px; border: 1px solid #1a2133; }
        .pill { background: #101425; border: 1px solid #2a3042; padding: 8px 12px; border-radius: 999px; }
    </style>
</head>
<body>
<div class="wrap">
    <h1>KRX 전일봉 → 다음날 양·음 바이어스 스크리너</h1>
    <div class="card">
        <div class="controls">
            <div class="control">
                <label>전종목시세 CSV (전일)</label>
                <input id="file" type="file" accept=".csv,text/csv" />
                <div class="hint">UTF-8/CP949 자동 인코딩 시도</div>
            </div>
            <div class="control">
                <label>전종목시세 CSV (다음날, 선택)</label>
                <input id="fileNext" type="file" accept=".csv,text/csv" />
                <div class="hint">같은 포맷의 다음 영업일 CSV를 올리면 수익률 컬럼이 채워집니다.</div>
            </div>
            <div class="control">
                <label>최소 거래대금(원)</label>
                <input id="minValue" type="number" inputmode="numeric" value="1000000000" />
            </div>
            <div class="control">
                <label>최소 변동성 Range%( (H-L)/O )</label>
                <input id="minRangePct" type="number" step="0.1" value="1.0" />
            </div>
            <div class="control">
                <label>바이어스 임계치</label>
                <input id="biasThresh" type="number" step="0.01" value="0.55" />
            </div>
            <div class="control">
                <label>정렬 기준</label>
                <select id="sortKey">
                    <option value="probUp">ProbUp</option>
                    <option value="edge">Edge</option>
                    <option value="rangePct">Range%</option>
                    <option value="value">거래대금</option>
                </select>
            </div>
            <div class="control">
                <label>최대 표시 개수</label>
                <input id="limit" type="number" value="200" />
            </div>
        </div>

        <div class="row">
            <button id="run" disabled>스캔 실행</button>
            <button id="download" class="btn-secondary" disabled>결과 CSV 다운로드</button>
            <span id="summary" class="hint"></span>
        </div>

        <div class="hr"></div>
        <div class="sticky-top row" style="justify-content: space-between;">
            <div class="row" style="gap:8px;">
                <span class="pill">전일 한 봉(OHLCV)만으로 룰 기반 바이어스</span>
                <span class="pill">NEUTRAL(애매) → 표에서 제외</span>
            </div>
            <div class="hint">열 제목 클릭으로 정렬 변경</div>
        </div>

        <div id="tableWrap" class="scroll"></div>
    </div>
</div>

<script>
    // ===== 유틸 =====
    function fmtKR(n) {
        if (n === null || n === undefined || isNaN(n)) return "";
        return n.toLocaleString("ko-KR");
    }
    function parseKRNumber(s) {
        if (s === undefined || s === null) return NaN;
        if (typeof s === "number") return s;
        s = String(s).replace(/[%\s,]/g, "");
        if (s === "") return NaN;
        const n = Number(s);            // 6.41E+08 같은 과학표기도 지원
        return isNaN(n) ? NaN : n;
    }

    // 간단 CSV 파서(따옴표 처리)
    function parseCSV(text, delimiter) {
        delimiter = delimiter || (text.indexOf("\t") > -1 ? "\t" : ",");
        const rows = [];
        let i = 0, field = "", row = [], inQuotes = false;
        while (i < text.length) {
            const c = text[i];
            if (inQuotes) {
                if (c === "\"") {
                    if (text[i + 1] === "\"") { field += "\""; i++; } else { inQuotes = false; }
                } else { field += c; }
            } else {
                if (c === "\"") { inQuotes = true; }
                else if (c === delimiter) { row.push(field); field = ""; }
                else if (c === "\n") { row.push(field); rows.push(row); row = []; field = ""; }
                else if (c === "\r") { /* skip */ }
                else { field += c; }
            }
            i++;
        }
        if (field.length || row.length) { row.push(field); rows.push(row); }
        return rows;
    }

    // 인코딩 자동 시도(UTF-8 → EUC-KR)
    function readCSVFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                let text = reader.result;
                if (/�/.test(text)) {
                    const reader2 = new FileReader();
                    reader2.onload = () => resolve(reader2.result);
                    reader2.onerror = reject;
                    try { reader2.readAsText(file, "euc-kr"); } catch (e) { resolve(text); }
                } else {
                    resolve(text);
                }
            };
            reader.onerror = reject;
            reader.readAsText(file, "utf-8");
        });
    }

    // 헤더 매핑(칼럼 이름 유연 매칭)
    const HEADER_MAP = {
        code: ["종목코드", "단축코드", "코드"],
        name: ["종목명", "한글명", "이름"],
        market: ["시장구분", "시장"],
        open: ["시가"],
        high: ["고가"],
        low: ["저가"],
        close: ["종가"],
        volume: ["거래량"],
        value: ["거래대금"],
        change: ["대비"],
        changeRate: ["등락률"],
        shares: ["상장주식수"],
        cap: ["시가총액"]
    };

    function buildIndex(header) {
        const idx = {};
        for (const key in HEADER_MAP) {
            const aliases = HEADER_MAP[key];
            let found = -1;
            for (const a of aliases) {
                const j = header.indexOf(a);
                if (j !== -1) { found = j; break; }
            }
            idx[key] = found;
        }
        const required = ["code","name","open","high","low","close"];
        const missing = required.filter(k => idx[k] === -1);
        if (missing.length) throw new Error("필수 칼럼이 없습니다: " + missing.join(", "));
        return idx;
    }

    // 전일봉 → 다음날 바이어스 추정(룰 기반)
    function nextBiasByRules(prev, biasThresh) {
        const O = prev.open, H = prev.high, L = prev.low, C = prev.close;
        const eps = 1e-9;
        const range = Math.max(H - L, eps);
        const body = C - O;

        const body_frac  = Math.min(Math.abs(body) / range, 1);
        const upper_frac = Math.max((H - Math.max(O, C)) / range, 0);
        const lower_frac = Math.max((Math.min(O, C) - L) / range, 0);
        const clv        = (2 * C - H - L) / range; // -1 ~ 1
        const range_to_O = (H - L) / Math.max(O, eps);

        let upScore = 0, downScore = 0;
        if (clv > 0.6 && body_frac > 0.6 && range_to_O > 0.02 && lower_frac < 0.2) upScore += 1.0;
        if (clv < -0.6 && body_frac > 0.6 && range_to_O > 0.02 && upper_frac < 0.2) downScore += 1.0;

        if (body_frac < 0.2 && range_to_O > 0.015) {
            if (upper_frac > lower_frac) upScore += 0.5;  // 윗꼬리 크면 반등 바이어스
            if (lower_frac > upper_frac) downScore += 0.5; // 아랫꼬리 크면 반락 바이어스
        }

        if (body > 0) upScore += 0.1; else if (body < 0) downScore += 0.1;

        const total = upScore + downScore;
        let probUp = total === 0 ? 0.5 : (upScore / total);
        probUp = Math.max(0, Math.min(1, probUp));

        let bias = "NEUTRAL";
        if (probUp >= biasThresh) bias = "UP";
        else if (probUp <= 1 - biasThresh) bias = "DOWN";

        return { probUp, bias, features: { body_frac, upper_frac, lower_frac, clv, range_to_O } };
    }

    // ===== 메인 =====
    let rawRows = [];
    let nextMap = new Map();

    // 전일 CSV
    document.getElementById("file").addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        try {
            const text = await readCSVFile(file);
            const rows = parseCSV(text);
            if (!rows.length) throw new Error("CSV가 비어있습니다.");
            const header = rows[0];
            const idx = buildIndex(header);
            const out = [];
            for (let i = 1; i < rows.length; i++) {
                const r = rows[i];
                if (!r || r.length < header.length) continue;
                const open  = parseKRNumber(r[idx.open]);
                const high  = parseKRNumber(r[idx.high]);
                const low   = parseKRNumber(r[idx.low]);
                const close = parseKRNumber(r[idx.close]);
                if (!isFinite(open) || !isFinite(high) || !isFinite(low) || !isFinite(close)) continue;
                out.push({
                    code: (r[idx.code] || "").trim(),
                    name: (r[idx.name] || "").trim(),
                    market: idx.market >= 0 ? (r[idx.market] || "").trim() : "",
                    open, high, low, close,
                    volume: idx.volume >= 0 ? parseKRNumber(r[idx.volume]) : undefined,
                    value:  idx.value  >= 0 ? parseKRNumber(r[idx.value])  : undefined,
                    change: idx.change >= 0 ? parseKRNumber(r[idx.change]) : undefined,
                    changeRate: idx.changeRate >= 0 ? parseKRNumber(r[idx.changeRate]) : undefined
                });
            }
            rawRows = out;
            document.getElementById("run").disabled = false;
            document.getElementById("summary").textContent = `전일 로딩: ${out.length}종목`;
        } catch (err) {
            console.error(err);
            alert("CSV 파싱 중 오류: " + err.message);
        }
    });

    // 다음날 CSV(선택)
    document.getElementById("fileNext").addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        try {
            const text = await readCSVFile(file);
            const rows = parseCSV(text);
            if (!rows.length) throw new Error("CSV가 비어있습니다.");
            const header = rows[0];
            const idx = buildIndex(header);
            const map = new Map();
            for (let i = 1; i < rows.length; i++) {
                const r = rows[i];
                if (!r || r.length < header.length) continue;
                const code  = (r[idx.code] || "").trim();
                const open  = parseKRNumber(r[idx.open]);
                const high  = parseKRNumber(r[idx.high]);
                const low   = parseKRNumber(r[idx.low]);
                const close = parseKRNumber(r[idx.close]);
                if (!code || !isFinite(open) || !isFinite(high) || !isFinite(low) || !isFinite(close)) continue;
                map.set(code, { open, high, low, close });
            }
            nextMap = map;
            document.getElementById("summary").textContent += ` · 다음날 로딩: ${map.size}종목`;
        } catch (err) {
            console.error(err);
            alert("다음날 CSV 파싱 중 오류: " + err.message);
        }
    });

    document.getElementById("run").addEventListener("click", () => {
        if (!rawRows.length) return;
        const minValue = parseKRNumber(document.getElementById("minValue").value);
        const minRangePct = parseKRNumber(document.getElementById("minRangePct").value);
        const biasThresh = Number(document.getElementById("biasThresh").value);
        const sortKey = document.getElementById("sortKey").value;
        const limit = parseInt(document.getElementById("limit").value || "200", 10);
        rankAndRender(rawRows, { minValue, minRangePct, biasThresh, sortKey, limit });
    });

    function rankAndRender(rows, opts) {
        const { minValue, minRangePct, biasThresh, sortKey, limit } = opts;

        const enriched = rows.map(r => {
            const range = r.high - r.low;
            const rangePct = range / Math.max(r.open, 1e-9);
            const bias = nextBiasByRules(r, biasThresh);
            const edge = (bias.probUp - 0.5) * rangePct;

            // 다음날 데이터가 있으면 수익률 계산
            const next = nextMap.get(r.code);
            let nextOpen = null, nextHigh = null, nextLow = null, nextClose = null;
            let retHO = null, retCO = null;
            if (next) {
                nextOpen = next.open; nextHigh = next.high; nextLow = next.low; nextClose = next.close;
                if (isFinite(nextOpen) && nextOpen > 0) {
                    retHO = (nextHigh - nextOpen) / nextOpen;   // 시가대비 고가
                    retCO = (nextClose - nextOpen) / nextOpen;  // 시가대비 종가
                }
            }

            return { ...r, rangePct, probUp: bias.probUp, biasLabel: bias.bias, edge,
                     nextOpen, nextLow, nextHigh, nextClose, retHO, retCO };
        }).filter(r => {
            if (isFinite(minValue) && !isNaN(minValue)) {
                if (r.value !== undefined && !isNaN(r.value)) {
                    if (r.value < minValue) return false;
                }
            }
            if (isFinite(minRangePct) && !isNaN(minRangePct)) {
                if ((r.rangePct * 100) < minRangePct) return false;
            }
            return r.biasLabel !== "NEUTRAL";
        });

        const sorters = {
            probUp: (a, b) => (b.probUp - a.probUp) || (b.rangePct - a.rangePct),
            edge: (a, b) => (b.edge - a.edge),
            rangePct: (a, b) => (b.rangePct - a.rangePct),
            value: (a, b) => ((b.value || 0) - (a.value || 0))
        };
        enriched.sort(sorters[sortKey] || sorters.probUp);
        const sliced = enriched.slice(0, limit);

        renderTable(sliced);

        const upCnt = sliced.filter(x => x.biasLabel === "UP").length;
        const downCnt = sliced.filter(x => x.biasLabel === "DOWN").length;
        document.getElementById("summary").textContent =
            `표시 ${sliced.length}종목 · UP ${upCnt} / DOWN ${downCnt} · 임계치 ${biasThresh}`;
        window.__lastResult = sliced;
        document.getElementById("download").disabled = sliced.length === 0;
    }

    function renderTable(data) {
        const wrap = document.getElementById("tableWrap");
        if (!data || !data.length) { wrap.innerHTML = '<div class="hint">표시할 결과가 없습니다.</div>'; return; }

        const headers = [
            { key: "name", label: "종목명" },
            { key: "code", label: "종목코드" },
            { key: "market", label: "시장" },
            { key: "open", label: "시가", fmt: fmtKR },
            { key: "high", label: "고가", fmt: fmtKR },
            { key: "low",  label: "저가", fmt: fmtKR },
            { key: "close",label: "종가", fmt: fmtKR },
            { key: "value",label: "거래대금", fmt: fmtKR },
            { key: "rangePct", label: "Range%", fmt: v => (v*100).toFixed(2) + "%" },
            { key: "probUp",   label: "ProbUp", fmt: v => (v*100).toFixed(1) + "%" },
            { key: "biasLabel",label: "Bias", fmt: v => v === "UP" ? '<span class="badge up">UP</span>' : (v === "DOWN" ? '<span class="badge down">DOWN</span>' : '<span class="badge neutral">NEUTRAL</span>') },
            { key: "edge",     label: "Edge", fmt: v => (v*100).toFixed(2) + "%" },
            { key: "nextOpen", label: "다음시가", fmt: v => v==null? "" : fmtKR(v) },
            { key: "nextLow",  label: "다음저가", fmt: v => v==null? "" : fmtKR(v) },
            { key: "nextHigh", label: "다음고가", fmt: v => v==null? "" : fmtKR(v) },
            { key: "nextClose",label: "다음종가", fmt: v => v==null? "" : fmtKR(v) },
            { key: "retHO",    label: "시가대비고가기준 수익률", fmt: v => (v==null||isNaN(v)) ? "" : (v*100).toFixed(2) + "%" },
            { key: "retCO",    label: "시가대비종가기준 수익률", fmt: v => (v==null||isNaN(v)) ? "" : (v*100).toFixed(2) + "%" }
        ];

        let html = "<table><thead><tr>";
        for (const h of headers) html += `<th data-key="${h.key}">${h.label}</th>`;
        html += "</tr></thead><tbody>";
        for (const r of data) {
            html += "<tr>";
            for (const h of headers) {
                const val = r[h.key];
                const content = h.fmt ? h.fmt(val) : (val ?? "");
                html += `<td>${content}</td>`;
            }
            html += "</tr>";
        }
        html += "</tbody></table>";
        wrap.innerHTML = html;

        // 헤더 클릭 정렬(선택한 키로 다시 실행)
        wrap.querySelectorAll("th").forEach(th => {
            th.addEventListener("click", () => {
                const key = th.getAttribute("data-key");
                const sel = document.getElementById("sortKey");
                if (key && sel.querySelector(`option[value="${key}"]`)) {
                    sel.value = key; document.getElementById("run").click();
                }
            });
        });
    }

    function toCSV(data) {
        const cols = [
            "종목명","종목코드","시장","시가","고가","저가","종가","거래대금",
            "Range%","ProbUp","Bias","Edge",
            "다음시가","다음저가","다음고가","다음종가",
            "시가대비고가기준 수익률","시가대비종가기준 수익률"
        ];
        const lines = [cols.join(",")];
        for (const r of data) {
            const row = [
                r.name, r.code, r.market ?? "",
                r.open, r.high, r.low, r.close, r.value ?? "",
                (r.rangePct*100).toFixed(2),
                (r.probUp*100).toFixed(1),
                r.biasLabel,
                (r.edge*100).toFixed(2),
                r.nextOpen ?? "", r.nextLow ?? "", r.nextHigh ?? "", r.nextClose ?? "",
                (r.retHO==null||isNaN(r.retHO)) ? "" : (r.retHO*100).toFixed(2),
                (r.retCO==null||isNaN(r.retCO)) ? "" : (r.retCO*100).toFixed(2)
            ].map(v => (v === null || v === undefined) ? "" : String(v));
            for (let i = 0; i < row.length; i++) {
                if (/[",\n]/.test(row[i])) { row[i] = "\"" + row[i].replace(/"/g,"\"\"") + "\""; }
            }
            lines.push(row.join(","));
        }
        return lines.join("\n");
    }

    document.getElementById("download").addEventListener("click", () => {
        const data = window.__lastResult || [];
        if (!data.length) return;
        const csv = toCSV(data);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "krx_nextday_bias.csv";
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
    });
</script>
</body>
</html>
