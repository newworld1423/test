<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance Perp USDT — 1D 직전봉 단일캔들 스캐너 (+Regime/Signal)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --bg: #0b0c10;
            --card: #121318;
            --muted: #9aa0a6;
            --text: #e8eaed;
            --accent: #3ea6ff;
            --good: #00c853;
            --bad: #ff5252;
            --warn: #ffd54f;
            --border: #2a2e36;
        }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                         Roboto, "Helvetica Neue", Arial, "Apple SD Gothic Neo",
                         "Noto Sans KR", "Malgun Gothic", "Apple Color Emoji",
                         "Segoe UI Emoji";
            background: var(--bg);
            color: var(--text);
        }
        header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, #0f1116, #0b0c10);
        }
        h1 { margin: 0 0 6px 0; font-size: 20px; font-weight: 700; }
        .sub { color: var(--muted); font-size: 13px; }
        .wrap { padding: 16px 20px 40px; max-width: 1300px; margin: 0 auto; }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto;
            gap: 12px;
            align-items: end;
            margin-bottom: 16px;
        }
        .field {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
        }
        .field label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }
        .field input[type="date"],
        .field input[type="text"],
        .field input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: #0c0d12;
            color: var(--text);
            font-size: 14px;
        }
        .actions { display: flex; gap: 8px; }
        button {
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #1a1f2b;
            color: var(--text);
            font-weight: 600;
            cursor: pointer;
        }
        button.primary { background: var(--accent); color: #001f33; border: none; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }

        .progress { margin: 12px 0 0; height: 8px; background: #0f1320; border: 1px solid var(--border); border-radius: 999px; overflow: hidden; }
        .bar { height: 100%; width: 0%; background: linear-gradient(90deg,#3ea6ff,#7cf3ff); }

        .summary { margin: 16px 0; display: flex; gap: 12px; flex-wrap: wrap; }
        .chip {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 8px 12px;
            font-size: 12px;
            color: var(--muted);
        }
        .chip strong { color: var(--text); }

        .table-wrap { border: 1px solid var(--border); border-radius: 14px; background: var(--card); overflow: visible; }
        .table-scroller { overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; border-radius: 14px; }
        table { width: 100%; border-collapse: collapse; font-size: 12.5px; min-width: 1850px; }
        thead th {
            position: sticky; top: 0; background: #111319; z-index: 2;
            padding: 10px 12px; border-bottom: 1px solid var(--border);
            text-align: right; white-space: nowrap;
        }
        thead th:first-child, tbody td:first-child { text-align: left; }
        tbody td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.04); text-align: right; white-space: nowrap; }
        tbody tr:hover { background: rgba(62,166,255,0.06); }
        .num.pos { color: var(--good); } .num.neg { color: var(--bad); }
        .muted { color: var(--muted); }

        .head-flex { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
        .sort-arrows { display: inline-flex; gap: 2px; }
        .sort-arrows button { border: 1px solid var(--border); background: #0f1320; padding: 2px 6px; line-height: 1; border-radius: 6px; color: var(--muted); font-size: 11px; }
        .sort-arrows button.active { color: var(--accent); border-color: var(--accent); }

        .searchline { display: flex; gap: 10px; align-items: center; margin: 10px 0 16px; }
        .searchline input {
            width: 240px; padding: 9px 12px; border: 1px solid var(--border); border-radius: 10px; background: #0c0d12; color: var(--text);
        }
        .note { font-size: 12px; color: var(--muted); }
        .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; font-weight: 700; }
        .pill.ok { background: rgba(0,200,83,.15); color: var(--good); }
        .pill.no { background: rgba(255,82,82,.15); color: var(--bad); }
        .pill.warn { background: rgba(255,213,79,.15); color: var(--warn); }
        .pill.neutral { background: rgba(154,160,166,.15); color: var(--muted); }
        .pill.long { background: rgba(0,200,83,.15); color: var(--good); }
        .pill.short { background: rgba(255,82,82,.15); color: var(--bad); }
    </style>
</head>
<body>
    <header>
        <h1>1일봉 직전봉 단일캔들 스캐너 (Binance Perp USDT)</h1>
        <div class="sub">선택한 날짜(UTC)의 <strong>직전봉</strong> 하나만으로 예측점수/예측확률을 계산합니다. 백테스트를 켜면 해당 날짜의 실제 결과(Open→High/Close)와 <strong>신호 진입 성공/실패</strong>도 함께 표시합니다. (성공/실패는 시가→종가 기준)</div>
    </header>

    <div class="wrap">
        <div class="controls">
            <div class="field">
                <label>스캔 기준 날짜 (UTC 00:00:00Z)</label>
                <input id="dateInput" type="date" />
                <div class="note" style="margin-top:6px;">※ Binance 1D 캔들은 <strong>UTC</strong> 기준입니다.</div>
            </div>

            <div class="field">
                <label>옵션</label>
                <div>
                    <label><input id="backtestChk" type="checkbox" /> 백테스트 (D일 실제 결과 포함)</label>
                </div>
                <div style="margin-top:6px;">
                    <label><input id="minQuoteVolChk" type="checkbox" /> 직전봉 거래대금 하한(USDT)</label>
                    <input id="minQuoteVol" type="number" placeholder="예: 5,000,000" style="margin-top:6px;" />
                    <div class="note">※ 유동성 낮은 종목 제외용(선택)</div>
                </div>
            </div>

            <div class="field">
                <label>신호/레짐 옵션</label>
                <div class="searchline" style="margin:0 0 8px;">
                    <input id="overheatPct" type="number" min="50" max="99" value="80" />
                    <span class="note">과열 퍼센타일(%) — range/chg 상위 이상이면 과열</span>
                </div>
                <div>
                    <label><input id="signalOnly" type="checkbox" /> 신호만 보기</label>
                </div>
                <div class="note" style="margin-top:6px;">레짐 기준(고정값): Bull ≥ 55% 또는 중앙등락률 ≥ +0.5%, Bear ≤ 45% 또는 중앙등락률 ≤ −0.5%</div>
            </div>

            <div class="field">
                <label>검색</label>
                <div class="searchline">
                    <input id="searchSym" type="text" placeholder="심볼 필터 (예: BTC, ETH...)" />
                    <span class="note">표시된 목록 실시간 필터</span>
                </div>
                <div class="actions">
                    <button id="scanBtn" class="primary">스캔 시작</button>
                    <button id="stopBtn">중지</button>
                </div>
            </div>
        </div>

        <div class="summary" id="summary"></div>
        <div class="progress"><div class="bar" id="bar"></div></div>

        <div class="table-wrap" style="margin-top:14px;">
            <div class="table-scroller">
                <table id="resultTable">
                    <thead id="thead"></thead>
                    <tbody id="tbody"></tbody>
                </table>
            </div>
        </div>

        <p class="note" style="margin-top:12px;">
            * 점수 산식(직전봉 하나만 사용): <code>Score = 0.5·(방향×몸통비율) + 0.3·(2·CLV−1) + 0.2·(아랫꼬리−윗꼬리) + 0.1·tanh(범위%) + 0.1·(직전봉 USDT 거래대금 z)</code><br>
            * <strong>예측확률</strong>은 같은 날짜 전체 심볼의 점수 분포를 z-score로 정규화 후 시그모이드로 변환한 상대적 확률값입니다.
        </p>
    </div>

    <script>
        "use strict";

        // ==========================
        // 유틸
        // ==========================
        function toUTCDateString(date = new Date()) {
            const y = date.getUTCFullYear();
            const m = String(date.getUTCMonth() + 1).padStart(2, "0");
            const d = String(date.getUTCDate()).padStart(2, "0");
            return `${y}-${m}-${d}`;
        }
        function parseDateUTC(yyyy_mm_dd) { return new Date(`${yyyy_mm_dd}T00:00:00.000Z`); }
        function tanh(x) { const e2x = Math.exp(2 * x); return (e2x - 1) / (e2x + 1); }
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
        function mean(arr) { return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0; }
        function stddev(arr) {
            if (arr.length <= 1) return 1;
            const m = mean(arr);
            const v = mean(arr.map(x => (x - m) ** 2));
            return Math.sqrt(v) || 1;
        }
        function median(arr) {
            if (!arr.length) return 0;
            const a = arr.slice().sort((x, y) => x - y);
            const mid = Math.floor(a.length / 2);
            return a.length % 2 ? a[mid] : (a[mid - 1] + a[mid]) / 2;
        }
        function quantile(arr, q) {
            if (!arr.length) return 0;
            const a = arr.slice().sort((x, y) => x - y);
            const pos = (a.length - 1) * q;
            const base = Math.floor(pos);
            const rest = pos - base;
            if (a[base + 1] !== undefined) return a[base] + rest * (a[base + 1] - a[base]);
            return a[base];
        }
        function quantileThresholds(arr, splits = 10) {
            const qs = [];
            for (let i = 1; i < splits; i++) qs.push(quantile(arr, i / splits));
            return qs; // length = splits-1
        }
        function valueToDecile(val, thresholds) {
            if (val == null || Number.isNaN(val)) return 5;
            let d = 1;
            for (let i = 0; i < thresholds.length; i++) {
                if (val > thresholds[i]) d++;
            }
            return Math.min(Math.max(d, 1), thresholds.length + 1);
        }
        function fmtNum(x, d = 2) {
            if (x === null || x === undefined || Number.isNaN(x)) return "-";
            const v = Number(x);
            const abs = Math.abs(v);
            if (abs >= 1e10) return v.toExponential(2);
            return v.toLocaleString(undefined, { minimumFractionDigits: d, maximumFractionDigits: d });
        }
        function fmtPct(x, d = 2) {
            if (x === null || x === undefined || Number.isNaN(x)) return "-";
            const v = Number(x);
            const cls = v >= 0 ? "pos" : "neg";
            return `<span class="num ${cls}">${fmtNum(v, d)}%</span>`;
        }
        function el(tag, attrs = {}, html = "") {
            const e = document.createElement(tag);
            Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
            e.innerHTML = html;
            return e;
        }

        // ==========================
        // 컬럼 정의
        // ==========================
        const BASE_COLUMNS = [
            { key: "symbol", label: "심볼" },
            { key: "prevOpen", label: "O-1" },
            { key: "prevHigh", label: "H-1" },
            { key: "prevLow",  label: "L-1" },
            { key: "prevClose",label: "C-1" },
            { key: "chgPct",   label: "등락률(%)" },
            { key: "rangePct", label: "범위(%)" },
            { key: "bodyPct",  label: "몸통비율" },
            { key: "upperW",   label: "윗꼬리" },
            { key: "lowerW",   label: "아랫꼬리" },
            { key: "wickImbPct", label: "WickImb(%)" },     // 추가
            { key: "clv",      label: "CLV" },
            { key: "quoteVol", label: "거래대금(USDT)" },
            { key: "overheat", label: "과열" },              // 추가
            { key: "bias",     label: "신호" },              // 추가 (LC/LR/SR/CH-L/CH-S)
            { key: "score",    label: "예측점수(원시)" },
            { key: "prob",     label: "예측확률(%)" },
        ];
        const BACKTEST_COLUMNS = [
            { key: "dayOpen",        label: "D 시가" },
            { key: "dayLow",         label: "D 저가" },
            { key: "dayHigh",        label: "D 고가" },
            { key: "dayClose",       label: "D 종가" },
            { key: "dayRetHighPct",  label: "D 수익률(시→고,%)" },
            { key: "dayRetClosePct", label: "D 수익률(시→종,%)" },
            { key: "signalSide",     label: "진입" },                  // 추가
            { key: "signalRtnClosePct", label: "신호수익(시→종,%)" },  // 추가
            { key: "signalResult",   label: "신호결과" },              // 추가
            { key: "result",         label: "결과" },
        ];

        // ==========================
        // Binance API
        // ==========================
        const BASE = "https://fapi.binance.com";

        async function fetchUSDTPerpSymbols(abortSignal) {
            const url = `${BASE}/fapi/v1/exchangeInfo`;
            const res = await fetch(url, { signal: abortSignal });
            if (!res.ok) throw new Error("exchangeInfo error");
            const data = await res.json();
            const syms = data.symbols
                .filter(s =>
                    s.status === "TRADING" &&
                    s.contractType === "PERPETUAL" &&
                    s.quoteAsset === "USDT"
                )
                .map(s => s.symbol);
            return syms;
        }

        async function fetchDailyCandle(symbol, openTimeMs, abortSignal) {
            const start = openTimeMs;
            const end = openTimeMs + 24 * 60 * 60 * 1000 - 1;
            const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=1d&startTime=${start}&endTime=${end}&limit=1`;
            const res = await fetch(url, { signal: abortSignal });
            if (!res.ok) throw new Error(`klines error ${symbol}`);
            const arr = await res.json();
            if (!Array.isArray(arr) || !arr.length) return null;
            const k = arr[0];
            return {
                symbol,
                openTime: Number(k[0]),
                open: Number(k[1]),
                high: Number(k[2]),
                low: Number(k[3]),
                close: Number(k[4]),
                volume: Number(k[5]),
                closeTime: Number(k[6]),
                quoteVolume: Number(k[7]),
                trades: Number(k[8]),
                takerBuyBase: Number(k[9]),
                takerBuyQuote: Number(k[10]),
            };
        }

        // ==========================
        // 점수/확률 계산 (직전봉 하나)
        // ==========================
        function featuresFromCandle(k) {
            const O = k.open, H = k.high, L = k.low, C = k.close;
            const QV = k.quoteVolume ?? 0;
            const range = Math.max(1e-12, (H - L));
            const body = Math.abs(C - O);
            const dir = (C > O) ? 1 : (C < O) ? -1 : 0;

            const bodyPct = body / range;
            const upper = H - Math.max(C, O);
            const lower = Math.min(C, O) - L;
            const upperW = upper / range;
            const lowerW = lower / range;
            const clv = (C - L) / range;
            const chgPct = (C - O) / (O || 1e-12) * 100;
            const rangePct = (H - L) / (O || 1e-12) * 100;
            const wickImbPct = (lowerW - upperW) * 100;

            return { dir, bodyPct, upperW, lowerW, clv, chgPct, rangePct, quoteVol: QV, wickImbPct };
        }

        function buildScores(rows) {
            const logs = rows.map(r => Math.log10(Math.max(1, r.features.quoteVol)));
            const mu = mean(logs), sd = stddev(logs);
            rows.forEach(r => {
                const vZ = (Math.log10(Math.max(1, r.features.quoteVol)) - mu) / sd;
                const f = r.features;
                const score =
                    0.5 * (f.dir * f.bodyPct) +
                    0.3 * ((2 * f.clv) - 1) +
                    0.2 * (f.lowerW - f.upperW) +
                    0.1 * tanh(f.rangePct / 10) +
                    0.1 * vZ;
                r.score = score;
                r._volZ = vZ;
            });
            const sArr = rows.map(r => r.score);
            const sMu = mean(sArr), sSd = stddev(sArr);
            const k = 1.2;
            rows.forEach(r => {
                const z = (r.score - sMu) / sSd;
                r.prob = 1 / (1 + Math.exp(-k * z));
            });
        }

        // ==========================
        // 레짐/신호 로직
        // ==========================
        const REGIME_CONST = {
            bullUpRatio: 0.55,     // 상승비율 55% 이상
            bearUpRatio: 0.45,     // 상승비율 45% 이하
            bullMedianChg: +0.5,   // 중앙등락률 +0.5% 이상
            bearMedianChg: -0.5,   // 중앙등락률 -0.5% 이하
            choppyWickImbGate: 1.0 // 찹피에서 ±1% 넘으면 방향성 신호
        };

        function computeRegime(rows) {
            const ups = rows.filter(r => r.chgPct > 0).length;
            const pctUp = rows.length ? (ups / rows.length) : 0;
            const medChg = median(rows.map(r => r.chgPct).filter(v => Number.isFinite(v)));

            let regime = "CHOPPY";
            if (pctUp >= REGIME_CONST.bullUpRatio || medChg >= REGIME_CONST.bullMedianChg) regime = "BULL";
            else if (pctUp <= REGIME_CONST.bearUpRatio || medChg <= REGIME_CONST.bearMedianChg) regime = "BEAR";
            return { regime, pctUp, medChg };
        }

        function buildDecileFns(rows) {
            const get = k => rows.map(r => r[k]).filter(v => Number.isFinite(v));
            const t = {};
            const fields = ["prob","score","chgPct","rangePct","bodyPct","upperW","lowerW","clv"];
            fields.forEach(f => { t[f] = quantileThresholds(get(f), 10); });
            return {
                dProb:  (v) => valueToDecile(v, t.prob),
                dScore: (v) => valueToDecile(v, t.score),
                dChg:   (v) => valueToDecile(v, t.chgPct),
                dRng:   (v) => valueToDecile(v, t.rangePct),
                dBody:  (v) => valueToDecile(v, t.bodyPct),
                dUpW:   (v) => valueToDecile(v, t.upperW),
                dLoW:   (v) => valueToDecile(v, t.lowerW),
                dCLV:   (v) => valueToDecile(v, t.clv),
                q80_rng: quantile(get("rangePct"), 0.8),
                q80_chg: quantile(get("chgPct"), 0.8),
            };
        }

        function classifySignals(rows, dec, regime, overheatPct = 80) {
            const qOver_rng = quantile(rows.map(r => r.rangePct), overheatPct / 100);
            const qOver_chg = quantile(rows.map(r => r.chgPct),   overheatPct / 100);

            rows.forEach(r => {
                // 과열 플래그
                r.overheat = (r.rangePct >= qOver_rng) || (r.chgPct >= qOver_chg);

                // 분위 값
                const dProb = dec.dProb(r.prob);
                const dScore = dec.dScore(r.score);
                const dChg = dec.dChg(r.chgPct);
                const dRng = dec.dRng(r.rangePct);
                const dBody = dec.dBody(r.bodyPct);
                const dUpW = dec.dUpW(r.upperW);
                const dLoW = dec.dLoW(r.lowerW);
                const dCLV = dec.dCLV(r.clv);

                // 기본값
                r.bias = "-";
                r.signalSide = "-";

                if (regime === "BULL") {
                    // Long Continuation (LC)
                    const cond =
                        (dProb >= 8 || dScore >= 8) &&
                        (dUpW <= 3) &&
                        (dCLV >= 7) &&
                        (dRng <= 8) &&
                        !r.overheat;
                    if (cond) { r.bias = "LC-롱"; r.signalSide = "LONG"; }
                } else if (regime === "BEAR") {
                    // Long Reversal (LR)
                    const condLR =
                        (dChg <= 3) &&
                        (dLoW >= 7) &&
                        (dProb >= 4 && dProb <= 6 || dScore >= 4 && dScore <= 6);
                    // Short Reversal (SR)
                    const condSR =
                        (dChg >= 8) &&
                        (dUpW >= 7) &&
                        ((dCLV <= 4) || (dBody >= 8)) &&
                        r.overheat;

                    if (condSR) { r.bias = "SR-숏"; r.signalSide = "SHORT"; }
                    else if (condLR) { r.bias = "LR-롱"; r.signalSide = "LONG"; }
                } else {
                    // CHOPPY: WickImb 기반
                    if (r.wickImbPct >= REGIME_CONST.choppyWickImbGate) { r.bias = "CH-L"; r.signalSide = "LONG"; }
                    else if (r.wickImbPct <= -REGIME_CONST.choppyWickImbGate) { r.bias = "CH-S"; r.signalSide = "SHORT"; }
                    else { r.bias = "CH-N"; r.signalSide = "-"; }
                }
            });
        }

        // ==========================
        // 렌더링
        // ==========================
        function updateTableMinWidth() {
            const thCount = document.querySelectorAll('#thead th').length || 18;
            const perCol = 120;
            const min = Math.max(1600, thCount * perCol);
            document.getElementById('resultTable').style.minWidth = `${min}px`;
        }

        function renderHeader(isBacktest, sortState) {
            const thead = document.getElementById("thead");
            thead.innerHTML = "";
            const tr = document.createElement("tr");
            const cols = isBacktest ? [...BASE_COLUMNS, ...BACKTEST_COLUMNS] : BASE_COLUMNS;
            cols.forEach(col => {
                const th = document.createElement("th");
                const wrap = el("div", { class: "head-flex" });
                const label = el("span", {}, col.label);
                const arrows = el("span", { class: "sort-arrows" });
                const up = el("button", { "data-key": col.key, "data-dir": "asc", title: "오름차순" }, "▲");
                const down = el("button", { "data-key": col.key, "data-dir": "desc", title: "내림차순" }, "▼");
                if (sortState.key === col.key) {
                    (sortState.dir === "asc" ? up : down).classList.add("active");
                }
                arrows.appendChild(up);
                arrows.appendChild(down);
                wrap.appendChild(label);
                wrap.appendChild(arrows);
                th.appendChild(wrap);
                tr.appendChild(th);
            });
            thead.appendChild(tr);

            thead.querySelectorAll(".sort-arrows button").forEach(btn => {
                btn.addEventListener("click", () => {
                    const key = btn.getAttribute("data-key");
                    const dir = btn.getAttribute("data-dir");
                    state.sort = { key, dir };
                    renderHeader(state.isBacktest, state.sort);
                    drawTable();
                });
            });

            updateTableMinWidth();
        }

        function drawTable() {
            const tbody = document.getElementById("tbody");
            const { rows, isBacktest, sort, symbolFilter, signalOnly } = state;

            const visible = rows.filter(r => {
                if (symbolFilter && !r.symbol.toLowerCase().includes(symbolFilter.toLowerCase())) return false;
                if (signalOnly && (!r.bias || r.bias === "-" || r.signalSide === "-")) return false;
                return true;
            });

            visible.sort((a, b) => {
                const k = sort.key;
                const dir = sort.dir === "asc" ? 1 : -1;
                const av = a[k];
                const bv = b[k];
                if (typeof av === "string" || typeof bv === "string") {
                    return String(av).localeCompare(String(bv)) * dir;
                }
                return ((av ?? -Infinity) - (bv ?? -Infinity)) * dir;
            });

            const nf2 = (v) => fmtNum(v, 2);
            const nf3 = (v) => fmtNum(v, 3);
            const nf4 = (v) => fmtNum(v, 4);

            const frag = document.createDocumentFragment();
            visible.forEach(r => {
                const tr = document.createElement("tr");
                const cells = [];

                // 기본 컬럼
                cells.push(`<td>${r.symbol}</td>`);
                cells.push(`<td>${nf4(r.prevOpen)}</td>`);
                cells.push(`<td>${nf4(r.prevHigh)}</td>`);
                cells.push(`<td>${nf4(r.prevLow)}</td>`);
                cells.push(`<td>${nf4(r.prevClose)}</td>`);
                cells.push(`<td>${fmtPct(r.chgPct)}</td>`);
                cells.push(`<td>${fmtNum(r.rangePct, 2)}%</td>`);
                cells.push(`<td>${fmtNum(r.bodyPct * 100, 2)}%</td>`);
                cells.push(`<td>${fmtNum(r.upperW * 100, 2)}%</td>`);
                cells.push(`<td>${fmtNum(r.lowerW * 100, 2)}%</td>`);
                cells.push(`<td>${fmtNum(r.wickImbPct, 2)}%</td>`);
                cells.push(`<td>${fmtNum(r.clv, 3)}</td>`);
                cells.push(`<td>${fmtNum(r.quoteVol, 0)}</td>`);
                // 과열/신호 pill
                const overheatPill = r.overheat ? `<span class="pill warn">HOT</span>` : `<span class="pill neutral">-</span>`;
                const biasPill = r.signalSide === "LONG" ? `<span class="pill long">${r.bias}</span>`
                                : r.signalSide === "SHORT" ? `<span class="pill short">${r.bias}</span>`
                                : `<span class="pill neutral">${r.bias}</span>`;
                cells.push(`<td>${overheatPill}</td>`);
                cells.push(`<td>${biasPill}</td>`);

                cells.push(`<td>${nf3(r.score)}</td>`);
                cells.push(`<td>${fmtNum(r.prob * 100, 2)}%</td>`);

                // 백테스트 컬럼
                if (isBacktest) {
                    const resPill = (typeof r.dayRetClosePct === 'number' && r.dayRetClosePct >= 0)
                        ? `<span class="pill ok">성공</span>`
                        : (typeof r.dayRetClosePct === 'number' && r.dayRetClosePct < 0)
                            ? `<span class="pill no">실패</span>` : `<span class="pill neutral">-</span>`;

                    // 신호 결과(시→종 기준, 숏이면 부호 반전)
                    let sigRtn = null, sigRes = "-";
                    if (r.signalSide === "LONG" && typeof r.dayRetClosePct === "number") {
                        sigRtn = r.dayRetClosePct;
                        sigRes = sigRtn >= 0 ? "성공" : "실패";
                    } else if (r.signalSide === "SHORT" && typeof r.dayRetClosePct === "number") {
                        sigRtn = -r.dayRetClosePct;
                        sigRes = sigRtn >= 0 ? "성공" : "실패";
                    }

                    const sigResPill = sigRes === "성공" ? `<span class="pill ok">성공</span>`
                                      : sigRes === "실패" ? `<span class="pill no">실패</span>`
                                      : `<span class="pill neutral">-</span>`;

                    cells.push(`<td>${r.dayOpen  != null ? nf4(r.dayOpen)  : '-'}</td>`);
                    cells.push(`<td>${r.dayLow   != null ? nf4(r.dayLow)   : '-'}</td>`);
                    cells.push(`<td>${r.dayHigh  != null ? nf4(r.dayHigh)  : '-'}</td>`);
                    cells.push(`<td>${r.dayClose != null ? nf4(r.dayClose) : '-'}</td>`);
                    cells.push(`<td>${typeof r.dayRetHighPct  === 'number' ? fmtPct(r.dayRetHighPct)  : '-'}</td>`);
                    cells.push(`<td>${typeof r.dayRetClosePct === 'number' ? fmtPct(r.dayRetClosePct) : '-'}</td>`);
                    cells.push(`<td>${r.signalSide}</td>`);
                    cells.push(`<td>${sigRtn != null ? fmtPct(sigRtn) : '-'}</td>`);
                    cells.push(`<td>${sigResPill}</td>`);
                    cells.push(`<td>${resPill}</td>`);
                }

                tr.innerHTML = cells.join("");
                frag.appendChild(tr);
            });

            tbody.innerHTML = "";
            tbody.appendChild(frag);

            // 요약
            const sum = document.getElementById("summary");
            sum.innerHTML = "";
            const total = visible.length;
            const top5 = visible.slice(0, 5).map(r => r.symbol).join(", ");
            sum.appendChild(el("div", { class: "chip" }, `표시 종목: <strong>${total.toLocaleString()}</strong>개`));
            sum.appendChild(el("div", { class: "chip" }, `정렬: <strong>${state.sort.key}</strong> (${state.sort.dir})`));
            sum.appendChild(el("div", { class: "chip" }, `Top5: <strong>${top5 || "-"}</strong>`));

            // 레짐/신호 요약
            if (state.regimeInfo) {
                const { regime, pctUp, medChg } = state.regimeInfo;
                sum.appendChild(el("div", { class: "chip" }, `레짐: <strong>${regime}</strong> (상승비율 ${fmtNum(pctUp*100,1)}%, 중앙등락 ${fmtNum(medChg,2)}%)`));
            }

            const sigLong = visible.filter(r => r.signalSide === "LONG").length;
            const sigShort = visible.filter(r => r.signalSide === "SHORT").length;
            sum.appendChild(el("div", { class: "chip" }, `신호(L/S): <strong>${sigLong}</strong> / <strong>${sigShort}</strong>`));

            if (state.isBacktest) {
                const tested = visible.filter(r => typeof r.dayRetClosePct === 'number');
                const success = tested.filter(r => r.dayRetClosePct >= 0).length;
                const rate = tested.length ? (success / tested.length) * 100 : 0;
                sum.appendChild(el("div", { class: "chip" }, `백테스트 성공(시→종): <strong>${success}</strong> / ${tested.length} (${fmtNum(rate, 1)}%)`));

                const sigTested = visible.filter(r => r.signalSide !== "-" && typeof r.dayRetClosePct === "number");
                const sigWin = sigTested.filter(r => (r.signalSide === "LONG" && r.dayRetClosePct >= 0) || (r.signalSide === "SHORT" && r.dayRetClosePct < 0)).length;
                const sigRate = sigTested.length ? sigWin / sigTested.length * 100 : 0;
                sum.appendChild(el("div", { class: "chip" }, `신호기반 성공률: <strong>${fmtNum(sigRate,1)}%</strong> (${sigWin}/${sigTested.length})`));
            }
        }

        function setProgress(done, total) {
            const bar = document.getElementById("bar");
            const pct = total ? Math.floor(done / total * 100) : 0;
            bar.style.width = `${pct}%`;
        }

        // ==========================
        // 스캔 로직
        // ==========================
        const state = {
            isBacktest: false,
            rows: [],
            sort: { key: "prob", dir: "desc" },
            symbolFilter: "",
            signalOnly: false,
            abortController: null,
            running: false,
            regimeInfo: null,
        };

        function poolRun(list, limit, worker, onTick) {
            return new Promise((resolve) => {
                let i = 0, done = 0;
                const total = list.length;
                const results = new Array(total);
                function next() {
                    if (i >= total) return;
                    const idx = i++;
                    worker(list[idx], idx).then(res => { results[idx] = res; })
                    .catch(() => { results[idx] = null; })
                    .finally(() => {
                        done++;
                        onTick?.(done, total);
                        if (done === total) resolve(results);
                        else next();
                    });
                }
                const c = Math.min(limit, total);
                for (let k = 0; k < c; k++) next();
            });
        }

        async function runScan() {
            if (state.running) return;
            state.running = true;
            state.rows = [];
            state.regimeInfo = null;
            setProgress(0, 1);

            const dateStr = document.getElementById("dateInput").value || toUTCDateString(new Date());
            const isBacktest = document.getElementById("backtestChk").checked;
            const minQVOn = document.getElementById("minQuoteVolChk").checked;
            const minQV = Number(document.getElementById("minQuoteVol").value || 0);
            const overheatPct = Math.min(99, Math.max(50, Number(document.getElementById("overheatPct").value || 80)));
            state.isBacktest = isBacktest;

            renderHeader(isBacktest, state.sort);
            drawTable();

            if (state.abortController) state.abortController.abort();
            const ac = new AbortController();
            state.abortController = ac;

            try {
                const D = parseDateUTC(dateStr).getTime();               // D일 00:00:00Z
                const prevOpenTime = D - 24 * 60 * 60 * 1000;            // 직전봉 openTime
                const symbols = await fetchUSDTPerpSymbols(ac.signal);

                const CONCURRENCY = 10;

                const results = await poolRun(symbols, CONCURRENCY, async (sym) => {
                    if (ac.signal.aborted) return null;

                    // 직전봉
                    const prev = await fetchDailyCandle(sym, prevOpenTime, ac.signal);
                    if (!prev) return null;
                    if (minQVOn && (prev.quoteVolume ?? 0) < minQV) return null;

                    const f = featuresFromCandle(prev);
                    const row = {
                        symbol: sym,
                        prevOpen: prev.open,
                        prevHigh: prev.high,
                        prevLow: prev.low,
                        prevClose: prev.close,
                        chgPct: f.chgPct,
                        rangePct: f.rangePct,
                        bodyPct: f.bodyPct,
                        upperW: f.upperW,
                        lowerW: f.lowerW,
                        wickImbPct: f.wickImbPct,
                        clv: f.clv,
                        quoteVol: f.quoteVol,
                        features: f,
                        score: null,
                        prob: null,
                        overheat: false,
                        bias: "-",
                        signalSide: "-",
                    };

                    if (isBacktest) {
                        // D일 실제 캔들
                        const cur = await fetchDailyCandle(sym, D, ac.signal);
                        if (cur) {
                            row.dayOpen  = cur.open;
                            row.dayLow   = cur.low;
                            row.dayHigh  = cur.high;
                            row.dayClose = cur.close;
                            row.dayRetHighPct  = (cur.high  - cur.open) / (cur.open || 1e-12) * 100; // 시→고
                            row.dayRetClosePct = (cur.close - cur.open) / (cur.open || 1e-12) * 100; // 시→종
                            row.result = row.dayRetClosePct >= 0 ? "성공" : "실패"; // 종가 기준 판정
                        } else {
                            row.dayOpen = row.dayLow = row.dayHigh = row.dayClose = null;
                            row.dayRetHighPct = row.dayRetClosePct = null;
                            row.result = "-";
                        }
                    }
                    return row;
                }, (done, total) => setProgress(done, total));

                const rows = results.filter(Boolean);

                // 점수/확률
                buildScores(rows);

                // 레짐
                const regimeInfo = computeRegime(rows);
                state.regimeInfo = regimeInfo;

                // 분위/과열/신호
                const dec = buildDecileFns(rows);
                classifySignals(rows, dec, regimeInfo.regime, overheatPct);

                // 신호 기반 백테스트 결과(시→종 기준, 숏 반전)
                if (isBacktest) {
                    rows.forEach(r => {
                        if (r.signalSide === "LONG" && typeof r.dayRetClosePct === "number") {
                            r.signalRtnClosePct = r.dayRetClosePct;
                            r.signalResult = r.signalRtnClosePct >= 0 ? "성공" : "실패";
                        } else if (r.signalSide === "SHORT" && typeof r.dayRetClosePct === "number") {
                            r.signalRtnClosePct = -r.dayRetClosePct;
                            r.signalResult = r.signalRtnClosePct >= 0 ? "성공" : "실패";
                        } else {
                            r.signalRtnClosePct = null;
                            r.signalResult = "-";
                        }
                    });
                }

                state.rows = rows;
                state.sort = { key: "prob", dir: "desc" };
                renderHeader(state.isBacktest, state.sort);
                drawTable();
                setProgress(1, 1);
            } catch (err) {
                console.error(err);
                alert("스캔 중 오류가 발생했습니다. 콘솔을 확인하세요.");
            } finally {
                state.running = false;
            }
        }

        function stopScan() {
            if (state.abortController) { try { state.abortController.abort(); } catch {} }
            state.running = false;
        }

        // ==========================
        // 초기화
        // ==========================
        (function init() {
            const dateInput = document.getElementById("dateInput");
            dateInput.value = toUTCDateString(new Date());

            document.getElementById("scanBtn").addEventListener("click", runScan);
            document.getElementById("stopBtn").addEventListener("click", stopScan);
            document.getElementById("backtestChk").addEventListener("change", () => {
                renderHeader(document.getElementById("backtestChk").checked, state.sort);
                drawTable();
            });
            document.getElementById("searchSym").addEventListener("input", (e) => {
                state.symbolFilter = e.target.value.trim();
                drawTable();
            });
            document.getElementById("signalOnly").addEventListener("change", (e) => {
                state.signalOnly = !!e.target.checked;
                drawTable();
            });

            renderHeader(false, state.sort);
        })();
    </script>
</body>
</html>
