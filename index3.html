<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT-M Perpetual 1D Prev Candle Scanner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { color-scheme: light dark; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif; margin: 0; padding: 24px; }
        h1 { margin: 0 0 12px; font-size: 20px; }
        .controls { display: grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap: 12px; align-items: end; margin: 12px 0 16px; }
        .controls label { display: block; font-size: 12px; opacity: .85; margin-bottom: 4px; }
        .controls input { width: 100%; padding: 8px 10px; font-size: 14px; }
        .controls button { padding: 10px 12px; font-size: 14px; cursor: pointer; }
        .rowspan-2 { grid-column: span 2; }
        .rowspan-3 { grid-column: span 3; }
        .status { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
        progress { width: 260px; height: 16px; }
        table { width: 100%; border-collapse: collapse; margin-top: 12px; }
        th, td { padding: 8px 10px; border-bottom: 1px solid rgba(127,127,127,.25); font-size: 13px; white-space: nowrap; }
        th { text-align: left; cursor: pointer; position: sticky; top: 0; background: canvas; }
        .right { text-align: right; }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
        .pos { color: #168a00; }
        .neg { color: #c70039; }
        .muted { opacity: .7; }
        .small { font-size: 12px; }
        .hint { font-size: 12px; opacity: .8; margin-top: 8px; }
        .sticky-actions { position: sticky; top: 0; background: canvas; z-index: 1; padding-bottom: 8px; }
        .badge { display: inline-block; padding: 2px 6px; border: 1px solid rgba(127,127,127,.4); border-radius: 6px; font-size: 11px; }
        .link { text-decoration: none; }
    </style>
</head>
<body>
    <h1>USDT-M Perp · 1D 직전봉 상승률 스캐너</h1>

    <div class="controls">
        <div>
            <label>동시성 (기본 5)</label>
            <input id="concurrency" type="number" min="1" max="20" value="5" />
        </div>
        <div>
            <label>요청 간 지연 ms (기본 120)</label>
            <input id="delay" type="number" min="0" max="2000" value="120" />
        </div>
        <div>
            <label>최대 재시도 (기본 3)</label>
            <input id="retries" type="number" min="0" max="10" value="3" />
        </div>
        <div>
            <label>타임아웃 ms (기본 9000)</label>
            <input id="timeout" type="number" min="1000" max="30000" value="9000" />
        </div>
        <div>
            <label>심볼 최대 개수 (0=전체)</label>
            <input id="limitSymbols" type="number" min="0" value="0" />
        </div>
        <div>
            <label>페어 필터(쉼표, 포함검색. 예: BTC,ETH)</label>
            <input id="pairFilter" type="text" placeholder="비워두면 전체" />
        </div>

        <div class="rowspan-3">
            <button id="startBtn">▶ 스캔 시작</button>
            <button id="stopBtn">■ 중단</button>
            <button id="exportBtn">CSV 저장</button>
        </div>
        <div class="rowspan-3">
            <div class="hint">
                • 대상: USDⓈ-M 무기한(quote=USDT, contractType=PERPETUAL)<br/>
                • 상승률 = (직전 1D 봉 종가-시가) / 시가 × 100<br/>
                • 정렬: 기본 내림차순(클릭으로 다른 컬럼 정렬 가능)
            </div>
        </div>
    </div>

    <div class="status sticky-actions">
        <span id="statusText" class="badge">대기 중</span>
        <progress id="progress" max="100" value="0"></progress>
        <span id="counter" class="small muted">0 / 0</span>
        <span id="rate" class="small muted"></span>
    </div>

    <table id="resultTable">
        <thead>
            <tr>
                <th data-key="rank">#</th>
                <th data-key="symbol">심볼</th>
                <th data-key="pct" class="right">직전봉 상승률(%)</th>
                <th data-key="open" class="right">직전 시가</th>
                <th data-key="close" class="right">직전 종가</th>
                <th data-key="volume" class="right">직전 거래량</th>
                <th data-key="time" class="right">직전 봉 시각(UTC)</th>
                <th>차트</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

<script>
(() => {
    const API = {
        BASE: "https://fapi.binance.com",
        EXCHANGE_INFO: "/fapi/v1/exchangeInfo",
        KLINES: "/fapi/v1/klines"
    };

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    const els = {
        start: $("#startBtn"),
        stop: $("#stopBtn"),
        export: $("#exportBtn"),
        progress: $("#progress"),
        status: $("#statusText"),
        counter: $("#counter"),
        rate: $("#rate"),
        tbody: $("#resultTable tbody"),
        headers: $$("#resultTable thead th"),
        inputs: {
            concurrency: $("#concurrency"),
            delay: $("#delay"),
            retries: $("#retries"),
            timeout: $("#timeout"),
            limitSymbols: $("#limitSymbols"),
            pairFilter: $("#pairFilter"),
        }
    };

    let abortFlag = false;
    let results = [];
    let sortState = { key: "pct", dir: "desc" };
    let startedAt = 0;
    let completed = 0;

    function setStatus(text) {
        els.status.textContent = text;
    }

    function sleep(ms) {
        return new Promise(res => setTimeout(res, ms));
    }

    async function fetchWithTimeout(url, { timeout = 9000, signal } = {}) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        try {
            const resp = await fetch(url, { signal: signal ?? controller.signal });
            return resp;
        } finally {
            clearTimeout(id);
        }
    }

    async function fetchJSON(url, { timeout, retries, backoffBase = 600, signal } = {}) {
        let attempt = 0;
        while (true) {
            try {
                const resp = await fetchWithTimeout(url, { timeout, signal });
                if (!resp.ok) {
                    // 418/429 등 레이트리밋 → 백오프
                    if ((resp.status === 418 || resp.status === 429) && attempt < retries) {
                        attempt++;
                        const wait = backoffBase * Math.pow(2, attempt - 1) + Math.random() * 400;
                        await sleep(wait);
                        continue;
                    }
                    // 기타 오류
                    throw new Error(`HTTP ${resp.status}`);
                }
                return await resp.json();
            } catch (err) {
                if (attempt < retries) {
                    attempt++;
                    const wait = backoffBase * Math.pow(2, attempt - 1) + Math.random() * 400;
                    await sleep(wait);
                    continue;
                }
                throw err;
            }
        }
    }

    function toCSV(rows) {
        const header = ["rank","symbol","pct","open","close","volume","time_utc"];
        const lines = [header.join(",")];
        for (const r of rows) {
            lines.push([
                r.rank,
                r.symbol,
                r.pct.toFixed(4),
                r.open,
                r.close,
                r.volume,
                new Date(r.time).toISOString().replace(".000Z","Z")
            ].join(","));
        }
        return lines.join("\n");
    }

    function render() {
        // 정렬
        const key = sortState.key;
        const dir = sortState.dir === "asc" ? 1 : -1;
        const sorted = [...results].sort((a, b) => {
            if (key === "symbol") return a.symbol.localeCompare(b.symbol) * dir;
            if (key === "time" || key === "open" || key === "close" || key === "volume") {
                return (a[key] - b[key]) * dir;
            }
            // pct / rank 기본
            return (a[key] - b[key]) * dir;
        });

        // 순위 재매김
        sorted.forEach((r, i) => r.rank = i + 1);

        const rows = sorted.map(r => {
            const pctClass = r.pct >= 0 ? "pos" : "neg";
            const chartUrl = `https://www.binance.com/ko/futures/${encodeURIComponent(r.symbol)}?interval=1d`;
            return `
                <tr>
                    <td class="mono right">${r.rank}</td>
                    <td class="mono"><a class="link" href="${chartUrl}" target="_blank" rel="noopener">${r.symbol}</a></td>
                    <td class="mono right ${pctClass}">${r.pct.toFixed(4)}</td>
                    <td class="mono right">${formatNum(r.open)}</td>
                    <td class="mono right">${formatNum(r.close)}</td>
                    <td class="mono right">${formatNum(r.volume)}</td>
                    <td class="mono right small muted">${new Date(r.time).toISOString().replace(".000Z","Z")}</td>
                    <td><a class="link" href="${chartUrl}" target="_blank" rel="noopener">Binance</a></td>
                </tr>
            `;
        }).join("");

        els.tbody.innerHTML = rows || `<tr><td colspan="8" class="small muted">데이터 없음</td></tr>`;
    }

    function formatNum(n) {
        if (n === null || n === undefined || Number.isNaN(n)) return "";
        // 큰 수는 간단히 압축 표기
        if (Math.abs(n) >= 1e9) return (n / 1e9).toFixed(2) + "B";
        if (Math.abs(n) >= 1e6) return (n / 1e6).toFixed(2) + "M";
        if (Math.abs(n) >= 1e3) return (n / 1e3).toFixed(2) + "K";
        // 소수는 원본 유지
        const str = String(n);
        const dot = str.indexOf(".");
        return dot >= 0 ? (str.length - dot > 7 ? n.toFixed(6) : str) : str;
    }

    async function getSymbols({ limitSymbols = 0, pairFilter = "" } = {}) {
        const info = await fetchJSON(`${API.BASE}${API.EXCHANGE_INFO}`, { timeout: 9000, retries: 2 });
        // USDⓈ-M PERPETUAL + quote=USDT + status=TRADING
        let syms = info.symbols.filter(s =>
            s.contractType === "PERPETUAL" &&
            s.quoteAsset === "USDT" &&
            s.status === "TRADING"
        ).map(s => s.symbol);

        if (pairFilter.trim()) {
            const tokens = pairFilter.split(",").map(t => t.trim().toUpperCase()).filter(Boolean);
            syms = syms.filter(sym => tokens.some(tok => sym.includes(tok)));
        }

        syms.sort(); // 일정한 순서
        if (limitSymbols > 0) {
            syms = syms.slice(0, limitSymbols);
        }
        return syms;
    }

    async function fetchPrevCandle(symbol, opts) {
        // limit=2 → [이전(완전 마감), 현재 진행중]
        const url = `${API.BASE}${API.KLINES}?symbol=${symbol}&interval=1d&limit=2`;
        const arr = await fetchJSON(url, opts);
        if (!Array.isArray(arr) || arr.length < 1) {
            throw new Error("No kline data");
        }
        // 이전 봉(마감된 것). limit=2면 index 0이 직전봉.
        const k = arr[0];
        const open = Number(k[1]);
        const close = Number(k[4]);
        const volume = Number(k[5]);
        const closeTime = Number(k[6]); // 봉 종료 시각(ms)
        if (!isFinite(open) || !isFinite(close)) throw new Error("Bad numbers");
        const pct = (close - open) / open * 100;
        return { symbol, open, close, volume, time: closeTime, pct };
    }

    async function runScan() {
        abortFlag = false;
        results = [];
        completed = 0;
        startedAt = performance.now();

        const concurrency = clamp(parseInt(els.inputs.concurrency.value, 10), 1, 20);
        const delay = clamp(parseInt(els.inputs.delay.value, 10), 0, 2000);
        const retries = clamp(parseInt(els.inputs.retries.value, 10), 0, 10);
        const timeout = clamp(parseInt(els.inputs.timeout.value, 10), 1000, 30000);
        const limitSymbols = Math.max(0, parseInt(els.inputs.limitSymbols.value, 10) || 0);
        const pairFilter = els.inputs.pairFilter.value || "";

        setStatus("심볼 로딩 중...");
        let symbols = [];
        try {
            symbols = await getSymbols({ limitSymbols, pairFilter });
        } catch (e) {
            setStatus("심볼 조회 실패");
            console.error(e);
            return;
        }

        els.progress.max = symbols.length;
        els.progress.value = 0;
        els.counter.textContent = `0 / ${symbols.length}`;
        setStatus(`스캔 중... (대상 ${symbols.length}개)`);

        // 작업 큐
        const tasks = symbols.map(sym => async () => {
            if (abortFlag) return;
            try {
                const r = await fetchPrevCandle(sym, { timeout, retries });
                results.push(r);
            } catch (e) {
                // 실패 심볼은 건너뜀(로그만)
                // console.warn(sym, e);
            } finally {
                completed++;
                els.progress.value = completed;
                els.counter.textContent = `${completed} / ${symbols.length}`;
                updateRate();
                // 지연
                if (delay > 0) await sleep(delay);
                render(); // 실시간 갱신
            }
        });

        // 동시 실행
        await runPool(tasks, concurrency);

        if (abortFlag) {
            setStatus("중단됨");
        } else {
            // 최종 정렬(내림차순)
            sortState = { key: "pct", dir: "desc" };
            render();
            setStatus("완료");
        }
    }

    function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
    }

    async function runPool(taskFns, concurrency) {
        const runners = [];
        let idx = 0;
        for (let i = 0; i < concurrency; i++) {
            runners.push((async function worker() {
                while (idx < taskFns.length && !abortFlag) {
                    const my = idx++;
                    await taskFns[my]();
                }
            })());
        }
        await Promise.all(runners);
    }

    function updateRate() {
        const elapsed = (performance.now() - startedAt) / 1000;
        if (elapsed <= 0) {
            els.rate.textContent = "";
            return;
        }
        const rps = completed / elapsed;
        els.rate.textContent = `속도: ${rps.toFixed(2)} req/s`;
    }

    // 이벤트 바인딩
    els.start.addEventListener("click", () => {
        if (abortFlag === false && completed !== 0 && els.status.textContent === "스캔 중...") return;
        runScan();
    });
    els.stop.addEventListener("click", () => {
        abortFlag = true;
        setStatus("중단 요청됨...");
    });
    els.export.addEventListener("click", () => {
        if (!results.length) return;
        // 정렬 반영본으로 저장
        const key = sortState.key, dir = sortState.dir;
        const sorted = [...results].sort((a, b) => {
            const d = (key === "symbol") ? a.symbol.localeCompare(b.symbol) : (a[key] - b[key]);
            return dir === "asc" ? d : -d;
        }).map((r, i) => ({ ...r, rank: i + 1 }));
        const csv = toCSV(sorted);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `usdt-perp-prev-1d-change_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    });

    // 헤더 정렬
    els.headers.forEach(th => {
        th.addEventListener("click", () => {
            const key = th.getAttribute("data-key");
            if (!key) return;
            if (sortState.key === key) {
                sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
            } else {
                sortState.key = key;
                sortState.dir = (key === "symbol" || key === "time") ? "asc" : "desc";
            }
            render();
        });
    });

})();
</script>
</body>
</html>