<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp 1M a[-2] 올타임로우 스캐너</title>
        <style>
            :root {
                --bg: #0b1220;
                --panel: #101a30;
                --panel2: #0f1a2f;
                --text: #e7eefc;
                --muted: #9bb0d0;
                --line: rgba(255, 255, 255, 0.09);
                --good: #44d19d;
                --bad: #ff6b6b;
                --warn: #ffcc66;
                --btn: #1b2a4a;
                --btn2: #223a66;
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
                background: radial-gradient(1200px 800px at 20% 0%, #142449 0%, var(--bg) 45%, #070b14 100%);
                color: var(--text);
            }

            .wrap {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }

            h1 {
                margin: 0 0 14px;
                font-size: 20px;
                letter-spacing: -0.2px;
            }

            .grid {
                display: grid;
                grid-template-columns: 1.2fr 0.8fr;
                gap: 14px;
            }

            .card {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
                border: 1px solid var(--line);
                border-radius: 12px;
                padding: 14px;
            }

            .row {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                align-items: center;
            }

            label {
                font-size: 12px;
                color: var(--muted);
            }

            input[type="number"],
            input[type="text"],
            select {
                background: rgba(0, 0, 0, 0.25);
                color: var(--text);
                border: 1px solid var(--line);
                border-radius: 10px;
                padding: 10px 10px;
                outline: none;
                min-width: 140px;
            }

            input[type="checkbox"] {
                transform: translateY(1px);
            }

            button {
                background: var(--btn);
                color: var(--text);
                border: 1px solid var(--line);
                border-radius: 10px;
                padding: 10px 12px;
                cursor: pointer;
                transition: 0.15s;
                font-weight: 600;
            }

            button:hover {
                background: var(--btn2);
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            .small {
                font-size: 12px;
                color: var(--muted);
                line-height: 1.5;
            }

            .stat {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-top: 10px;
            }

            .pill {
                border: 1px solid var(--line);
                border-radius: 12px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.18);
            }

            .pill b {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin-bottom: 4px;
            }

            .pill span {
                font-size: 14px;
                font-weight: 700;
            }

            .progress {
                width: 100%;
                height: 10px;
                background: rgba(255, 255, 255, 0.08);
                border-radius: 999px;
                overflow: hidden;
                margin-top: 10px;
                border: 1px solid var(--line);
            }

            .progress > div {
                height: 100%;
                width: 0%;
                background: linear-gradient(90deg, rgba(68, 209, 157, 0.9), rgba(91, 170, 255, 0.9));
                transition: width 0.2s;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                overflow: hidden;
                border-radius: 12px;
                border: 1px solid var(--line);
            }

            thead th {
                text-align: left;
                font-size: 12px;
                color: var(--muted);
                background: rgba(0, 0, 0, 0.25);
                padding: 10px;
                border-bottom: 1px solid var(--line);
                white-space: nowrap;
            }

            tbody td {
                padding: 10px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.06);
                font-size: 13px;
                vertical-align: top;
            }

            tbody tr:hover td {
                background: rgba(255, 255, 255, 0.04);
            }

            .ok {
                color: var(--good);
                font-weight: 800;
            }

            .no {
                color: var(--bad);
                font-weight: 800;
            }

            .tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.18);
                font-size: 12px;
                color: var(--muted);
                white-space: nowrap;
            }

            .mono {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }

            .footer {
                margin-top: 10px;
                display: flex;
                justify-content: space-between;
                gap: 10px;
                flex-wrap: wrap;
                align-items: center;
            }

            .log {
                height: 170px;
                overflow: auto;
                background: rgba(0, 0, 0, 0.22);
                border: 1px solid var(--line);
                border-radius: 12px;
                padding: 10px;
                font-size: 12px;
                line-height: 1.5;
                color: #cfe0ff;
                white-space: pre-wrap;
            }

            .subhead {
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
                gap: 10px;
                flex-wrap: wrap;
                margin: 14px 0 8px;
            }

            .subhead b {
                font-size: 14px;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <h1>Binance USDT Perp — 1달봉(1M) 전체 스캔: a[-2] 저가가 올타임로우(최저)인 심볼만</h1>

            <div class="grid">
                <div class="card">
                    <div class="row" style="justify-content: space-between;">
                        <div>
                            <div class="small">
                                조건: 현재봉을 a라고 하면 <b>a[-2] (두 달 전 봉)의 저가(low)가</b> 해당 심볼의 <b>전체 1M 히스토리 최저 저가(ATL)</b>와 같을 때만
                                결과에 포함.<br />
                                추가 분리: <b>현재봉 Low(a)</b>가 <b>a[-1] Low(전월 Low)</b>보다 <b>낮으면 아래 테이블</b>, <b>같거나 높으면 위 테이블</b>에 표시.
                                (현재봉은 진행 중이라 Low는 업데이트될 수 있음)
                            </div>
                        </div>
                        <div class="row">
                            <button id="btnStart">스캔 시작</button>
                            <button id="btnStop" disabled>중단</button>
                            <button id="btnExport" disabled>CSV 내보내기</button>
                        </div>
                    </div>

                    <hr style="border: 0; border-top: 1px solid var(--line); margin: 12px 0;" />

                    <div class="row">
                        <div>
                            <label>동시 처리 개수(권장 2~5)</label><br />
                            <input id="concurrency" type="number" min="1" max="10" value="3" />
                        </div>
                        <div>
                            <label>최대 심볼 수(0=전체)</label><br />
                            <input id="maxSymbols" type="number" min="0" value="0" />
                        </div>
                        <div>
                            <label>캔들 페이지당 limit (최대 1500)</label><br />
                            <input id="pageLimit" type="number" min="200" max="1500" value="1500" />
                        </div>
                        <div>
                            <label>재시도 횟수</label><br />
                            <input id="retries" type="number" min="0" max="10" value="4" />
                        </div>
                        <div>
                            <label>페이지간 딜레이(ms)</label><br />
                            <input id="pageDelay" type="number" min="0" max="2000" value="120" />
                        </div>
                        <div style="min-width: 220px;">
                            <label>필터</label><br />
                            <div class="row" style="gap: 12px; margin-top: 8px;">
                                <label class="tag">
                                    <input id="onlyTrading" type="checkbox" checked />
                                    TRADING만
                                </label>
                                <label class="tag">
                                    <input id="excludeBUSD" type="checkbox" checked />
                                    BUSD/USDC 등 제외(USDT만)
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="stat">
                        <div class="pill">
                            <b>진행</b>
                            <span id="statProgress">-</span>
                        </div>
                        <div class="pill">
                            <b>조건 충족(결과)</b>
                            <span id="statHits">0</span>
                        </div>
                        <div class="pill">
                            <b>마지막 처리 심볼</b>
                            <span id="statLast">-</span>
                        </div>
                        <div class="pill">
                            <b>에러</b>
                            <span id="statErr">0</span>
                        </div>
                    </div>

                    <div class="progress">
                        <div id="bar"></div>
                    </div>

                    <div class="footer">
                        <div class="small">
                            Binance Futures API: <span class="mono">https://fapi.binance.com</span><br />
                            * 너무 오래 걸리면 동시 처리 수를 낮추거나, max 심볼 수를 제한해봐.
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="row" style="justify-content: space-between;">
                        <div><b>로그</b></div>
                        <div class="tag mono" id="apiStatus">idle</div>
                    </div>
                    <div style="height: 10px;"></div>
                    <div id="log" class="log"></div>
                </div>
            </div>

            <div style="height: 14px;"></div>

            <div class="card">
                <div class="row" style="justify-content: space-between; align-items: flex-end;">
                    <div>
                        <b>결과 테이블</b>
                        <div class="small">a[-2] low가 올타임로우(ATL)인 심볼만 표시</div>
                    </div>
                    <div class="row">
                        <span class="tag">정렬: a[-2] 저가 오름차순</span>
                        <span class="tag">분리: 현재봉 Low(a) vs a[-1] Low</span>
                    </div>
                </div>

                <div class="subhead">
                    <div class="row">
                        <b>위: 현재봉 Low(a) ≥ a[-1] Low</b>
                        <span class="tag">Count: <span id="countHigh">0</span></span>
                    </div>
                    <div class="small">전월 저점 아래로는 아직 안 깼음(상대적으로 방어 중)</div>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Symbol</th>
                            <th>a[-2] Low</th>
                            <th>a[-2] Date (UTC)</th>
                            <th>ATL Low</th>
                            <th>ATL Date (UTC)</th>
                            <th>캔들 수(1M)</th>
                            <th>a Low(현재)</th>
                            <th>a[-1] Low</th>
                            <th>비교</th>
                            <th>비고</th>
                        </tr>
                    </thead>
                    <tbody id="tbodyHigh">
                        <tr>
                            <td colspan="11" style="color: var(--muted);">아직 결과 없음</td>
                        </tr>
                    </tbody>
                </table>

                <div class="subhead" style="margin-top: 18px;">
                    <div class="row">
                        <b>아래: 현재봉 Low(a) &lt; a[-1] Low</b>
                        <span class="tag">Count: <span id="countLow">0</span></span>
                    </div>
                    <div class="small">전월 저점 하향 돌파(추세 하방 지속 신호일 수 있어 더 보수적으로)</div>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Symbol</th>
                            <th>a[-2] Low</th>
                            <th>a[-2] Date (UTC)</th>
                            <th>ATL Low</th>
                            <th>ATL Date (UTC)</th>
                            <th>캔들 수(1M)</th>
                            <th>a Low(현재)</th>
                            <th>a[-1] Low</th>
                            <th>비교</th>
                            <th>비고</th>
                        </tr>
                    </thead>
                    <tbody id="tbodyLow">
                        <tr>
                            <td colspan="11" style="color: var(--muted);">아직 결과 없음</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <script>
            "use strict";

            const API_BASE = "https://fapi.binance.com";

            const $ = (id) => document.getElementById(id);

            const el = {
                btnStart: $("btnStart"),
                btnStop: $("btnStop"),
                btnExport: $("btnExport"),
                concurrency: $("concurrency"),
                maxSymbols: $("maxSymbols"),
                pageLimit: $("pageLimit"),
                retries: $("retries"),
                pageDelay: $("pageDelay"),
                onlyTrading: $("onlyTrading"),
                excludeBUSD: $("excludeBUSD"),
                statProgress: $("statProgress"),
                statHits: $("statHits"),
                statLast: $("statLast"),
                statErr: $("statErr"),
                bar: $("bar"),
                tbodyHigh: $("tbodyHigh"),
                tbodyLow: $("tbodyLow"),
                countHigh: $("countHigh"),
                countLow: $("countLow"),
                log: $("log"),
                apiStatus: $("apiStatus"),
            };

            let isRunning = false;
            let abortFlag = false;

            /** 결과 저장 */
            const hits = [];
            let totalSymbols = 0;
            let doneSymbols = 0;
            let errCount = 0;

            function logLine(msg) {
                const t = new Date().toISOString().replace("T", " ").replace("Z", "Z");
                el.log.textContent += `[${t}] ${msg}\n`;
                el.log.scrollTop = el.log.scrollHeight;
            }

            function setStatus(text) {
                el.apiStatus.textContent = text;
            }

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function toUtcDateStr(ms) {
                const d = new Date(ms);
                const y = d.getUTCFullYear();
                const m = String(d.getUTCMonth() + 1).padStart(2, "0");
                const day = String(d.getUTCDate()).padStart(2, "0");
                return `${y}-${m}-${day}`;
            }

            function num(n) {
                const x = Number(n);
                if (!Number.isFinite(x)) return "-";
                return x.toLocaleString(undefined, { maximumFractionDigits: 12 });
            }

            async function fetchJsonWithRetry(url, retryMax) {
                let attempt = 0;
                let lastErr = null;

                while (attempt <= retryMax) {
                    if (abortFlag) throw new Error("aborted");
                    try {
                        const res = await fetch(url, { cache: "no-store" });
                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 200)}`);
                        }
                        return await res.json();
                    } catch (e) {
                        lastErr = e;
                        const wait = Math.min(1500 * Math.pow(2, attempt), 12000);
                        logLine(`요청 실패(시도 ${attempt + 1}/${retryMax + 1}) → ${String(e.message || e)} / ${Math.round(wait)}ms 후 재시도`);
                        await sleep(wait);
                        attempt += 1;
                    }
                }
                throw lastErr || new Error("fetch failed");
            }

            async function getUsdtPerpSymbols() {
                const url = `${API_BASE}/fapi/v1/exchangeInfo`;
                const data = await fetchJsonWithRetry(url, Number(el.retries.value));

                const onlyTrading = el.onlyTrading.checked;
                const excludeBUSD = el.excludeBUSD.checked;

                const list = (data.symbols || [])
                    .filter((s) => s && s.contractType === "PERPETUAL")
                    .filter((s) => (excludeBUSD ? s.quoteAsset === "USDT" : true))
                    .filter((s) => (onlyTrading ? s.status === "TRADING" : true))
                    .map((s) => s.symbol)
                    .sort((a, b) => a.localeCompare(b));

                return list;
            }

            /**
             * 특정 심볼의 1M 캔들을 "가능한 끝까지" 페이지네이션해서 전부 가져온다.
             * - Binance limit 최대 1500
             * - endTime을 점점 과거로 당겨서 반복
             */
            async function fetchAllMonthlyKlines(symbol) {
                const limit = Math.max(200, Math.min(1500, Number(el.pageLimit.value) || 1500));
                const retryMax = Number(el.retries.value) || 0;
                const pageDelay = Math.max(0, Number(el.pageDelay.value) || 0);

                let endTime = null; // null이면 최신부터
                const all = [];

                while (true) {
                    if (abortFlag) break;

                    const qs = new URLSearchParams();
                    qs.set("symbol", symbol);
                    qs.set("interval", "1M");
                    qs.set("limit", String(limit));
                    if (endTime !== null) qs.set("endTime", String(endTime));

                    const url = `${API_BASE}/fapi/v1/klines?${qs.toString()}`;
                    const page = await fetchJsonWithRetry(url, retryMax);

                    if (!Array.isArray(page) || page.length === 0) break;

                    // 최신->과거 순으로 오는데, endTime을 썼을 때도 최신부터 반환되므로 그대로 합치면 중복 가능성 있음.
                    // 안전하게 "openTime" 기준으로 dedupe 하자.
                    for (const k of page) {
                        if (!Array.isArray(k)) continue;
                        const openTime = Number(k[0]);
                        if (!Number.isFinite(openTime)) continue;
                        all.push(k);
                    }

                    // 가장 오래된 openTime을 찾고, 그 이전으로 endTime 이동
                    let minOpen = Infinity;
                    for (const k of page) {
                        const openTime = Number(k[0]);
                        if (Number.isFinite(openTime) && openTime < minOpen) minOpen = openTime;
                    }

                    // 다음 페이지가 없을 조건:
                    // - page.length < limit (더 과거가 없을 가능성 큼)
                    // - minOpen이 Infinity면 종료
                    if (!Number.isFinite(minOpen) || page.length < limit) break;

                    endTime = minOpen - 1;

                    if (pageDelay > 0) await sleep(pageDelay);
                }

                // openTime 기준 정렬 + dedupe
                const map = new Map();
                for (const k of all) {
                    const t = Number(k[0]);
                    if (!Number.isFinite(t)) continue;
                    if (!map.has(t)) map.set(t, k);
                }
                const merged = Array.from(map.entries())
                    .sort((a, b) => a[0] - b[0])
                    .map((x) => x[1]);

                return merged;
            }

            /**
             * 판정:
             * - 캔들 최소 3개 이상 필요 (a[-2] 존재)
             * - a[-2] low가 전체 low 중 최저(ATL)인지
             * - 추가: 현재봉 low(a) vs a[-1] low 비교값 제공
             */
            function judgeAminus2IsATL(klines) {
                if (!Array.isArray(klines) || klines.length < 3) {
                    return { ok: false, reason: "1M 캔들 수 부족(<3)" };
                }

                const idxA = klines.length - 1; // current candle a
                const idxPrev = idxA - 1; // a[-1]
                const idxTarget = idxA - 2; // a[-2]

                const cur = klines[idxA];
                const prev = klines[idxPrev];
                const target = klines[idxTarget];

                const currentLow = Number(cur[3]);
                const prevLow = Number(prev[3]);
                const targetLow = Number(target[3]);

                if (!Number.isFinite(targetLow)) return { ok: false, reason: "a[-2] low 파싱 실패" };
                if (!Number.isFinite(currentLow)) return { ok: false, reason: "a low(현재) 파싱 실패" };
                if (!Number.isFinite(prevLow)) return { ok: false, reason: "a[-1] low 파싱 실패" };

                let atl = Infinity;
                let atlTime = null;

                for (const k of klines) {
                    const low = Number(k[3]);
                    const openTime = Number(k[0]);
                    if (!Number.isFinite(low)) continue;
                    if (low < atl) {
                        atl = low;
                        atlTime = Number.isFinite(openTime) ? openTime : null;
                    }
                }

                if (!Number.isFinite(atl)) return { ok: false, reason: "ATL 계산 실패" };

                // 부동소수점 비교: 바이낸스 low는 문자열 decimal이라 Number 변환 후 동일값이면 대개 안전
                const ok = targetLow === atl;

                return {
                    ok,
                    targetLow,
                    targetTime: Number(target[0]),
                    atlLow: atl,
                    atlTime,
                    candles: klines.length,
                    currentLow,
                    currentTime: Number(cur[0]),
                    prevLow,
                    prevTime: Number(prev[0]),
                    curBelowPrev: currentLow < prevLow,
                };
            }

            function updateStats() {
                el.statProgress.textContent = `${doneSymbols.toLocaleString()} / ${totalSymbols.toLocaleString()}`;
                el.statHits.textContent = hits.length.toLocaleString();
                el.statErr.textContent = errCount.toLocaleString();
                const pct = totalSymbols > 0 ? Math.min(100, (doneSymbols / totalSymbols) * 100) : 0;
                el.bar.style.width = `${pct.toFixed(2)}%`;
                el.btnExport.disabled = hits.length === 0;
            }

            function renderTable() {
                const tbodyHigh = el.tbodyHigh;
                const tbodyLow = el.tbodyLow;

                tbodyHigh.innerHTML = "";
                tbodyLow.innerHTML = "";

                const sorted = [...hits].sort((a, b) => a.targetLow - b.targetLow);

                const high = sorted.filter((r) => r.currentLow >= r.prevLow);
                const low = sorted.filter((r) => r.currentLow < r.prevLow);

                el.countHigh.textContent = String(high.length);
                el.countLow.textContent = String(low.length);

                function renderEmpty(tbody) {
                    const tr = document.createElement("tr");
                    const td = document.createElement("td");
                    td.colSpan = 11;
                    td.style.color = "var(--muted)";
                    td.textContent = "아직 결과 없음";
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                }

                function renderRows(tbody, arr) {
                    if (arr.length === 0) {
                        renderEmpty(tbody);
                        return;
                    }

                    let i = 1;
                    for (const r of arr) {
                        const tr = document.createElement("tr");

                        const compareText = r.currentLow < r.prevLow ? "a < a[-1]" : "a ≥ a[-1]";

                        const cells = [
                            String(i),
                            r.symbol,
                            num(r.targetLow),
                            toUtcDateStr(r.targetTime),
                            num(r.atlLow),
                            r.atlTime ? toUtcDateStr(r.atlTime) : "-",
                            String(r.candles),
                            num(r.currentLow),
                            num(r.prevLow),
                            compareText,
                            r.note || "",
                        ];

                        for (let c = 0; c < cells.length; c += 1) {
                            const td = document.createElement("td");
                            td.textContent = cells[c];
                            if (c === 1) td.classList.add("mono");
                            if (c === 9) td.classList.add(r.currentLow < r.prevLow ? "no" : "ok");
                            tr.appendChild(td);
                        }

                        tbody.appendChild(tr);
                        i += 1;
                    }
                }

                renderRows(tbodyHigh, high);
                renderRows(tbodyLow, low);
            }

            function exportCsv() {
                const sorted = [...hits].sort((a, b) => a.targetLow - b.targetLow);

                const header = [
                    "symbol",
                    "a_minus_2_low",
                    "a_minus_2_date_utc",
                    "atl_low",
                    "atl_date_utc",
                    "monthly_candles",
                    "a_current_low",
                    "a_minus_1_low",
                    "a_low_lt_a_minus_1_low",
                    "note",
                ];

                const rows = [header.join(",")];

                for (const r of sorted) {
                    const line = [
                        r.symbol,
                        String(r.targetLow),
                        toUtcDateStr(r.targetTime),
                        String(r.atlLow),
                        r.atlTime ? toUtcDateStr(r.atlTime) : "",
                        String(r.candles),
                        String(r.currentLow),
                        String(r.prevLow),
                        r.currentLow < r.prevLow ? "true" : "false",
                        (r.note || "").replaceAll('"', '""'),
                    ];
                    rows.push(line.map((x) => `"${x}"`).join(","));
                }

                const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `binance_usdtperp_1M_a-2_ATL_split_${new Date().toISOString().slice(0, 10)}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            }

            async function worker(symbolQueue) {
                while (symbolQueue.length > 0) {
                    if (abortFlag) break;

                    const symbol = symbolQueue.shift();
                    if (!symbol) break;

                    el.statLast.textContent = symbol;

                    try {
                        const klines = await fetchAllMonthlyKlines(symbol);
                        const judged = judgeAminus2IsATL(klines);

                        if (judged.ok) {
                            hits.push({
                                symbol,
                                ok: true,
                                targetLow: judged.targetLow,
                                targetTime: judged.targetTime,
                                atlLow: judged.atlLow,
                                atlTime: judged.atlTime,
                                candles: judged.candles,
                                currentLow: judged.currentLow,
                                prevLow: judged.prevLow,
                                note: judged.currentLow < judged.prevLow ? "a[-2] low = ATL / a low < a[-1] low" : "a[-2] low = ATL / a low ≥ a[-1] low",
                            });

                            if (judged.currentLow < judged.prevLow) {
                                logLine(`⚠️ HIT ${symbol} :: a[-2] low=ATL & 현재 low(${judged.currentLow}) < 전월 low(${judged.prevLow})`);
                            } else {
                                logLine(`✅ HIT ${symbol} :: a[-2] low=ATL & 현재 low(${judged.currentLow}) ≥ 전월 low(${judged.prevLow})`);
                            }

                            renderTable();
                        } else {
                            // 필요하면 NO 케이스 로그 추가 가능
                        }
                    } catch (e) {
                        errCount += 1;
                        logLine(`❌ ERROR ${symbol} :: ${String(e.message || e)}`);
                    } finally {
                        doneSymbols += 1;
                        updateStats();
                    }
                }
            }

            async function startScan() {
                isRunning = true;
                abortFlag = false;
                hits.length = 0;
                errCount = 0;
                doneSymbols = 0;
                totalSymbols = 0;

                el.btnStart.disabled = true;
                el.btnStop.disabled = false;
                setStatus("running");
                el.log.textContent = "";
                el.statLast.textContent = "-";
                updateStats();
                renderTable();

                try {
                    logLine("exchangeInfo 로딩...");
                    const symbols = await getUsdtPerpSymbols();

                    const maxSymbols = Math.max(0, Number(el.maxSymbols.value) || 0);
                    const finalSymbols = maxSymbols > 0 ? symbols.slice(0, maxSymbols) : symbols;

                    totalSymbols = finalSymbols.length;
                    updateStats();

                    logLine(`대상 심볼 수: ${totalSymbols.toLocaleString()}`);
                    logLine("스캔 시작... (1M 전체 페이지네이션)");

                    const q = [...finalSymbols];
                    const conc = Math.max(1, Math.min(10, Number(el.concurrency.value) || 3));

                    const workers = [];
                    for (let i = 0; i < conc; i += 1) {
                        workers.push(worker(q));
                    }

                    await Promise.allSettled(workers);

                    if (abortFlag) {
                        logLine("⛔ 사용자 중단됨");
                        setStatus("aborted");
                    } else {
                        logLine("✅ 스캔 완료");
                        setStatus("done");
                    }
                } catch (e) {
                    logLine(`치명 오류: ${String(e.message || e)}`);
                    setStatus("error");
                } finally {
                    isRunning = false;
                    el.btnStart.disabled = false;
                    el.btnStop.disabled = true;
                    updateStats();
                    renderTable();
                }
            }

            function stopScan() {
                if (!isRunning) return;
                abortFlag = true;
                setStatus("stopping...");
                logLine("중단 요청됨(진행 중 요청 완료 후 종료)");
                el.btnStop.disabled = true;
            }

            el.btnStart.addEventListener("click", () => {
                if (isRunning) return;
                startScan();
            });

            el.btnStop.addEventListener("click", () => {
                stopScan();
            });

            el.btnExport.addEventListener("click", () => {
                exportCsv();
            });

            // 초기 안내
            logLine("대기 중. [스캔 시작]을 누르면 USDT 무기한 전 종목을 1M 전체 히스토리로 스캔합니다.");
        </script>
    </body>
</html>
