<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT-PERP ATL(1m refined) + Trigger Scanner (09:00 KST)</title>
    <style>
        :root {
            --bg: #0b1020;
            --card: #121a33;
            --text: #e8ecff;
            --muted: rgba(232, 236, 255, 0.65);
            --line: rgba(232, 236, 255, 0.12);
            --good: #7CFFB2;
            --warn: #FFD37C;
            --bad: #FF7C7C;
            --btn: #2a3cff;
        }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
            background: radial-gradient(1200px 600px at 20% 10%, rgba(42, 60, 255, 0.18), transparent 60%),
                        radial-gradient(900px 500px at 80% 10%, rgba(124, 255, 178, 0.10), transparent 55%),
                        var(--bg);
            color: var(--text);
        }
        .wrap {
            max-width: 1280px;
            margin: 0 auto;
            padding: 18px;
        }
        h1 {
            margin: 10px 0 12px;
            font-size: 18px;
            font-weight: 800;
            letter-spacing: 0.2px;
        }
        .grid {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 14px;
        }
        .card {
            background: linear-gradient(180deg, rgba(18, 26, 51, 0.95), rgba(18, 26, 51, 0.78));
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 14px;
            box-shadow: 0 14px 45px rgba(0, 0, 0, 0.25);
        }
        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .row + .row {
            margin-top: 10px;
        }
        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px 10px;
            border-radius: 10px;
            border: 1px solid var(--line);
            background: rgba(0, 0, 0, 0.25);
            color: var(--text);
            outline: none;
        }
        input[type="checkbox"] {
            transform: translateY(1px);
        }
        .col {
            flex: 1 1 150px;
            min-width: 150px;
        }
        .btn {
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(232, 236, 255, 0.18);
            background: rgba(0, 0, 0, 0.12);
            color: var(--text);
            cursor: pointer;
            font-weight: 700;
        }
        .btn.primary {
            background: rgba(42, 60, 255, 0.75);
            border-color: rgba(42, 60, 255, 0.95);
        }
        .btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--line);
            font-size: 12px;
            color: var(--muted);
            background: rgba(0, 0, 0, 0.18);
        }
        .pill b {
            color: var(--text);
        }
        .log {
            margin-top: 10px;
            max-height: 190px;
            overflow: auto;
            border-radius: 12px;
            border: 1px solid var(--line);
            background: rgba(0, 0, 0, 0.22);
            padding: 10px;
            font-size: 12px;
            line-height: 1.45;
            color: rgba(232, 236, 255, 0.78);
            white-space: pre-wrap;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        thead th {
            position: sticky;
            top: 0;
            background: rgba(18, 26, 51, 0.95);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid var(--line);
            font-size: 12px;
            text-align: left;
            padding: 10px 8px;
            color: rgba(232, 236, 255, 0.85);
        }
        tbody td {
            border-bottom: 1px solid rgba(232, 236, 255, 0.08);
            padding: 10px 8px;
            font-size: 12px;
            vertical-align: top;
        }
        tbody tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }
        .good { color: var(--good); font-weight: 800; }
        .warn { color: var(--warn); font-weight: 800; }
        .bad { color: var(--bad); font-weight: 800; }
        .muted { color: var(--muted); }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .small {
            font-size: 11px;
            color: rgba(232, 236, 255, 0.70);
            line-height: 1.35;
        }
        @media (max-width: 980px) {
            .grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Binance USDT-PERP — ATL(1m 정밀) 근접 + 트리거 후보 스캐너 (매일 09:00 KST 자동 실행)</h1>

    <div class="grid">
        <div class="card">
            <div class="row">
                <span class="pill">상태: <b id="statusText">대기</b></span>
                <span class="pill">KST: <b id="kstNow">-</b></span>
                <span class="pill">다음 자동 스캔: <b id="nextRun">-</b></span>
            </div>

            <div class="row" style="margin-top: 12px;">
                <div class="col">
                    <label>ATL 근접 기준(%)</label>
                    <input id="distPct" type="number" value="5" min="0.1" step="0.1" />
                </div>
                <div class="col">
                    <label>최소 24h 거래대금(USDT)</label>
                    <input id="minQuoteVol" type="number" value="20000000" min="0" step="1000000" />
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label>근접 후보 중 트리거 검사 상위 N개</label>
                    <input id="topNForSignals" type="number" value="35" min="5" step="1" />
                </div>
                <div class="col">
                    <label>ATL 백필(하루에 처리할 심볼 수)</label>
                    <input id="backfillSymbolsPerRun" type="number" value="30" min="0" step="1" />
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label>동시 요청(concurrency)</label>
                    <input id="concurrency" type="number" value="4" min="1" step="1" />
                </div>
                <div class="col">
                    <label>요청 간 기본 딜레이(ms)</label>
                    <input id="baseDelay" type="number" value="120" min="0" step="10" />
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label class="row" style="gap: 8px; margin: 0;">
                        <input id="autoRun" type="checkbox" checked />
                        <span class="muted">매일 09:00(KST) 자동 스캔</span>
                    </label>
                </div>
                <div class="col">
                    <label class="row" style="gap: 8px; margin: 0;">
                        <input id="useMarkPrice" type="checkbox" />
                        <span class="muted">현재가 대신 Mark Price(느림)</span>
                    </label>
                </div>
            </div>

            <div class="row" style="margin-top: 12px;">
                <button class="btn primary" id="btnScan">지금 스캔</button>
                <button class="btn" id="btnBackfill">ATL 백필만 실행</button>
                <button class="btn" id="btnExport">CSV 내보내기</button>
                <button class="btn" id="btnClear">캐시 초기화</button>
            </div>

            <div class="row" style="margin-top: 12px;">
                <span class="pill">ATL 보유: <b id="atlDone">0</b></span>
                <span class="pill">전체 심볼: <b id="symTotal">0</b></span>
                <span class="pill">근접 후보: <b id="nearCount">0</b></span>
            </div>

            <div class="small" style="margin-top: 10px;">
                ⚠️ 이 도구는 “근접 + 트리거 후보”를 보여줄 뿐, 수익을 보장하지 않아.  
                ATL 근처 롱은 실패 시 손실이 빠르게 커질 수 있으니, 항상 손절 기준(무효화)을 먼저 정해.
            </div>

            <div class="log" id="logBox"></div>
        </div>

        <div class="card">
            <div class="row" style="justify-content: space-between;">
                <div class="pill">정렬: <b>ATL 근접(%) 오름차순</b></div>
                <div class="pill">신호: <b>Reclaim(1h) / BaseBreak(4h) / HLBreak(4h)</b></div>
            </div>

            <div style="margin-top: 10px; overflow:auto; max-height: 72vh; border-radius: 12px; border: 1px solid var(--line);">
                <table>
                    <thead>
                        <tr>
                            <th style="min-width:120px;">Symbol</th>
                            <th style="min-width:110px;">Price</th>
                            <th style="min-width:110px;">ATL(1m)</th>
                            <th style="min-width:90px;">Dist%</th>
                            <th style="min-width:130px;">24h QuoteVol</th>
                            <th style="min-width:130px;">Signal</th>
                            <th style="min-width:260px;">Entry / Stop / TP</th>
                            <th style="min-width:320px;">Reason</th>
                        </tr>
                    </thead>
                    <tbody id="tbody">
                        <tr><td colspan="8" class="muted">아직 결과가 없어. “지금 스캔”을 눌러줘.</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="small" style="margin-top: 10px;">
                ※ ATL은 (1) 1D로 “최저 저점 날짜”를 찾고 → (2) 그 날짜 하루를 1m(1440개)로 훑어서 “정밀 ATL”로 확정한다.  
                처음 며칠은 캐시가 쌓이면서 ATL 보유 심볼이 늘어나고, 결과 품질이 점점 좋아져.
            </div>
        </div>
    </div>
</div>

<script>
(function () {
    "use strict";

    const BINANCE_FAPI = "https://fapi.binance.com";
    const STORAGE_KEY = "ATL_SCANNER_STATE_V1";

    const $ = (id) => document.getElementById(id);

    const ui = {
        statusText: $("statusText"),
        kstNow: $("kstNow"),
        nextRun: $("nextRun"),
        distPct: $("distPct"),
        minQuoteVol: $("minQuoteVol"),
        topNForSignals: $("topNForSignals"),
        backfillSymbolsPerRun: $("backfillSymbolsPerRun"),
        concurrency: $("concurrency"),
        baseDelay: $("baseDelay"),
        autoRun: $("autoRun"),
        useMarkPrice: $("useMarkPrice"),
        btnScan: $("btnScan"),
        btnBackfill: $("btnBackfill"),
        btnExport: $("btnExport"),
        btnClear: $("btnClear"),
        logBox: $("logBox"),
        tbody: $("tbody"),
        atlDone: $("atlDone"),
        symTotal: $("symTotal"),
        nearCount: $("nearCount")
    };

    let running = false;
    let lastResults = [];

    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function toKstDate(d = new Date()) {
        return new Date(d.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
    }

    function fmtKst(d) {
        const x = toKstDate(d);
        const yy = x.getFullYear();
        const mm = String(x.getMonth() + 1).padStart(2, "0");
        const dd = String(x.getDate()).padStart(2, "0");
        const hh = String(x.getHours()).padStart(2, "0");
        const mi = String(x.getMinutes()).padStart(2, "0");
        const ss = String(x.getSeconds()).padStart(2, "0");
        return `${yy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
    }

    function log(line) {
        const msg = `[${fmtKst(new Date())}] ${line}\n`;
        ui.logBox.textContent = msg + ui.logBox.textContent;
    }

    function setStatus(s) {
        ui.statusText.textContent = s;
    }

    function loadState() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return { symbols: {}, meta: {} };
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") return { symbols: {}, meta: {} };
            parsed.symbols = parsed.symbols || {};
            parsed.meta = parsed.meta || {};
            return parsed;
        } catch (e) {
            return { symbols: {}, meta: {} };
        }
    }

    function saveState(state) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function clampNumber(x, fallback = 0) {
        const n = Number(x);
        return Number.isFinite(n) ? n : fallback;
    }

    async function fetchJsonWithRetry(url, opts = {}) {
        const {
            retries = 5,
            baseBackoffMs = 500
        } = opts;

        for (let i = 0; i <= retries; i++) {
            try {
                const res = await fetch(url, { method: "GET" });

                if (res.status === 418 || res.status === 429) {
                    const wait = baseBackoffMs * Math.pow(2, i);
                    log(`Rate limited (${res.status}). Backoff ${wait}ms: ${url}`);
                    await sleep(wait);
                    continue;
                }

                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 120)}`);
                }

                return await res.json();
            } catch (e) {
                if (i === retries) throw e;
                const wait = baseBackoffMs * Math.pow(2, i);
                log(`Fetch error. Retry ${i + 1}/${retries} in ${wait}ms: ${String(e.message || e)}`);
                await sleep(wait);
            }
        }

        throw new Error("unreachable");
    }

    class TaskQueue {
        constructor(concurrency, baseDelayMs) {
            this.concurrency = Math.max(1, concurrency);
            this.baseDelayMs = Math.max(0, baseDelayMs);
            this.running = 0;
            this.queue = [];
        }

        push(task) {
            return new Promise((resolve, reject) => {
                this.queue.push({ task, resolve, reject });
                this._run();
            });
        }

        async _run() {
            while (this.running < this.concurrency && this.queue.length > 0) {
                const item = this.queue.shift();
                this.running++;

                (async () => {
                    try {
                        if (this.baseDelayMs > 0) await sleep(this.baseDelayMs);
                        const out = await item.task();
                        item.resolve(out);
                    } catch (e) {
                        item.reject(e);
                    } finally {
                        this.running--;
                        this._run();
                    }
                })();
            }
        }

        async drain() {
            while (this.running > 0 || this.queue.length > 0) {
                await sleep(80);
            }
        }
    }

    function isClosedCandle(k) {
        const closeTime = clampNumber(k[6], 0);
        return Date.now() >= closeTime;
    }

    function toClosedCandles(klines) {
        if (!Array.isArray(klines)) return [];
        const closed = klines.filter(isClosedCandle);
        return closed;
    }

    function candleParts(k) {
        const open = clampNumber(k[1], 0);
        const high = clampNumber(k[2], 0);
        const low = clampNumber(k[3], 0);
        const close = clampNumber(k[4], 0);

        const body = Math.abs(close - open);
        const range = Math.max(0, high - low);
        const upperWick = Math.max(0, high - Math.max(open, close));
        const lowerWick = Math.max(0, Math.min(open, close) - low);

        return { open, high, low, close, body, range, upperWick, lowerWick };
    }

    function avg(arr) {
        if (!arr || arr.length === 0) return 0;
        let s = 0;
        for (const x of arr) s += x;
        return s / arr.length;
    }

    function pct(a, b) {
        if (b === 0) return 0;
        return (a / b) * 100;
    }

    function formatNum(n, maxFrac = 8) {
        const x = Number(n);
        if (!Number.isFinite(x)) return "-";
        const abs = Math.abs(x);
        const frac = abs >= 1000 ? 2 : abs >= 1 ? 6 : 8;
        const f = Math.min(maxFrac, frac);
        return x.toLocaleString("en-US", { maximumFractionDigits: f });
    }

    function formatUSDT(n) {
        const x = Number(n);
        if (!Number.isFinite(x)) return "-";
        if (x >= 1e9) return `${(x / 1e9).toFixed(2)}B`;
        if (x >= 1e6) return `${(x / 1e6).toFixed(2)}M`;
        if (x >= 1e3) return `${(x / 1e3).toFixed(2)}K`;
        return x.toFixed(0);
    }

    function computeRTargets(entry, stop) {
        const e = Number(entry);
        const s = Number(stop);
        if (!Number.isFinite(e) || !Number.isFinite(s) || e <= 0 || s <= 0 || e === s) return null;
        const r = Math.abs(e - s);
        return {
            tp1: e + r * 1.0,
            tp2: e + r * 2.0,
            tp3: e + r * 3.0
        };
    }

    function signalReclaim1h(atl, kl1h) {
        const closed = toClosedCandles(kl1h);
        if (closed.length < 30) return null;

        const last = closed[closed.length - 1];
        const p = candleParts(last);

        const volumes = closed.slice(-21, -1).map((k) => clampNumber(k[5], 0));
        const volAvg = avg(volumes);
        const lastVol = clampNumber(last[5], 0);

        const touchPct = 0.30;          // ATL 위 0.30% 이내 터치
        const reclaimClosePct = 0.60;   // ATL 위 0.60% 이상에서 종가 마감
        const wickRatio = 1.8;          // 아래꼬리/몸통 비율
        const volMult = 1.3;            // 평균 대비 거래량

        const touchOk = p.low <= atl * (1 + touchPct / 100);
        const reclaimOk = p.close >= atl * (1 + reclaimClosePct / 100);
        const wickOk = p.body > 0 ? (p.lowerWick / p.body) >= wickRatio : p.lowerWick > 0;
        const volOk = volAvg > 0 ? lastVol >= volAvg * volMult : true;

        if (touchOk && reclaimOk && wickOk && volOk) {
            const entry = p.close;
            const stop = Math.max(0, p.low * 0.999); // 아주 작은 버퍼
            const tps = computeRTargets(entry, stop);

            return {
                name: "Reclaim(1h)",
                entry,
                stop,
                tps,
                reason: `ATL 근처 스윕 후(저가 터치) 종가 reclaim + 아래꼬리 강함 + 거래량 증가`
            };
        }

        return null;
    }

    function signalBaseBreak4h(kl4h) {
        const closed = toClosedCandles(kl4h);
        if (closed.length < 40) return null;

        const baseN = 12;
        const base = closed.slice(-baseN);
        const highs = base.map((k) => clampNumber(k[2], 0));
        const lows = base.map((k) => clampNumber(k[3], 0));
        const baseHigh = Math.max(...highs);
        const baseLow = Math.min(...lows);
        const mid = (baseHigh + baseLow) / 2;

        const rangePct = mid > 0 ? pct(baseHigh - baseLow, mid) : 999;
        const maxRangePct = 6.0; // 12개 4h 캔들 기준 박스 폭 6% 이내

        const last = closed[closed.length - 1];
        const p = candleParts(last);

        const prevHigh = Math.max(...closed.slice(-(baseN + 1), -1).map((k) => clampNumber(k[2], 0)));
        const breakoutOk = p.close > prevHigh;

        const volumes = closed.slice(-21, -1).map((k) => clampNumber(k[5], 0));
        const volAvg = avg(volumes);
        const lastVol = clampNumber(last[5], 0);
        const volOk = volAvg > 0 ? lastVol >= volAvg * 1.2 : true;

        if (rangePct <= maxRangePct && breakoutOk && volOk) {
            const entry = p.close;
            const stop = Math.max(0, baseLow * 0.998);
            const height = baseHigh - baseLow;
            const tp1 = entry + height * 0.8;
            const tp2 = entry + height * 1.6;

            return {
                name: "BaseBreak(4h)",
                entry,
                stop,
                tps: { tp1, tp2 },
                reason: `4h 박스(최근 ${baseN}개) 폭 ${rangePct.toFixed(2)}%로 축소 후 상단 돌파 + 거래량`
            };
        }

        return null;
    }

    function signalHLBreak4h(kl4h) {
        const closed = toClosedCandles(kl4h);
        if (closed.length < 80) return null;

        const lookback = 70;
        const arr = closed.slice(-lookback);

        const lows = arr.map((k) => clampNumber(k[3], 0));
        const highs = arr.map((k) => clampNumber(k[2], 0));

        const swingLows = [];
        for (let i = 2; i < arr.length - 2; i++) {
            const l = lows[i];
            if (l <= lows[i - 1] && l <= lows[i - 2] && l <= lows[i + 1] && l <= lows[i + 2]) {
                swingLows.push({ i, low: l, t: clampNumber(arr[i][0], 0) });
            }
        }

        if (swingLows.length < 2) return null;

        const a = swingLows[swingLows.length - 2];
        const b = swingLows[swingLows.length - 1];

        const hlMinPct = 1.0; // 두 번째 저점이 첫 저점보다 1% 이상 높아야 "의미있는 HL"
        if (b.low <= a.low * (1 + hlMinPct / 100)) return null;

        const start = b.i;
        const betweenHigh = Math.max(...highs.slice(start, highs.length - 1));
        const last = arr[arr.length - 1];
        const p = candleParts(last);

        if (p.close <= betweenHigh) return null;

        const entry = p.close;
        const stop = Math.max(0, b.low * 0.998);
        const tps = computeRTargets(entry, stop);

        return {
            name: "HLBreak(4h)",
            entry,
            stop,
            tps,
            reason: `4h Higher Low 형성 후, 구조 고점(${formatNum(betweenHigh)}) 종가 돌파`
        };
    }

    async function getExchangeInfo() {
        const url = `${BINANCE_FAPI}/fapi/v1/exchangeInfo`;
        return await fetchJsonWithRetry(url);
    }

    async function getTicker24hrAll() {
        const url = `${BINANCE_FAPI}/fapi/v1/ticker/24hr`;
        return await fetchJsonWithRetry(url);
    }

    async function getMarkPricesAll() {
        const url = `${BINANCE_FAPI}/fapi/v1/premiumIndex`;
        return await fetchJsonWithRetry(url);
    }

    async function getKlines(symbol, interval, opts = {}) {
        const { limit = 200, startTime, endTime } = opts;
        const params = new URLSearchParams();
        params.set("symbol", symbol);
        params.set("interval", interval);
        params.set("limit", String(Math.min(1500, Math.max(1, limit))));
        if (startTime != null) params.set("startTime", String(startTime));
        if (endTime != null) params.set("endTime", String(endTime));

        const url = `${BINANCE_FAPI}/fapi/v1/klines?${params.toString()}`;
        return await fetchJsonWithRetry(url);
    }

    async function updateDailyAtlCandidate(state, symbol, record) {
        if (record.dailyBackfillDone) return;

        const now = Date.now();
        const endTime = record.dailyBackfillEndTime != null ? record.dailyBackfillEndTime : now;

        const kl = await getKlines(symbol, "1d", { limit: 1500, endTime });

        if (!Array.isArray(kl) || kl.length === 0) {
            record.dailyBackfillDone = true;
            return;
        }

        for (const k of kl) {
            const low = clampNumber(k[3], 0);
            const openTime = clampNumber(k[0], 0);

            if (!record.dailyMinLow || low < record.dailyMinLow) {
                record.dailyMinLow = low;
                record.dailyMinOpenTime = openTime;
            }
        }

        if (kl.length < 1500) {
            record.dailyBackfillDone = true;
        } else {
            const firstOpen = clampNumber(kl[0][0], 0);
            record.dailyBackfillEndTime = firstOpen - 1;
        }

        record.updatedAt = now;
        state.symbols[symbol] = record;
    }

    async function refineAtlFrom1m(state, symbol, record) {
        if (!record.dailyBackfillDone) return;
        if (!record.dailyMinOpenTime) return;
        if (record.atlRefined && record.atlSourceDayOpenTime === record.dailyMinOpenTime) return;

        const dayStart = record.dailyMinOpenTime;
        const dayEnd = dayStart + 24 * 60 * 60 * 1000 - 1;

        const kl = await getKlines(symbol, "1m", { limit: 1500, startTime: dayStart, endTime: dayEnd });

        if (!Array.isArray(kl) || kl.length === 0) return;

        let minLow = Number.POSITIVE_INFINITY;
        let minOpenTime = null;

        for (const k of kl) {
            const low = clampNumber(k[3], 0);
            const openTime = clampNumber(k[0], 0);
            if (low > 0 && low < minLow) {
                minLow = low;
                minOpenTime = openTime;
            }
        }

        if (Number.isFinite(minLow) && minOpenTime != null) {
            record.atl = minLow;
            record.atlTime = minOpenTime;
            record.atlRefined = true;
            record.atlSourceDayOpenTime = record.dailyMinOpenTime;
            record.updatedAt = Date.now();
            state.symbols[symbol] = record;
        }
    }

    function ensureRecord(state, symbol) {
        const r = state.symbols[symbol] || {};
        if (!r.createdAt) r.createdAt = Date.now();
        return r;
    }

    function buildRow(r) {
        const tr = document.createElement("tr");

        const signalColor = r.signal && r.signal.startsWith("Reclaim") ? "good"
            : r.signal && r.signal.startsWith("BaseBreak") ? "warn"
            : r.signal && r.signal.startsWith("HLBreak") ? "warn"
            : "muted";

        const tps = r.plan && r.plan.tps ? r.plan.tps : null;
        const tpText = tps
            ? Object.keys(tps).map((k) => `${k.toUpperCase()}:${formatNum(tps[k])}`).join("  ")
            : "-";

        tr.innerHTML = `
            <td class="mono"><b>${r.symbol}</b></td>
            <td class="mono">${formatNum(r.price)}</td>
            <td class="mono">${formatNum(r.atl)}</td>
            <td class="mono ${r.distPct <= 2 ? "good" : r.distPct <= 5 ? "warn" : "muted"}">${r.distPct.toFixed(2)}%</td>
            <td class="mono">${formatUSDT(r.quoteVol)}</td>
            <td class="${signalColor}">${r.signal || "-"}</td>
            <td class="mono">
                ${r.plan ? `E:${formatNum(r.plan.entry)}  S:${formatNum(r.plan.stop)}<br><span class="muted">${tpText}</span>` : "-"}
            </td>
            <td class="small">${r.reason || "-"}</td>
        `;
        return tr;
    }

    function renderResults(results) {
        ui.tbody.innerHTML = "";
        if (!results || results.length === 0) {
            ui.tbody.innerHTML = `<tr><td colspan="8" class="muted">조건에 맞는 후보가 없어.</td></tr>`;
            return;
        }

        const frag = document.createDocumentFragment();
        for (const r of results) frag.appendChild(buildRow(r));
        ui.tbody.appendChild(frag);
    }

    function exportCSV(results) {
        if (!results || results.length === 0) return;

        const headers = [
            "symbol", "price", "atl_1m", "dist_pct", "quote_vol_24h",
            "signal", "entry", "stop", "tp1", "tp2", "tp3", "reason"
        ];

        const lines = [];
        lines.push(headers.join(","));

        for (const r of results) {
            const tps = (r.plan && r.plan.tps) ? r.plan.tps : {};
            const row = [
                r.symbol,
                r.price,
                r.atl,
                r.distPct,
                r.quoteVol,
                (r.signal || ""),
                (r.plan ? r.plan.entry : ""),
                (r.plan ? r.plan.stop : ""),
                (tps.tp1 || ""),
                (tps.tp2 || ""),
                (tps.tp3 || ""),
                `"${String(r.reason || "").replaceAll('"', '""')}"`
            ];
            lines.push(row.join(","));
        }

        const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;

        const ts = fmtKst(new Date()).replaceAll(":", "").replaceAll("-", "").replaceAll(" ", "_");
        a.download = `ATL_scanner_${ts}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function computeNext09KST() {
        const nowKST = toKstDate(new Date());
        const next = new Date(nowKST);
        next.setHours(9, 0, 0, 0);
        if (next.getTime() <= nowKST.getTime()) {
            next.setDate(next.getDate() + 1);
        }
        return next;
    }

    let nextTimer = null;
    let tickTimer = null;

    function scheduleNextRun() {
        if (nextTimer) clearTimeout(nextTimer);
        const enabled = ui.autoRun.checked;

        const now = new Date();
        ui.kstNow.textContent = fmtKst(now);

        if (!enabled) {
            ui.nextRun.textContent = "-";
            return;
        }

        const next = computeNext09KST();
        ui.nextRun.textContent = fmtKst(next);

        const nowKST = toKstDate(now);
        const delay = Math.max(0, next.getTime() - nowKST.getTime());

        nextTimer = setTimeout(async () => {
            await runScan({ mode: "scan" });
            scheduleNextRun();
        }, delay);
    }

    function startClock() {
        if (tickTimer) clearInterval(tickTimer);
        tickTimer = setInterval(() => {
            ui.kstNow.textContent = fmtKst(new Date());
        }, 1000);
    }

    async function runScan({ mode }) {
        if (running) return;
        running = true;

        ui.btnScan.disabled = true;
        ui.btnBackfill.disabled = true;

        try {
            setStatus(mode === "backfill" ? "ATL 백필 중" : "스캔 중");
            log(`시작: mode=${mode}`);

            const state = loadState();

            const distMax = clampNumber(ui.distPct.value, 5);
            const minQuoteVol = clampNumber(ui.minQuoteVol.value, 0);
            const topNForSignals = Math.max(5, clampNumber(ui.topNForSignals.value, 35));
            const backfillSymbolsPerRun = Math.max(0, clampNumber(ui.backfillSymbolsPerRun.value, 30));
            const concurrency = Math.max(1, clampNumber(ui.concurrency.value, 4));
            const baseDelay = Math.max(0, clampNumber(ui.baseDelay.value, 120));
            const useMarkPrice = ui.useMarkPrice.checked;

            const q = new TaskQueue(concurrency, baseDelay);

            const ex = await getExchangeInfo();
            const symbols = (ex && ex.symbols) ? ex.symbols : [];

            const tradable = symbols
                .filter((s) => s && s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
                .map((s) => s.symbol);

            ui.symTotal.textContent = String(tradable.length);

            const tickers24 = await getTicker24hrAll();
            const tmap = new Map();
            for (const t of tickers24) {
                if (!t || !t.symbol) continue;
                tmap.set(t.symbol, t);
            }

            let markMap = null;
            if (useMarkPrice) {
                const marks = await getMarkPricesAll();
                markMap = new Map();
                for (const m of marks) {
                    if (!m || !m.symbol) continue;
                    markMap.set(m.symbol, m);
                }
            }

            const rows = [];
            for (const sym of tradable) {
                const t = tmap.get(sym);
                if (!t) continue;

                const lastPrice = useMarkPrice
                    ? clampNumber((markMap && markMap.get(sym) ? markMap.get(sym).markPrice : t.lastPrice), 0)
                    : clampNumber(t.lastPrice, 0);

                const quoteVol = clampNumber(t.quoteVolume, 0);

                rows.push({
                    symbol: sym,
                    price: lastPrice,
                    quoteVol
                });
            }

            rows.sort((a, b) => b.quoteVol - a.quoteVol);

            const totalWithAtl = rows.reduce((acc, r) => {
                const rec = state.symbols[r.symbol];
                if (rec && rec.atlRefined && rec.atl > 0) return acc + 1;
                return acc;
            }, 0);

            ui.atlDone.textContent = String(totalWithAtl);

            // 1) ATL 백필 (우선 거래대금 큰 것부터, 하루 처리량 제한)
            if (backfillSymbolsPerRun > 0) {
                const need = rows
                    .filter((r) => {
                        const rec = state.symbols[r.symbol];
                        return !(rec && rec.atlRefined && rec.atl > 0);
                    })
                    .slice(0, backfillSymbolsPerRun);

                if (need.length > 0) log(`ATL 백필 대상: ${need.length}개 심볼`);

                for (const r of need) {
                    const sym = r.symbol;

                    q.push(async () => {
                        const rec = ensureRecord(state, sym);

                        // 1D로 최저 날짜 후보를 찾는다 (chunk 단위 누적)
                        await updateDailyAtlCandidate(state, sym, rec);

                        // dailyBackfillDone이면, 그 날짜 하루를 1m로 훑어 정밀 ATL 확정
                        await refineAtlFrom1m(state, sym, rec);

                        return true;
                    }).catch((e) => {
                        log(`ATL 백필 실패 ${sym}: ${String(e.message || e).slice(0, 160)}`);
                    });
                }

                await q.drain();
                saveState(state);
            }

            // 2) ATL 근접 후보 추출
            const candidates = [];
            for (const r of rows) {
                if (r.quoteVol < minQuoteVol) continue;

                const rec = state.symbols[r.symbol];
                if (!rec || !rec.atlRefined || !rec.atl || rec.atl <= 0) continue;

                const distPct = pct(r.price - rec.atl, rec.atl);
                if (distPct <= distMax) {
                    candidates.push({
                        symbol: r.symbol,
                        price: r.price,
                        quoteVol: r.quoteVol,
                        atl: rec.atl,
                        distPct,
                        atlTime: rec.atlTime
                    });
                }
            }

            candidates.sort((a, b) => a.distPct - b.distPct);

            ui.nearCount.textContent = String(candidates.length);

            if (mode === "backfill") {
                setStatus("ATL 백필 완료");
                log("완료: ATL 백필만 실행");
                return;
            }

            // 3) 후보 상위 N개만 시그널(1h/4h) 검사
            const checkList = candidates.slice(0, topNForSignals);
            log(`트리거 검사: ${checkList.length}개 심볼`);

            const out = [];
            const q2 = new TaskQueue(concurrency, baseDelay);

            for (const c of checkList) {
                q2.push(async () => {
                    const [kl1h, kl4h] = await Promise.all([
                        getKlines(c.symbol, "1h", { limit: 220 }),
                        getKlines(c.symbol, "4h", { limit: 220 })
                    ]);

                    const s1 = signalReclaim1h(c.atl, kl1h);
                    const s2 = signalBaseBreak4h(kl4h);
                    const s3 = signalHLBreak4h(kl4h);

                    // 우선순위: Reclaim(공격적 단기) > BaseBreak(균형) > HLBreak(보수)
                    const best = s1 || s2 || s3;

                    out.push({
                        symbol: c.symbol,
                        price: c.price,
                        atl: c.atl,
                        distPct: c.distPct,
                        quoteVol: c.quoteVol,
                        signal: best ? best.name : "-",
                        plan: best ? { entry: best.entry, stop: best.stop, tps: best.tps } : null,
                        reason: best ? best.reason : "ATL 근접이지만 트리거(확인 신호)가 아직 부족"
                    });
                }).catch((e) => {
                    log(`시그널 실패 ${c.symbol}: ${String(e.message || e).slice(0, 160)}`);
                });
            }

            await q2.drain();

            // 트리거 있는 애들을 위로, 그 다음 근접도 정렬
            out.sort((a, b) => {
                const aHas = a.signal !== "-" ? 0 : 1;
                const bHas = b.signal !== "-" ? 0 : 1;
                if (aHas !== bHas) return aHas - bHas;
                return a.distPct - b.distPct;
            });

            lastResults = out;
            renderResults(out);

            const atlDoneNow = rows.reduce((acc, r) => {
                const rec = state.symbols[r.symbol];
                if (rec && rec.atlRefined && rec.atl > 0) return acc + 1;
                return acc;
            }, 0);

            ui.atlDone.textContent = String(atlDoneNow);

            setStatus("완료");
            log("완료: 스캔 끝");
        } catch (e) {
            setStatus("오류");
            log(`오류: ${String(e.message || e)}`);
        } finally {
            running = false;
            ui.btnScan.disabled = false;
            ui.btnBackfill.disabled = false;
        }
    }

    // UI events
    ui.btnScan.addEventListener("click", () => runScan({ mode: "scan" }));
    ui.btnBackfill.addEventListener("click", () => runScan({ mode: "backfill" }));

    ui.btnExport.addEventListener("click", () => {
        exportCSV(lastResults);
    });

    ui.btnClear.addEventListener("click", () => {
        localStorage.removeItem(STORAGE_KEY);
        ui.atlDone.textContent = "0";
        ui.nearCount.textContent = "0";
        ui.tbody.innerHTML = `<tr><td colspan="8" class="muted">캐시를 초기화했어. 다시 “지금 스캔”을 실행해줘.</td></tr>`;
        log("캐시 초기화 완료");
    });

    ui.autoRun.addEventListener("change", () => scheduleNextRun());

    // init
    startClock();
    scheduleNextRun();
    log("준비 완료. (처음 며칠은 ATL 캐시가 쌓이면서 더 정확해져)");
})();
</script>
</body>
</html>
