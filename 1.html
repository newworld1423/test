<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance 선물 1일봉 해머 스캐너</title>
    <style>
        :root { --bg:#0b1220; --fg:#eaeef7; --muted:#93a1b1; --accent:#4da3ff; --line:#1e293b; }
        * { box-sizing: border-box; }
        body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif; background:var(--bg); color:var(--fg); }
        header { position:sticky; top:0; background:#0b1220cc; backdrop-filter: blur(6px); border-bottom:1px solid #223; padding:12px 16px; z-index:10; }
        .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
        input, button, label { font-size:14px; }
        input, button { padding:10px 12px; border-radius:12px; border:1px solid #334; background:#111827; color:var(--fg); }
        button { background:var(--accent); color:#081018; border:0; font-weight:600; cursor:pointer; }
        button:disabled { opacity:0.6; cursor:not-allowed; }
        .wrap { padding:16px; }
        .hint { color:var(--muted); font-size:12px; }
        table { width:100%; border-collapse:collapse; table-layout: auto; }
        th, td { padding:10px 8px; border-bottom:1px solid var(--line); font-size:14px; vertical-align:middle; }
        th { position:sticky; top:110px; background:#0b1220; text-align:left; z-index:5; white-space:nowrap; }
        .ok { color:#5cf1a6; }
        .err { color:#ff6b6b; }
        .right { text-align:right; }
        .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
        #metaSummary { margin-top:6px; font-size:12px; color:#cbe4ff; }
        .sortable { cursor:pointer; user-select:none; }
        .sort-ind { margin-left:6px; opacity:0.7; }
        .sort-active .sort-ind { opacity:1; }
        .empty { color:#9fb1c6; text-align:center; padding:24px 8px; }
    </style>
</head>
<body>
<header>
    <div class="row">
        <label><input type="checkbox" id="backtest" /> 과거 백테스팅</label>
        <input type="date" id="dateInput" disabled />
        <input type="text" id="symbolFilter" placeholder="심볼 필터 (예: BTC, SOL)" />
        <button id="scanBtn">스캔</button>
        <span id="status" class="hint"></span>
    </div>
    <div class="hint" style="margin-top:6px">
        * 표시는 모두 <b>KST(UTC+9)</b> 기준 · (참고) 바이낸스 1일봉 경계는 <b>UTC 00:00</b><br/>
        * 해머: <span class="mono">아래꼬리 ≥ 2 × 몸통</span> · <span class="mono">윗꼬리 &lt; 몸통</span> · <b>2봉전은 음봉</b><br/>
        * 시가/종가/고가는 체크일(UTC) 1일봉 · 고가 시각은 체크일 <b>15분봉</b>으로 탐색
    </div>
    <div id="metaSummary"></div>
</header>

<div class="wrap">
    <table id="resultTable">
        <thead>
            <tr>
                <th class="sortable" data-key="sym">심볼<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="checkDate">체크일(KST)<span class="sort-ind">⇵</span></th>
                <th>직전봉(해머)</th>
                <th class="sortable right" data-key="ratio">하단/몸통<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="open">체크일 시가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="close">체크일 종가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="high">체크일 고가<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="highTime">고가 시각(KST)<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="pct">시가→종가 %<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="highPct">시가→고가 %<span class="sort-ind">⇵</span></th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<script>
    // ---------- 유틸 ----------
    const KST_OFFSET_MS = 9 * 60 * 60 * 1000; // UTC+9
    function toKSTDateStr(msUTC) {
        const d = new Date(msUTC + KST_OFFSET_MS);
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, "0");
        const day = String(d.getUTCDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
    }
    function toKSTHHMM(msUTC) {
        const d = new Date(msUTC + KST_OFFSET_MS);
        const hh = String(d.getUTCHours()).padStart(2, "0");
        const mm = String(d.getUTCMinutes()).padStart(2, "0");
        return `${hh}:${mm}`;
    }
    function dateToUTCStartMs(localDateStr) {
        const [y, m, d] = localDateStr.split("-").map(Number);
        return Date.UTC(y, m - 1, d, 0, 0, 0, 0);
    }
    function pct(curr, base) { return base === 0 ? 0 : ((curr - base) / base) * 100; }
    function fmt(n, digits = 2) { return Number.isFinite(n) ? n.toFixed(digits) : "-"; }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function debounce(fn, wait = 200) { let t; return (...a) => { clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }

    // ---------- Binance API ----------
    const API_INFO = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const API_K = "https://fapi.binance.com/fapi/v1/klines";

    async function getUsdtPerpSymbols() {
        const res = await fetch(API_INFO);
        if (!res.ok) throw new Error("exchangeInfo 오류");
        const data = await res.json();
        return data.symbols
            .filter(s => s.status === "TRADING" && s.quoteAsset === "USDT" && s.contractType === "PERPETUAL")
            .map(s => s.symbol);
    }

    async function getDailyHistory(symbol, targetDateUTCStartMs, limit = 120) {
        const url = `${API_K}?symbol=${symbol}&interval=1d&endTime=${targetDateUTCStartMs}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`klines 오류: ${symbol}`);
        const arr = await res.json();
        return arr.map(k => ({
            openTime: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
            closeTime: k[6],
            quoteVolume: parseFloat(k[7]),
            numberOfTrades: parseInt(k[8], 10)
        }));
    }

    // 해머: 아래꼬리 ≥ 2 × 몸통  AND  윗꼬리 < 몸통  AND  (2봉전은 음봉)
    function isHammer(c, prev2) {
        const o = c.open, h = c.high, l = c.low, cl = c.close;
        const body  = Math.abs(cl - o);
        if (body <= 0) return false;

        const lower = Math.min(o, cl) - l;   // 밑꼬리
        const upper = h - Math.max(o, cl);   // 윗꼬리
        const prev2Bear = prev2 && (prev2.close < prev2.open);

        return lower >= 2 * body && upper < body && prev2Bear === true;
    }

    // ---------- 스캔 ----------
    async function scan({ targetDateUTCStartMs, symbols, concurrency = 9, signal }) {
        const results = [];
        let prevSumPct = 0, prevCount = 0;
        let done = 0;

        async function worker(sym) {
            if (signal?.aborted) return;
            try {
                const hist = await getDailyHistory(sym, targetDateUTCStartMs, 120);
                if (hist.length < 2) return;

                const idxPrev = hist.length - 1;       // 직전봉(체크일 전날, UTC 기준)
                const prev = hist[idxPrev];
                const prev2 = hist[idxPrev - 1];

                // 전체 직전봉 등락률 집계(백테스트 요약용)
                const prevChg = pct(prev.close, prev.open);
                if (Number.isFinite(prevChg)) { prevSumPct += prevChg; prevCount++; }

                // 해머 조건 + 2봉전 음봉 조건
                if (!isHammer(prev, prev2)) return;

                const body = Math.abs(prev.close - prev.open);
                const lower = Math.min(prev.open, prev.close) - prev.low;
                const ratio = lower / body;

                const checkDateMs = targetDateUTCStartMs;     // 내부 정렬 기준(UTC ms)
                const prevDateMs  = prev.openTime;

                // 체크일 시/고/종
                let openT = NaN, highT = NaN, closeT = NaN, changePct = NaN, highPct = NaN;
                try {
                    const url = `${API_K}?symbol=${sym}&interval=1d&startTime=${targetDateUTCStartMs}&limit=1`;
                    const r2 = await fetch(url);
                    if (r2.ok) {
                        const a2 = await r2.json();
                        if (a2.length) {
                            openT  = parseFloat(a2[0][1]);
                            highT  = parseFloat(a2[0][2]);
                            closeT = parseFloat(a2[0][4]);
                            changePct = pct(closeT, openT);
                            highPct   = pct(highT, openT);
                        }
                    }
                } catch (e2) {
                    console.warn(`[${sym}] check-day fetch warn:`, e2?.message || e2);
                }

                // 체크일 고가 시각(KST 표기용, 내부 ms는 UTC) — 15분봉
                let highTimeMs = null;
                try {
                    const dayMs = 24 * 60 * 60 * 1000;
                    const start = targetDateUTCStartMs;
                    const end   = targetDateUTCStartMs + dayMs;
                    const urlI  = `${API_K}?symbol=${sym}&interval=15m&startTime=${start}&endTime=${end}&limit=1000`;
                    const r3 = await fetch(urlI);
                    if (r3.ok) {
                        const arr = await r3.json();
                        if (arr.length) {
                            let maxH = -Infinity;
                            for (let i = 0; i < arr.length; i++) {
                                const hi = parseFloat(arr[i][2]);
                                if (hi > maxH) maxH = hi;
                            }
                            const firstIdx = arr.findIndex(k => parseFloat(k[2]) === maxH);
                            if (firstIdx >= 0) highTimeMs = arr[firstIdx][0];
                        }
                    }
                } catch (e3) {
                    console.warn(`[${sym}] intraday high-time warn:`, e3?.message || e3);
                }

                results.push({
                    symbol: sym,
                    checkDateMs,
                    prevDateMs,
                    open: openT,
                    high: highT,
                    close: closeT,
                    changePct,
                    highPct,
                    ratio,
                    highTimeMs
                });
            } catch (e) {
                console.warn(`[${sym}] scan error:`, e?.message || e);
            } finally {
                done++;
                document.getElementById("status").textContent = `진행: ${done}/${symbols.length}`;
            }
        }

        const queue = [...symbols];
        const runners = Array.from({ length: concurrency }).map(async () => {
            while (queue.length) {
                const sym = queue.shift();
                await worker(sym);
                await sleep(60);
            }
        });
        await Promise.all(runners);

        const meta = {
            avgPrevAll: prevCount ? (prevSumPct / prevCount) : NaN,
            nPrevAll: prevCount
        };
        return { results, meta };
    }

    // ---------- UI 상태 ----------
    const backtestEl = document.getElementById("backtest");
    const dateEl = document.getElementById("dateInput");
    const scanBtn = document.getElementById("scanBtn");
    const filterEl = document.getElementById("symbolFilter");
    const tbody = document.querySelector("#resultTable tbody");
    const metaSummaryEl = document.getElementById("metaSummary");
    const ths = Array.from(document.querySelectorAll("#resultTable thead th.sortable"));

    let lastScan = [];
    let lastMeta = null;
    let lastTotalSymbols = 0;
    let aborter = null;

    let sortKey = "pct";
    let sortDir = "desc";

    backtestEl.addEventListener("change", () => {
        dateEl.disabled = !backtestEl.checked;
        updateMetaSummary();
    });
    filterEl.addEventListener("input", debounce(updateView, 150));

    ths.forEach(th => {
        th.addEventListener("click", () => {
            const key = th.getAttribute("data-key");
            if (sortKey === key) {
                sortDir = (sortDir === "asc" ? "desc" : "asc");
            } else {
                sortKey = key;
                sortDir = (key === "sym" || key === "checkDate") ? "asc" : "desc";
            }
            updateView();
        });
    });

    scanBtn.addEventListener("click", startScan);

    function getTargetUTCStartMs() {
        if (backtestEl.checked && dateEl.value) {
            return dateToUTCStartMs(dateEl.value);
        } else {
            const now = new Date();
            return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
        }
    }

    function renderRows(rows) {
        tbody.innerHTML = "";
        if (!rows.length) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td class="empty" colspan="10">조건에 맞는 결과가 없습니다.</td>`;
            tbody.appendChild(tr);
            return;
        }

        for (const r of rows) {
            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${r.symbol}</td>
                <td class="mono">${toKSTDateStr(r.checkDateMs)}</td>
                <td><span class="ok">해머</span> <span class="hint mono">(${toKSTDateStr(r.prevDateMs)})</span></td>
                <td class="right mono">${Number.isFinite(r.ratio) ? r.ratio.toFixed(2) : "-"}</td>
                <td class="right mono">${fmt(r.open, 4)}</td>
                <td class="right mono">${fmt(r.close, 4)}</td>
                <td class="right mono">${fmt(r.high, 4)}</td>
                <td class="mono">${r.highTimeMs ? toKSTHHMM(r.highTimeMs) : "-"}</td>
                <td class="right mono">${fmt(r.changePct, 2)}%</td>
                <td class="right mono">${fmt(r.highPct, 2)}%</td>
            `;
            tbody.appendChild(tr);
        }
    }

    function compare(a, b, key) {
        const get = (o) => {
            switch (key) {
                case "sym": return o.symbol;
                case "checkDate": return o.checkDateMs;     // ms 정렬
                case "ratio": return o.ratio;
                case "open": return o.open;
                case "close": return o.close;
                case "high": return o.high;
                case "highTime": return (o.highTimeMs == null ? -Infinity : o.highTimeMs);
                case "pct": return o.changePct;
                case "highPct": return o.highPct;
                default: return o.changePct;
            }
        };
        const va = get(a), vb = get(b);
        if (typeof va === "string" || typeof vb === "string") {
            return String(va).localeCompare(String(vb));
        }
        return (va ?? -Infinity) - (vb ?? -Infinity);
    }

    function applySortAndFilter(arr) {
        const term = filterEl.value.trim().toUpperCase();
        let out = arr.slice();
        if (term) out = out.filter(r => r.symbol.includes(term));
        out.sort((a, b) => {
            const c = compare(a, b, sortKey);
            return sortDir === "asc" ? c : -c;
        });
        return out;
    }

    function updateSortIndicators() {
        const thsAll = Array.from(document.querySelectorAll("#resultTable thead th.sortable"));
        thsAll.forEach(th => {
            th.classList.remove("sort-active");
            const ind = th.querySelector(".sort-ind");
            if (!ind) return;
            if (th.getAttribute("data-key") === sortKey) {
                th.classList.add("sort-active");
                ind.textContent = sortDir === "asc" ? "▲" : "▼";
            } else {
                ind.textContent = "⇵";
            }
        });
    }

    function updateMetaSummary() {
        if (backtestEl.checked && lastMeta && Number.isFinite(lastMeta.avgPrevAll)) {
            metaSummaryEl.textContent =
                `백테스트 요약 · 전체코인 직전봉 평균 변화: ${fmt(lastMeta.avgPrevAll, 2)}% (N=${lastMeta.nPrevAll})`;
        } else {
            metaSummaryEl.textContent = "";
        }
    }

    function updateView() {
        if (!lastScan.length) { updateSortIndicators(); return; }
        const rows = applySortAndFilter(lastScan);
        renderRows(rows);
        document.getElementById("status").textContent =
            `완료: ${rows.length}개 해머 발견 (총 ${lastTotalSymbols || rows.length})`;
        updateSortIndicators();
        updateMetaSummary();
    }

    async function startScan() {
        scanBtn.disabled = true;
        tbody.innerHTML = "";
        metaSummaryEl.textContent = "";
        document.getElementById("status").textContent = "심볼 불러오는 중…";

        try {
            const symbols = await getUsdtPerpSymbols();
            const targetUTC = getTargetUTCStartMs();
            aborter = new AbortController();

            document.getElementById("status").textContent = `총 ${symbols.length}개 심볼 스캔 중…`;

            const { results, meta } = await scan({
                targetDateUTCStartMs: targetUTC,
                symbols,
                concurrency: 9,
                signal: aborter.signal
            });

            lastScan = results;
            lastMeta = meta;
            lastTotalSymbols = symbols.length;
            updateView();
        } catch (e) {
            document.getElementById("status").innerHTML = `<span class="err">오류: ${e.message}</span>`;
        } finally {
            scanBtn.disabled = false;
        }
    }
</script>
</body>
</html>
