<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance 선물 1일봉 해머 스캐너</title>
    <style>
        :root { --bg:#0b1220; --fg:#eaeef7; --muted:#93a1b1; --accent:#4da3ff; --line:#1e293b; }
        * { box-sizing: border-box; }
        body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif; background:var(--bg); color:var(--fg); }
        header { position:sticky; top:0; background:#0b1220cc; backdrop-filter: blur(6px); border-bottom:1px solid #223; padding:12px 16px; z-index:10; }
        .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
        input, button, label { font-size:14px; }
        input, button { padding:10px 12px; border-radius:12px; border:1px solid #334; background:#111827; color:var(--fg); }
        button { background:var(--accent); color:#081018; border:0; font-weight:600; cursor:pointer; }
        button:disabled { opacity:0.6; cursor:not-allowed; }
        .wrap { padding:16px; }
        .hint { color:var(--muted); font-size:12px; }
        table { width:100%; border-collapse:collapse; table-layout: auto; }
        th, td { padding:10px 8px; border-bottom:1px solid var(--line); font-size:14px; vertical-align:middle; }
        th { position:sticky; top:110px; background:#0b1220; text-align:left; z-index:5; white-space:nowrap; }
        .badge { padding:2px 8px; border-radius:999px; background:#13263b; color:#a7e1ff; font-size:12px; }
        .ok { color:#5cf1a6; }
        .err { color:#ff6b6b; }
        .warn { color:#ffcd58; }
        .right { text-align:right; }
        .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
        #metaSummary { margin-top:6px; font-size:12px; color:#cbe4ff; }
        .sortable { cursor:pointer; user-select:none; }
        .sort-ind { margin-left:6px; opacity:0.7; }
        .sort-active .sort-ind { opacity:1; }
        .ma-pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:12px; line-height:1; }
        .ma-up { background:#0f2e1f; color:#7dffc2; }
        .ma-down { background:#2a1720; color:#ff9bb0; }
        .yb-pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:12px; line-height:1; }
        .yb-up { background:#0f2e1f; color:#7dffc2; }
        .yb-down { background:#2a1720; color:#ff9bb0; }
        .empty { color:#9fb1c6; text-align:center; padding:24px 8px; }
    </style>
</head>
<body>
<header>
    <div class="row">
        <label><input type="checkbox" id="backtest" /> 과거 백테스팅</label>
        <input type="date" id="dateInput" disabled />
        <input type="text" id="symbolFilter" placeholder="심볼 필터 (예: BTC, SOL)" />
        <button id="scanBtn">스캔</button>
        <span id="status" class="hint"></span>
    </div>
    <div class="hint" style="margin-top:6px">
        * 1일봉 UTC 00:00(한국 09:00 전환) · 해머: <span class="mono">아래꼬리 ≥ 2 × 몸통</span> · volume/txn은 <b>직전봉</b> 값
    </div>
    <div id="metaSummary"></div>
</header>

<div class="wrap">
    <table id="resultTable">
        <thead>
            <tr>
                <th class="sortable" data-key="sym">심볼<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="checkDate">체크일(UTC)<span class="sort-ind">⇵</span></th>
                <th>직전봉(해머)</th>
                <th class="sortable right" data-key="ratio">하단/몸통<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="open">체크일 시가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="close">체크일 종가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="high">체크일 고가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="pct">시가→종가 %<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="highPct">시가→고가 %<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="volPrev">직전봉 volume<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="txnPrev">직전봉 txn<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="prev2Up">2봉전 양/음<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="ma7">7MA 위/아래<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="ma25">25MA 위/아래<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="ma99">99MA 위/아래<span class="sort-ind">⇵</span></th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<script>
    // ---------- 유틸 ----------
    function toUTCDateStr(ms) {
        const d = new Date(ms);
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, "0");
        const day = String(d.getUTCDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
    }
    function dateToUTCStartMs(localDateStr) {
        const [y, m, d] = localDateStr.split("-").map(Number);
        return Date.UTC(y, m - 1, d, 0, 0, 0, 0);
    }
    function pct(curr, base) {
        return base === 0 ? 0 : ((curr - base) / base) * 100;
    }
    function fmt(n, digits = 2) {
        return Number.isFinite(n) ? n.toFixed(digits) : "-";
    }
    function fmtInt(n) {
        if (!Number.isFinite(n)) return "-";
        return Math.round(n).toLocaleString("ko-KR");
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function debounce(fn, wait = 200) { let t; return (...a) => { clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }

    // ---------- Binance API ----------
    const API_INFO = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const API_K = "https://fapi.binance.com/fapi/v1/klines";

    async function getUsdtPerpSymbols() {
        const res = await fetch(API_INFO);
        if (!res.ok) throw new Error("exchangeInfo 오류");
        const data = await res.json();
        return data.symbols
            .filter(s => s.status === "TRADING" && s.quoteAsset === "USDT" && s.contractType === "PERPETUAL")
            .map(s => s.symbol);
    }

    // prev/MA 계산용: 체크일 직전까지 최대 120개 일봉
    async function getDailyHistory(symbol, targetDateUTCStartMs, limit = 120) {
        const url = `${API_K}?symbol=${symbol}&interval=1d&endTime=${targetDateUTCStartMs}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`klines 오류: ${symbol}`);
        const arr = await res.json();
        return arr.map(k => ({
            openTime: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
            closeTime: k[6],
            quoteVolume: parseFloat(k[7]),
            numberOfTrades: parseInt(k[8], 10)
        }));
    }

    // 해머: 아래꼬리 ≥ 2 × 몸통
    function isHammer(c) {
        const body = Math.abs(c.close - c.open);
        const lower = Math.min(c.open, c.close) - c.low;
        return body > 0 && lower >= 2 * body;
    }

    function smaAt(closes, endIndex, n) {
        if (endIndex + 1 < n) return NaN;
        let sum = 0;
        for (let i = endIndex - n + 1; i <= endIndex; i++) sum += closes[i];
        return sum / n;
    }

    // ---------- 스캔 ----------
    async function scan({ targetDateUTCStartMs, symbols, concurrency = 9, signal }) {
        const results = [];
        let prevSumPct = 0, prevCount = 0;
        let done = 0;

        async function worker(sym) {
            if (signal?.aborted) return;
            try {
                // ✔ 변수명 통일: targetDateUTCStartMs
                const hist = await getDailyHistory(sym, targetDateUTCStartMs, 120);
                if (hist.length < 2) return;

                const idxPrev = hist.length - 1;       // 직전봉(체크일 전날)
                const prev = hist[idxPrev];
                const prev2 = hist[idxPrev - 1];       // 2봉전 (있을 때만)

                // 전체 직전봉 등락률 집계
                const prevChg = pct(prev.close, prev.open);
                if (Number.isFinite(prevChg)) { prevSumPct += prevChg; prevCount++; }

                // 해머 스캔
                if (!isHammer(prev)) return;

                const body = Math.abs(prev.close - prev.open);
                const lower = Math.min(prev.open, prev.close) - prev.low;
                const ratio = lower / body;

                // MA 계산 (직전봉까지의 종가 기준)
                const closes = hist.map(h => h.close);
                const ma7  = smaAt(closes, idxPrev, 7);
                const ma25 = smaAt(closes, idxPrev, 25);
                const ma99 = smaAt(closes, idxPrev, 99);
                const above7  = Number.isFinite(ma7)  ? (prev.close >= ma7)  : null;
                const above25 = Number.isFinite(ma25) ? (prev.close >= ma25) : null;
                const above99 = Number.isFinite(ma99) ? (prev.close >= ma99) : null;

                const checkDateStr = toUTCDateStr(targetDateUTCStartMs);
                const prevDateStr  = toUTCDateStr(prev.openTime);

                // ✔ 체크일(=targetDateUTCStartMs) 시/고/종 1회 조회
                let openT = NaN, highT = NaN, closeT = NaN, changePct = NaN, highPct = NaN;
                try {
                    const url = `${API_K}?symbol=${sym}&interval=1d&startTime=${targetDateUTCStartMs}&limit=1`;
                    const r2 = await fetch(url);
                    if (r2.ok) {
                        const a2 = await r2.json();
                        if (a2.length) {
                            openT = parseFloat(a2[0][1]);
                            highT = parseFloat(a2[0][2]);
                            closeT = parseFloat(a2[0][4]);
                            changePct = pct(closeT, openT);  // 시→종
                            highPct   = pct(highT, openT);   // 시→고
                        }
                    }
                } catch (e2) {
                    console.warn(`[${sym}] check-day fetch warn:`, e2?.message || e2);
                }

                results.push({
                    symbol: sym,
                    checkDate: checkDateStr,
                    prevDate: prevDateStr,
                    open: openT,
                    high: highT,
                    close: closeT,
                    changePct,          // 시→종 %
                    highPct,            // 시→고 %
                    ratio,
                    volumePrev: prev.volume,
                    txnPrev: prev.numberOfTrades,
                    prev2Up: (prev2 && prev2.close >= prev2.open) ? 1 : 0, // 1=양봉, 0=음봉(또는 없음)
                    ma7:  above7,
                    ma25: above25,
                    ma99: above99
                });
            } catch (e) {
                // ✔ 이제 심볼별 오류가 콘솔에 보입니다.
                console.warn(`[${sym}] scan error:`, e?.message || e);
            } finally {
                done++;
                document.getElementById("status").textContent = `진행: ${done}/${symbols.length}`;
            }
        }

        const queue = [...symbols];
        const runners = Array.from({ length: concurrency }).map(async () => {
            while (queue.length) {
                const sym = queue.shift();
                await worker(sym);
                await sleep(60); // 과요청 방지
            }
        });
        await Promise.all(runners);

        const meta = {
            avgPrevAll: prevCount ? (prevSumPct / prevCount) : NaN,
            nPrevAll: prevCount
        };
        return { results, meta };
    }

    // ---------- UI 상태 ----------
    const backtestEl = document.getElementById("backtest");
    const dateEl = document.getElementById("dateInput");
    const scanBtn = document.getElementById("scanBtn");
    const filterEl = document.getElementById("symbolFilter");
    const tbody = document.querySelector("#resultTable tbody");
    const metaSummaryEl = document.getElementById("metaSummary");
    const ths = Array.from(document.querySelectorAll("#resultTable thead th.sortable"));

    let lastScan = [];
    let lastMeta = null;
    let lastTotalSymbols = 0;
    let aborter = null;

    // 정렬 상태
    let sortKey = "pct";   // 기본: 시→종 %
    let sortDir = "desc";  // asc|desc

    backtestEl.addEventListener("change", () => {
        dateEl.disabled = !backtestEl.checked;
        updateMetaSummary();
    });
    filterEl.addEventListener("input", debounce(updateView, 150));

    // 헤더 클릭 정렬
    ths.forEach(th => {
        th.addEventListener("click", () => {
            const key = th.getAttribute("data-key");
            if (sortKey === key) {
                sortDir = (sortDir === "asc" ? "desc" : "asc");
            } else {
                sortKey = key;
                sortDir = (key === "sym" || key === "checkDate") ? "asc" : "desc";
            }
            updateView();
        });
    });

    scanBtn.addEventListener("click", startScan);

    function getTargetUTCStartMs() {
        if (backtestEl.checked && dateEl.value) {
            return dateToUTCStartMs(dateEl.value);
        } else {
            const now = new Date();
            return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
        }
    }

    function renderRows(rows) {
        tbody.innerHTML = "";
        if (!rows.length) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td class="empty" colspan="15">조건에 맞는 결과가 없습니다.</td>`;
            tbody.appendChild(tr);
            return;
        }

        for (const r of rows) {
            const prev2Badge = r.prev2Up === 1
                ? `<span class="yb-pill yb-up">양봉</span>`
                : `<span class="yb-pill yb-down">음봉</span>`;

            const maCell = (ok) => {
                if (ok === null) return `<span class="ma-pill warn">데이터부족</span>`;
                return ok ? `<span class="ma-pill ma-up">위</span>` : `<span class="ma-pill ma-down">아래</span>`;
            };

            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td><span class="badge">USDT</span> ${r.symbol}</td>
                <td class="mono">${r.checkDate}</td>
                <td><span class="ok">해머</span> <span class="hint mono">(${r.prevDate})</span></td>
                <td class="right mono">${Number.isFinite(r.ratio) ? r.ratio.toFixed(2) + "×" : "-"}</td>
                <td class="right mono">${fmt(r.open, 4)}</td>
                <td class="right mono">${fmt(r.close, 4)}</td>
                <td class="right mono">${fmt(r.high, 4)}</td>
                <td class="right mono">${fmt(r.changePct, 2)}%</td>
                <td class="right mono">${fmt(r.highPct, 2)}%</td>
                <td class="right mono">${fmt(r.volumePrev, 2)}</td>
                <td class="right mono">${fmtInt(r.txnPrev)}</td>
                <td>${prev2Badge}</td>
                <td>${maCell(r.ma7)}</td>
                <td>${maCell(r.ma25)}</td>
                <td>${maCell(r.ma99)}</td>
            `;
            tbody.appendChild(tr);
        }
    }

    function compare(a, b, key) {
        const get = (o) => {
            switch (key) {
                case "sym": return o.symbol;
                case "checkDate": return o.checkDate;
                case "ratio": return o.ratio;
                case "open": return o.open;
                case "close": return o.close;
                case "high": return o.high;
                case "pct": return o.changePct;      // 시→종
                case "highPct": return o.highPct;    // 시→고
                case "volPrev": return o.volumePrev;
                case "txnPrev": return o.txnPrev;
                case "prev2Up": return o.prev2Up;    // 1/0
                case "ma7": return o.ma7 === null ? -1 : (o.ma7 ? 1 : 0);
                case "ma25": return o.ma25 === null ? -1 : (o.ma25 ? 1 : 0);
                case "ma99": return o.ma99 === null ? -1 : (o.ma99 ? 1 : 0);
                default: return o.changePct;
            }
        };
        const va = get(a), vb = get(b);
        if (typeof va === "string" || typeof vb === "string") {
            return va.localeCompare(vb);
        }
        return (va ?? -Infinity) - (vb ?? -Infinity);
    }

    function applySortAndFilter(arr) {
        const term = filterEl.value.trim().toUpperCase();
        let out = arr.slice();
        if (term) out = out.filter(r => r.symbol.includes(term));
        out.sort((a, b) => {
            const c = compare(a, b, sortKey);
            return sortDir === "asc" ? c : -c;
        });
        return out;
    }

    function updateSortIndicators() {
        const thsAll = Array.from(document.querySelectorAll("#resultTable thead th.sortable"));
        thsAll.forEach(th => {
            th.classList.remove("sort-active");
            const ind = th.querySelector(".sort-ind");
            if (!ind) return;
            if (th.getAttribute("data-key") === sortKey) {
                th.classList.add("sort-active");
                ind.textContent = sortDir === "asc" ? "▲" : "▼";
            } else {
                ind.textContent = "⇵";
            }
        });
    }

    function updateMetaSummary() {
        if (backtestEl.checked && lastMeta && Number.isFinite(lastMeta.avgPrevAll)) {
            metaSummaryEl.textContent =
                `백테스트 요약 · 전체코인 직전봉 평균 변화: ${fmt(lastMeta.avgPrevAll, 2)}% (N=${lastMeta.nPrevAll})`;
        } else {
            metaSummaryEl.textContent = "";
        }
    }

    function updateView() {
        if (!lastScan.length) { updateSortIndicators(); return; }
        const rows = applySortAndFilter(lastScan);
        renderRows(rows);
        document.getElementById("status").textContent =
            `완료: ${rows.length}개 해머 발견 (총 ${lastTotalSymbols || rows.length})`;
        updateSortIndicators();
        updateMetaSummary();
    }

    async function startScan() {
        scanBtn.disabled = true;
        tbody.innerHTML = "";
        metaSummaryEl.textContent = "";
        document.getElementById("status").textContent = "심볼 불러오는 중…";

        try {
            const symbols = await getUsdtPerpSymbols();
            const targetUTC = getTargetUTCStartMs();
            aborter = new AbortController();

            document.getElementById("status").textContent = `총 ${symbols.length}개 심볼 스캔 중…`;

            const { results, meta } = await scan({
                targetDateUTCStartMs: targetUTC,   // ✔ 이름 통일
                symbols,
                concurrency: 9,
                signal: aborter.signal
            });

            lastScan = results;
            lastMeta = meta;
            lastTotalSymbols = symbols.length;
            updateView();
        } catch (e) {
            document.getElementById("status").innerHTML = `<span class="err">오류: ${e.message}</span>`;
        } finally {
            scanBtn.disabled = false;
        }
    }
</script>
</body>
</html>
