<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>Binance Futures Scanner — Pullback & MA Stack Rebreak (Backtest Returns)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --bg: #0f1115;
            --panel: #171922;
            --text: #e8ecf1;
            --muted: #9aa4b2;
            --accent: #3b82f6;
            --good: #22c55e;
            --bad: #ef4444;
            --warn: #f59e0b;
            --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 24px; background: var(--bg); color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial;
        }
        h1 { margin: 0 0 8px; font-size: 20px; }
        .desc { color: var(--muted); margin-bottom: 16px; line-height: 1.4; }
        .panel {
            background: var(--panel); border: 1px solid #222533; border-radius: 12px; padding: 16px; margin-bottom: 16px;
        }
        .controls { display: grid; grid-template-columns: repeat(12, minmax(0, 1fr)); gap: 12px; }
        .field { display: flex; flex-direction: column; gap: 6px; }
        label { font-size: 12px; color: var(--muted); }
        select, input[type="number"], input[type="date"] {
            background: #0b0d13; border: 1px solid #2a2f45; color: var(--text); padding: 10px 12px; border-radius: 8px;
            outline: none;
        }
        button {
            background: var(--accent); color: white; border: none; border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer;
        }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        .inline { display: flex; gap: 12px; align-items: center; }
        .checkbox { display: flex; gap: 8px; align-items: center; font-size: 13px; color: var(--muted); }

        .progress { margin-top: 8px; font-size: 12px; color: var(--muted); }
        .table-wrap { overflow: auto; border-radius: 12px; border: 1px solid #222533; }
        table { width: 100%; border-collapse: collapse; min-width: 1500px; }
        thead th {
            text-align: left; font-size: 12px; color: var(--muted); background: #121520; position: sticky; top: 0;
            padding: 10px; border-bottom: 1px solid #222533;
        }
        tbody td { padding: 10px; border-bottom: 1px solid #1b1f2d; font-size: 13px; vertical-align: top; }
        .mono { font-family: var(--mono); }
        .pill { padding: 2px 8px; background: rgba(34,197,94,.12); border: 1px solid rgba(34,197,94,.35); color: #a7f3d0; border-radius: 999px; font-size: 11px; }
        .foot { margin-top: 10px; font-size: 12px; color: var(--muted); }
        .flex { display: flex; gap: 8px; flex-wrap: wrap; }
        .bull { color: var(--good); font-weight: 700; }
        .bear { color: var(--bad); font-weight: 700; }
        .doji { color: var(--warn); font-weight: 700; }
        .muted { color: var(--muted); }
    </style>
</head>
<body>
    <h1>상승추세 풀백 + MA 스택(7&gt;25&gt;99) 재돌파 스캐너</h1>
    <div class="desc">
        바이낸스 USDⓂ 무기한 선물(USDT) · <b>직전 봉(완성봉)</b> 기준 판정.<br/>
        <b>Auto</b>: 바이낸스 서버 시각 기준 <b>봉 마감 직후(+버퍼)</b> 자동 스캔.<br/>
        <b>과거 리테스트</b>: 선택한 <b>UTC 날짜(=바이낸스 1D 경계)</b>에서 조건 일치 봉을 찾아 <b>다음 봉의 방향/수익률</b>과 <b>해당 코인의 하루 합계 수익률</b>을 표시.
    </div>

    <div class="panel">
        <div class="controls">
            <div class="field">
                <label>타임프레임</label>
                <select id="tf">
                    <option value="15m" selected>15m</option>
                    <option value="1m">1m</option>
                    <option value="5m">5m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                    <option value="1d">1d</option>
                </select>
            </div>
            <div class="field">
                <label>스캔 심볼 수 (상위 거래대금)</label>
                <input id="maxSymbols" type="number" value="80" min="10" max="500" />
            </div>
            <div class="field">
                <label>동시 요청 수(스로틀)</label>
                <input id="concurrency" type="number" value="8" min="1" max="24" />
            </div>
            <div class="field">
                <label>최근 N봉(풀백 탐색)</label>
                <input id="lookback" type="number" value="6" min="3" max="20" />
            </div>
            <div class="field">
                <label>K라인 개수(지표 계산)</label>
                <input id="klimit" type="number" value="220" min="120" max="1500" />
            </div>
            <div class="field">
                <label>권장 점수만</label>
                <label class="checkbox">
                    <input id="recommendedOnly" type="checkbox" checked />
                    <span>점수 ≥ 51 (권장)</span>
                </label>
            </div>
            <div class="field">
                <label>최소 점수(수동)</label>
                <input id="minScore" type="number" value="51" min="0" max="100" disabled />
            </div>
            <div class="field">
                <label>마감 후 대기(버퍼, 초)</label>
                <input id="bufferSec" type="number" value="2" min="0" max="10" />
            </div>
            <div class="field">
                <label>&nbsp;</label>
                <div class="inline">
                    <button id="scanBtn">스캔</button>
                    <label class="checkbox">
                        <input id="autoToggle" type="checkbox" />
                        <span>Auto (봉 마감 직후)</span>
                    </label>
                </div>
            </div>
            <div class="field">
                <label>과거 리테스트(UTC)</label>
                <label class="checkbox">
                    <input id="backtestToggle" type="checkbox" />
                    <span>켜기</span>
                </label>
            </div>
            <div class="field">
                <label>리테스트 날짜(UTC)</label>
                <input id="backtestDate" type="date" disabled />
            </div>
            <div class="field">
                <label>다음봉 진단(리테스트)</label>
                <label class="checkbox">
                    <input id="diagnosticsToggle" type="checkbox" />
                    <span>시장/기술 요인 분석</span>
                </label>
            </div>
        </div>
        <div class="progress" id="progress">준비됨. 실시간 스캔 또는 리테스트를 사용할 수 있습니다.</div>
    </div>

    <div class="panel table-wrap">
        <table>
            <thead>
                <tr>
                    <th>순위</th>
                    <th>심볼</th>
                    <th>점수</th>
                    <th>가격</th>
                    <th>RSI(14)</th>
                    <th>7 / 25 / 99</th>
                    <th>UTC 시간(리테스트)</th>
                    <th>다음봉</th>
                    <th>다음봉 수익률(%)</th>
                    <th>그 코인의 하루 합계(%)</th>
                    <th>진단(요인)</th>
                    <th>신호 플래그</th>
                    <th>메모</th>
                </tr>
            </thead>
            <tbody id="tbody"></tbody>
        </table>
        <div class="foot">
            ※ “다음봉 수익률”은 (다음봉 종가−다음봉 시가)/다음봉 시가 × 100 입니다. “하루 합계”는 같은 코인에서 해당 날짜에 발생한 모든 시그널의 “다음봉 수익률”을 합산한 값입니다.
        </div>
    </div>

    <script>
        // ========= 공통 유틸 =========
        const FAPI = "https://fapi.binance.com";
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const by = (k) => (a, b) => (a[k] > b[k] ? -1 : a[k] < b[k] ? 1 : 0);
        const fmtPct = (v) => (v == null || isNaN(v)) ? "-" : `${v >= 0 ? "+" : ""}${v.toFixed(2)}%`;

        function intervalMs(tf) {
            const map = { "1m": 60e3, "5m": 5*60e3, "15m": 15*60e3, "1h": 60*60e3, "4h": 4*60*60e3, "1d": 24*60*60e3 };
            return map[tf] ?? 15*60e3;
        }

        async function getServerTimeMs() {
            try {
                const r = await fetch(`${FAPI}/fapi/v1/time`);
                const j = await r.json();
                return j.serverTime;
            } catch (e) {
                return Date.now();
            }
        }

        function setDefaultUTCDateInput(inp) {
            const now = new Date();
            const y = now.getUTCFullYear();
            const m = String(now.getUTCMonth() + 1).padStart(2, "0");
            const d = String(now.getUTCDate()).padStart(2, "0");
            inp.value = `${y}-${m}-${d}`;
        }

        // ========= 지표 =========
        function sma(values, period) {
            const out = Array(values.length).fill(null);
            if (values.length < period) return out;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                sum += values[i];
                if (i >= period - 1) {
                    out[i] = sum / period;
                    sum -= values[i - (period - 1)];
                }
            }
            return out;
        }
        function stdAt(values, i, period, mean) {
            const start = i - period + 1;
            if (start < 0) return null;
            let s = 0;
            for (let k = start; k <= i; k++) {
                const d = values[k] - mean;
                s += d * d;
            }
            return Math.sqrt(s / period);
        }
        function ema(values, period) {
            if (!values || values.length < period + 2) return Array(values.length).fill(null);
            const k = 2 / (period + 1);
            const out = Array(values.length).fill(null);
            let sum = 0;
            for (let i = 0; i < period; i++) sum += values[i];
            let prev = sum / period;
            out[period - 1] = prev;
            for (let i = period; i < values.length; i++) {
                const cur = values[i] * k + prev * (1 - k);
                out[i] = cur;
                prev = cur;
            }
            return out;
        }
        function rsi(values, period = 14) {
            const out = Array(values.length).fill(null);
            if (values.length < period + 2) return out;
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const ch = values[i] - values[i - 1];
                gains += Math.max(ch, 0);
                losses += Math.max(-ch, 0);
            }
            let avgGain = gains / period;
            let avgLoss = losses / period;
            out[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
            for (let i = period + 1; i < values.length; i++) {
                const ch = values[i] - values[i - 1];
                const gain = Math.max(ch, 0);
                const loss = Math.max(-ch, 0);
                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;
                out[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
            }
            return out;
        }

        // ========= 시그널 평가 =========
        function evaluateAtIndex(klines, idx, lookback = 6) {
            if (!klines || klines.length < 120 || idx <= 0 || idx >= klines.length - 1) {
                return { passed: false, score: 0, flags: ["데이터 부족"] };
            }
            const open  = klines.map(k => Number(k[1]));
            const high  = klines.map(k => Number(k[2]));
            const low   = klines.map(k => Number(k[3]));
            const close = klines.map(k => Number(k[4]));
            const vol   = klines.map(k => Number(k[5]));

            const e7 = ema(close, 7);
            const e25 = ema(close, 25);
            const e99 = ema(close, 99);
            const r14 = rsi(close, 14);

            const last = idx;
            const prev = idx - 1;

            if ([e7[last], e25[last], e99[last]].some(v => v == null)) {
                return { passed: false, score: 0, flags: ["지표 계산 구간 부족"] };
            }

            let score = 0;
            const flags = [];

            const stack = e7[last] > e25[last] && e25[last] > e99[last];
            const slopeUp = e7[last] > e7[prev] && e25[last] > e25[prev];
            if (stack) { score += 15; flags.push("정배열(7>25>99)"); }
            if (slopeUp) { score += 8; flags.push("7/25 기울기↑"); }

            const aboveAll = close[last] > e7[last] && close[last] > e25[last] && close[last] > e99[last];
            if (aboveAll) { score += 10; flags.push("종가>7/25/99"); }

            const from = Math.max(99 + 5, last - lookback);
            const to = last - 1;
            let hadPullback = false;
            if (from <= to) {
                for (let i = from; i <= to; i++) {
                    if (close[i] < e7[i]) { hadPullback = true; break; }
                }
            }
            const rebreak = close[last] > e7[last];
            if (hadPullback && rebreak) { score += 8; flags.push("풀백 후 7MA 재돌파"); }

            const recentHigh = (from <= last - 1) ? Math.max(...high.slice(from, last)) : -Infinity;
            if (close[last] > recentHigh) { score += 10; flags.push("미니고점 돌파"); }

            const rsiLast = r14[last] ?? 0;
            const rsiSlice = r14.slice(Math.max(0, from), last).filter(v => v != null);
            const rsiMinRecent = rsiSlice.length ? Math.min(...rsiSlice) : 100;
            if (rsiLast > 50 && rsiMinRecent >= 40) { score += 6; flags.push("RSI Bull Range"); }

            const volUp = vol[last] > (vol[prev] || 0);
            if (volUp) { score += 4; flags.push("거래량 증가"); }

            const passed = (stack && rebreak && aboveAll && hadPullback);
            return {
                passed,
                score,
                flags,
                metrics: { open: open[last], close: close[last], high: high[last], low: low[last],
                    e7: e7[last], e25: e25[last], e99: e99[last], rsi: rsiLast }
            };
        }

        // ========= 진단(요약) =========
        function sma20UpperBandCloseFlag(close, idx) {
            const mean20 = sma(close, 20)[idx];
            if (mean20 == null) return false;
            const sd = stdAt(close, idx, 20, mean20);
            if (sd == null) return false;
            const upper = mean20 + 2 * sd;
            return close[idx] >= upper;
        }
        function buildTimeMap(kl) {
            const m = new Map();
            for (let i = 0; i < kl.length; i++) m.set(Number(kl[i][6]), i);
            return m;
        }
        function pct(a, b) {
            return b === 0 ? 0 : (a - b) / b;
        }
        function analyzeNextBarReasons(kl, idx, context) {
            const open  = kl.map(k => Number(k[1]));
            const high  = kl.map(k => Number(k[2]));
            const low   = kl.map(k => Number(k[3]));
            const close = kl.map(k => Number(k[4]));
            const vol   = kl.map(k => Number(k[5]));
            const last = idx; const next = idx + 1;
            const reasonsBull = [], reasonsBear = [];

            // 시장 순/역풍
            if (context && context.btc && context.eth) {
                const tClose = Number(kl[last][6]);
                const bi = context.btc.map.get(tClose);
                const ei = context.eth.map.get(tClose);
                if (bi != null && bi + 1 < context.btc.kl.length) {
                    const ro = Number(context.btc.kl[bi + 1][1]), rc = Number(context.btc.kl[bi + 1][4]);
                    const r = pct(rc, ro);
                    if (r > 0.002) reasonsBull.push("BTC 순풍(+0.2%↑)");
                    if (r < -0.002) reasonsBear.push("BTC 역풍(−0.2%↓)");
                }
                if (ei != null && ei + 1 < context.eth.kl.length) {
                    const ro = Number(context.eth.kl[ei + 1][1]), rc = Number(context.eth.kl[ei + 1][4]);
                    const r = pct(rc, ro);
                    if (r > 0.003) reasonsBull.push("ETH 순풍(+0.3%↑)");
                    if (r < -0.003) reasonsBear.push("ETH 역풍(−0.3%↓)");
                }
            }

            // 저항/과열/이격
            const h20 = Math.max(...high.slice(Math.max(0, last - 20), last));
            const h50 = Math.max(...high.slice(Math.max(0, last - 50), last));
            if (Math.abs(pct(h20, close[last])) <= 0.003) reasonsBear.push("상단 저항(20봉 근접)");
            if (Math.abs(pct(h50, close[last])) <= 0.005) reasonsBear.push("상단 저항(50봉 근접)");
            const e25 = ema(close, 25), e7 = ema(close, 7);
            if ((close[last] / (e25[last] || close[last])) >= 1.02 || (close[last] / (e7[last] || close[last])) >= 1.01) {
                reasonsBear.push("MA 이격 과다");
            }
            if (sma20UpperBandCloseFlag(close, last)) reasonsBear.push("상단 밴드 과열");

            // 캔들/모멘텀
            const range = Math.max(1e-12, high[last] - low[last]);
            const upperWick = high[last] - Math.max(close[last], open[last]);
            if (upperWick / range >= 0.5) reasonsBear.push("상단 꼬리 과다");

            if (next < kl.length) {
                const volUp = Number(kl[next][5]) > Number(kl[last][5]);
                const nextOpen = Number(kl[next][1]), nextClose = Number(kl[next][4]);
                const ret = pct(nextClose, nextOpen);
                if (ret > 0.003 && volUp) reasonsBull.push("모멘텀 지속(양봉+거래량↑)");
                if (ret < -0.003 && !volUp) reasonsBear.push("모멘텀 약화(음봉+거래량↓)");
            }

            return { reasonsBull, reasonsBear };
        }

        // ========= API =========
        async function fetchExchangeInfoUSDTPerp() {
            const url = `${FAPI}/fapi/v1/exchangeInfo`;
            const res = await fetch(url);
            if (!res.ok) throw new Error("exchangeInfo 실패");
            const json = await res.json();
            return json.symbols
                .filter(s => s.quoteAsset === "USDT" && s.contractType === "PERPETUAL" && s.status === "TRADING")
                .map(s => s.symbol);
        }
        async function fetch24hTickers() {
            const url = `${FAPI}/fapi/v1/ticker/24hr`;
            const res = await fetch(url);
            if (!res.ok) throw new Error("24hr ticker 실패");
            return await res.json();
        }
        async function fetchKlines(symbol, interval, { limit, startTime, endTime } = {}) {
            const params = new URLSearchParams({ symbol, interval });
            if (limit != null) params.set("limit", String(limit));
            if (startTime != null) params.set("startTime", String(startTime));
            if (endTime != null) params.set("endTime", String(endTime));
            const url = `${FAPI}/fapi/v1/klines?${params.toString()}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`klines 실패: ${symbol}`);
            return await res.json();
        }

        // ========= DOM/상태 =========
        const tbody = document.getElementById("tbody");
        const progressEl = document.getElementById("progress");
        const scanBtn = document.getElementById("scanBtn");
        const autoToggle = document.getElementById("autoToggle");
        const backtestToggle = document.getElementById("backtestToggle");
        const backtestDate = document.getElementById("backtestDate");
        const recommendedOnly = document.getElementById("recommendedOnly");
        const minScoreInput = document.getElementById("minScore");
        const diagnosticsToggle = document.getElementById("diagnosticsToggle");
        setDefaultUTCDateInput(backtestDate);

        recommendedOnly.addEventListener("change", () => {
            const on = recommendedOnly.checked;
            minScoreInput.disabled = on;
            if (on) minScoreInput.value = 51;
        });

        // ========= 실시간 스캔 =========
        async function scanRealtime() {
            try {
                scanBtn.disabled = true;
                tbody.innerHTML = "";
                progressEl.textContent = "심볼 목록 불러오는 중…";

                const tf = document.getElementById("tf").value;
                const maxSymbols = Number(document.getElementById("maxSymbols").value || 80);
                const concurrency = Number(document.getElementById("concurrency").value || 8);
                const lookback = Number(document.getElementById("lookback").value || 6);
                const klimit = Number(document.getElementById("klimit").value || 220);
                const minScore = Number(minScoreInput.value || 0);

                const [allPerp, tickers] = await Promise.all([fetchExchangeInfoUSDTPerp(), fetch24hTickers()]);
                const tickerMap = new Map(tickers.map(t => [t.symbol, t]));
                const candidates = allPerp.map(sym => {
                    const t = tickerMap.get(sym);
                    return { symbol: sym, quoteVol: t ? Number(t.quoteVolume || 0) : 0, lastPrice: t ? Number(t.lastPrice || 0) : 0 };
                }).sort((a, b) => b.quoteVol - a.quoteVol).slice(0, maxSymbols);

                progressEl.textContent = `스캔 대상: ${candidates.length} · TF ${tf} · 요청 중…`;

                const results = [];
                let done = 0;
                async function worker(job) {
                    const { symbol, lastPrice } = job;
                    try {
                        const kl = await fetchKlines(symbol, tf, { limit: klimit });
                        const lastIdx = kl.length - 2;
                        const ev = evaluateAtIndex(kl, lastIdx, lookback);
                        if (ev.passed && ev.score >= minScore) {
                            results.push({
                                symbol,
                                score: ev.score,
                                price: lastPrice || (kl.length ? Number(kl[lastIdx][4]) : null),
                                rsi: ev.metrics?.rsi ?? null,
                                e7: ev.metrics?.e7 ?? null,
                                e25: ev.metrics?.e25 ?? null,
                                e99: ev.metrics?.e99 ?? null,
                                flags: ev.flags,
                                timeUTC: "-",
                                nextBar: "-",
                                nextRetPct: null,
                                dailySumNextRetPct: null,
                                diagnostics: "-"
                            });
                        }
                    } catch {}
                    finally {
                        done += 1;
                        if (done % 5 === 0 || done === candidates.length) {
                            progressEl.textContent = `요청 진행: ${done}/${candidates.length}`;
                        }
                    }
                }
                const queue = candidates.slice();
                const runners = Array.from({ length: concurrency }, async () => {
                    while (queue.length) { await worker(queue.shift()); await sleep(35); }
                });
                await Promise.all(runners);

                results.sort(by("score"));
                renderRows(results, lookback);
                progressEl.textContent = `완료: 신호 ${results.length}건 / 대상 ${candidates.length}건 (필터: 점수 ≥ ${minScore})`;
            } catch (err) {
                progressEl.textContent = `에러: ${err?.message || err}`;
            } finally {
                scanBtn.disabled = false;
            }
        }

        // ========= 리테스트(다음봉 수익률 + 하루 합계) =========
        async function scanBacktest() {
            try {
                scanBtn.disabled = true;
                tbody.innerHTML = "";
                progressEl.textContent = "리테스트: 심볼/티커 로딩 중…";

                const tf = document.getElementById("tf").value;
                const tfMs = intervalMs(tf);
                const maxSymbols = Number(document.getElementById("maxSymbols").value || 80);
                const concurrency = Number(document.getElementById("concurrency").value || 8);
                const lookback = Number(document.getElementById("lookback").value || 6);
                const minScore = Number(minScoreInput.value || 0);
                const doDiag = !!document.getElementById("diagnosticsToggle").checked;

                const dateStr = backtestDate.value;
                if (!dateStr) throw new Error("리테스트 날짜(UTC)를 선택하세요.");
                const [yy, mm, dd] = dateStr.split("-").map(Number);
                const dayStartUTC = Date.UTC(yy, mm - 1, dd, 0, 0, 0, 0);
                const dayEndUTC = dayStartUTC + 24*60*60*1000 - 1;

                const warmupBars = 300;
                const startFetch = dayStartUTC - warmupBars * tfMs;
                const endFetch = dayEndUTC + tfMs * 2;

                const [allPerp, tickers] = await Promise.all([fetchExchangeInfoUSDTPerp(), fetch24hTickers()]);
                const tickerMap = new Map(tickers.map(t => [t.symbol, t]));
                const candidates = allPerp.map(sym => {
                    const t = tickerMap.get(sym);
                    return { symbol: sym, quoteVol: t ? Number(t.quoteVolume || 0) : 0 };
                }).sort((a, b) => b.quoteVol - a.quoteVol).slice(0, maxSymbols);

                // 시장 진단용
                let market = null;
                if (doDiag) {
                    const [btc, eth] = await Promise.all([
                        fetchKlines("BTCUSDT", tf, { startTime: startFetch, endTime: endFetch, limit: 1500 }),
                        fetchKlines("ETHUSDT", tf, { startTime: startFetch, endTime: endFetch, limit: 1500 })
                    ]);
                    market = { btc: { kl: btc, map: buildTimeMap(btc) }, eth: { kl: eth, map: buildTimeMap(eth) } };
                }

                progressEl.textContent = `리테스트 대상: ${candidates.length} · TF ${tf} · ${dateStr} (UTC) · 요청 중…`;

                const results = [];
                let done = 0;

                async function worker(job) {
                    const { symbol } = job;
                    try {
                        const expectedBars = Math.ceil((endFetch - startFetch) / tfMs) + 10;
                        const kl = await fetchKlines(symbol, tf, { startTime: startFetch, endTime: endFetch, limit: Math.max(expectedBars, 120) });

                        for (let i = 1; i < kl.length - 1; i++) {
                            const closeTime = Number(kl[i][6]);
                            if (closeTime < dayStartUTC || closeTime > dayEndUTC) continue;

                            const ev = evaluateAtIndex(kl, i, lookback);
                            if (ev.passed && ev.score >= minScore) {
                                // 다음 봉 방향 + 수익률
                                const nextOpen = Number(kl[i + 1][1]);
                                const nextClose = Number(kl[i + 1][4]);
                                let nextBar = "-";
                                if (nextClose > nextOpen) nextBar = "양봉";
                                else if (nextClose < nextOpen) nextBar = "음봉";
                                else nextBar = "도지";
                                const nextRetPct = ((nextClose - nextOpen) / nextOpen) * 100;

                                // 진단
                                let diags = "-";
                                if (doDiag) {
                                    const { reasonsBull, reasonsBear } = analyzeNextBarReasons(kl, i, market);
                                    const bulls = reasonsBull.length ? `상승요인: ${reasonsBull.join(", ")}` : "";
                                    const bears = reasonsBear.length ? `하락요인: ${reasonsBear.join(", ")}` : "";
                                    diags = [bulls, bears].filter(Boolean).join(" | ") || "요인 특이사항 적음";
                                }

                                results.push({
                                    symbol,
                                    score: ev.score,
                                    price: Number(kl[i][4]),
                                    rsi: ev.metrics?.rsi ?? null,
                                    e7: ev.metrics?.e7 ?? null,
                                    e25: ev.metrics?.e25 ?? null,
                                    e99: ev.metrics?.e99 ?? null,
                                    flags: ev.flags,
                                    timeUTC: new Date(closeTime).toISOString().replace(".000Z", "Z"),
                                    nextBar,
                                    nextRetPct,
                                    dailySumNextRetPct: null, // 나중에 채움
                                    diagnostics: diags
                                });
                            }
                        }
                    } catch {}
                    finally {
                        done += 1;
                        if (done % 3 === 0 || done === candidates.length) {
                            progressEl.textContent = `리테스트 진행: ${done}/${candidates.length}`;
                        }
                    }
                }

                const queue = candidates.slice();
                const runners = Array.from({ length: concurrency }, async () => {
                    while (queue.length) { await worker(queue.shift()); await sleep(35); }
                });
                await Promise.all(runners);

                // 같은 코인(같은 날짜)별 "다음봉 수익률" 합계 계산
                const sumMap = new Map(); // symbol -> sum(%)
                for (const r of results) {
                    if (r.nextRetPct == null) continue;
                    sumMap.set(r.symbol, (sumMap.get(r.symbol) || 0) + r.nextRetPct);
                }
                for (const r of results) {
                    r.dailySumNextRetPct = sumMap.has(r.symbol) ? sumMap.get(r.symbol) : null;
                }

                results.sort(by("score"));
                renderRows(results, lookback);

                const bull = results.filter(r => r.nextBar === "양봉").length;
                const bear = results.filter(r => r.nextBar === "음봉").length;
                const doji = results.filter(r => r.nextBar === "도지").length;
                progressEl.innerHTML = `리테스트 완료: 조건 일치 <b>${results.length}</b>건 (양봉 ${bull}, 음봉 ${bear}, 도지 ${doji}) · (점수 ≥ ${minScore})`;
            } catch (err) {
                progressEl.textContent = `리테스트 에러: ${err?.message || err}`;
            } finally {
                scanBtn.disabled = false;
            }
        }

        // ========= 렌더 =========
        function renderRows(items, lookback) {
            tbody.innerHTML = "";
            items.forEach((r, idx) => {
                const tags = r.flags.map(f => `<span class="pill">${f}</span>`).join(" ");
                const nextCls = r.nextBar === "양봉" ? "bull" : (r.nextBar === "음봉" ? "bear" : (r.nextBar === "도지" ? "doji" : "muted"));
                const retCls = (r.nextRetPct == null) ? "muted" : (r.nextRetPct > 0 ? "bull" : (r.nextRetPct < 0 ? "bear" : "muted"));
                const sumCls = (r.dailySumNextRetPct == null) ? "muted" : (r.dailySumNextRetPct > 0 ? "bull" : (r.dailySumNextRetPct < 0 ? "bear" : "muted"));
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${idx + 1}</td>
                    <td class="mono">${r.symbol}</td>
                    <td><strong>${r.score}</strong></td>
                    <td class="mono">${r.price?.toFixed ? r.price.toFixed(6).replace(/\.?0+$/,"") : "-"}</td>
                    <td>${r.rsi != null ? r.rsi.toFixed(1) : "-"}</td>
                    <td class="mono">
                        7:${r.e7?.toFixed ? r.e7.toFixed(6).replace(/\.?0+$/,"") : "-"} /
                        25:${r.e25?.toFixed ? r.e25.toFixed(6).replace(/\.?0+$/,"") : "-"} /
                        99:${r.e99?.toFixed ? r.e99.toFixed(6).replace(/\.?0+$/,"") : "-"}
                    </td>
                    <td class="mono">${r.timeUTC || "-"}</td>
                    <td class="${nextCls}">${r.nextBar || "-"}</td>
                    <td class="${retCls}">${fmtPct(r.nextRetPct)}</td>
                    <td class="${sumCls}">${fmtPct(r.dailySumNextRetPct)}</td>
                    <td>${r.diagnostics || "-"}</td>
                    <td><div class="flex">${tags}</div></td>
                    <td class="mono">lookback=${lookback}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        // ========= Auto(서버시각 동기) =========
        let autoTimer = null, countdownTimer = null, nextRunAt = null;
        function clearTimers() { clearTimeout(autoTimer); autoTimer = null; clearInterval(countdownTimer); countdownTimer = null; }

        async function scheduleNextAutoScan() {
            if (!autoToggle.checked) return;
            if (backtestToggle.checked) {
                autoToggle.checked = false;
                progressEl.textContent = "리테스트 모드에서는 Auto를 사용할 수 없습니다.";
                return;
            }
            const tf = document.getElementById("tf").value;
            const ms = intervalMs(tf);
            const bufferMs = Math.max(0, Number(document.getElementById("bufferSec").value || 2) * 1000);

            const now = await getServerTimeMs();
            const next = Math.ceil(now / ms) * ms;
            const delay = Math.max(1000, next - now + bufferMs);
            nextRunAt = now + delay;

            clearTimers();
            autoTimer = setTimeout(async () => { await scanRealtime(); scheduleNextAutoScan(); }, delay);

            countdownTimer = setInterval(async () => {
                const cur = await getServerTimeMs();
                const remainMs = Math.max(0, nextRunAt - cur);
                progressEl.textContent = `Auto 대기: ~${Math.ceil(remainMs / 1000)}s 후 스캔(봉 마감+버퍼)`;
                if (remainMs <= 0) clearInterval(countdownTimer);
            }, 1000);

            progressEl.textContent = `Auto 대기: ~${Math.round(delay / 1000)}s 후 스캔(봉 마감+버퍼)`;
        }

        document.addEventListener("visibilitychange", () => {
            if (autoToggle.checked && document.visibilityState === "visible") scheduleNextAutoScan();
        });

        // ========= 이벤트 =========
        backtestToggle.addEventListener("change", () => {
            const on = backtestToggle.checked;
            backtestDate.disabled = !on;
            diagnosticsToggle.disabled = !on;
            if (on) { autoToggle.checked = false; clearTimers(); progressEl.textContent = "리테스트 모드: 날짜(UTC) 선택 후 스캔하세요."; }
            else { progressEl.textContent = "리테스트 해제됨. 실시간 스캔/Auto 사용 가능."; }
        });

        document.getElementById("scanBtn").addEventListener("click", async () => {
            if (backtestToggle.checked) { await scanBacktest(); } else { await scanRealtime(); }
        });
        document.getElementById("autoToggle").addEventListener("change", () => {
            if (autoToggle.checked) scheduleNextAutoScan(); else { clearTimers(); progressEl.textContent = "Auto 해제됨."; }
        });
        document.getElementById("tf").addEventListener("change", () => { if (autoToggle.checked) scheduleNextAutoScan(); });
        document.getElementById("bufferSec").addEventListener("change", () => { if (autoToggle.checked) scheduleNextAutoScan(); });

        // 초기
        progressEl.textContent = "준비됨. 실시간 스캔 또는 리테스트를 사용할 수 있습니다.";
    </script>
</body>
</html>
