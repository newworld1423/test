<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance 선물 1일봉 해머 스캐너</title>
    <style>
        :root { --bg:#0b1220; --fg:#eaeef7; --muted:#93a1b1; --accent:#4da3ff; --line:#1e293b; }
        * { box-sizing: border-box; }
        body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif; background:var(--bg); color:var(--fg); }
        header { position:sticky; top:0; background:#0b1220cc; backdrop-filter: blur(6px); border-bottom:1px solid #223; padding:12px 16px; z-index:10; }
        .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
        input, button, label { font-size:14px; }
        input, button { padding:10px 12px; border-radius:12px; border:1px solid #334; background:#111827; color:var(--fg); }
        button { background:var(--accent); color:#081018; border:0; font-weight:600; cursor:pointer; }
        button:disabled { opacity:0.6; cursor:not-allowed; }
        #calendarBtn { padding:10px 12px; border-radius:12px; border:1px solid #334; background:#0f172a; }
        #calendarBtn:hover { background:#111b34; }
        .wrap { padding:16px; }
        .hint { color:var(--muted); font-size:12px; }
        table { width:100%; border-collapse:collapse; table-layout: auto; }
        th, td { padding:10px 8px; border-bottom:1px solid var(--line); font-size:14px; vertical-align:middle; }
        th { position:sticky; top:110px; background:#0b1220; text-align:left; z-index:5; white-space:nowrap; }
        .ok { color:#5cf1a6; }
        .err { color:#ff6b6b; }
        .right { text-align:right; }
        .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
        #metaSummary { margin-top:6px; font-size:12px; color:#cbe4ff; }
        .sortable { cursor:pointer; user-select:none; }
        .sort-ind { margin-left:6px; opacity:0.7; }
        .sort-active .sort-ind { opacity:1; }
        .empty { color:#9fb1c6; text-align:center; padding:24px 8px; }
    </style>
</head>
<body>
<header>
    <div class="row">
        <label><input type="checkbox" id="backtest" /> 과거 백테스팅</label>
        <input type="date" id="dateInput" disabled />
        <button id="calendarBtn" type="button" title="달력 열기" aria-label="달력 열기">📅</button>
        <input type="text" id="symbolFilter" placeholder="심볼 필터 (예: BTC, SOL)" />
        <button id="scanBtn">스캔</button>
        <span id="status" class="hint"></span>
    </div>
    <div class="hint" style="margin-top:6px">
        * 표시는 모두 <b>KST(UTC+9)</b> 기준 · (참고) 바이낸스 1일봉 경계는 <b>UTC 00:00</b><br/>
        * 해머 정의: <span class="mono">아래꼬리 ≥ 2 × 몸통</span> · <span class="mono">윗꼬리 &lt; 몸통</span> · <span class="mono">종가 &gt; 시가</span><br/>
        * <b>백테스팅 OFF</b>: <u>현재 진행 중인 1일봉</u>이 해머이고 <u>직전봉이 음봉</u>일 때 표시<br/>
        * <b>백테스팅 ON</b>: <u>전날(닫힌 1일봉)</u>이 해머이고 <u>2봉전이 음봉</u>일 때 표시<br/>
        * 시가/종가/고가는 체크일(UTC) 1일봉 · 고가 시각은 체크일 <b>15분봉</b>으로 탐색
    </div>
    <div id="metaSummary"></div>
</header>

<div class="wrap">
    <table id="resultTable">
        <thead>
            <tr>
                <th class="sortable" data-key="sym">심볼<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="checkDate">체크일(KST)<span class="sort-ind">⇵</span></th>
                <th>판정</th>
                <th class="sortable right" data-key="ratio">하단/몸통<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="open">체크일 시가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="close">체크일 종가<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="high">체크일 고가<span class="sort-ind">⇵</span></th>
                <th class="sortable" data-key="highTime">고가 시각(KST)<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="pct">시가→종가 %<span class="sort-ind">⇵</span></th>
                <th class="sortable right" data-key="highPct">시가→고가 %<span class="sort-ind">⇵</span></th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<script>
    // ---------- 유틸 ----------
    const KST_OFFSET_MS = 9 * 60 * 60 * 1000; // UTC+9
    function toKSTDateStr(msUTC) {
        const d = new Date(msUTC + KST_OFFSET_MS);
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, "0");
        const day = String(d.getUTCDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
    }
    function toKSTHHMM(msUTC) {
        const d = new Date(msUTC + KST_OFFSET_MS);
        const hh = String(d.getUTCHours()).padStart(2, "0");
        const mm = String(d.getUTCMinutes()).padStart(2, "0");
        return `${hh}:${mm}`;
    }
    function dateToUTCStartMs(localDateStr) {
        const [y, m, d] = localDateStr.split("-").map(Number);
        return Date.UTC(y, m - 1, d, 0, 0, 0, 0);
    }
    function pct(curr, base) { return base === 0 ? 0 : ((curr - base) / base) * 100; }
    function fmt(n, digits = 2) { return Number.isFinite(n) ? n.toFixed(digits) : "-"; }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function debounce(fn, wait = 200) { let t; return (...a) => { clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }

    // ---------- Binance API ----------
    const API_INFO = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const API_K = "https://fapi.binance.com/fapi/v1/klines";

    async function getUsdtPerpSymbols() {
        const res = await fetch(API_INFO);
        if (!res.ok) throw new Error("exchangeInfo 오류");
        const data = await res.json();
        return data.symbols
            .filter(s => s.status === "TRADING" && s.quoteAsset === "USDT" && s.contractType === "PERPETUAL")
            .map(s => s.symbol);
    }

    async function getDailyHistory(symbol, targetDateUTCStartMs, limit = 120) {
        const url = `${API_K}?symbol=${symbol}&interval=1d&endTime=${targetDateUTCStartMs}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`klines 오류: ${symbol}`);
        const arr = await res.json();
        return arr.map(k => ({
            openTime: k[0],
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
            closeTime: k[6],
            quoteVolume: parseFloat(k[7]),
            numberOfTrades: parseInt(k[8], 10)
        }));
    }

    // 해머: 아래꼬리 ≥ 2 × 몸통 AND 윗꼬리 < 몸통 AND 종가>시가 AND (컨텍스트 봉은 음봉)
    function isHammer(c, prevContext) {
        const o = c.open, h = c.high, l = c.low, cl = c.close;
        const body  = Math.abs(cl - o);
        if (body <= 0) return false;                 // 도지 배제

        const lower = Math.min(o, cl) - l;           // 밑꼬리
        const upper = h - Math.max(o, cl);           // 윗꼬리
        const contextBear = prevContext && (prevContext.close < prevContext.open); // 컨텍스트 봉(직전/2봉전) 음봉 요구

        return lower >= 2 * body && upper < body && cl > o && contextBear === true;
    }

    // ---------- 스캔 ----------
    async function scan({ targetDateUTCStartMs, symbols, concurrency = 9, signal, useCurrent = false }) {
        const results = [];
        let prevSumPct = 0, prevCount = 0;
        let done = 0;

        async function worker(sym) {
            if (signal?.aborted) return;
            try {
                if (useCurrent) {
                    // ── 현재봉(진행 중) 해머 + 직전봉 음봉 ──
                    // 직전봉(닫힌 캔들) 구하기
                    const histPrev = await getDailyHistory(sym, targetDateUTCStartMs, 2); // [.., 직전봉]
                    if (!histPrev.length) return;
                    const prevClosed = histPrev[histPrev.length - 1];
                    const prevBear = prevClosed.close < prevClosed.open;

                    // 현재봉(오늘 UTC 00:00 시작, 진행 중 캔들)
                    const urlCur = `${API_K}?symbol=${sym}&interval=1d&startTime=${targetDateUTCStartMs}&limit=1`;
                    const rCur = await fetch(urlCur);
                    if (!rCur.ok) return;
                    const aCur = await rCur.json();
                    if (!aCur.length) return;

                    const cur = {
                        openTime: aCur[0][0],
                        open: parseFloat(aCur[0][1]),
                        high: parseFloat(aCur[0][2]),
                        low:  parseFloat(aCur[0][3]),
                        close:parseFloat(aCur[0][4]),
                    };

                    // 현재봉을 해머로 판정(컨텍스트로 직전봉 전달)
                    if (!isHammer(cur, prevClosed)) return;

                    const body  = Math.abs(cur.close - cur.open);
                    const lower = Math.min(cur.open, cur.close) - cur.low;
                    const ratio = lower / body;

                    // 표시값: 현재봉 시/고/종, 퍼센트
                    const openT  = cur.open;
                    const highT  = cur.high;
                    const closeT = cur.close;
                    const changePct = pct(closeT, openT);
                    const highPct   = pct(highT, openT);

                    // 현재봉 고가 시각(15분봉) — endTime은 지금 시각
                    let highTimeMs = null;
                    try {
                        const start = targetDateUTCStartMs;
                        const end   = Date.now();
                        const urlI  = `${API_K}?symbol=${sym}&interval=15m&startTime=${start}&endTime=${end}&limit=1000`;
                        const rI = await fetch(urlI);
                        if (rI.ok) {
                            const arr = await rI.json();
                            if (arr.length) {
                                let maxH = -Infinity;
                                for (let i = 0; i < arr.length; i++) {
                                    const hi = parseFloat(arr[i][2]);
                                    if (hi > maxH) maxH = hi;
                                }
                                const firstIdx = arr.findIndex(k => parseFloat(k[2]) === maxH);
                                if (firstIdx >= 0) highTimeMs = arr[firstIdx][0];
                            }
                        }
                    } catch {}

                    // 메타(요약) 집계는 안전하게 유지
                    const prevChg = pct(prevClosed.close, prevClosed.open);
                    if (Number.isFinite(prevChg)) { prevSumPct += prevChg; prevCount++; }

                    results.push({
                        symbol: sym,
                        checkDateMs: targetDateUTCStartMs, // 오늘(UTC) 00:00
                        prevDateMs: prevClosed.openTime,
                        open: openT,
                        high: highT,
                        close: closeT,
                        changePct,
                        highPct,
                        ratio,
                        highTimeMs,
                        prevBear
                    });
                } else {
                    // ── 전날 해머 + 2봉전 음봉(기존 백테스트 로직) ──
                    const hist = await getDailyHistory(sym, targetDateUTCStartMs, 120);
                    if (hist.length < 2) return;

                    const idxPrev = hist.length - 1; // 직전봉(체크일 전날)
                    const prev = hist[idxPrev];
                    const prev2 = hist[idxPrev - 1];

                    const prevChg = pct(prev.close, prev.open);
                    if (Number.isFinite(prevChg)) { prevSumPct += prevChg; prevCount++; }

                    if (!isHammer(prev, prev2)) return;

                    const body = Math.abs(prev.close - prev.open);
                    const lower = Math.min(prev.open, prev.close) - prev.low;
                    const ratio = lower / body;

                    const checkDateMs = targetDateUTCStartMs;
                    const prevDateMs  = prev.openTime;

                    // 체크일(다음 날) 시/고/종
                    let openT = NaN, highT = NaN, closeT = NaN, changePct = NaN, highPct = NaN;
                    try {
                        const url = `${API_K}?symbol=${sym}&interval=1d&startTime=${targetDateUTCStartMs}&limit=1`;
                        const r2 = await fetch(url);
                        if (r2.ok) {
                            const a2 = await r2.json();
                            if (a2.length) {
                                openT  = parseFloat(a2[0][1]);
                                highT  = parseFloat(a2[0][2]);
                                closeT = parseFloat(a2[0][4]);
                                changePct = pct(closeT, openT);
                                highPct   = pct(highT, openT);
                            }
                        }
                    } catch {}

                    // 고가 시각(15분봉) — 체크일 하루 범위
                    let highTimeMs = null;
                    try {
                        const dayMs = 24 * 60 * 60 * 1000;
                        const start = targetDateUTCStartMs;
                        const end   = targetDateUTCStartMs + dayMs;
                        const urlI  = `${API_K}?symbol=${sym}&interval=15m&startTime=${start}&endTime=${end}&limit=1000`;
                        const r3 = await fetch(urlI);
                        if (r3.ok) {
                            const arr = await r3.json();
                            if (arr.length) {
                                let maxH = -Infinity;
                                for (let i = 0; i < arr.length; i++) {
                                    const hi = parseFloat(arr[i][2]);
                                    if (hi > maxH) maxH = hi;
                                }
                                const firstIdx = arr.findIndex(k => parseFloat(k[2]) === maxH);
                                if (firstIdx >= 0) highTimeMs = arr[firstIdx][0];
                            }
                        }
                    } catch {}

                    results.push({
                        symbol: sym,
                        checkDateMs,
                        prevDateMs,
                        open: openT,
                        high: highT,
                        close: closeT,
                        changePct,
                        highPct,
                        ratio,
                        highTimeMs,
                        prevBear: (prev2 && prev2.close < prev2.open) || false
                    });
                }
            } catch (e) {
                console.warn(`[${sym}] scan error:`, e?.message || e);
            } finally {
                done++;
                document.getElementById("status").textContent = `진행: ${done}/${symbols.length}`;
            }
        }

        const queue = [...symbols];
        const runners = Array.from({ length: concurrency }).map(async () => {
            while (queue.length) {
                const sym = queue.shift();
                await worker(sym);
                await sleep(60);
            }
        });
        await Promise.all(runners);

        const meta = {
            avgPrevAll: prevCount ? (prevSumPct / prevCount) : NaN,
            nPrevAll: prevCount
        };
        return { results, meta };
    }

    // ---------- UI 상태 ----------
    const backtestEl = document.getElementById("backtest");
    const dateEl = document.getElementById("dateInput");
    const calendarBtn = document.getElementById("calendarBtn");
    const scanBtn = document.getElementById("scanBtn");
    const filterEl = document.getElementById("symbolFilter");
    const tbody = document.querySelector("#resultTable tbody");
    const metaSummaryEl = document.getElementById("metaSummary");
    const ths = Array.from(document.querySelectorAll("#resultTable thead th.sortable"));

    let lastScan = [];
    let lastMeta = null;
    let lastTotalSymbols = 0;
    let aborter = null;

    let sortKey = "pct";
    let sortDir = "desc";

    // 달력 열기
    function openDatePicker() {
        if (typeof dateEl.showPicker === "function") {
            dateEl.showPicker();
        } else {
            dateEl.focus();
            setTimeout(() => { try { dateEl.click(); } catch(_) {} }, 0);
        }
    }

    // 백테스트 체크 토글 시: 활성화 + 자동 달력 오픈
    backtestEl.addEventListener("change", () => {
        const on = backtestEl.checked;
        dateEl.disabled = !on;
        updateMetaSummary();
        if (on) {
            if (!dateEl.value) {
                const now = new Date();
                const y = now.getUTCFullYear();
                const m = String(now.getUTCMonth() + 1).padStart(2, "0");
                const d = String(now.getUTCDate()).padStart(2, "0");
                dateEl.value = `${y}-${m}-${d}`;
            }
            setTimeout(openDatePicker, 50);
        }
    });

    // 📅 버튼: 자동으로 백테스트 ON + 달력 열기
    calendarBtn.addEventListener("click", () => {
        if (!backtestEl.checked) {
            backtestEl.checked = true;
            dateEl.disabled = false;
        }
        if (!dateEl.value) {
            const now = new Date();
            const y = now.getUTCFullYear();
            const m = String(now.getUTCMonth() + 1).padStart(2, "0");
            const d = String(now.getUTCDate()).padStart(2, "0");
            dateEl.value = `${y}-${m}-${d}`;
        }
        openDatePicker();
    });

    // 비활성 상태에서도 날짜 필드 클릭 시 자동으로 켜고 열기
    dateEl.addEventListener("mousedown", (e) => {
        if (dateEl.disabled) {
            e.preventDefault();
            backtestEl.checked = true;
            dateEl.disabled = false;
            setTimeout(openDatePicker, 50);
        }
    });

    filterEl.addEventListener("input", debounce(updateView, 150));

    // 헤더 클릭 정렬
    ths.forEach(th => {
        th.addEventListener("click", () => {
            const key = th.getAttribute("data-key");
            if (sortKey === key) {
                sortDir = (sortDir === "asc" ? "desc" : "asc");
            } else {
                sortKey = key;
                sortDir = (key === "sym" || key === "checkDate") ? "asc" : "desc";
            }
            updateView();
        });
    });

    scanBtn.addEventListener("click", startScan);

    function getTargetUTCStartMs() {
        if (backtestEl.checked && dateEl.value) {
            return dateToUTCStartMs(dateEl.value);
        } else {
            const now = new Date();
            return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
        }
    }

    function renderRows(rows) {
        tbody.innerHTML = "";
        if (!rows.length) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td class="empty" colspan="10">조건에 맞는 결과가 없습니다.</td>`;
            tbody.appendChild(tr);
            return;
        }

        const basisLabel = backtestEl.checked ? "직전봉 해머" : "현재봉 해머";

        for (const r of rows) {
            const subHint = backtestEl.checked
                ? `(${toKSTDateStr(r.prevDateMs)})`
                : (r.prevBear ? "(직전: 음봉)" : "(직전: 양봉)");

            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${r.symbol}</td>
                <td class="mono">${toKSTDateStr(r.checkDateMs)}</td>
                <td><span class="ok">${basisLabel}</span> <span class="hint mono">${subHint}</span></td>
                <td class="right mono">${Number.isFinite(r.ratio) ? r.ratio.toFixed(2) : "-"}</td>
                <td class="right mono">${fmt(r.open, 4)}</td>
                <td class="right mono">${fmt(r.close, 4)}</td>
                <td class="right mono">${fmt(r.high, 4)}</td>
                <td class="mono">${r.highTimeMs ? toKSTHHMM(r.highTimeMs) : "-"}</td>
                <td class="right mono">${fmt(r.changePct, 2)}%</td>
                <td class="right mono">${fmt(r.highPct, 2)}%</td>
            `;
            tbody.appendChild(tr);
        }
    }

    function compare(a, b, key) {
        const get = (o) => {
            switch (key) {
                case "sym": return o.symbol;
                case "checkDate": return o.checkDateMs;
                case "ratio": return o.ratio;
                case "open": return o.open;
                case "close": return o.close;
                case "high": return o.high;
                case "highTime": return (o.highTimeMs == null ? -Infinity : o.highTimeMs);
                case "pct": return o.changePct;
                case "highPct": return o.highPct;
                default: return o.changePct;
            }
        };
        const va = get(a), vb = get(b);
        if (typeof va === "string" || typeof vb === "string") {
            return String(va).localeCompare(String(vb));
        }
        return (va ?? -Infinity) - (vb ?? -Infinity);
    }

    function applySortAndFilter(arr) {
        const term = filterEl.value.trim().toUpperCase();
        let out = arr.slice();
        if (term) out = out.filter(r => r.symbol.includes(term));
        out.sort((a, b) => {
            const c = compare(a, b, sortKey);
            return sortDir === "asc" ? c : -c;
        });
        return out;
    }

    function updateSortIndicators() {
        const thsAll = Array.from(document.querySelectorAll("#resultTable thead th.sortable"));
        thsAll.forEach(th => {
            th.classList.remove("sort-active");
            const ind = th.querySelector(".sort-ind");
            if (!ind) return;
            if (th.getAttribute("data-key") === sortKey) {
                th.classList.add("sort-active");
                ind.textContent = sortDir === "asc" ? "▲" : "▼";
            } else {
                ind.textContent = "⇵";
            }
        });
    }

    function updateMetaSummary() {
        if (backtestEl.checked && lastMeta && Number.isFinite(lastMeta.avgPrevAll)) {
            metaSummaryEl.textContent =
                `백테스트 요약 · 전체코인 직전봉 평균 변화: ${fmt(lastMeta.avgPrevAll, 2)}% (N=${lastMeta.nPrevAll})`;
        } else {
            metaSummaryEl.textContent = "";
        }
    }

    function updateView() {
        if (!lastScan.length) { updateSortIndicators(); return; }
        const rows = applySortAndFilter(lastScan);
        renderRows(rows);
        document.getElementById("status").textContent =
            `완료: ${rows.length}개 해머 발견 (총 ${lastTotalSymbols || rows.length})`;
        updateSortIndicators();
        updateMetaSummary();
    }

    async function startScan() {
        scanBtn.disabled = true;
        tbody.innerHTML = "";
        metaSummaryEl.textContent = "";
        document.getElementById("status").textContent = "심볼 불러오는 중…";

        try {
            const symbols = await getUsdtPerpSymbols();
            const targetUTC = getTargetUTCStartMs();
            aborter = new AbortController();

            document.getElementById("status").textContent = `총 ${symbols.length}개 심볼 스캔 중…`;

            const { results, meta } = await scan({
                targetDateUTCStartMs: targetUTC,
                symbols,
                concurrency: 9,
                signal: aborter?.signal,
                useCurrent: !backtestEl.checked   // ★ 백테스팅 OFF면 현재봉 모드
            });

            lastScan = results;
            lastMeta = meta;
            lastTotalSymbols = symbols.length;
            updateView();
        } catch (e) {
            document.getElementById("status").innerHTML = `<span class="err">오류: ${e.message}</span>`;
        } finally {
            scanBtn.disabled = false;
        }
    }
</script>
</body>
</html>
