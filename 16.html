<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <title>Binance Perp USDT — 상장 이후 All-Time Low / High 스캐너</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --bg: #05060a;
            --card: #12131a;
            --muted: #9aa0a6;
            --text: #e8eaed;
            --accent: #3ea6ff;
            --good: #00c853;
            --bad: #ff5252;
            --border: #2a2e36;
            --row-alt: #181924;
            --pos-low: #00e676;
            --pos-mid: #ffd54f;
            --pos-high: #ff5252;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at top, #151821 0, #050609 55%, #020308 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", sans-serif;
        }

        .page {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px;
        }

        header {
            margin-bottom: 16px;
        }

        header h1 {
            font-size: 20px;
            margin: 0 0 4px;
        }

        header p {
            margin: 2px 0;
            font-size: 13px;
            color: var(--muted);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        button {
            border: none;
            border-radius: 999px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 0 1px #00000040, 0 10px 20px rgba(0, 0, 0, 0.55);
            transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.08s;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
            box-shadow: none;
            transform: none;
        }

        button:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 0 0 1px #00000070, 0 16px 30px rgba(0, 0, 0, 0.75);
        }

        #status {
            font-size: 13px;
            color: var(--muted);
        }

        .hint {
            font-size: 11px;
            color: var(--muted);
            margin-top: 4px;
        }

        .table-wrap {
            border-radius: 16px;
            background: rgba(10, 11, 18, 0.9);
            border: 1px solid var(--border);
            overflow: hidden;
            margin-top: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        thead {
            background: linear-gradient(to right, #151826, #10121b);
        }

        th, td {
            padding: 6px 8px;
            text-align: right;
            white-space: nowrap;
        }

        th {
            font-weight: 600;
            border-bottom: 1px solid var(--border);
            color: var(--muted);
            position: sticky;
            top: 0;
            z-index: 1;
            backdrop-filter: blur(12px);
        }

        tbody tr:nth-child(odd) {
            background: #0e1017;
        }

        tbody tr:nth-child(even) {
            background: var(--row-alt);
        }

        tbody tr:hover {
            background: #242840;
        }

        td.symbol {
            text-align: left;
            font-weight: 600;
        }

        td.low {
            color: var(--good);
        }

        td.high {
            color: var(--bad);
        }

        td.ratio {
            font-weight: 600;
        }

        td.pos {
            font-weight: 600;
        }

        td.pos.pos-low {
            color: var(--pos-low);
        }

        td.pos.pos-mid {
            color: var(--pos-mid);
        }

        td.pos.pos-high {
            color: var(--pos-high);
        }

        .scroll {
            max-height: 70vh;
            overflow: auto;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 17px;
            }
            th, td {
                padding: 5px 6px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <header>
            <h1>Binance Perp USDT — 상장 이후 All-Time Low / High 스캐너</h1>
            <p>· Binance USDⓈ-M 무기한 선물(USDT 페어)의 상장 이후 전체 1일봉(1d)을 스캔해서 최저가 / 최고가 / 현재 위치 % 계산</p>
            <p>· 온보드(onboardDate) 이후부터 오늘까지의 모든 1d 캔들을 기준으로 ATL / ATH를 찾음</p>
        </header>

        <section class="controls">
            <button id="scanBtn">전체 스캔 시작 (USDT PERP 전부)</button>
            <span id="status"></span>
        </section>
        <div class="hint">
            ※ 무기한 선물(USDⓈ-M Perpetual) + USDT 페어만 스캔합니다.<br>
            ※ 요청이 많아서 스캔은 몇 분 이상 걸릴 수 있습니다. (브라우저 탭만 켜 두면 됨)
        </div>

        <section class="table-wrap">
            <div class="scroll">
                <table id="resultTable">
                    <thead>
                        <tr>
                            <th style="text-align:left;">심볼</th>
                            <th>상장 이후 최저가</th>
                            <th>최저가 날짜(UTC)</th>
                            <th>상장 이후 최고가</th>
                            <th>최고가 날짜(UTC)</th>
                            <th>현재가</th>
                            <th>현재 위치(0~100%)</th>
                            <th>최고/최저 배율</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- 결과 행 -->
                    </tbody>
                </table>
            </div>
        </section>
    </div>

    <script>
        const API_BASE = "https://fapi.binance.com";
        const ONE_DAY = 24 * 60 * 60 * 1000;
        // 온보드 정보가 없을 경우 대비: 2019-01-01부터 스캔 (USDⓈ-M 선물 런칭 이전이라도 문제 없음)
        const DEFAULT_START_TIME = Date.UTC(2019, 0, 1);
        const REQUEST_SLEEP_MS = 60; // 각 kline 요청 사이 딜레이 (레이트리밋 완화용)

        const scanBtn = document.getElementById("scanBtn");
        const statusEl = document.getElementById("status");
        const tbody = document.querySelector("#resultTable tbody");

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fetchWithRetry(url, maxRetries = 5) {
            let attempt = 0;
            while (true) {
                try {
                    const res = await fetch(url);
                    if (res.status === 418 || res.status === 429) {
                        attempt += 1;
                        const wait = 15000 * attempt;
                        statusEl.textContent = `레이트리밋(${res.status}) → ${Math.round(wait / 1000)}초 대기 후 재시도 (${attempt}/${maxRetries})`;
                        if (attempt >= maxRetries) {
                            throw new Error(`Too many rate limit errors for ${url}`);
                        }
                        await sleep(wait);
                        continue;
                    }
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status} for ${url}`);
                    }
                    return res.json();
                } catch (err) {
                    attempt += 1;
                    if (attempt >= maxRetries) {
                        throw err;
                    }
                    const wait = 5000 * attempt;
                    statusEl.textContent = `요청 실패 → ${Math.round(wait / 1000)}초 후 재시도 (${attempt}/${maxRetries})`;
                    await sleep(wait);
                }
            }
        }

        function getDecimalsFromTickSize(tickSize) {
            if (!tickSize) return 4;
            const idx = tickSize.indexOf("1");
            if (idx <= 0) {
                return 0;
            }
            return idx - 1;
        }

        async function loadSymbols() {
            const url = `${API_BASE}/fapi/v1/exchangeInfo`;
            const json = await fetchWithRetry(url);
            const all = json.symbols || [];

            const filtered = all.filter(s =>
                s.contractType === "PERPETUAL" &&
                s.quoteAsset === "USDT"
            );

            const meta = {};
            const symbols = [];

            for (const s of filtered) {
                const priceFilter = (s.filters || []).find(f => f.filterType === "PRICE_FILTER");
                const decimals = getDecimalsFromTickSize(priceFilter ? priceFilter.tickSize : null);
                const onboard = typeof s.onboardDate === "number" ? s.onboardDate : DEFAULT_START_TIME;

                meta[s.symbol] = {
                    decimals,
                    onboardDate: onboard
                };
                symbols.push(s.symbol);
            }

            return { symbols, meta };
        }

        async function loadCurrentPrices() {
            // 모든 선물 심볼 현재가 한 번에 가져오기
            const url = `${API_BASE}/fapi/v1/ticker/price`;
            const json = await fetchWithRetry(url);
            const map = {};
            for (const item of json) {
                map[item.symbol] = parseFloat(item.price);
            }
            return map;
        }

        async function fetchAllKlines1d(symbol, startTime) {
            const limit = 1000;
            const now = Date.now();
            let from = startTime || DEFAULT_START_TIME;
            const all = [];
            let safety = 0;
            const maxLoops = 20; // 안전 장치 (20 * 1000일 = 20000일 > 50년)

            while (from < now && safety < maxLoops) {
                safety += 1;
                const url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1d&startTime=${from}&limit=${limit}`;
                const data = await fetchWithRetry(url);
                if (!data || !data.length) {
                    break;
                }

                all.push(...data);

                const lastOpenTime = data[data.length - 1][0];
                from = lastOpenTime + ONE_DAY;

                if (data.length < limit) {
                    break;
                }

                await sleep(REQUEST_SLEEP_MS);
            }

            return all;
        }

        function formatDateUTC(ts) {
            if (!ts && ts !== 0) return "-";
            const d = new Date(ts);
            const y = d.getUTCFullYear();
            const m = (d.getUTCMonth() + 1).toString().padStart(2, "0");
            const day = d.getUTCDate().toString().padStart(2, "0");
            return `${y}-${m}-${day}`;
        }

        function formatPrice(v, decimals) {
            if (!isFinite(v)) return "-";
            const d = Math.max(0, Math.min(decimals, 8));
            return Number(v).toFixed(d);
        }

        function clamp(v, min, max) {
            return Math.min(max, Math.max(min, v));
        }

        async function scanAll() {
            scanBtn.disabled = true;
            tbody.innerHTML = "";
            statusEl.textContent = "심볼 목록 불러오는 중...";

            try {
                const { symbols, meta } = await loadSymbols();
                statusEl.textContent = `심볼 ${symbols.length}개 로드 완료. 현재가 불러오는 중...`;

                const priceMap = await loadCurrentPrices();

                statusEl.textContent = `심볼 ${symbols.length}개 스캔 시작 (1d 전체 히스토리)...`;
                const results = [];
                let done = 0;

                for (const symbol of symbols) {
                    done += 1;
                    const info = meta[symbol] || { decimals: 4, onboardDate: DEFAULT_START_TIME };

                    statusEl.textContent = `스캔 중... ${done}/${symbols.length} (${symbol})`;

                    try {
                        const klines = await fetchAllKlines1d(symbol, info.onboardDate);

                        if (!klines || !klines.length) {
                            await sleep(REQUEST_SLEEP_MS);
                            continue;
                        }

                        let minLow = Infinity;
                        let minLowTime = null;
                        let maxHigh = -Infinity;
                        let maxHighTime = null;

                        for (const k of klines) {
                            const openTime = k[0];
                            const high = parseFloat(k[2]);
                            const low = parseFloat(k[3]);

                            if (low < minLow) {
                                minLow = low;
                                minLowTime = openTime;
                            }
                            if (high > maxHigh) {
                                maxHigh = high;
                                maxHighTime = openTime;
                            }
                        }

                        if (!isFinite(minLow) || !isFinite(maxHigh)) {
                            await sleep(REQUEST_SLEEP_MS);
                            continue;
                        }

                        const currentPrice = priceMap[symbol];
                        if (!isFinite(currentPrice)) {
                            await sleep(REQUEST_SLEEP_MS);
                            continue;
                        }

                        let posPercent = 0;
                        if (maxHigh > minLow) {
                            posPercent = ((currentPrice - minLow) / (maxHigh - minLow)) * 100;
                            posPercent = clamp(posPercent, 0, 100);
                        }

                        const ratio = maxHigh / minLow;

                        results.push({
                            symbol,
                            minLow,
                            minLowTime,
                            maxHigh,
                            maxHighTime,
                            currentPrice,
                            posPercent,
                            ratio
                        });

                        await sleep(REQUEST_SLEEP_MS);
                    } catch (errSymbol) {
                        console.error("심볼 스캔 에러:", symbol, errSymbol);
                        await sleep(REQUEST_SLEEP_MS * 2);
                    }
                }

                // 현재 위치(%)가 낮은 순으로 정렬 (0% = 거의 역사적 저점)
                results.sort((a, b) => a.posPercent - b.posPercent);

                for (const row of results) {
                    const info = meta[row.symbol] || { decimals: 4 };
                    const pos = row.posPercent;
                    let posClass = "pos-mid";
                    if (pos <= 20) {
                        posClass = "pos-low";
                    } else if (pos >= 80) {
                        posClass = "pos-high";
                    }

                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td class="symbol">${row.symbol}</td>
                        <td class="low">${formatPrice(row.minLow, info.decimals)}</td>
                        <td>${formatDateUTC(row.minLowTime)}</td>
                        <td class="high">${formatPrice(row.maxHigh, info.decimals)}</td>
                        <td>${formatDateUTC(row.maxHighTime)}</td>
                        <td>${formatPrice(row.currentPrice, info.decimals)}</td>
                        <td class="pos ${posClass}">${row.posPercent.toFixed(1)}%</td>
                        <td class="ratio">${row.ratio.toFixed(2)}x</td>
                    `;
                    tbody.appendChild(tr);
                }

                statusEl.textContent = `완료: ${results.length}개 심볼 스캔 완료 (현재 위치 % 낮은 순으로 정렬).`;
            } catch (e) {
                console.error(e);
                statusEl.textContent = "에러: " + e.message;
            } finally {
                scanBtn.disabled = false;
            }
        }

        scanBtn.addEventListener("click", scanAll);
    </script>
</body>
</html>
