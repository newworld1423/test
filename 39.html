<!DOCTYPE html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp Long Scanner + Backtest</title>
        <style>
            :root {
                --bg: #0b0f17;
                --panel: #111827;
                --panel2: #0f172a;
                --text: #e5e7eb;
                --muted: #9ca3af;
                --line: rgba(255, 255, 255, 0.08);
                --good: rgba(34, 197, 94, 0.18);
                --warn: rgba(245, 158, 11, 0.18);
                --bad: rgba(239, 68, 68, 0.18);
                --chip: rgba(255, 255, 255, 0.06);
                --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
                background: radial-gradient(1200px 600px at 20% 0%, rgba(99, 102, 241, 0.15), transparent 60%),
                    radial-gradient(900px 500px at 90% 10%, rgba(16, 185, 129, 0.12), transparent 55%),
                    var(--bg);
                color: var(--text);
            }

            .wrap {
                max-width: 1400px;
                margin: 0 auto;
                padding: 18px;
            }

            .header {
                display: flex;
                gap: 12px;
                align-items: flex-start;
                justify-content: space-between;
                flex-wrap: wrap;
                margin-bottom: 14px;
            }

            h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: -0.3px;
            }

            .sub {
                color: var(--muted);
                font-size: 12px;
                line-height: 1.45;
                margin-top: 6px;
            }

            .panel {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), transparent 25%), var(--panel);
                border: 1px solid var(--line);
                border-radius: 14px;
                box-shadow: var(--shadow);
                overflow: hidden;
            }

            .grid2 {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 14px;
            }

            .controls {
                padding: 14px;
                display: grid;
                grid-template-columns: repeat(12, 1fr);
                gap: 10px;
                align-items: end;
            }

            .field {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .field label {
                font-size: 12px;
                color: var(--muted);
            }

            .field input,
            .field select {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: var(--panel2);
                color: var(--text);
                outline: none;
            }

            .field input:focus,
            .field select:focus {
                border-color: rgba(99, 102, 241, 0.55);
                box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
            }

            .btns {
                display: flex;
                gap: 8px;
                align-items: center;
                justify-content: flex-end;
                flex-wrap: wrap;
            }

            button {
                appearance: none;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: var(--text);
                padding: 10px 12px;
                border-radius: 10px;
                cursor: pointer;
                transition: transform 0.06s ease, background 0.15s ease, border-color 0.15s ease;
                font-weight: 700;
                letter-spacing: -0.2px;
            }

            button:hover {
                background: rgba(255, 255, 255, 0.09);
            }

            button:active {
                transform: translateY(1px);
            }

            button.primary {
                border-color: rgba(99, 102, 241, 0.55);
                background: rgba(99, 102, 241, 0.2);
            }

            button.danger {
                border-color: rgba(239, 68, 68, 0.55);
                background: rgba(239, 68, 68, 0.18);
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            .status {
                padding: 12px 14px;
                border-top: 1px solid var(--line);
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
                flex-wrap: wrap;
            }

            .chip {
                display: inline-flex;
                gap: 8px;
                align-items: center;
                padding: 6px 10px;
                border-radius: 999px;
                background: var(--chip);
                border: 1px solid var(--line);
                font-size: 12px;
                color: var(--muted);
                white-space: nowrap;
            }

            .chip strong {
                color: var(--text);
                font-weight: 800;
            }

            .tableWrap {
                margin-top: 14px;
                overflow: hidden;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                background: rgba(17, 24, 39, 0.85);
                backdrop-filter: blur(10px);
                border-bottom: 1px solid var(--line);
                text-align: left;
                padding: 10px 10px;
                color: var(--muted);
                font-weight: 800;
                cursor: pointer;
                user-select: none;
                white-space: nowrap;
            }

            tbody td {
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                vertical-align: middle;
                white-space: nowrap;
            }

            tbody tr:hover {
                background: rgba(255, 255, 255, 0.03);
            }

            .mono {
                font-variant-numeric: tabular-nums;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }

            .badge {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 5px 9px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.05);
                font-size: 12px;
                color: var(--muted);
                white-space: nowrap;
            }

            .badge.good {
                background: var(--good);
                color: #bbf7d0;
                border-color: rgba(34, 197, 94, 0.35);
            }

            .badge.warn {
                background: var(--warn);
                color: #fde68a;
                border-color: rgba(245, 158, 11, 0.35);
            }

            .badge.bad {
                background: var(--bad);
                color: #fecaca;
                border-color: rgba(239, 68, 68, 0.35);
            }

            .right {
                text-align: right;
            }

            .small {
                font-size: 12px;
                color: var(--muted);
            }

            .footer {
                margin-top: 12px;
                padding: 12px 2px;
                color: var(--muted);
                font-size: 12px;
                line-height: 1.55;
            }

            .twoTables {
                display: grid;
                grid-template-columns: 1fr;
                gap: 14px;
            }

            @media (max-width: 1100px) {
                .grid2 {
                    grid-template-columns: 1fr;
                }
            }

            @media (max-width: 980px) {
                .controls {
                    grid-template-columns: repeat(6, 1fr);
                }
            }

            @media (max-width: 560px) {
                .controls {
                    grid-template-columns: repeat(2, 1fr);
                }
            }

            /* ====== Body-fixed Tooltip (안 잘림) ====== */
            .th-tooltip {
                position: fixed;
                z-index: 999999;
                max-width: min(340px, 76vw);
                background: rgba(15, 23, 42, 0.98);
                color: var(--text);
                border: 1px solid var(--line);
                border-radius: 12px;
                padding: 10px 12px;
                font-size: 12px;
                line-height: 1.45;
                box-shadow: var(--shadow);
                pointer-events: none;
                opacity: 0;
                transform: translateY(4px);
                transition: opacity 0.12s ease, transform 0.12s ease;
                display: none;
            }

            .th-tooltip.is-on {
                display: block;
                opacity: 1;
                transform: translateY(0);
            }
            /* ====== /Tooltip ====== */
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="header">
                <div>
                    <h1>Binance USDT 무기한 롱 스캐너 + 백테스트(15m) 통합</h1>
                    <div class="sub">
                        조건(신호봉 기준): 1D(종가 &gt; 99SMA) + 1H(종가 &gt; EMA50 &gt; EMA200) + 15m(EMA20 재탈환 + RSI상승, 45~65)<br />
                        진입: 다음 15m 시가 / SL: (최근 N 저점) vs (1H ATR*배수) 중 더 타이트한 값(=롱 기준 더 높은 SL) / TP: RR 고정<br />
                        판정: 15m 고가/저가 터치(동봉 TP&SL은 설정값에 따라 SL 우선/TP 우선)
                    </div>
                </div>
            </div>

            <div class="grid2">
                <!-- Scanner Panel -->
                <div class="panel">
                    <div class="controls">
                        <div class="field" style="grid-column: span 4;">
                            <label>스캔 대상(24h 거래대금 상위 N)</label>
                            <input id="maxSymbols" type="number" min="10" max="200" step="1" value="80" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>최소 24h 거래대금(USDT)</label>
                            <input id="minQuoteVol" type="number" min="0" step="1000000" value="50000000" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>필터</label>
                            <select id="filterMode">
                                <option value="all" selected>전체 표시</option>
                                <option value="trend">추세 우호(1D OK + 1H Strong)만</option>
                                <option value="setup">세팅 완료(재탈환+RSI)만</option>
                            </select>
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>Base URL</label>
                            <input id="baseUrl" type="text" value="https://fapi.binance.com" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>동시 요청(스캔)</label>
                            <input id="concurrency" type="number" min="1" max="20" step="1" value="8" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>요청 템포</label>
                            <select id="tempo">
                                <option value="fast">빠름</option>
                                <option value="normal" selected>보통</option>
                                <option value="slow">느림(429 줄이기)</option>
                            </select>
                        </div>

                        <div class="btns" style="grid-column: span 12;">
                            <button id="btnScan" class="primary">스캔 시작</button>
                            <button id="btnScanStop" class="danger" disabled>스캔 중지</button>
                            <button id="btnScanCsv" disabled>스캔 CSV 복사</button>
                            <button id="btnClearCache">로컬 캐시 삭제</button>
                        </div>
                    </div>

                    <div class="status">
                        <div class="chip">스캔 상태: <strong id="scanStatus">대기</strong></div>
                        <div class="chip">진행: <strong id="scanProgress">0 / 0</strong></div>
                        <div class="chip">표시: <strong id="scanShown">0</strong></div>
                        <div class="chip">마지막: <strong id="scanLastRun">-</strong></div>
                    </div>
                </div>

                <!-- Backtest Panel -->
                <div class="panel">
                    <div class="controls">
                        <div class="field" style="grid-column: span 4;">
                            <label>백테스트 시작일</label>
                            <input id="btStart" type="date" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>백테스트 종료일</label>
                            <input id="btEnd" type="date" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>대상(스캔 상위 N)</label>
                            <input id="btTopN" type="number" min="1" max="80" step="1" value="20" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>RR(익절 R)</label>
                            <input id="btRR" type="number" min="0.5" max="10" step="0.1" value="2.0" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>ATR배수(SL)</label>
                            <input id="btAtrMult" type="number" min="0.5" max="5" step="0.1" value="1.2" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>최근저점 N(15m)</label>
                            <input id="btSwingN" type="number" min="3" max="60" step="1" value="12" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>최대 보유(15m bars)</label>
                            <input id="btMaxHold" type="number" min="4" max="2000" step="1" value="96" />
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>동봉 TP/SL 터치 시 처리</label>
                            <select id="btTieBreak">
                                <option value="sl" selected>보수적: SL 우선</option>
                                <option value="tp">낙관적: TP 우선</option>
                            </select>
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>펀딩 필터</label>
                            <select id="btFundingMode">
                                <option value="on" selected>사용(진입 시점 펀딩이 너무 양수면 제외)</option>
                                <option value="off">미사용</option>
                            </select>
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>펀딩 상한(예: 0.0003 = 0.03%)</label>
                            <input id="btFundingMax" type="number" min="0" max="0.01" step="0.0001" value="0.0003" />
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>백테스트 동시요청(권장 2~4)</label>
                            <input id="btConcurrency" type="number" min="1" max="10" step="1" value="3" />
                        </div>

                        <div class="btns" style="grid-column: span 12;">
                            <button id="btnBt" class="primary">백테스트 실행</button>
                            <button id="btnBtStop" class="danger" disabled>백테스트 중지</button>
                            <button id="btnBtCsv" disabled>백테스트 CSV 복사</button>
                        </div>
                    </div>

                    <div class="status">
                        <div class="chip">백테스트 상태: <strong id="btStatus">대기</strong></div>
                        <div class="chip">진행: <strong id="btProgress">0 / 0</strong></div>
                        <div class="chip">총 트레이드: <strong id="btTrades">0</strong></div>
                        <div class="chip">승률: <strong id="btWinrate">-</strong></div>
                        <div class="chip">Net R: <strong id="btNetR">-</strong></div>
                    </div>
                </div>
            </div>

            <div class="twoTables">
                <!-- Scan Table -->
                <div class="panel tableWrap">
                    <div style="padding: 10px 12px; border-bottom: 1px solid var(--line);" class="small">
                        스캐너 결과 (기본: Score 내림차순) / 헤더 클릭 정렬 / 헤더 hover = 의미 툴팁
                    </div>
                    <div style="overflow: auto; max-height: 60vh;">
                        <table>
                            <thead>
                                <tr>
                                    <th data-skey="symbol" data-tip="거래 심볼(USDT 무기한 선물). 예: BTCUSDT">Symbol</th>
                                    <th data-skey="score" class="right" data-tip="롱 진입 적합도 종합 점수(0~100). 추세/세팅/유동성/펀딩/과열/변동성 반영.">Score</th>
                                    <th data-skey="price" class="right" data-tip="현재가(24h 티커 lastPrice). 표시용 참고값.">Price</th>
                                    <th data-skey="setup" data-tip="세팅 상태 태그. (세팅완료=1D OK + 1H Strong + 15m 재탈환+RSI상승)">Setup</th>
                                    <th data-skey="entry" class="right" data-tip="진입 참고가(스캐너): 신호봉 15m 종가. 백테스트는 다음 15m 시가 진입.">EntryRef</th>
                                    <th data-skey="sl" class="right" data-tip="손절(SL): 최근 N개 15m 저점 최저 vs 1H ATR*배수 중 더 타이트한 값(롱 기준 더 높은 SL).">SL</th>
                                    <th data-skey="tp" class="right" data-tip="익절(TP): Entry + RR*(Entry-SL). RR은 백테스트 설정 사용.">TP</th>
                                    <th data-skey="riskPct" class="right" data-tip="리스크 폭(%): (Entry-SL)/Entry * 100.">Risk%</th>
                                    <th data-skey="dailyOk" data-tip="1D 필터: 일봉 종가가 99SMA 위인지 여부.">1D(99SMA)</th>
                                    <th data-skey="trendOk" data-tip="1H 추세: 1H 종가 > EMA50 > EMA200이면 Strong.">1H Trend</th>
                                    <th data-skey="rsi" class="right" data-tip="RSI(15m,14): 신호봉 RSI 값. 기본은 45~65 + 상승을 선호.">RSI(15m)</th>
                                    <th data-skey="funding" class="right" data-tip="마지막 펀딩율(lastFundingRate). 너무 큰 양수면 롱 비용 증가.">Funding</th>
                                    <th data-skey="chg24" class="right" data-tip="최근 24시간 변동률(%). 급등 과열이면 점수 패널티.">24h%</th>
                                    <th data-skey="qv" class="right" data-tip="24h 거래대금(USDT). 유동성 지표.">24h QV</th>
                                    <th data-tip="바이낸스 선물 페이지 링크.">Link</th>
                                </tr>
                            </thead>
                            <tbody id="scanTbody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Backtest Table -->
                <div class="panel tableWrap">
                    <div style="padding: 10px 12px; border-bottom: 1px solid var(--line);" class="small">
                        백테스트 결과(심볼별 요약) / 헤더 클릭 정렬 / 헤더 hover = 의미 툴팁
                    </div>
                    <div style="overflow: auto; max-height: 60vh;">
                        <table>
                            <thead>
                                <tr>
                                    <th data-bkey="symbol" data-tip="심볼(USDT 무기한 선물).">Symbol</th>
                                    <th data-bkey="trades" class="right" data-tip="조건 충족으로 실제로 진입한 트레이드 수.">Trades</th>
                                    <th data-bkey="winrate" class="right" data-tip="승률(%). R>0 비율(시간 종료로 +R도 승리로 처리).">Win%</th>
                                    <th data-bkey="netR" class="right" data-tip="누적 R 합계. (각 트레이드를 1R 기준으로 환산해 합산)">Net R</th>
                                    <th data-bkey="avgR" class="right" data-tip="평균 R. (NetR / Trades)">Avg R</th>
                                    <th data-bkey="pf" class="right" data-tip="Profit Factor = 총이익R / 총손실R(절대값). 1보다 크면 우위.">PF</th>
                                    <th data-bkey="maxDD" class="right" data-tip="Max Drawdown(R). 누적 R 곡선 기준 최대 낙폭.">MaxDD(R)</th>
                                    <th data-bkey="bestR" class="right" data-tip="최고 단일 트레이드 R.">Best R</th>
                                    <th data-bkey="worstR" class="right" data-tip="최악 단일 트레이드 R.">Worst R</th>
                                </tr>
                            </thead>
                            <tbody id="btTbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="footer">
                <div>주의: 이 도구는 “전략 아이디어 검증/시각화” 용도이며 투자 조언이 아닙니다.</div>
            </div>
        </div>

        <div id="thTooltip" class="th-tooltip" role="tooltip"></div>

        <script>
            "use strict";

            const $ = (sel) => document.querySelector(sel);

            const els = {
                maxSymbols: $("#maxSymbols"),
                minQuoteVol: $("#minQuoteVol"),
                filterMode: $("#filterMode"),
                baseUrl: $("#baseUrl"),
                concurrency: $("#concurrency"),
                tempo: $("#tempo"),
                btnScan: $("#btnScan"),
                btnScanStop: $("#btnScanStop"),
                btnScanCsv: $("#btnScanCsv"),
                btnClearCache: $("#btnClearCache"),
                scanStatus: $("#scanStatus"),
                scanProgress: $("#scanProgress"),
                scanShown: $("#scanShown"),
                scanLastRun: $("#scanLastRun"),
                scanTbody: $("#scanTbody"),

                btStart: $("#btStart"),
                btEnd: $("#btEnd"),
                btTopN: $("#btTopN"),
                btRR: $("#btRR"),
                btAtrMult: $("#btAtrMult"),
                btSwingN: $("#btSwingN"),
                btMaxHold: $("#btMaxHold"),
                btTieBreak: $("#btTieBreak"),
                btFundingMode: $("#btFundingMode"),
                btFundingMax: $("#btFundingMax"),
                btConcurrency: $("#btConcurrency"),
                btnBt: $("#btnBt"),
                btnBtStop: $("#btnBtStop"),
                btnBtCsv: $("#btnBtCsv"),
                btStatus: $("#btStatus"),
                btProgress: $("#btProgress"),
                btTrades: $("#btTrades"),
                btWinrate: $("#btWinrate"),
                btNetR: $("#btNetR"),
                btTbody: $("#btTbody"),

                thTooltip: $("#thTooltip"),
            };

            const TEMPO_DELAY_MS = { fast: 0, normal: 80, slow: 180 };
            const CACHE_PREFIX = "binance_recent_kline_cache_v3:";
            const CACHE_MAX_BYTES = 4 * 1024 * 1024;

            const state = {
                scanRunning: false,
                btRunning: false,
                abortScan: false,
                abortBt: false,

                scanRows: [],
                scanSortKey: "score",
                scanSortDir: "desc",

                btRows: [],
                btSortKey: "netR",
                btSortDir: "desc",

                scanTotal: 0,
                scanDone: 0,

                btTotal: 0,
                btDone: 0,
            };

            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }

            function safeFloat(x) {
                const v = Number.parseFloat(x);
                return Number.isFinite(v) ? v : NaN;
            }

            function safeInt(x) {
                const v = Number.parseInt(x, 10);
                return Number.isFinite(v) ? v : NaN;
            }

            function fmtNum(n, digits = 2) {
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString(undefined, { maximumFractionDigits: digits });
            }

            function fmtPct(n, digits = 2) {
                if (!Number.isFinite(n)) return "-";
                const sign = n > 0 ? "+" : "";
                return `${sign}${n.toFixed(digits)}%`;
            }

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function nowString() {
                const d = new Date();
                const yy = d.getFullYear();
                const mm = String(d.getMonth() + 1).padStart(2, "0");
                const dd = String(d.getDate()).padStart(2, "0");
                const hh = String(d.getHours()).padStart(2, "0");
                const mi = String(d.getMinutes()).padStart(2, "0");
                const ss = String(d.getSeconds()).padStart(2, "0");
                return `${yy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
            }

            function intervalToMs(interval) {
                const num = Number.parseInt(interval, 10);
                if (Number.isFinite(num)) {
                    if (interval.endsWith("m")) return num * 60 * 1000;
                    if (interval.endsWith("h")) return num * 60 * 60 * 1000;
                    if (interval.endsWith("d")) return num * 24 * 60 * 60 * 1000;
                    if (interval.endsWith("w")) return num * 7 * 24 * 60 * 60 * 1000;
                }
                if (interval === "1M") return 30 * 24 * 60 * 60 * 1000;
                return 0;
            }

            function nextCandleOpenTimeMs(interval) {
                const ms = intervalToMs(interval);
                if (!ms) return Date.now() + 60 * 1000;
                const now = Date.now();
                const next = Math.floor(now / ms) * ms + ms;
                return next;
            }

            function cacheGet(key) {
                try {
                    const raw = localStorage.getItem(CACHE_PREFIX + key);
                    if (!raw) return null;
                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== "object") return null;
                    if (typeof parsed.validUntil === "number" && Date.now() < parsed.validUntil && Array.isArray(parsed.data)) return parsed.data;
                    return null;
                } catch (_) {
                    return null;
                }
            }

            function cacheSet(key, data, validUntil) {
                try {
                    const payload = JSON.stringify({ validUntil, data });
                    if (payload.length > CACHE_MAX_BYTES) return;
                    localStorage.setItem(CACHE_PREFIX + key, payload);
                } catch (_) {}
            }

            function cacheClearAll() {
                try {
                    const keys = [];
                    for (let i = 0; i < localStorage.length; i += 1) {
                        const k = localStorage.key(i);
                        if (k && k.startsWith(CACHE_PREFIX)) keys.push(k);
                    }
                    keys.forEach((k) => localStorage.removeItem(k));
                } catch (_) {}
            }

            async function fetchJson(url, { abortCheck, retries = 2, retryDelay = 350 } = {}) {
                let lastErr = null;

                for (let i = 0; i <= retries; i += 1) {
                    if (abortCheck && abortCheck()) throw new Error("aborted");

                    try {
                        const res = await fetch(url, { method: "GET" });
                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            const err = new Error(`HTTP ${res.status} ${res.statusText} ${text.slice(0, 120)}`);
                            err.status = res.status;
                            throw err;
                        }
                        return await res.json();
                    } catch (e) {
                        lastErr = e;
                        const status = e && typeof e === "object" ? e.status : null;
                        const shouldRetry = i < retries && (status === 429 || status === 418 || status === 503 || status === 502);
                        if (!shouldRetry) break;
                        await sleep(retryDelay * (i + 1));
                    }
                }
                throw lastErr || new Error("fetch failed");
            }

            async function asyncPool(items, worker, concurrency, delayMs, abortCheck) {
                const results = [];
                let idx = 0;

                const runners = new Array(concurrency).fill(0).map(async () => {
                    while (true) {
                        if (abortCheck && abortCheck()) break;

                        const myIdx = idx;
                        idx += 1;
                        if (myIdx >= items.length) break;

                        try {
                            const out = await worker(items[myIdx], myIdx);
                            results.push(out);
                        } catch (e) {
                            results.push({ __error: true, error: String(e && e.message ? e.message : e) });
                        }

                        if (delayMs > 0) await sleep(delayMs);
                    }
                });

                await Promise.all(runners);
                return results;
            }

            function parseKlines(raw) {
                const openTimes = [];
                const closeTimes = [];
                const opens = [];
                const highs = [];
                const lows = [];
                const closes = [];

                for (let i = 0; i < raw.length; i += 1) {
                    const row = raw[i];
                    openTimes.push(Number(row[0]));
                    opens.push(safeFloat(row[1]));
                    highs.push(safeFloat(row[2]));
                    lows.push(safeFloat(row[3]));
                    closes.push(safeFloat(row[4]));
                    closeTimes.push(Number(row[6]));
                }

                return { openTimes, closeTimes, opens, highs, lows, closes };
            }

            function smaArray(values, period) {
                const out = new Array(values.length).fill(NaN);
                if (values.length < period) return out;
                let sum = 0;
                for (let i = 0; i < values.length; i += 1) {
                    sum += values[i];
                    if (i >= period) sum -= values[i - period];
                    if (i >= period - 1) out[i] = sum / period;
                }
                return out;
            }

            function emaArray(values, period) {
                const out = new Array(values.length).fill(NaN);
                if (values.length < period) return out;

                const k = 2 / (period + 1);
                let sum = 0;
                for (let i = 0; i < period; i += 1) sum += values[i];
                let ema = sum / period;
                out[period - 1] = ema;

                for (let i = period; i < values.length; i += 1) {
                    ema = values[i] * k + ema * (1 - k);
                    out[i] = ema;
                }
                return out;
            }

            function rsiArray(values, period) {
                const out = new Array(values.length).fill(NaN);
                if (values.length < period + 2) return out;

                let gain = 0;
                let loss = 0;

                for (let i = 1; i <= period; i += 1) {
                    const diff = values[i] - values[i - 1];
                    if (diff >= 0) gain += diff;
                    else loss -= diff;
                }

                let avgGain = gain / period;
                let avgLoss = loss / period;

                let rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
                out[period] = 100 - 100 / (1 + rs);

                for (let i = period + 1; i < values.length; i += 1) {
                    const diff = values[i] - values[i - 1];
                    const g = diff > 0 ? diff : 0;
                    const l = diff < 0 ? -diff : 0;

                    avgGain = (avgGain * (period - 1) + g) / period;
                    avgLoss = (avgLoss * (period - 1) + l) / period;

                    rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
                    out[i] = 100 - 100 / (1 + rs);
                }

                return out;
            }

            function atrArray(highs, lows, closes, period) {
                const out = new Array(highs.length).fill(NaN);
                if (highs.length < period + 2) return out;

                const trs = new Array(highs.length).fill(NaN);
                for (let i = 1; i < highs.length; i += 1) {
                    const tr = Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1]));
                    trs[i] = tr;
                }

                let sum = 0;
                let start = 1;
                let end = start + period - 1;
                if (end >= trs.length) return out;

                for (let i = start; i <= end; i += 1) sum += trs[i];
                let atr = sum / period;
                out[end] = atr;

                for (let i = end + 1; i < trs.length; i += 1) {
                    atr = (atr * (period - 1) + trs[i]) / period;
                    out[i] = atr;
                }

                return out;
            }

            function normalize01(val, min, max) {
                if (!Number.isFinite(val) || !Number.isFinite(min) || !Number.isFinite(max) || max <= min) return 0;
                return clamp((val - min) / (max - min), 0, 1);
            }

            function binanceTradeLink(symbol) {
                return `https://www.binance.com/en/futures/${encodeURIComponent(symbol)}`;
            }

            function scanSetupTag(dailyOk, trendStrong, reclaim, rsiOk) {
                if (dailyOk && trendStrong && reclaim && rsiOk) return { text: "세팅완료", cls: "good" };
                if (dailyOk && trendStrong) return { text: "추세우호", cls: "warn" };
                if (reclaim && rsiOk) return { text: "역추세(주의)", cls: "bad" };
                return { text: "관찰", cls: "warn" };
            }

            function computeScore(parts) {
                const w = { daily: 0.22, trend: 0.25, pullback: 0.18, rsi: 0.15, funding: 0.08, liquidity: 0.12 };
                const base =
                    100 *
                    (w.daily * (parts.dailyOk ? 1 : 0) +
                        w.trend * parts.trendStrength +
                        w.pullback * parts.pullback +
                        w.rsi * parts.rsiScore +
                        w.funding * parts.fundingScore +
                        w.liquidity * parts.liq);

                const penalty = 100 * (0.10 * parts.volPenalty + 0.08 * parts.overheatPenalty);
                return clamp(base - penalty, 0, 100);
            }

            function pickLastClosedIndex(klinesParsed) {
                const n = klinesParsed.openTimes.length;
                if (n < 3) return n - 1;
                const lastCloseTime = klinesParsed.closeTimes[n - 1];
                const now = Date.now();
                if (now < lastCloseTime) return n - 2;
                return n - 1;
            }

            async function getExchangeInfo(baseUrl, abortCheck) {
                return await fetchJson(`${baseUrl}/fapi/v1/exchangeInfo`, { abortCheck });
            }

            async function getTicker24h(baseUrl, abortCheck) {
                return await fetchJson(`${baseUrl}/fapi/v1/ticker/24hr`, { abortCheck });
            }

            async function getPremiumIndexAll(baseUrl, abortCheck) {
                return await fetchJson(`${baseUrl}/fapi/v1/premiumIndex`, { abortCheck });
            }

            async function getKlinesRecent(baseUrl, symbol, interval, limit, abortCheck) {
                const cacheKey = `${symbol}:${interval}:${limit}`;
                const cached = cacheGet(cacheKey);
                if (cached) return cached;

                const url = `${baseUrl}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`;
                const data = await fetchJson(url, { abortCheck });

                const validUntil = nextCandleOpenTimeMs(interval) + 500;
                cacheSet(cacheKey, data, validUntil);

                return data;
            }

            async function fetchAllKlinesRange(baseUrl, symbol, interval, startTime, endTime, abortCheck) {
                const limit = 1500;
                const out = [];
                let cursor = startTime;
                let guard = 0;
                const stepMs = intervalToMs(interval);

                while (cursor < endTime) {
                    if (abortCheck && abortCheck()) throw new Error("aborted");
                    guard += 1;
                    if (guard > 20000) break;

                    const url =
                        `${baseUrl}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}` +
                        `&interval=${encodeURIComponent(interval)}` +
                        `&startTime=${encodeURIComponent(cursor)}` +
                        `&endTime=${encodeURIComponent(endTime)}` +
                        `&limit=${encodeURIComponent(limit)}`;

                    const chunk = await fetchJson(url, { abortCheck, retries: 3, retryDelay: 450 });
                    if (!Array.isArray(chunk) || chunk.length === 0) break;

                    for (let i = 0; i < chunk.length; i += 1) out.push(chunk[i]);

                    const lastOpenTime = Number(chunk[chunk.length - 1][0]);
                    const nextCursor = lastOpenTime + stepMs;

                    if (!Number.isFinite(lastOpenTime) || nextCursor <= cursor) break;
                    cursor = nextCursor;

                    if (chunk.length < limit) break;
                }

                return out;
            }

            async function fetchAllFundingRates(baseUrl, symbol, startTime, endTime, abortCheck) {
                const limit = 1000;
                const out = [];
                let cursor = startTime;
                let guard = 0;

                while (cursor <= endTime) {
                    if (abortCheck && abortCheck()) throw new Error("aborted");
                    guard += 1;
                    if (guard > 5000) break;

                    const url =
                        `${baseUrl}/fapi/v1/fundingRate?symbol=${encodeURIComponent(symbol)}` +
                        `&startTime=${encodeURIComponent(cursor)}` +
                        `&endTime=${encodeURIComponent(endTime)}` +
                        `&limit=${encodeURIComponent(limit)}`;

                    const chunk = await fetchJson(url, { abortCheck, retries: 3, retryDelay: 450 });
                    if (!Array.isArray(chunk) || chunk.length === 0) break;

                    for (let i = 0; i < chunk.length; i += 1) out.push(chunk[i]);

                    const last = chunk[chunk.length - 1];
                    const lastTime = Number(last && last.fundingTime ? last.fundingTime : NaN);
                    if (!Number.isFinite(lastTime) || lastTime <= cursor) break;

                    cursor = lastTime + 1;
                    if (chunk.length < limit) break;
                }

                return out;
            }

            function fundingRateAt(fundingRows, timeMs) {
                if (!Array.isArray(fundingRows) || fundingRows.length === 0) return NaN;

                let lo = 0;
                let hi = fundingRows.length - 1;
                let ans = -1;

                while (lo <= hi) {
                    const mid = (lo + hi) >> 1;
                    const t = Number(fundingRows[mid].fundingTime);
                    if (Number.isFinite(t) && t <= timeMs) {
                        ans = mid;
                        lo = mid + 1;
                    } else {
                        hi = mid - 1;
                    }
                }

                if (ans < 0) return NaN;
                const r = safeFloat(fundingRows[ans].fundingRate);
                return r;
            }

            function buildUniverse(exchangeInfo, tickers, premiumAll, minQuoteVol, maxSymbols) {
                const perpUsdtSymbols = new Set(
                    (exchangeInfo.symbols || [])
                        .filter((s) => s && s.status === "TRADING" && s.contractType === "PERPETUAL" && s.quoteAsset === "USDT")
                        .map((s) => s.symbol)
                );

                const tickerMap = new Map();
                for (let i = 0; i < tickers.length; i += 1) {
                    const t = tickers[i];
                    if (t && t.symbol) tickerMap.set(t.symbol, t);
                }

                const fundingMap = new Map();
                for (let i = 0; i < premiumAll.length; i += 1) {
                    const p = premiumAll[i];
                    if (!p || !p.symbol) continue;
                    fundingMap.set(p.symbol, safeFloat(p.lastFundingRate));
                }

                const universe = [];
                for (const sym of perpUsdtSymbols) {
                    const t = tickerMap.get(sym);
                    if (!t) continue;

                    const qv = safeFloat(t.quoteVolume);
                    const price = safeFloat(t.lastPrice);
                    const chg24 = safeFloat(t.priceChangePercent);
                    if (!Number.isFinite(qv) || !Number.isFinite(price) || !Number.isFinite(chg24)) continue;
                    if (qv < minQuoteVol) continue;

                    const funding = fundingMap.has(sym) ? fundingMap.get(sym) : NaN;
                    universe.push({ symbol: sym, qv, price, chg24, funding });
                }

                universe.sort((a, b) => b.qv - a.qv);
                const picked = universe.slice(0, maxSymbols);

                const logQvs = picked.map((x) => Math.log10(x.qv + 1));
                const minLog = Math.min(...logQvs);
                const maxLog = Math.max(...logQvs);

                return picked.map((x) => ({
                    ...x,
                    qvNorm: normalize01(Math.log10(x.qv + 1), minLog, maxLog),
                }));
            }

            function renderScanTable() {
                const mode = els.filterMode.value;
                let rows = state.scanRows.slice();

                if (mode === "trend") rows = rows.filter((r) => r.dailyOk && r.trendStrong);
                else if (mode === "setup") rows = rows.filter((r) => r.dailyOk && r.trendStrong && r.reclaim && r.rsiOk);

                const dir = state.scanSortDir === "asc" ? 1 : -1;
                const key = state.scanSortKey;

                rows.sort((a, b) => {
                    const va = a[key];
                    const vb = b[key];
                    if (typeof va === "string" && typeof vb === "string") return va.localeCompare(vb) * dir;
                    const na = Number.isFinite(va) ? va : -Infinity;
                    const nb = Number.isFinite(vb) ? vb : -Infinity;
                    return (na - nb) * dir;
                });

                els.scanTbody.innerHTML = "";
                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    const tag = scanSetupTag(r.dailyOk, r.trendStrong, r.reclaim, r.rsiOk);
                    const dailyBadge = r.dailyOk ? `<span class="badge good">OK</span>` : `<span class="badge bad">NO</span>`;
                    const trendBadge = r.trendStrong ? `<span class="badge good">Strong</span>` : `<span class="badge bad">Weak</span>`;
                    const fundingCls = !Number.isFinite(r.funding) ? "warn" : r.funding <= 0 ? "good" : r.funding <= 0.0003 ? "warn" : "bad";

                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td class="mono"><strong>${r.symbol}</strong></td>
                        <td class="right mono"><strong>${fmtNum(r.score, 1)}</strong></td>
                        <td class="right mono">${fmtNum(r.price, 6)}</td>
                        <td><span class="badge ${tag.cls}">${tag.text}</span></td>
                        <td class="right mono">${fmtNum(r.entry, 6)}</td>
                        <td class="right mono">${fmtNum(r.sl, 6)}</td>
                        <td class="right mono">${fmtNum(r.tp, 6)}</td>
                        <td class="right mono">${fmtNum(r.riskPct, 2)}%</td>
                        <td>${dailyBadge}</td>
                        <td>${trendBadge}</td>
                        <td class="right mono">${fmtNum(r.rsi, 1)}</td>
                        <td class="right mono"><span class="badge ${fundingCls}">${Number.isFinite(r.funding) ? (r.funding * 100).toFixed(4) + "%" : "-"}</span></td>
                        <td class="right mono">${fmtPct(r.chg24, 2)}</td>
                        <td class="right mono">${fmtNum(r.qv, 0)}</td>
                        <td><a class="badge" href="${binanceTradeLink(r.symbol)}" target="_blank" rel="noreferrer">Binance</a></td>
                    `;
                    els.scanTbody.appendChild(tr);
                }

                els.scanShown.textContent = String(rows.length);
                els.btnScanCsv.disabled = rows.length === 0;
            }

            function renderBtTable() {
                const dir = state.btSortDir === "asc" ? 1 : -1;
                const key = state.btSortKey;

                const rows = state.btRows.slice();
                rows.sort((a, b) => {
                    const va = a[key];
                    const vb = b[key];
                    if (typeof va === "string" && typeof vb === "string") return va.localeCompare(vb) * dir;
                    const na = Number.isFinite(va) ? va : -Infinity;
                    const nb = Number.isFinite(vb) ? vb : -Infinity;
                    return (na - nb) * dir;
                });

                els.btTbody.innerHTML = "";
                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td class="mono"><strong>${r.symbol}</strong></td>
                        <td class="right mono">${fmtNum(r.trades, 0)}</td>
                        <td class="right mono">${fmtNum(r.winrate, 1)}%</td>
                        <td class="right mono"><strong>${fmtNum(r.netR, 2)}</strong></td>
                        <td class="right mono">${fmtNum(r.avgR, 2)}</td>
                        <td class="right mono">${Number.isFinite(r.pf) ? fmtNum(r.pf, 2) : "-"}</td>
                        <td class="right mono">${fmtNum(r.maxDD, 2)}</td>
                        <td class="right mono">${fmtNum(r.bestR, 2)}</td>
                        <td class="right mono">${fmtNum(r.worstR, 2)}</td>
                    `;
                    els.btTbody.appendChild(tr);
                }

                els.btnBtCsv.disabled = rows.length === 0;
            }

            /* ===== Tooltip (body-fixed) ===== */
            function tooltipShow(text, clientX, clientY) {
                if (!text) return;
                els.thTooltip.textContent = text;
                els.thTooltip.classList.add("is-on");

                const pad = 12;
                let x = clientX + 14;
                let y = clientY - 12;

                els.thTooltip.style.left = `${x}px`;
                els.thTooltip.style.top = `${y}px`;

                const rect = els.thTooltip.getBoundingClientRect();
                const vw = window.innerWidth;
                const vh = window.innerHeight;

                if (x + rect.width + pad > vw) x = Math.max(pad, vw - rect.width - pad);
                if (y + rect.height + pad > vh) y = Math.max(pad, vh - rect.height - pad);
                if (y < pad) y = pad;

                els.thTooltip.style.left = `${x}px`;
                els.thTooltip.style.top = `${y}px`;
            }

            function tooltipHide() {
                els.thTooltip.classList.remove("is-on");
            }

            function attachHeaderTooltips() {
                const ths = document.querySelectorAll("thead th[data-tip]");
                ths.forEach((th) => {
                    th.addEventListener("pointerenter", (e) => {
                        tooltipShow(th.getAttribute("data-tip") || "", e.clientX, e.clientY);
                    });
                    th.addEventListener("pointermove", (e) => {
                        if (!els.thTooltip.classList.contains("is-on")) return;
                        tooltipShow(th.getAttribute("data-tip") || "", e.clientX, e.clientY);
                    });
                    th.addEventListener("pointerleave", () => {
                        tooltipHide();
                    });
                });

                window.addEventListener("scroll", tooltipHide, { passive: true });
                window.addEventListener("blur", tooltipHide);
            }
            /* ===== /Tooltip ===== */

            function attachHeaderSort() {
                document.querySelectorAll("thead th[data-skey]").forEach((th) => {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-skey");
                        if (!key) return;

                        if (state.scanSortKey === key) state.scanSortDir = state.scanSortDir === "desc" ? "asc" : "desc";
                        else {
                            state.scanSortKey = key;
                            state.scanSortDir = key === "symbol" ? "asc" : "desc";
                        }
                        renderScanTable();
                    });
                });

                document.querySelectorAll("thead th[data-bkey]").forEach((th) => {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-bkey");
                        if (!key) return;

                        if (state.btSortKey === key) state.btSortDir = state.btSortDir === "desc" ? "asc" : "desc";
                        else {
                            state.btSortKey = key;
                            state.btSortDir = key === "symbol" ? "asc" : "desc";
                        }
                        renderBtTable();
                    });
                });
            }

            function toCsvScan(rows) {
                const header = ["symbol", "score", "price", "setup", "entryRef", "sl", "tp", "riskPct", "dailyOk", "trendStrong", "rsi15m", "funding", "chg24", "quoteVolume"];
                const lines = [header.join(",")];

                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    const tag = scanSetupTag(r.dailyOk, r.trendStrong, r.reclaim, r.rsiOk).text;
                    lines.push(
                        [
                            r.symbol,
                            Number.isFinite(r.score) ? r.score.toFixed(2) : "",
                            Number.isFinite(r.price) ? r.price : "",
                            tag,
                            Number.isFinite(r.entry) ? r.entry : "",
                            Number.isFinite(r.sl) ? r.sl : "",
                            Number.isFinite(r.tp) ? r.tp : "",
                            Number.isFinite(r.riskPct) ? r.riskPct.toFixed(4) : "",
                            r.dailyOk ? "1" : "0",
                            r.trendStrong ? "1" : "0",
                            Number.isFinite(r.rsi) ? r.rsi.toFixed(2) : "",
                            Number.isFinite(r.funding) ? r.funding : "",
                            Number.isFinite(r.chg24) ? r.chg24.toFixed(4) : "",
                            Number.isFinite(r.qv) ? Math.round(r.qv) : "",
                        ].join(",")
                    );
                }
                return lines.join("\n");
            }

            function toCsvBt(rows) {
                const header = ["symbol", "trades", "winrate", "netR", "avgR", "pf", "maxDD", "bestR", "worstR"];
                const lines = [header.join(",")];

                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    lines.push(
                        [
                            r.symbol,
                            r.trades,
                            Number.isFinite(r.winrate) ? r.winrate.toFixed(2) : "",
                            Number.isFinite(r.netR) ? r.netR.toFixed(4) : "",
                            Number.isFinite(r.avgR) ? r.avgR.toFixed(4) : "",
                            Number.isFinite(r.pf) ? r.pf.toFixed(4) : "",
                            Number.isFinite(r.maxDD) ? r.maxDD.toFixed(4) : "",
                            Number.isFinite(r.bestR) ? r.bestR.toFixed(4) : "",
                            Number.isFinite(r.worstR) ? r.worstR.toFixed(4) : "",
                        ].join(",")
                    );
                }
                return lines.join("\n");
            }

            async function copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch (_) {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand("copy");
                    ta.remove();
                    return true;
                }
            }

            function parseDateToMs(dateStr, endOfDay) {
                if (!dateStr) return NaN;
                const [y, m, d] = dateStr.split("-").map((x) => Number.parseInt(x, 10));
                if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return NaN;
                if (endOfDay) return new Date(y, m - 1, d, 23, 59, 59, 999).getTime();
                return new Date(y, m - 1, d, 0, 0, 0, 0).getTime();
            }

            async function runScan() {
                state.abortScan = false;
                state.scanRunning = true;
                state.scanRows = [];
                state.scanTotal = 0;
                state.scanDone = 0;

                els.btnScan.disabled = true;
                els.btnScanStop.disabled = false;
                els.btnScanCsv.disabled = true;
                els.scanStatus.textContent = "초기 로딩...";

                const baseUrl = String(els.baseUrl.value || "").trim().replace(/\/+$/, "");
                const maxSymbols = clamp(safeInt(els.maxSymbols.value) || 80, 10, 200);
                const minQuoteVol = Math.max(0, safeFloat(els.minQuoteVol.value) || 0);
                const concurrency = clamp(safeInt(els.concurrency.value) || 8, 1, 20);
                const tempo = els.tempo.value;
                const delayMs = TEMPO_DELAY_MS[tempo] ?? 80;

                const abortCheck = () => state.abortScan;

                const [exchangeInfo, tickers, premiumAll] = await Promise.all([
                    getExchangeInfo(baseUrl, abortCheck),
                    getTicker24h(baseUrl, abortCheck),
                    getPremiumIndexAll(baseUrl, abortCheck),
                ]);

                const universe = buildUniverse(exchangeInfo, tickers, premiumAll, minQuoteVol, maxSymbols);

                state.scanTotal = universe.length;
                els.scanProgress.textContent = `0 / ${state.scanTotal}`;
                els.scanShown.textContent = "0";
                renderScanTable();

                els.scanStatus.textContent = "캔들 수집/계산 중...";

                const rr = clamp(safeFloat(els.btRR.value) || 2.0, 0.5, 10);
                const atrMult = clamp(safeFloat(els.btAtrMult.value) || 1.2, 0.5, 5);
                const swingN = clamp(safeInt(els.btSwingN.value) || 12, 3, 60);

                const worker = async (item) => {
                    const symbol = item.symbol;

                    const [raw15, raw1h, raw1d] = await Promise.all([
                        getKlinesRecent(baseUrl, symbol, "15m", 230, abortCheck),
                        getKlinesRecent(baseUrl, symbol, "1h", 320, abortCheck),
                        getKlinesRecent(baseUrl, symbol, "1d", 210, abortCheck),
                    ]);

                    const k15 = parseKlines(raw15);
                    const k1h = parseKlines(raw1h);
                    const k1d = parseKlines(raw1d);

                    const idx15 = pickLastClosedIndex(k15);
                    const idx1h = pickLastClosedIndex(k1h);
                    const idx1d = pickLastClosedIndex(k1d);

                    const ema20_15 = emaArray(k15.closes, 20);
                    const rsi15 = rsiArray(k15.closes, 14);

                    const ema50_1h = emaArray(k1h.closes, 50);
                    const ema200_1h = emaArray(k1h.closes, 200);
                    const atr14_1h = atrArray(k1h.highs, k1h.lows, k1h.closes, 14);

                    const sma99_1d = smaArray(k1d.closes, 99);

                    const close15 = k15.closes[idx15];
                    const prevClose15 = k15.closes[idx15 - 1];
                    const e15 = ema20_15[idx15];
                    const prevE15 = ema20_15[idx15 - 1];
                    const rsiNow = rsi15[idx15];
                    const rsiPrev = rsi15[idx15 - 1];

                    const dailyOk = Number.isFinite(sma99_1d[idx1d]) && k1d.closes[idx1d] > sma99_1d[idx1d];

                    const trendStrong =
                        Number.isFinite(ema50_1h[idx1h]) &&
                        Number.isFinite(ema200_1h[idx1h]) &&
                        k1h.closes[idx1h] > ema50_1h[idx1h] &&
                        ema50_1h[idx1h] > ema200_1h[idx1h];

                    const reclaim = Number.isFinite(e15) && Number.isFinite(prevE15) && close15 > e15 && prevClose15 <= prevE15;

                    const rsiOk = Number.isFinite(rsiNow) && Number.isFinite(rsiPrev) && rsiNow >= 45 && rsiNow <= 65 && rsiNow > rsiPrev;

                    const pullbackDist = Number.isFinite(e15) && e15 > 0 ? Math.abs(close15 - e15) / e15 : NaN;
                    const pullback = Number.isFinite(pullbackDist) ? clamp(1 - pullbackDist / 0.02, 0, 1) : 0;

                    let trendStrength = 0.1;
                    if (trendStrong) trendStrength = 1;
                    else if (Number.isFinite(ema200_1h[idx1h]) && k1h.closes[idx1h] > ema200_1h[idx1h]) trendStrength = 0.6;

                    let rsiScore = 0.25;
                    if (Number.isFinite(rsiNow) && Number.isFinite(rsiPrev)) {
                        if (rsiNow >= 45 && rsiNow <= 60) rsiScore = rsiNow > rsiPrev ? 1 : 0.75;
                        else if (rsiNow > 60 && rsiNow <= 70) rsiScore = rsiNow > rsiPrev ? 0.55 : 0.4;
                        else if (rsiNow > 70) rsiScore = 0.15;
                        else rsiScore = 0.25;
                    }

                    const funding = Number.isFinite(item.funding) ? item.funding : NaN;
                    let fundingScore = 0.5;
                    if (Number.isFinite(funding)) {
                        if (funding <= 0) fundingScore = 1;
                        else fundingScore = clamp(1 - funding / 0.001, 0, 1);
                    }

                    let volPenalty = 0;
                    if (Number.isFinite(atr14_1h[idx1h]) && k1h.closes[idx1h] > 0) {
                        const atrPct = atr14_1h[idx1h] / k1h.closes[idx1h];
                        volPenalty = clamp((atrPct - 0.025) / 0.08, 0, 1);
                    }

                    const overheatPenalty = clamp(((Number.isFinite(item.chg24) ? item.chg24 : 0) - 15) / 25, 0, 1);

                    const score = computeScore({
                        dailyOk,
                        trendStrength,
                        pullback,
                        rsiScore,
                        fundingScore,
                        liq: item.qvNorm,
                        volPenalty,
                        overheatPenalty,
                    });

                    const entry = close15;

                    let swingLow = NaN;
                    if (idx15 - (swingN - 1) >= 0) {
                        let minL = Infinity;
                        for (let i = idx15 - (swingN - 1); i <= idx15; i += 1) {
                            const l = k15.lows[i];
                            if (Number.isFinite(l)) minL = Math.min(minL, l);
                        }
                        swingLow = Number.isFinite(minL) ? minL : NaN;
                    }

                    const atr1h = atr14_1h[idx1h];
                    const slFromAtr = Number.isFinite(atr1h) ? entry - atrMult * atr1h : NaN;
                    const slFromSwing = Number.isFinite(swingLow) ? swingLow * (1 - 0.0005) : NaN;

                    const candidates = [];
                    if (Number.isFinite(slFromAtr) && slFromAtr < entry) candidates.push(slFromAtr);
                    if (Number.isFinite(slFromSwing) && slFromSwing < entry) candidates.push(slFromSwing);

                    // 롱에서 "타이트" = entry에 더 가까운(더 높은) SL
                    const sl = candidates.length > 0 ? Math.max(...candidates) : NaN;

                    const risk = Number.isFinite(sl) ? entry - sl : NaN;
                    const tp = Number.isFinite(risk) && risk > 0 ? entry + rr * risk : NaN;
                    const riskPct = Number.isFinite(risk) && entry > 0 ? (risk / entry) * 100 : NaN;

                    return {
                        symbol,
                        score,
                        price: item.price,
                        qv: item.qv,
                        chg24: item.chg24,
                        funding,

                        dailyOk,
                        trendStrong,
                        reclaim,
                        rsiOk,

                        rsi: rsiNow,

                        entry,
                        sl,
                        tp,
                        riskPct,
                    };
                };

                const abortCheck2 = () => state.abortScan;

                const results = await asyncPool(
                    universe,
                    async (it) => {
                        const row = await worker(it);

                        state.scanDone += 1;
                        els.scanProgress.textContent = `${state.scanDone} / ${state.scanTotal}`;

                        state.scanRows.push(row);
                        state.scanSortKey = "score";
                        state.scanSortDir = "desc";
                        renderScanTable();

                        return row;
                    },
                    concurrency,
                    delayMs,
                    abortCheck2
                );

                state.scanRows = results.filter((r) => r && !r.__error && r.symbol);
                state.scanSortKey = "score";
                state.scanSortDir = "desc";

                els.scanLastRun.textContent = nowString();
                els.scanStatus.textContent = state.abortScan ? "중지됨" : "완료";
                renderScanTable();
            }

            function computeMaxDDFromEquityRs(rs) {
                let peak = 0;
                let eq = 0;
                let maxDD = 0;
                for (let i = 0; i < rs.length; i += 1) {
                    eq += rs[i];
                    if (eq > peak) peak = eq;
                    const dd = peak - eq;
                    if (dd > maxDD) maxDD = dd;
                }
                return maxDD;
            }

            async function runBacktest() {
                state.abortBt = false;
                state.btRunning = true;
                state.btRows = [];
                state.btTotal = 0;
                state.btDone = 0;

                els.btnBt.disabled = true;
                els.btnBtStop.disabled = false;
                els.btnBtCsv.disabled = true;

                els.btStatus.textContent = "준비 중...";
                els.btProgress.textContent = `0 / 0`;
                els.btTrades.textContent = "0";
                els.btWinrate.textContent = "-";
                els.btNetR.textContent = "-";

                const baseUrl = String(els.baseUrl.value || "").trim().replace(/\/+$/, "");
                const startMs = parseDateToMs(els.btStart.value, false);
                const endMs = parseDateToMs(els.btEnd.value, true);

                if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) {
                    els.btStatus.textContent = "날짜가 올바르지 않음";
                    return;
                }

                const topN = clamp(safeInt(els.btTopN.value) || 20, 1, 80);
                const rr = clamp(safeFloat(els.btRR.value) || 2.0, 0.5, 10);
                const atrMult = clamp(safeFloat(els.btAtrMult.value) || 1.2, 0.5, 5);
                const swingN = clamp(safeInt(els.btSwingN.value) || 12, 3, 60);
                const maxHold = clamp(safeInt(els.btMaxHold.value) || 96, 4, 2000);
                const tieBreak = els.btTieBreak.value === "tp" ? "tp" : "sl";
                const fundingMode = els.btFundingMode.value === "on" ? "on" : "off";
                const fundingMax = Math.max(0, safeFloat(els.btFundingMax.value) || 0);
                const concurrency = clamp(safeInt(els.btConcurrency.value) || 3, 1, 10);

                const abortCheck = () => state.abortBt;

                // 스캔 결과가 없으면 자동으로 스캔부터 수행
                if (!Array.isArray(state.scanRows) || state.scanRows.length === 0) {
                    els.btStatus.textContent = "스캔 결과 없음 → 스캔 먼저 실행 중...";
                    await runScan();
                    if (abortCheck()) {
                        els.btStatus.textContent = "중지됨";
                        return;
                    }
                }

                const sorted = state.scanRows
                    .slice()
                    .filter((r) => r && r.symbol)
                    .sort((a, b) => (Number.isFinite(b.score) ? b.score : -Infinity) - (Number.isFinite(a.score) ? a.score : -Infinity));

                const targets = sorted.slice(0, topN).map((r) => r.symbol);

                state.btTotal = targets.length;
                state.btDone = 0;
                els.btProgress.textContent = `0 / ${state.btTotal}`;

                els.btStatus.textContent = "데이터 수집/시뮬레이션 중...";

                const delayMs = 120; // 백테스트는 조금 더 보수적으로

                const worker = async (symbol) => {
                    const lookback15 = Math.max(240, swingN + 80) * intervalToMs("15m");
                    const lookback1h = 360 * intervalToMs("1h");
                    const lookback1d = 140 * intervalToMs("1d");
                    const forward15 = (maxHold + 5) * intervalToMs("15m");

                    const k15Start = startMs - lookback15;
                    const k1hStart = startMs - lookback1h;
                    const k1dStart = startMs - lookback1d;

                    const k15End = endMs + forward15;
                    const k1hEnd = endMs;
                    const k1dEnd = endMs;

                    const [raw15, raw1h, raw1d] = await Promise.all([
                        fetchAllKlinesRange(baseUrl, symbol, "15m", k15Start, k15End, abortCheck),
                        fetchAllKlinesRange(baseUrl, symbol, "1h", k1hStart, k1hEnd, abortCheck),
                        fetchAllKlinesRange(baseUrl, symbol, "1d", k1dStart, k1dEnd, abortCheck),
                    ]);

                    let fundingRows = [];
                    if (fundingMode === "on") {
                        const fStart = startMs - 10 * intervalToMs("1d");
                        fundingRows = await fetchAllFundingRates(baseUrl, symbol, fStart, endMs, abortCheck);
                        fundingRows.sort((a, b) => Number(a.fundingTime) - Number(b.fundingTime));
                    }

                    const k15 = parseKlines(raw15);
                    const k1h = parseKlines(raw1h);
                    const k1d = parseKlines(raw1d);

                    if (k15.opens.length < 50 || k1h.opens.length < 210 || k1d.opens.length < 120) {
                        return {
                            symbol,
                            trades: 0,
                            winrate: 0,
                            netR: 0,
                            avgR: 0,
                            pf: NaN,
                            maxDD: 0,
                            bestR: NaN,
                            worstR: NaN,
                        };
                    }

                    const ema20_15 = emaArray(k15.closes, 20);
                    const rsi15 = rsiArray(k15.closes, 14);

                    const ema50_1h = emaArray(k1h.closes, 50);
                    const ema200_1h = emaArray(k1h.closes, 200);
                    const atr14_1h = atrArray(k1h.highs, k1h.lows, k1h.closes, 14);

                    const sma99_1d = smaArray(k1d.closes, 99);

                    // time alignment pointer (1h, 1d)
                    let p1h = 0;
                    let p1d = 0;

                    const tradesR = [];
                    let trades = 0;
                    let wins = 0;
                    let sumPos = 0;
                    let sumNeg = 0;
                    let bestR = -Infinity;
                    let worstR = Infinity;

                    for (let i = 1; i < k15.opens.length - 2; i += 1) {
                        if (abortCheck()) break;

                        const closeTime15 = k15.closeTimes[i];
                        const openTime15 = k15.openTimes[i];

                        // 백테스트 구간의 "신호봉"만 체크
                        if (closeTime15 < startMs || closeTime15 > endMs) continue;
                        if (!Number.isFinite(openTime15) || !Number.isFinite(closeTime15)) continue;

                        // move pointer to latest 1h closeTime <= 15m closeTime
                        while (p1h + 1 < k1h.closeTimes.length && k1h.closeTimes[p1h + 1] <= closeTime15) p1h += 1;
                        while (p1d + 1 < k1d.closeTimes.length && k1d.closeTimes[p1d + 1] <= closeTime15) p1d += 1;

                        const idx1h = p1h;
                        const idx1d = p1d;

                        const dailyOk = Number.isFinite(sma99_1d[idx1d]) && k1d.closes[idx1d] > sma99_1d[idx1d];

                        const trendStrong =
                            Number.isFinite(ema50_1h[idx1h]) &&
                            Number.isFinite(ema200_1h[idx1h]) &&
                            k1h.closes[idx1h] > ema50_1h[idx1h] &&
                            ema50_1h[idx1h] > ema200_1h[idx1h];

                        const close = k15.closes[i];
                        const prevClose = k15.closes[i - 1];
                        const e = ema20_15[i];
                        const prevE = ema20_15[i - 1];

                        const reclaim = Number.isFinite(e) && Number.isFinite(prevE) && close > e && prevClose <= prevE;

                        const rsiNow = rsi15[i];
                        const rsiPrev = rsi15[i - 1];
                        const rsiOk = Number.isFinite(rsiNow) && Number.isFinite(rsiPrev) && rsiNow >= 45 && rsiNow <= 65 && rsiNow > rsiPrev;

                        if (!(dailyOk && trendStrong && reclaim && rsiOk)) continue;

                        // entry = next 15m open
                        const entryIdx = i + 1;
                        const entryTime = k15.openTimes[entryIdx];
                        const entryPrice = k15.opens[entryIdx];
                        if (!Number.isFinite(entryTime) || !Number.isFinite(entryPrice) || entryPrice <= 0) continue;

                        if (fundingMode === "on") {
                            const fr = fundingRateAt(fundingRows, entryTime);
                            if (Number.isFinite(fr) && fr > fundingMax) continue;
                        }

                        // swing low (signal bar 포함, 직전 N개)
                        if (i - (swingN - 1) < 0) continue;

                        let swingLow = Infinity;
                        for (let j = i - (swingN - 1); j <= i; j += 1) {
                            const l = k15.lows[j];
                            if (Number.isFinite(l)) swingLow = Math.min(swingLow, l);
                        }
                        if (!Number.isFinite(swingLow) || swingLow === Infinity) continue;

                        const slFromSwing = swingLow * (1 - 0.0005);
                        const atr = atr14_1h[idx1h];
                        const slFromAtr = Number.isFinite(atr) ? entryPrice - atrMult * atr : NaN;

                        const slCandidates = [];
                        if (Number.isFinite(slFromSwing) && slFromSwing < entryPrice) slCandidates.push(slFromSwing);
                        if (Number.isFinite(slFromAtr) && slFromAtr < entryPrice) slCandidates.push(slFromAtr);

                        if (slCandidates.length === 0) continue;

                        // 롱에서 "타이트" = 더 높은 SL (entry에 가까움)
                        const sl = Math.max(...slCandidates);
                        const risk = entryPrice - sl;
                        if (!Number.isFinite(risk) || risk <= 0) continue;

                        const tp = entryPrice + rr * risk;

                        let exitIdx = -1;
                        let outcome = "TIME";
                        let exitPrice = k15.closes[Math.min(entryIdx + maxHold, k15.closes.length - 1)];

                        const lastIdx = Math.min(entryIdx + maxHold, k15.closes.length - 1);

                        for (let j = entryIdx; j <= lastIdx; j += 1) {
                            const hi = k15.highs[j];
                            const lo = k15.lows[j];
                            if (!Number.isFinite(hi) || !Number.isFinite(lo)) continue;

                            const hitSL = lo <= sl;
                            const hitTP = hi >= tp;

                            if (hitSL && hitTP) {
                                outcome = tieBreak === "tp" ? "TP" : "SL";
                                exitIdx = j;
                                exitPrice = outcome === "TP" ? tp : sl;
                                break;
                            }

                            if (hitSL) {
                                outcome = "SL";
                                exitIdx = j;
                                exitPrice = sl;
                                break;
                            }

                            if (hitTP) {
                                outcome = "TP";
                                exitIdx = j;
                                exitPrice = tp;
                                break;
                            }
                        }

                        // TIME 종료면 lastIdx에서 종가로 처리
                        if (exitIdx < 0) {
                            exitIdx = lastIdx;
                            outcome = "TIME";
                            exitPrice = k15.closes[exitIdx];
                        }

                        const R = (exitPrice - entryPrice) / risk;

                        trades += 1;
                        tradesR.push(R);

                        if (R > 0) wins += 1;
                        if (R > 0) sumPos += R;
                        else sumNeg += R;

                        if (R > bestR) bestR = R;
                        if (R < worstR) worstR = R;

                        // 포지션 중복 방지: 청산될 때까지 다음 신호는 스킵
                        i = Math.max(i, exitIdx);
                    }

                    const netR = tradesR.reduce((a, b) => a + b, 0);
                    const avgR = trades > 0 ? netR / trades : 0;
                    const winrate = trades > 0 ? (wins / trades) * 100 : 0;

                    const pf = sumNeg < 0 ? sumPos / Math.abs(sumNeg) : (sumPos > 0 ? Infinity : NaN);
                    const maxDD = computeMaxDDFromEquityRs(tradesR);

                    return {
                        symbol,
                        trades,
                        winrate,
                        netR,
                        avgR,
                        pf,
                        maxDD,
                        bestR: bestR === -Infinity ? NaN : bestR,
                        worstR: worstR === Infinity ? NaN : worstR,
                    };
                };

                const results = await asyncPool(
                    targets,
                    async (sym) => {
                        const row = await worker(sym);

                        state.btDone += 1;
                        els.btProgress.textContent = `${state.btDone} / ${state.btTotal}`;

                        state.btRows.push(row);
                        state.btSortKey = "netR";
                        state.btSortDir = "desc";
                        renderBtTable();

                        // summary update
                        let totalTrades = 0;
                        let totalWins = 0;
                        let totalNetR = 0;

                        for (let i = 0; i < state.btRows.length; i += 1) {
                            const r = state.btRows[i];
                            totalTrades += r.trades;
                            totalNetR += r.netR;
                            totalWins += r.trades > 0 ? Math.round((r.winrate / 100) * r.trades) : 0;
                        }

                        els.btTrades.textContent = String(totalTrades);
                        els.btNetR.textContent = Number.isFinite(totalNetR) ? totalNetR.toFixed(2) : "-";
                        els.btWinrate.textContent = totalTrades > 0 ? ((totalWins / totalTrades) * 100).toFixed(1) + "%" : "-";

                        return row;
                    },
                    concurrency,
                    delayMs,
                    abortCheck
                );

                state.btRows = results.filter((r) => r && !r.__error && r.symbol);
                state.btSortKey = "netR";
                state.btSortDir = "desc";

                // final summary
                let totalTrades = 0;
                let totalWins = 0;
                let totalNetR = 0;

                for (let i = 0; i < state.btRows.length; i += 1) {
                    const r = state.btRows[i];
                    totalTrades += r.trades;
                    totalNetR += r.netR;
                    totalWins += r.trades > 0 ? Math.round((r.winrate / 100) * r.trades) : 0;
                }

                els.btTrades.textContent = String(totalTrades);
                els.btNetR.textContent = Number.isFinite(totalNetR) ? totalNetR.toFixed(2) : "-";
                els.btWinrate.textContent = totalTrades > 0 ? ((totalWins / totalTrades) * 100).toFixed(1) + "%" : "-";

                els.btStatus.textContent = state.abortBt ? "중지됨" : "완료";
                renderBtTable();
                els.btnBtCsv.disabled = state.btRows.length === 0;
            }

            /* ===== 이벤트 바인딩 ===== */
            els.btnScan.addEventListener("click", async () => {
                if (state.scanRunning) return;
                try {
                    await runScan();
                } catch (e) {
                    els.scanStatus.textContent = `에러: ${String(e && e.message ? e.message : e)}`;
                } finally {
                    state.scanRunning = false;
                    els.btnScan.disabled = false;
                    els.btnScanStop.disabled = true;
                }
            });

            els.btnScanStop.addEventListener("click", () => {
                state.abortScan = true;
                els.scanStatus.textContent = "중지 요청...";
                els.btnScanStop.disabled = true;
            });

            els.btnClearCache.addEventListener("click", () => {
                cacheClearAll();
                els.scanStatus.textContent = "로컬 캐시 삭제됨";
            });

            els.btnScanCsv.addEventListener("click", async () => {
                const csv = toCsvScan(state.scanRows);
                await copyToClipboard(csv);
                els.scanStatus.textContent = "스캔 CSV 복사됨";
            });

            els.btnBt.addEventListener("click", async () => {
                if (state.btRunning) return;
                try {
                    await runBacktest();
                } catch (e) {
                    els.btStatus.textContent = `에러: ${String(e && e.message ? e.message : e)}`;
                } finally {
                    state.btRunning = false;
                    els.btnBt.disabled = false;
                    els.btnBtStop.disabled = true;
                }
            });

            els.btnBtStop.addEventListener("click", () => {
                state.abortBt = true;
                els.btStatus.textContent = "중지 요청...";
                els.btnBtStop.disabled = true;
            });

            els.btnBtCsv.addEventListener("click", async () => {
                const csv = toCsvBt(state.btRows);
                await copyToClipboard(csv);
                els.btStatus.textContent = "백테스트 CSV 복사됨";
            });

            (function initDates() {
                const now = new Date();
                const end = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const start = new Date(end.getTime() - 30 * 24 * 60 * 60 * 1000);

                const toDateStr = (d) => {
                    const yy = d.getFullYear();
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    const dd = String(d.getDate()).padStart(2, "0");
                    return `${yy}-${mm}-${dd}`;
                };

                els.btEnd.value = toDateStr(end);
                els.btStart.value = toDateStr(start);
            })();

            attachHeaderSort();
            attachHeaderTooltips();
            renderScanTable();
            renderBtTable();
        </script>
    </body>
</html>
