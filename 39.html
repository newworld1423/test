<!DOCTYPE html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp Long Scanner + Backtest</title>
        <style>
            :root {
                --bg: #0b0f17;
                --panel: #111827;
                --panel2: #0f172a;
                --text: #e5e7eb;
                --muted: #9ca3af;
                --line: rgba(255, 255, 255, 0.08);
                --good: rgba(34, 197, 94, 0.18);
                --warn: rgba(245, 158, 11, 0.18);
                --bad: rgba(239, 68, 68, 0.18);
                --chip: rgba(255, 255, 255, 0.06);
                --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
                background: radial-gradient(1200px 600px at 20% 0%, rgba(99, 102, 241, 0.15), transparent 60%),
                    radial-gradient(900px 500px at 90% 10%, rgba(16, 185, 129, 0.12), transparent 55%),
                    var(--bg);
                color: var(--text);
            }

            .wrap {
                max-width: 1400px;
                margin: 0 auto;
                padding: 18px;
            }

            .header {
                display: flex;
                gap: 12px;
                align-items: flex-start;
                justify-content: space-between;
                flex-wrap: wrap;
                margin-bottom: 14px;
            }

            h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: -0.3px;
            }

            .sub {
                color: var(--muted);
                font-size: 12px;
                line-height: 1.45;
                margin-top: 6px;
            }

            .panel {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), transparent 25%), var(--panel);
                border: 1px solid var(--line);
                border-radius: 14px;
                box-shadow: var(--shadow);
                overflow: hidden;
            }

            .grid2 {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 14px;
            }

            .controls {
                padding: 14px;
                display: grid;
                grid-template-columns: repeat(12, 1fr);
                gap: 10px;
                align-items: end;
            }

            .field {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .field label {
                font-size: 12px;
                color: var(--muted);
            }

            .field input,
            .field select {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: var(--panel2);
                color: var(--text);
                outline: none;
            }

            .field input:focus,
            .field select:focus {
                border-color: rgba(99, 102, 241, 0.55);
                box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
            }

            .btns {
                display: flex;
                gap: 8px;
                align-items: center;
                justify-content: flex-end;
                flex-wrap: wrap;
            }

            button {
                appearance: none;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: var(--text);
                padding: 10px 12px;
                border-radius: 10px;
                cursor: pointer;
                transition: transform 0.06s ease, background 0.15s ease, border-color 0.15s ease;
                font-weight: 700;
                letter-spacing: -0.2px;
            }

            button:hover {
                background: rgba(255, 255, 255, 0.09);
            }

            button:active {
                transform: translateY(1px);
            }

            button.primary {
                border-color: rgba(99, 102, 241, 0.55);
                background: rgba(99, 102, 241, 0.2);
            }

            button.danger {
                border-color: rgba(239, 68, 68, 0.55);
                background: rgba(239, 68, 68, 0.18);
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            .status {
                padding: 12px 14px;
                border-top: 1px solid var(--line);
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
                flex-wrap: wrap;
            }

            .chip {
                display: inline-flex;
                gap: 8px;
                align-items: center;
                padding: 6px 10px;
                border-radius: 999px;
                background: var(--chip);
                border: 1px solid var(--line);
                font-size: 12px;
                color: var(--muted);
                white-space: nowrap;
            }

            .chip strong {
                color: var(--text);
                font-weight: 800;
            }

            .note {
                font-size: 12px;
                color: var(--muted);
                line-height: 1.5;
            }

            .tableWrap {
                margin-top: 14px;
                overflow: hidden;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                background: rgba(17, 24, 39, 0.85);
                backdrop-filter: blur(10px);
                border-bottom: 1px solid var(--line);
                text-align: left;
                padding: 10px 10px;
                color: var(--muted);
                font-weight: 800;
                cursor: pointer;
                user-select: none;
                white-space: nowrap;
            }

            tbody td {
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                vertical-align: middle;
                white-space: nowrap;
            }

            tbody tr:hover {
                background: rgba(255, 255, 255, 0.03);
            }

            .mono {
                font-variant-numeric: tabular-nums;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }

            .badge {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 5px 9px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.05);
                font-size: 12px;
                color: var(--muted);
                white-space: nowrap;
            }

            .badge.good {
                background: var(--good);
                color: #bbf7d0;
                border-color: rgba(34, 197, 94, 0.35);
            }

            .badge.warn {
                background: var(--warn);
                color: #fde68a;
                border-color: rgba(245, 158, 11, 0.35);
            }

            .badge.bad {
                background: var(--bad);
                color: #fecaca;
                border-color: rgba(239, 68, 68, 0.35);
            }

            .right {
                text-align: right;
            }

            .small {
                font-size: 12px;
                color: var(--muted);
            }

            .footer {
                margin-top: 12px;
                padding: 12px 2px;
                color: var(--muted);
                font-size: 12px;
                line-height: 1.55;
            }

            .twoTables {
                display: grid;
                grid-template-columns: 1fr;
                gap: 14px;
            }

            @media (max-width: 1100px) {
                .grid2 {
                    grid-template-columns: 1fr;
                }
            }

            @media (max-width: 980px) {
                .controls {
                    grid-template-columns: repeat(6, 1fr);
                }
            }

            @media (max-width: 560px) {
                .controls {
                    grid-template-columns: repeat(2, 1fr);
                }
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="header">
                <div>
                    <h1>Binance USDT 무기한 롱 스캐너 + 백테스트(15m) 통합</h1>
                    <div class="sub">
                        규칙: 1D(99SMA 상단) + 1H(EMA50&gt;EMA200 정배열) + 15m(EMA20 재탈환 + RSI 상승) → 다음 15m 시가 진입 가정<br />
                        SL: 최근N 저점 vs 1H ATR 기반 중 더 타이트한 값 / TP: RR 고정 / 판정: 15m 고가/저가 터치(동봉 TP&SL은 기본 SL 우선)
                    </div>
                </div>
            </div>

            <div class="grid2">
                <!-- Scanner Panel -->
                <div class="panel">
                    <div class="controls">
                        <div class="field" style="grid-column: span 4;">
                            <label>스캔 대상(24h 거래대금 상위 N)</label>
                            <input id="maxSymbols" type="number" min="10" max="200" step="1" value="80" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>최소 24h 거래대금(USDT)</label>
                            <input id="minQuoteVol" type="number" min="0" step="1000000" value="50000000" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>필터</label>
                            <select id="filterMode">
                                <option value="all" selected>전체 표시</option>
                                <option value="trend">추세 우호(1D OK + 1H Strong)만</option>
                                <option value="setup">세팅 완료(재탈환+RSI)만</option>
                            </select>
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>Base URL</label>
                            <input id="baseUrl" type="text" value="https://fapi.binance.com" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>동시 요청</label>
                            <input id="concurrency" type="number" min="1" max="20" step="1" value="8" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>요청 템포</label>
                            <select id="tempo">
                                <option value="fast">빠름</option>
                                <option value="normal" selected>보통</option>
                                <option value="slow">느림(429 줄이기)</option>
                            </select>
                        </div>

                        <div class="btns" style="grid-column: span 12;">
                            <button id="btnScan" class="primary">스캔 시작</button>
                            <button id="btnScanStop" class="danger" disabled>스캔 중지</button>
                            <button id="btnScanCsv" disabled>스캔 CSV 복사</button>
                            <button id="btnClearCache">로컬 캐시 삭제</button>
                        </div>
                    </div>

                    <div class="status">
                        <div class="chip">스캔 상태: <strong id="scanStatus">대기</strong></div>
                        <div class="chip">진행: <strong id="scanProgress">0 / 0</strong></div>
                        <div class="chip">표시: <strong id="scanShown">0</strong></div>
                        <div class="chip">마지막: <strong id="scanLastRun">-</strong></div>
                    </div>
                </div>

                <!-- Backtest Panel -->
                <div class="panel">
                    <div class="controls">
                        <div class="field" style="grid-column: span 4;">
                            <label>백테스트 시작일</label>
                            <input id="btStart" type="date" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>백테스트 종료일</label>
                            <input id="btEnd" type="date" />
                        </div>

                        <div class="field" style="grid-column: span 4;">
                            <label>대상(스캔 상위 N)</label>
                            <input id="btTopN" type="number" min="1" max="80" step="1" value="20" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>RR(익절 R)</label>
                            <input id="btRR" type="number" min="0.5" max="10" step="0.1" value="2.0" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>ATR배수(SL)</label>
                            <input id="btAtrMult" type="number" min="0.5" max="5" step="0.1" value="1.2" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>최근저점 N(15m)</label>
                            <input id="btSwingN" type="number" min="3" max="60" step="1" value="12" />
                        </div>

                        <div class="field" style="grid-column: span 3;">
                            <label>최대 보유(15m bars)</label>
                            <input id="btMaxHold" type="number" min="4" max="2000" step="1" value="96" />
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>동봉 TP/SL 터치 시 처리</label>
                            <select id="btTieBreak">
                                <option value="sl" selected>보수적: SL 우선</option>
                                <option value="tp">낙관적: TP 우선</option>
                            </select>
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>펀딩 필터</label>
                            <select id="btFundingMode">
                                <option value="on" selected>사용(진입 시점 펀딩이 너무 양수면 제외)</option>
                                <option value="off">미사용</option>
                            </select>
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>펀딩 상한(예: 0.0003 = 0.03%)</label>
                            <input id="btFundingMax" type="number" min="0" max="0.01" step="0.0001" value="0.0003" />
                        </div>

                        <div class="field" style="grid-column: span 6;">
                            <label>백테스트 동시요청(권장 2~4)</label>
                            <input id="btConcurrency" type="number" min="1" max="10" step="1" value="3" />
                        </div>

                        <div class="btns" style="grid-column: span 12;">
                            <button id="btnBt" class="primary">백테스트 실행</button>
                            <button id="btnBtStop" class="danger" disabled>백테스트 중지</button>
                            <button id="btnBtCsv" disabled>백테스트 CSV 복사</button>
                        </div>
                    </div>

                    <div class="status">
                        <div class="chip">백테스트 상태: <strong id="btStatus">대기</strong></div>
                        <div class="chip">진행: <strong id="btProgress">0 / 0</strong></div>
                        <div class="chip">총 트레이드: <strong id="btTrades">0</strong></div>
                        <div class="chip">승률: <strong id="btWinrate">-</strong></div>
                        <div class="chip">Net R: <strong id="btNetR">-</strong></div>
                    </div>
                </div>
            </div>

            <div class="twoTables">
                <!-- Scan Table -->
                <div class="panel tableWrap">
                    <div style="padding: 10px 12px; border-bottom: 1px solid var(--line);" class="small">
                        스캐너 결과 (기본: Score 내림차순) / 헤더 클릭 정렬
                    </div>
                    <div style="overflow: auto; max-height: 60vh;">
                        <table>
                            <thead>
                                <tr>
                                    <th data-skey="symbol">Symbol</th>
                                    <th data-skey="score" class="right">Score</th>
                                    <th data-skey="price" class="right">Price</th>
                                    <th data-skey="setup">Setup</th>
                                    <th data-skey="entry" class="right">EntryRef</th>
                                    <th data-skey="sl" class="right">SL</th>
                                    <th data-skey="tp" class="right">TP</th>
                                    <th data-skey="riskPct" class="right">Risk%</th>
                                    <th data-skey="dailyOk">1D(99SMA)</th>
                                    <th data-skey="trendOk">1H Trend</th>
                                    <th data-skey="rsi" class="right">RSI(15m)</th>
                                    <th data-skey="funding" class="right">Funding</th>
                                    <th data-skey="chg24" class="right">24h%</th>
                                    <th data-skey="qv" class="right">24h QV</th>
                                    <th>Link</th>
                                </tr>
                            </thead>
                            <tbody id="scanTbody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Backtest Table -->
                <div class="panel tableWrap">
                    <div style="padding: 10px 12px; border-bottom: 1px solid var(--line);" class="small">
                        백테스트 결과(심볼별 요약) / 헤더 클릭 정렬
                    </div>
                    <div style="overflow: auto; max-height: 60vh;">
                        <table>
                            <thead>
                                <tr>
                                    <th data-bkey="symbol">Symbol</th>
                                    <th data-bkey="trades" class="right">Trades</th>
                                    <th data-bkey="winrate" class="right">Win%</th>
                                    <th data-bkey="netR" class="right">Net R</th>
                                    <th data-bkey="avgR" class="right">Avg R</th>
                                    <th data-bkey="pf" class="right">PF</th>
                                    <th data-bkey="maxDD" class="right">MaxDD(R)</th>
                                    <th data-bkey="bestR" class="right">Best R</th>
                                    <th data-bkey="worstR" class="right">Worst R</th>
                                </tr>
                            </thead>
                            <tbody id="btTbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="footer">
                <div>주의: 이 도구는 “전략 아이디어 검증/시각화” 용도이며 투자 조언이 아닙니다. 실제 체결/슬리피지/수수료/강제청산/펀딩 주기 변화 등은 별도 고려가 필요합니다.</div>
            </div>
        </div>

        <script>
            "use strict";

            const $ = (sel) => document.querySelector(sel);

            const els = {
                // scan
                maxSymbols: $("#maxSymbols"),
                minQuoteVol: $("#minQuoteVol"),
                filterMode: $("#filterMode"),
                baseUrl: $("#baseUrl"),
                concurrency: $("#concurrency"),
                tempo: $("#tempo"),
                btnScan: $("#btnScan"),
                btnScanStop: $("#btnScanStop"),
                btnScanCsv: $("#btnScanCsv"),
                btnClearCache: $("#btnClearCache"),
                scanStatus: $("#scanStatus"),
                scanProgress: $("#scanProgress"),
                scanShown: $("#scanShown"),
                scanLastRun: $("#scanLastRun"),
                scanTbody: $("#scanTbody"),

                // backtest
                btStart: $("#btStart"),
                btEnd: $("#btEnd"),
                btTopN: $("#btTopN"),
                btRR: $("#btRR"),
                btAtrMult: $("#btAtrMult"),
                btSwingN: $("#btSwingN"),
                btMaxHold: $("#btMaxHold"),
                btTieBreak: $("#btTieBreak"),
                btFundingMode: $("#btFundingMode"),
                btFundingMax: $("#btFundingMax"),
                btConcurrency: $("#btConcurrency"),
                btnBt: $("#btnBt"),
                btnBtStop: $("#btnBtStop"),
                btnBtCsv: $("#btnBtCsv"),
                btStatus: $("#btStatus"),
                btProgress: $("#btProgress"),
                btTrades: $("#btTrades"),
                btWinrate: $("#btWinrate"),
                btNetR: $("#btNetR"),
                btTbody: $("#btTbody"),
            };

            const TEMPO_DELAY_MS = {
                fast: 0,
                normal: 80,
                slow: 180,
            };

            const CACHE_PREFIX = "binance_recent_kline_cache_v2:";
            const CACHE_MAX_BYTES = 4 * 1024 * 1024;

            const state = {
                scanRunning: false,
                btRunning: false,
                abortScan: false,
                abortBt: false,

                scanRows: [],
                scanSortKey: "score",
                scanSortDir: "desc",

                btRows: [],
                btSortKey: "netR",
                btSortDir: "desc",

                scanTotal: 0,
                scanDone: 0,

                btTotal: 0,
                btDone: 0,
            };

            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }

            function safeFloat(x) {
                const v = Number.parseFloat(x);
                return Number.isFinite(v) ? v : NaN;
            }

            function safeInt(x) {
                const v = Number.parseInt(x, 10);
                return Number.isFinite(v) ? v : NaN;
            }

            function fmtNum(n, digits = 2) {
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString(undefined, { maximumFractionDigits: digits });
            }

            function fmtPct(n, digits = 2) {
                if (!Number.isFinite(n)) return "-";
                const sign = n > 0 ? "+" : "";
                return `${sign}${n.toFixed(digits)}%`;
            }

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function nowString() {
                const d = new Date();
                const yy = d.getFullYear();
                const mm = String(d.getMonth() + 1).padStart(2, "0");
                const dd = String(d.getDate()).padStart(2, "0");
                const hh = String(d.getHours()).padStart(2, "0");
                const mi = String(d.getMinutes()).padStart(2, "0");
                const ss = String(d.getSeconds()).padStart(2, "0");
                return `${yy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
            }

            function intervalToMs(interval) {
                const num = Number.parseInt(interval, 10);
                if (Number.isFinite(num)) {
                    if (interval.endsWith("m")) return num * 60 * 1000;
                    if (interval.endsWith("h")) return num * 60 * 60 * 1000;
                    if (interval.endsWith("d")) return num * 24 * 60 * 60 * 1000;
                    if (interval.endsWith("w")) return num * 7 * 24 * 60 * 60 * 1000;
                }
                if (interval === "1M") return 30 * 24 * 60 * 60 * 1000;
                return 0;
            }

            function nextCandleOpenTimeMs(interval) {
                const ms = intervalToMs(interval);
                if (!ms) return Date.now() + 60 * 1000;
                const now = Date.now();
                const next = Math.floor(now / ms) * ms + ms;
                return next;
            }

            function cacheGet(key) {
                try {
                    const raw = localStorage.getItem(CACHE_PREFIX + key);
                    if (!raw) return null;
                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== "object") return null;

                    if (typeof parsed.validUntil === "number" && Date.now() < parsed.validUntil && Array.isArray(parsed.data)) {
                        return parsed.data;
                    }
                    return null;
                } catch (_) {
                    return null;
                }
            }

            function cacheSet(key, data, validUntil) {
                try {
                    const payload = JSON.stringify({ validUntil, data });
                    if (payload.length > CACHE_MAX_BYTES) return;
                    localStorage.setItem(CACHE_PREFIX + key, payload);
                } catch (_) {
                    // ignore
                }
            }

            function cacheClearAll() {
                try {
                    const keys = [];
                    for (let i = 0; i < localStorage.length; i += 1) {
                        const k = localStorage.key(i);
                        if (k && k.startsWith(CACHE_PREFIX)) keys.push(k);
                    }
                    keys.forEach((k) => localStorage.removeItem(k));
                } catch (_) {
                    // ignore
                }
            }

            async function fetchJson(url, { abortCheck, retries = 2, retryDelay = 350 } = {}) {
                let lastErr = null;

                for (let i = 0; i <= retries; i += 1) {
                    if (abortCheck && abortCheck()) throw new Error("aborted");

                    try {
                        const res = await fetch(url, { method: "GET" });
                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            const err = new Error(`HTTP ${res.status} ${res.statusText} ${text.slice(0, 120)}`);
                            err.status = res.status;
                            throw err;
                        }
                        return await res.json();
                    } catch (e) {
                        lastErr = e;

                        const status = e && typeof e === "object" ? e.status : null;
                        const shouldRetry = i < retries && (status === 429 || status === 418 || status === 503 || status === 502);
                        if (!shouldRetry) break;

                        await sleep(retryDelay * (i + 1));
                    }
                }

                throw lastErr || new Error("fetch failed");
            }

            async function asyncPool(items, worker, concurrency, delayMs, abortCheck) {
                const results = [];
                let idx = 0;

                const runners = new Array(concurrency).fill(0).map(async () => {
                    while (true) {
                        if (abortCheck && abortCheck()) break;

                        const myIdx = idx;
                        idx += 1;
                        if (myIdx >= items.length) break;

                        try {
                            const out = await worker(items[myIdx], myIdx);
                            results.push(out);
                        } catch (e) {
                            results.push({ __error: true, error: String(e && e.message ? e.message : e) });
                        }

                        if (delayMs > 0) await sleep(delayMs);
                    }
                });

                await Promise.all(runners);
                return results;
            }

            function parseKlines(raw) {
                const openTimes = [];
                const opens = [];
                const highs = [];
                const lows = [];
                const closes = [];
                const closeTimes = [];

                for (let i = 0; i < raw.length; i += 1) {
                    const row = raw[i];
                    openTimes.push(Number(row[0]));
                    opens.push(safeFloat(row[1]));
                    highs.push(safeFloat(row[2]));
                    lows.push(safeFloat(row[3]));
                    closes.push(safeFloat(row[4]));
                    closeTimes.push(Number(row[6]));
                }

                return { openTimes, closeTimes, opens, highs, lows, closes };
            }

            function smaArray(values, period) {
                const out = new Array(values.length).fill(NaN);
                if (values.length < period) return out;

                let sum = 0;
                for (let i = 0; i < values.length; i += 1) {
                    sum += values[i];
                    if (i >= period) sum -= values[i - period];
                    if (i >= period - 1) out[i] = sum / period;
                }

                return out;
            }

            function emaArray(values, period) {
                const out = new Array(values.length).fill(NaN);
                if (values.length < period) return out;

                const k = 2 / (period + 1);
                let sum = 0;

                for (let i = 0; i < period; i += 1) sum += values[i];
                let ema = sum / period;
                out[period - 1] = ema;

                for (let i = period; i < values.length; i += 1) {
                    ema = values[i] * k + ema * (1 - k);
                    out[i] = ema;
                }

                return out;
            }

            function rsiArray(values, period) {
                const out = new Array(values.length).fill(NaN);
                if (values.length < period + 2) return out;

                let gain = 0;
                let loss = 0;

                for (let i = 1; i <= period; i += 1) {
                    const diff = values[i] - values[i - 1];
                    if (diff >= 0) gain += diff;
                    else loss -= diff;
                }

                let avgGain = gain / period;
                let avgLoss = loss / period;

                let rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
                out[period] = 100 - 100 / (1 + rs);

                for (let i = period + 1; i < values.length; i += 1) {
                    const diff = values[i] - values[i - 1];
                    const g = diff > 0 ? diff : 0;
                    const l = diff < 0 ? -diff : 0;

                    avgGain = (avgGain * (period - 1) + g) / period;
                    avgLoss = (avgLoss * (period - 1) + l) / period;

                    rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
                    out[i] = 100 - 100 / (1 + rs);
                }

                return out;
            }

            function atrArray(highs, lows, closes, period) {
                const out = new Array(highs.length).fill(NaN);
                if (highs.length < period + 2) return out;

                const trs = new Array(highs.length).fill(NaN);
                for (let i = 1; i < highs.length; i += 1) {
                    const tr = Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1]));
                    trs[i] = tr;
                }

                let sum = 0;
                let start = 1;
                let end = start + period - 1;
                if (end >= trs.length) return out;

                for (let i = start; i <= end; i += 1) sum += trs[i];
                let atr = sum / period;
                out[end] = atr;

                for (let i = end + 1; i < trs.length; i += 1) {
                    atr = (atr * (period - 1) + trs[i]) / period;
                    out[i] = atr;
                }

                return out;
            }

            function rollingMinArray(values, window) {
                const out = new Array(values.length).fill(NaN);
                const dq = []; // indices

                for (let i = 0; i < values.length; i += 1) {
                    while (dq.length > 0 && dq[0] <= i - window) dq.shift();

                    const v = values[i];
                    while (dq.length > 0) {
                        const lastIdx = dq[dq.length - 1];
                        if (values[lastIdx] <= v) break;
                        dq.pop();
                    }
                    dq.push(i);

                    if (i >= window - 1) out[i] = values[dq[0]];
                }

                return out;
            }

            function normalize01(val, min, max) {
                if (!Number.isFinite(val) || !Number.isFinite(min) || !Number.isFinite(max) || max <= min) return 0;
                return clamp((val - min) / (max - min), 0, 1);
            }

            function binanceTradeLink(symbol) {
                return `https://www.binance.com/en/futures/${encodeURIComponent(symbol)}`;
            }

            function scanSetupTag(dailyOk, trendStrong, reclaim, rsiOk) {
                if (dailyOk && trendStrong && reclaim && rsiOk) return { text: "세팅완료", cls: "good" };
                if (dailyOk && trendStrong) return { text: "추세우호", cls: "warn" };
                if (reclaim && rsiOk) return { text: "역추세(주의)", cls: "bad" };
                return { text: "관찰", cls: "warn" };
            }

            function computeScore(parts) {
                const w = {
                    daily: 0.22,
                    trend: 0.25,
                    pullback: 0.18,
                    rsi: 0.15,
                    funding: 0.08,
                    liquidity: 0.12,
                };

                const base =
                    100 *
                    (w.daily * (parts.dailyOk ? 1 : 0) +
                        w.trend * parts.trendStrength +
                        w.pullback * parts.pullback +
                        w.rsi * parts.rsiScore +
                        w.funding * parts.fundingScore +
                        w.liquidity * parts.liq);

                const penalty = 100 * (0.10 * parts.volPenalty + 0.08 * parts.overheatPenalty);
                return clamp(base - penalty, 0, 100);
            }

            function pickLastClosedIndex(klinesParsed, interval) {
                const n = klinesParsed.openTimes.length;
                if (n < 3) return n - 1;

                const lastCloseTime = klinesParsed.closeTimes[n - 1];
                const now = Date.now();
                if (now < lastCloseTime) return n - 2;
                return n - 1;
            }

            async function getExchangeInfo(baseUrl, abortCheck) {
                const url = `${baseUrl}/fapi/v1/exchangeInfo`;
                return await fetchJson(url, { abortCheck });
            }

            async function getTicker24h(baseUrl, abortCheck) {
                const url = `${baseUrl}/fapi/v1/ticker/24hr`;
                return await fetchJson(url, { abortCheck });
            }

            async function getPremiumIndexAll(baseUrl, abortCheck) {
                const url = `${baseUrl}/fapi/v1/premiumIndex`;
                return await fetchJson(url, { abortCheck });
            }

            async function getKlinesRecent(baseUrl, symbol, interval, limit, abortCheck) {
                const cacheKey = `${symbol}:${interval}:${limit}`;
                const cached = cacheGet(cacheKey);
                if (cached) return cached;

                const url = `${baseUrl}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`;
                const data = await fetchJson(url, { abortCheck });

                const validUntil = nextCandleOpenTimeMs(interval) + 500;
                cacheSet(cacheKey, data, validUntil);

                return data;
            }

            async function fetchAllKlinesRange(baseUrl, symbol, interval, startTime, endTime, abortCheck, memCache) {
                const key = `K:${symbol}:${interval}:${startTime}:${endTime}`;
                if (memCache.has(key)) return memCache.get(key);

                const limit = 1500;
                const out = [];

                let cursor = startTime;
                let guard = 0;
                const stepMs = intervalToMs(interval);

                while (cursor < endTime) {
                    if (abortCheck && abortCheck()) throw new Error("aborted");
                    guard += 1;
                    if (guard > 20000) break;

                    const url =
                        `${baseUrl}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}` +
                        `&interval=${encodeURIComponent(interval)}` +
                        `&startTime=${encodeURIComponent(cursor)}` +
                        `&endTime=${encodeURIComponent(endTime)}` +
                        `&limit=${encodeURIComponent(limit)}`;

                    const chunk = await fetchJson(url, { abortCheck, retries: 3, retryDelay: 450 });
                    if (!Array.isArray(chunk) || chunk.length === 0) break;

                    for (let i = 0; i < chunk.length; i += 1) out.push(chunk[i]);

                    const lastOpenTime = Number(chunk[chunk.length - 1][0]);
                    const nextCursor = lastOpenTime + stepMs;

                    if (!Number.isFinite(lastOpenTime) || nextCursor <= cursor) break;
                    cursor = nextCursor;

                    if (chunk.length < limit) break;
                }

                memCache.set(key, out);
                return out;
            }

            async function fetchAllFundingRates(baseUrl, symbol, startTime, endTime, abortCheck, memCache) {
                const key = `F:${symbol}:${startTime}:${endTime}`;
                if (memCache.has(key)) return memCache.get(key);

                const limit = 1000;
                const out = [];
                let cursor = startTime;
                let guard = 0;

                while (cursor <= endTime) {
                    if (abortCheck && abortCheck()) throw new Error("aborted");
                    guard += 1;
                    if (guard > 5000) break;

                    const url =
                        `${baseUrl}/fapi/v1/fundingRate?symbol=${encodeURIComponent(symbol)}` +
                        `&startTime=${encodeURIComponent(cursor)}` +
                        `&endTime=${encodeURIComponent(endTime)}` +
                        `&limit=${encodeURIComponent(limit)}`;

                    const chunk = await fetchJson(url, { abortCheck, retries: 3, retryDelay: 450 });
                    if (!Array.isArray(chunk) || chunk.length === 0) break;

                    for (let i = 0; i < chunk.length; i += 1) out.push(chunk[i]);

                    const last = chunk[chunk.length - 1];
                    const lastTime = Number(last && last.fundingTime ? last.fundingTime : NaN);
                    if (!Number.isFinite(lastTime) || lastTime <= cursor) break;

                    cursor = lastTime + 1;

                    if (chunk.length < limit) break;
                }

                memCache.set(key, out);
                return out;
            }

            function buildUniverse(exchangeInfo, tickers, premiumAll, minQuoteVol, maxSymbols) {
                const perpUsdtSymbols = new Set(
                    (exchangeInfo.symbols || [])
                        .filter((s) => s && s.status === "TRADING" && s.contractType === "PERPETUAL" && s.quoteAsset === "USDT")
                        .map((s) => s.symbol)
                );

                const tickerMap = new Map();
                for (let i = 0; i < tickers.length; i += 1) {
                    const t = tickers[i];
                    if (t && t.symbol) tickerMap.set(t.symbol, t);
                }

                const fundingMap = new Map();
                for (let i = 0; i < premiumAll.length; i += 1) {
                    const p = premiumAll[i];
                    if (!p || !p.symbol) continue;
                    fundingMap.set(p.symbol, safeFloat(p.lastFundingRate));
                }

                const universe = [];
                for (const sym of perpUsdtSymbols) {
                    const t = tickerMap.get(sym);
                    if (!t) continue;

                    const qv = safeFloat(t.quoteVolume);
                    const price = safeFloat(t.lastPrice);
                    const chg24 = safeFloat(t.priceChangePercent);
                    if (!Number.isFinite(qv) || !Number.isFinite(price) || !Number.isFinite(chg24)) continue;
                    if (qv < minQuoteVol) continue;

                    const funding = fundingMap.has(sym) ? fundingMap.get(sym) : NaN;

                    universe.push({ symbol: sym, qv, price, chg24, funding });
                }

                universe.sort((a, b) => b.qv - a.qv);
                const picked = universe.slice(0, maxSymbols);

                const logQvs = picked.map((x) => Math.log10(x.qv + 1));
                const minLog = Math.min(...logQvs);
                const maxLog = Math.max(...logQvs);

                return picked.map((x) => ({
                    ...x,
                    qvNorm: normalize01(Math.log10(x.qv + 1), minLog, maxLog),
                }));
            }

            function renderScanTable() {
                const mode = els.filterMode.value;
                let rows = state.scanRows.slice();

                if (mode === "trend") {
                    rows = rows.filter((r) => r.dailyOk && r.trendStrong);
                } else if (mode === "setup") {
                    rows = rows.filter((r) => r.dailyOk && r.trendStrong && r.reclaim && r.rsiOk);
                }

                const dir = state.scanSortDir === "asc" ? 1 : -1;
                const key = state.scanSortKey;

                rows.sort((a, b) => {
                    const va = a[key];
                    const vb = b[key];

                    if (typeof va === "string" && typeof vb === "string") return va.localeCompare(vb) * dir;

                    const na = Number.isFinite(va) ? va : -Infinity;
                    const nb = Number.isFinite(vb) ? vb : -Infinity;
                    return (na - nb) * dir;
                });

                els.scanTbody.innerHTML = "";
                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    const tag = scanSetupTag(r.dailyOk, r.trendStrong, r.reclaim, r.rsiOk);
                    const dailyBadge = r.dailyOk ? `<span class="badge good">OK</span>` : `<span class="badge bad">NO</span>`;
                    const trendBadge = r.trendStrong ? `<span class="badge good">Strong</span>` : `<span class="badge bad">Weak</span>`;
                    const fundingCls = !Number.isFinite(r.funding) ? "warn" : r.funding <= 0 ? "good" : r.funding <= 0.0003 ? "warn" : "bad";

                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td class="mono"><strong>${r.symbol}</strong></td>
                        <td class="right mono"><strong>${fmtNum(r.score, 1)}</strong></td>
                        <td class="right mono">${fmtNum(r.price, 6)}</td>
                        <td><span class="badge ${tag.cls}">${tag.text}</span></td>
                        <td class="right mono">${fmtNum(r.entry, 6)}</td>
                        <td class="right mono">${fmtNum(r.sl, 6)}</td>
                        <td class="right mono">${fmtNum(r.tp, 6)}</td>
                        <td class="right mono">${fmtNum(r.riskPct, 2)}%</td>
                        <td>${dailyBadge}</td>
                        <td>${trendBadge}</td>
                        <td class="right mono">${fmtNum(r.rsi, 1)}</td>
                        <td class="right mono"><span class="badge ${fundingCls}">${Number.isFinite(r.funding) ? (r.funding * 100).toFixed(4) + "%" : "-"}</span></td>
                        <td class="right mono">${fmtPct(r.chg24, 2)}</td>
                        <td class="right mono">${fmtNum(r.qv, 0)}</td>
                        <td><a class="badge" href="${binanceTradeLink(r.symbol)}" target="_blank" rel="noreferrer">Binance</a></td>
                    `;
                    els.scanTbody.appendChild(tr);
                }

                els.scanShown.textContent = String(rows.length);
                els.btnScanCsv.disabled = rows.length === 0;
            }

            function renderBtTable() {
                const dir = state.btSortDir === "asc" ? 1 : -1;
                const key = state.btSortKey;

                const rows = state.btRows.slice();
                rows.sort((a, b) => {
                    const va = a[key];
                    const vb = b[key];

                    if (typeof va === "string" && typeof vb === "string") return va.localeCompare(vb) * dir;

                    const na = Number.isFinite(va) ? va : -Infinity;
                    const nb = Number.isFinite(vb) ? vb : -Infinity;
                    return (na - nb) * dir;
                });

                els.btTbody.innerHTML = "";
                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <td class="mono"><strong>${r.symbol}</strong></td>
                        <td class="right mono">${fmtNum(r.trades, 0)}</td>
                        <td class="right mono">${fmtNum(r.winrate, 1)}%</td>
                        <td class="right mono"><strong>${fmtNum(r.netR, 2)}</strong></td>
                        <td class="right mono">${fmtNum(r.avgR, 2)}</td>
                        <td class="right mono">${fmtNum(r.pf, 2)}</td>
                        <td class="right mono">${fmtNum(r.maxDD, 2)}</td>
                        <td class="right mono">${fmtNum(r.bestR, 2)}</td>
                        <td class="right mono">${fmtNum(r.worstR, 2)}</td>
                    `;
                    els.btTbody.appendChild(tr);
                }

                els.btnBtCsv.disabled = rows.length === 0;
            }

            function attachHeaderSort() {
                document.querySelectorAll("thead th[data-skey]").forEach((th) => {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-skey");
                        if (!key) return;

                        if (state.scanSortKey === key) {
                            state.scanSortDir = state.scanSortDir === "desc" ? "asc" : "desc";
                        } else {
                            state.scanSortKey = key;
                            state.scanSortDir = key === "symbol" ? "asc" : "desc";
                        }
                        renderScanTable();
                    });
                });

                document.querySelectorAll("thead th[data-bkey]").forEach((th) => {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-bkey");
                        if (!key) return;

                        if (state.btSortKey === key) {
                            state.btSortDir = state.btSortDir === "desc" ? "asc" : "desc";
                        } else {
                            state.btSortKey = key;
                            state.btSortDir = key === "symbol" ? "asc" : "desc";
                        }
                        renderBtTable();
                    });
                });
            }

            function toCsvScan(rows) {
                const header = ["symbol", "score", "price", "setup", "entryRef", "sl", "tp", "riskPct", "dailyOk", "trendStrong", "rsi15m", "funding", "chg24", "quoteVolume"];
                const lines = [header.join(",")];

                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    const tag = scanSetupTag(r.dailyOk, r.trendStrong, r.reclaim, r.rsiOk).text;
                    lines.push(
                        [
                            r.symbol,
                            Number.isFinite(r.score) ? r.score.toFixed(2) : "",
                            Number.isFinite(r.price) ? r.price : "",
                            tag,
                            Number.isFinite(r.entry) ? r.entry : "",
                            Number.isFinite(r.sl) ? r.sl : "",
                            Number.isFinite(r.tp) ? r.tp : "",
                            Number.isFinite(r.riskPct) ? r.riskPct.toFixed(4) : "",
                            r.dailyOk ? "1" : "0",
                            r.trendStrong ? "1" : "0",
                            Number.isFinite(r.rsi) ? r.rsi.toFixed(2) : "",
                            Number.isFinite(r.funding) ? r.funding : "",
                            Number.isFinite(r.chg24) ? r.chg24.toFixed(4) : "",
                            Number.isFinite(r.qv) ? Math.round(r.qv) : "",
                        ].join(",")
                    );
                }

                return lines.join("\n");
            }

            function toCsvBt(rows) {
                const header = ["symbol", "trades", "winrate", "netR", "avgR", "pf", "maxDD", "bestR", "worstR"];
                const lines = [header.join(",")];

                for (let i = 0; i < rows.length; i += 1) {
                    const r = rows[i];
                    lines.push(
                        [
                            r.symbol,
                            r.trades,
                            Number.isFinite(r.winrate) ? r.winrate.toFixed(2) : "",
                            Number.isFinite(r.netR) ? r.netR.toFixed(4) : "",
                            Number.isFinite(r.avgR) ? r.avgR.toFixed(4) : "",
                            Number.isFinite(r.pf) ? r.pf.toFixed(4) : "",
                            Number.isFinite(r.maxDD) ? r.maxDD.toFixed(4) : "",
                            Number.isFinite(r.bestR) ? r.bestR.toFixed(4) : "",
                            Number.isFinite(r.worstR) ? r.worstR.toFixed(4) : "",
                        ].join(",")
                    );
                }

                return lines.join("\n");
            }

            async function copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch (_) {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand("copy");
                    ta.remove();
                    return true;
                }
            }

            async function runScan() {
                state.abortScan = false;
                state.scanRunning = true;
                state.scanRows = [];
                state.scanTotal = 0;
                state.scanDone = 0;

                els.btnScan.disabled = true;
                els.btnScanStop.disabled = false;
                els.btnScanCsv.disabled = true;
                els.scanStatus.textContent = "초기 로딩...";

                const baseUrl = String(els.baseUrl.value || "").trim().replace(/\/+$/, "");
                const maxSymbols = clamp(safeInt(els.maxSymbols.value) || 80, 10, 200);
                const minQuoteVol = Math.max(0, safeFloat(els.minQuoteVol.value) || 0);
                const concurrency = clamp(safeInt(els.concurrency.value) || 8, 1, 20);
                const tempo = els.tempo.value;
                const delayMs = TEMPO_DELAY_MS[tempo] ?? 80;

                const abortCheck = () => state.abortScan;

                const [exchangeInfo, tickers, premiumAll] = await Promise.all([
                    getExchangeInfo(baseUrl, abortCheck),
                    getTicker24h(baseUrl, abortCheck),
                    getPremiumIndexAll(baseUrl, abortCheck),
                ]);

                const universe = buildUniverse(exchangeInfo, tickers, premiumAll, minQuoteVol, maxSymbols);

                state.scanTotal = universe.length;
                els.scanProgress.textContent = `0 / ${state.scanTotal}`;
                els.scanShown.textContent = "0";
                renderScanTable();

                els.scanStatus.textContent = "캔들 수집/계산 중...";

                const worker = async (item) => {
                    const symbol = item.symbol;

                    const [raw15, raw1h, raw1d] = await Promise.all([
                        getKlinesRecent(baseUrl, symbol, "15m", 210, abortCheck),
                        getKlinesRecent(baseUrl, symbol, "1h", 260, abortCheck),
                        getKlinesRecent(baseUrl, symbol, "1d", 210, abortCheck),
                    ]);

                    const k15 = parseKlines(raw15);
                    const k1h = parseKlines(raw1h);
                    const k1d = parseKlines(raw1d);

                    const idx15 = pickLastClosedIndex(k15, "15m");
                    const idx1h = pickLastClosedIndex(k1h, "1h");
                    const idx1d = pickLastClosedIndex(k1d, "1d");

                    const ema20_15 = emaArray(k15.closes, 20);
                    const rsi15 = rsiArray(k15.closes, 14);

                    const ema50_1h = emaArray(k1h.closes, 50);
                    const ema200_1h = emaArray(k1h.closes, 200);
                    const atr14_1h = atrArray(k1h.highs, k1h.lows, k1h.closes, 14);

                    const sma99_1d = smaArray(k1d.closes, 99);

                    const close15 = k15.closes[idx15];
                    const prevClose15 = k15.closes[idx15 - 1];
                    const e15 = ema20_15[idx15];
                    const prevE15 = ema20_15[idx15 - 1];
                    const rsiNow = rsi15[idx15];
                    const rsiPrev = rsi15[idx15 - 1];

                    const dailyOk = Number.isFinite(sma99_1d[idx1d]) && k1d.closes[idx1d] > sma99_1d[idx1d];

                    const trendStrong =
                        Number.isFinite(ema50_1h[idx1h]) &&
                        Number.isFinite(ema200_1h[idx1h]) &&
                        k1h.closes[idx1h] > ema50_1h[idx1h] &&
                        ema50_1h[idx1h] > ema200_1h[idx1h];

                    const reclaim = Number.isFinite(e15) && Number.isFinite(prevE15) && close15 > e15 && prevClose15 <= prevE15;

                    const rsiOk = Number.isFinite(rsiNow) && Number.isFinite(rsiPrev) && rsiNow >= 45 && rsiNow <= 65 && rsiNow > rsiPrev;

                    const pullbackDist = Number.isFinite(e15) && e15 > 0 ? Math.abs(close15 - e15) / e15 : NaN;
                    const pullback = Number.isFinite(pullbackDist) ? clamp(1 - pullbackDist / 0.02, 0, 1) : 0;

                    let trendStrength = 0.1;
                    if (trendStrong) trendStrength = 1;
                    else if (Number.isFinite(ema200_1h[idx1h]) && k1h.closes[idx1h] > ema200_1h[idx1h]) trendStrength = 0.6;

                    let rsiScore = 0.25;
                    if (Number.isFinite(rsiNow) && Number.isFinite(rsiPrev)) {
                        if (rsiNow >= 45 && rsiNow <= 60) rsiScore = rsiNow > rsiPrev ? 1 : 0.75;
                        else if (rsiNow > 60 && rsiNow <= 70) rsiScore = rsiNow > rsiPrev ? 0.55 : 0.4;
                        else if (rsiNow > 70) rsiScore = 0.15;
                        else rsiScore = 0.25;
                    }

                    const funding = Number.isFinite(item.funding) ? item.funding : NaN;
                    let fundingScore = 0.5;
                    if (Number.isFinite(funding)) {
                        if (funding <= 0) fundingScore = 1;
                        else fundingScore = clamp(1 - funding / 0.001, 0, 1);
                    }

                    let volPenalty = 0;
                    if (Number.isFinite(atr14_1h[idx1h]) && k1h.closes[idx1h] > 0) {
                        const atrPct = atr14_1h[idx1h] / k1h.closes[idx1h];
                        volPenalty = clamp((atrPct - 0.025) / 0.08, 0, 1);
                    }

                    const overheatPenalty = clamp(((Number.isFinite(item.chg24) ? item.chg24 : 0) - 15) / 25, 0, 1);

                    const score = computeScore({
                        dailyOk,
                        trendStrength,
                        pullback,
                        rsiScore,
                        fundingScore,
                        liq: item.qvNorm,
                        volPenalty,
                        overheatPenalty,
                    });

                    // Entry/SL/TP (스캐너 표시용): entryRef = 15m 신호봉 종가
                    const entry = close15;
                    const swingN = clamp(safeInt(els.btSwingN.value) || 12, 3, 60);
                    const atrMult = clamp(safeFloat(els.btAtrMult.value) || 1.2, 0.5, 5);
                    const rr = clamp(safeFloat(els.btRR.value) || 2.0, 0.5, 10);

                    let swingLow = NaN;
                    if (idx15 - (swingN - 1) >= 0) {
                        let minL = Infinity;
                        for (let i = idx15 - (swingN - 1); i <= idx15; i += 1) {
                            const l = k15.lows[i];
                            if (Number.isFinite(l)) minL = Math.min(minL, l);
                        }
                        swingLow = Number.isFinite(minL) ? minL : NaN;
                    }

                    const atr1h = atr14_1h[idx1h];
                    const slFromAtr = Number.isFinite(atr1h) ? entry - atrMult * atr1h : NaN;
                    const slFromSwing = Number.isFinite(swingLow) ? swingLow * (1 - 0.0005) : NaN;

                    let sl = NaN;
                    if (Number.isFinite(slFromAtr) && Number.isFinite(slFromSwing)) sl = Math.min(slFromAtr, slFromSwing);
                    else if (Number.isFinite(slFromAtr)) sl = slFromAtr;
                    else if (Number.isFinite(slFromSwing)) sl = slFromSwing;

                    const risk = Number.isFinite(sl) ? entry - sl : NaN;
                    const tp = Number.isFinite(risk) && risk > 0 ? entry + rr * risk : NaN;
                    const riskPct = Number.isFinite(risk) && entry > 0 ? (risk / entry) * 100 : NaN;

                    return {
                        symbol,
                        score,
                        price: item.price,
                        qv: item.qv,
                        chg24: item.chg24,
                        funding,

                        dailyOk,
                        trendStrong,
                        reclaim,
                        rsiOk,

                        rsi: rsiNow,

                        entry,
                        sl,
                        tp,
                        riskPct,
                    };
                };

                const results = await asyncPool(
                    universe,
                    async (it) => {
                        const row = await worker(it);

                        state.scanDone += 1;
                        els.scanProgress.textContent = `${state.scanDone} / ${state.scanTotal}`;

                        state.scanRows.push(row);
                        state.scanSortKey = "score";
                        state.scanSortDir = "desc";
                        renderScanTable();

                        return row;
                    },
                    concurrency,
                    delayMs,
                    abortCheck
                );

                state.scanRows = results.filter((r) => r && !r.__error && r.symbol);
                state.scanSortKey = "score";
                state.scanSortDir = "desc";

                els.scanLastRun.textContent = nowString();
                els.scanStatus.textContent = state.abortScan ? "중지됨" : "완료";
                renderScanTable();
            }

            function dateToMsStart(dateStr) {
                // input[type=date]는 로컬 타임존 기준 자정이 들어옴
                const d = new Date(dateStr);
                return d.getTime();
            }

            function computeEquityMaxDD(rs) {
                let peak = 0;
                let eq = 0;
                let maxDD = 0;

                for (let i = 0; i < rs.length; i += 1) {
                    eq += rs[i];
                    if (eq > peak) peak = eq;
                    const dd = peak - eq;
                    if (dd > maxDD) maxDD = dd;
                }

                return maxDD;
            }

            function findStartIndex(times, startTime) {
                let lo = 0;
                let hi = times.length - 1;
                let ans = times.length;

                while (lo <= hi) {
                    const mid = (lo + hi) >> 1;
                    if (times[mid] >= startTime) {
                        ans = mid;
                        hi = mid - 1;
                    } else {
                        lo = mid + 1;
                    }
                }

                return ans;
            }

            function runBacktestOnSymbol(input) {
                const {
                    symbol,
                    k15,
                    k1h,
                    k1d,
                    funding,
                    startTime,
                    endTime,
                    rr,
                    atrMult,
                    swingN,
                    maxHold,
                    tieBreak,
                    fundingMode,
                    fundingMax,
                } = input;

                const ema20_15 = emaArray(k15.closes, 20);
                const rsi15 = rsiArray(k15.closes, 14);
                const rollMinLow = rollingMinArray(k15.lows, swingN);

                const ema50_1h = emaArray(k1h.closes, 50);
                const ema200_1h = emaArray(k1h.closes, 200);
                const atr14_1h = atrArray(k1h.highs, k1h.lows, k1h.closes, 14);

                const sma99_1d = smaArray(k1d.closes, 99);

                const idxStart = findStartIndex(k15.openTimes, startTime);
                const idxEnd = findStartIndex(k15.openTimes, endTime);

                let i = Math.max(idxStart, 2);
                let idx1h = 0;
                let idx1d = 0;
                let idxF = 0;

                const trades = [];
                const rList = [];

                while (i < idxEnd - 2) {
                    const t = k15.openTimes[i];

                    while (idx1h + 1 < k1h.openTimes.length && k1h.openTimes[idx1h + 1] <= t) idx1h += 1;
                    while (idx1d + 1 < k1d.openTimes.length && k1d.openTimes[idx1d + 1] <= t) idx1d += 1;

                    const close15 = k15.closes[i];
                    const prevClose15 = k15.closes[i - 1];
                    const e15 = ema20_15[i];
                    const prevE15 = ema20_15[i - 1];

                    const rsiNow = rsi15[i];
                    const rsiPrev = rsi15[i - 1];

                    const dailyOk = Number.isFinite(sma99_1d[idx1d]) && k1d.closes[idx1d] > sma99_1d[idx1d];

                    const trendStrong =
                        Number.isFinite(ema50_1h[idx1h]) &&
                        Number.isFinite(ema200_1h[idx1h]) &&
                        k1h.closes[idx1h] > ema50_1h[idx1h] &&
                        ema50_1h[idx1h] > ema200_1h[idx1h];

                    const reclaim = Number.isFinite(e15) && Number.isFinite(prevE15) && close15 > e15 && prevClose15 <= prevE15;
                    const rsiOk = Number.isFinite(rsiNow) && Number.isFinite(rsiPrev) && rsiNow >= 45 && rsiNow <= 65 && rsiNow > rsiPrev;

                    const entryIndex = i + 1;
                    const entryTime = k15.openTimes[entryIndex];

                    // funding at entryTime (마지막 fundingTime <= entryTime)
                    let fundingOk = true;
                    let fundingAtEntry = NaN;

                    if (fundingMode === "on" && Array.isArray(funding) && funding.length > 0) {
                        while (idxF + 1 < funding.length && Number(funding[idxF + 1].fundingTime) <= entryTime) idxF += 1;
                        const f = funding[idxF];
                        const ft = f ? Number(f.fundingTime) : NaN;

                        if (Number.isFinite(ft) && ft <= entryTime) {
                            fundingAtEntry = safeFloat(f.fundingRate);
                            if (Number.isFinite(fundingAtEntry)) fundingOk = fundingAtEntry <= fundingMax;
                        }
                    }

                    const signal = dailyOk && trendStrong && reclaim && rsiOk && fundingOk;

                    if (!signal) {
                        i += 1;
                        continue;
                    }

                    const entry = k15.opens[entryIndex];

                    const swingLow = rollMinLow[i];
                    const atr1h = atr14_1h[idx1h];

                    const slFromSwing = Number.isFinite(swingLow) ? swingLow * (1 - 0.0005) : NaN;
                    const slFromAtr = Number.isFinite(atr1h) ? entry - atrMult * atr1h : NaN;

                    let sl = NaN;
                    if (Number.isFinite(slFromSwing) && Number.isFinite(slFromAtr)) sl = Math.min(slFromSwing, slFromAtr);
                    else if (Number.isFinite(slFromSwing)) sl = slFromSwing;
                    else if (Number.isFinite(slFromAtr)) sl = slFromAtr;

                    const risk = Number.isFinite(sl) ? entry - sl : NaN;
                    if (!Number.isFinite(risk) || risk <= 0) {
                        i += 1;
                        continue;
                    }

                    const tp = entry + rr * risk;

                    // simulate forward
                    let exitIndex = -1;
                    let exitPrice = NaN;
                    let exitReason = "EOD";
                    let r = 0;

                    const lastJ = Math.min(idxEnd - 1, entryIndex + maxHold);

                    for (let j = entryIndex; j <= lastJ; j += 1) {
                        const hi = k15.highs[j];
                        const lo = k15.lows[j];

                        const hitTP = Number.isFinite(hi) && hi >= tp;
                        const hitSL = Number.isFinite(lo) && lo <= sl;

                        if (hitTP && hitSL) {
                            if (tieBreak === "sl") {
                                exitIndex = j;
                                exitPrice = sl;
                                exitReason = "SL";
                                r = -1;
                                break;
                            }
                            exitIndex = j;
                            exitPrice = tp;
                            exitReason = "TP";
                            r = rr;
                            break;
                        }

                        if (hitSL) {
                            exitIndex = j;
                            exitPrice = sl;
                            exitReason = "SL";
                            r = -1;
                            break;
                        }

                        if (hitTP) {
                            exitIndex = j;
                            exitPrice = tp;
                            exitReason = "TP";
                            r = rr;
                            break;
                        }

                        if (j === lastJ) {
                            exitIndex = j;
                            exitPrice = k15.closes[j];
                            exitReason = j < idxEnd - 1 ? "TIME" : "EOD";
                            r = (exitPrice - entry) / risk;
                            break;
                        }
                    }

                    trades.push({
                        symbol,
                        entryTime,
                        exitTime: exitIndex >= 0 ? k15.closeTimes[exitIndex] : NaN,
                        entry,
                        sl,
                        tp,
                        exit: exitPrice,
                        reason: exitReason,
                        r,
                        fundingAtEntry,
                    });

                    rList.push(r);
                    i = Math.max(exitIndex + 1, i + 1);
                }

                const tradesN = trades.length;
                let wins = 0;
                let sumPos = 0;
                let sumNeg = 0;
                let netR = 0;
                let bestR = -Infinity;
                let worstR = Infinity;

                for (let k = 0; k < trades.length; k += 1) {
                    const rrVal = trades[k].r;
                    netR += rrVal;
                    if (rrVal > 0) {
                        wins += 1;
                        sumPos += rrVal;
                    } else if (rrVal < 0) {
                        sumNeg += rrVal;
                    }
                    bestR = Math.max(bestR, rrVal);
                    worstR = Math.min(worstR, rrVal);
                }

                const winrate = tradesN > 0 ? (wins / tradesN) * 100 : 0;
                const avgR = tradesN > 0 ? netR / tradesN : 0;
                const pf = sumNeg < 0 ? sumPos / Math.abs(sumNeg) : sumPos > 0 ? Infinity : 0;
                const maxDD = computeEquityMaxDD(rList);

                return {
                    symbol,
                    trades: tradesN,
                    winrate,
                    netR,
                    avgR,
                    pf,
                    maxDD,
                    bestR: tradesN ? bestR : 0,
                    worstR: tradesN ? worstR : 0,
                    _trades: trades,
                };
            }

            async function runBacktest() {
                state.abortBt = false;
                state.btRunning = true;
                state.btRows = [];
                state.btTotal = 0;
                state.btDone = 0;

                els.btnBt.disabled = true;
                els.btnBtStop.disabled = false;
                els.btnBtCsv.disabled = true;

                els.btStatus.textContent = "준비...";
                els.btProgress.textContent = "0 / 0";
                els.btTrades.textContent = "0";
                els.btWinrate.textContent = "-";
                els.btNetR.textContent = "-";

                const baseUrl = String(els.baseUrl.value || "").trim().replace(/\/+$/, "");
                const topN = clamp(safeInt(els.btTopN.value) || 20, 1, 80);

                const startStr = els.btStart.value;
                const endStr = els.btEnd.value;

                if (!startStr || !endStr) {
                    els.btStatus.textContent = "시작/종료일을 먼저 선택";
                    return;
                }

                const startTime = dateToMsStart(startStr);
                const endTime = dateToMsStart(endStr) + 24 * 60 * 60 * 1000 - 1;

                if (!(endTime > startTime)) {
                    els.btStatus.textContent = "종료일이 시작일보다 뒤여야 함";
                    return;
                }

                const rr = clamp(safeFloat(els.btRR.value) || 2.0, 0.5, 10);
                const atrMult = clamp(safeFloat(els.btAtrMult.value) || 1.2, 0.5, 5);
                const swingN = clamp(safeInt(els.btSwingN.value) || 12, 3, 60);
                const maxHold = clamp(safeInt(els.btMaxHold.value) || 96, 4, 2000);
                const tieBreak = els.btTieBreak.value === "tp" ? "tp" : "sl";
                const fundingMode = els.btFundingMode.value === "off" ? "off" : "on";
                const fundingMax = Math.max(0, safeFloat(els.btFundingMax.value) || 0.0003);

                const btConcurrency = clamp(safeInt(els.btConcurrency.value) || 3, 1, 10);
                const delayMs = TEMPO_DELAY_MS[els.tempo.value] ?? 80;

                const abortCheck = () => state.abortBt;

                // symbols: scanRows가 있으면 상위N, 없으면 새로 universe 구성
                let symbols = [];

                if (state.scanRows.length > 0) {
                    const sorted = state.scanRows.slice().sort((a, b) => b.score - a.score);
                    symbols = sorted.slice(0, topN).map((r) => r.symbol);
                } else {
                    els.btStatus.textContent = "스캔 결과 없음 → 유니버스 구성 중...";
                    const exchangeInfo = await getExchangeInfo(baseUrl, abortCheck);
                    const tickers = await getTicker24h(baseUrl, abortCheck);
                    const premiumAll = await getPremiumIndexAll(baseUrl, abortCheck);

                    const maxSymbols = topN;
                    const minQuoteVol = Math.max(0, safeFloat(els.minQuoteVol.value) || 0);

                    const universe = buildUniverse(exchangeInfo, tickers, premiumAll, minQuoteVol, maxSymbols);
                    symbols = universe.map((x) => x.symbol);
                }

                state.btTotal = symbols.length;
                els.btProgress.textContent = `0 / ${state.btTotal}`;
                els.btStatus.textContent = "데이터 수집/백테스트 중...";

                const memCache = new Map();

                // warmup windows
                const warm1d = 130 * 24 * 60 * 60 * 1000;
                const warm1h = 20 * 24 * 60 * 60 * 1000;
                const warm15 = 7 * 24 * 60 * 60 * 1000;

                const start15 = startTime - warm15;
                const start1h = startTime - warm1h;
                const start1d = startTime - warm1d;

                const worker = async (symbol) => {
                    const raw15 = await fetchAllKlinesRange(baseUrl, symbol, "15m", start15, endTime, abortCheck, memCache);
                    const raw1h = await fetchAllKlinesRange(baseUrl, symbol, "1h", start1h, endTime, abortCheck, memCache);
                    const raw1d = await fetchAllKlinesRange(baseUrl, symbol, "1d", start1d, endTime, abortCheck, memCache);

                    const k15 = parseKlines(raw15);
                    const k1h = parseKlines(raw1h);
                    const k1d = parseKlines(raw1d);

                    let funding = [];
                    if (fundingMode === "on") {
                        // funding은 잦지 않으니 startTime만큼만
                        const fRaw = await fetchAllFundingRates(baseUrl, symbol, startTime, endTime, abortCheck, memCache);
                        funding = Array.isArray(fRaw) ? fRaw : [];
                    }

                    return runBacktestOnSymbol({
                        symbol,
                        k15,
                        k1h,
                        k1d,
                        funding,
                        startTime,
                        endTime,
                        rr,
                        atrMult,
                        swingN,
                        maxHold,
                        tieBreak,
                        fundingMode,
                        fundingMax,
                    });
                };

                const results = await asyncPool(
                    symbols,
                    async (sym) => {
                        const out = await worker(sym);
                        state.btDone += 1;
                        els.btProgress.textContent = `${state.btDone} / ${state.btTotal}`;

                        state.btRows.push(out);
                        state.btSortKey = "netR";
                        state.btSortDir = "desc";
                        renderBtTable();

                        // summary update
                        let totalTrades = 0;
                        let totalWins = 0;
                        let totalNetR = 0;

                        for (let i = 0; i < state.btRows.length; i += 1) {
                            const r = state.btRows[i];
                            totalTrades += r.trades;
                            totalNetR += r.netR;

                            // wins 추정: winrate*trades
                            totalWins += (r.winrate / 100) * r.trades;
                        }

                        const winrateAll = totalTrades > 0 ? (totalWins / totalTrades) * 100 : 0;

                        els.btTrades.textContent = String(totalTrades);
                        els.btWinrate.textContent = totalTrades > 0 ? `${winrateAll.toFixed(1)}%` : "-";
                        els.btNetR.textContent = totalTrades > 0 ? totalNetR.toFixed(2) : "-";

                        return out;
                    },
                    btConcurrency,
                    delayMs,
                    abortCheck
                );

                state.btRows = results.filter((r) => r && !r.__error && r.symbol);

                els.btStatus.textContent = state.abortBt ? "중지됨" : "완료";
                els.btnBtCsv.disabled = state.btRows.length === 0;

                renderBtTable();
            }

            // events
            els.btnScan.addEventListener("click", async () => {
                if (state.scanRunning) return;
                try {
                    await runScan();
                } catch (e) {
                    els.scanStatus.textContent = `에러: ${String(e && e.message ? e.message : e)}`;
                } finally {
                    state.scanRunning = false;
                    els.btnScan.disabled = false;
                    els.btnScanStop.disabled = true;
                }
            });

            els.btnScanStop.addEventListener("click", () => {
                state.abortScan = true;
                els.scanStatus.textContent = "중지 요청...";
                els.btnScanStop.disabled = true;
            });

            els.btnClearCache.addEventListener("click", () => {
                cacheClearAll();
                els.scanStatus.textContent = "로컬 캐시 삭제됨";
            });

            els.btnScanCsv.addEventListener("click", async () => {
                const csv = toCsvScan(state.scanRows);
                await copyToClipboard(csv);
                els.scanStatus.textContent = "스캔 CSV 복사됨";
            });

            els.btnBt.addEventListener("click", async () => {
                if (state.btRunning) return;
                try {
                    await runBacktest();
                } catch (e) {
                    els.btStatus.textContent = `에러: ${String(e && e.message ? e.message : e)}`;
                } finally {
                    state.btRunning = false;
                    els.btnBt.disabled = false;
                    els.btnBtStop.disabled = true;
                }
            });

            els.btnBtStop.addEventListener("click", () => {
                state.abortBt = true;
                els.btStatus.textContent = "중지 요청...";
                els.btnBtStop.disabled = true;
            });

            els.btnBtCsv.addEventListener("click", async () => {
                const csv = toCsvBt(state.btRows);
                await copyToClipboard(csv);
                els.btStatus.textContent = "백테스트 CSV 복사됨";
            });

            // default date range: last 30 days
            (function initDates() {
                const now = new Date();
                const end = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const start = new Date(end.getTime() - 30 * 24 * 60 * 60 * 1000);

                const toDateStr = (d) => {
                    const yy = d.getFullYear();
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    const dd = String(d.getDate()).padStart(2, "0");
                    return `${yy}-${mm}-${dd}`;
                };

                els.btEnd.value = toDateStr(end);
                els.btStart.value = toDateStr(start);
            })();

            attachHeaderSort();
            renderScanTable();
            renderBtTable();
        </script>
    </body>
</html>
