<!DOCTYPE html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp 15m Cross Above Current 1D 99MA Scanner</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, Pretendard, Apple SD Gothic Neo, Noto Sans KR, sans-serif;
                background: #0b0f14;
                color: #e6edf3;
            }

            .wrap {
                max-width: 1100px;
                margin: 0 auto;
                padding: 20px;
            }

            .card {
                background: #111823;
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 14px;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }

            .row > * {
                flex: 0 0 auto;
            }

            label {
                font-size: 13px;
                opacity: 0.9;
                display: block;
                margin-bottom: 6px;
            }

            input,
            select,
            button {
                background: #0b0f14;
                border: 1px solid rgba(255, 255, 255, 0.12);
                color: #e6edf3;
                border-radius: 10px;
                padding: 10px 12px;
                outline: none;
            }

            input {
                width: 120px;
            }

            button {
                cursor: pointer;
                font-weight: 600;
            }

            button.primary {
                background: #1f6feb;
                border-color: rgba(31, 111, 235, 0.5);
            }

            button.danger {
                background: #da3633;
                border-color: rgba(218, 54, 51, 0.5);
            }

            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .status {
                font-size: 13px;
                opacity: 0.95;
                line-height: 1.5;
            }

            .muted {
                opacity: 0.7;
            }

            .progress {
                height: 10px;
                border-radius: 999px;
                background: rgba(255, 255, 255, 0.08);
                overflow: hidden;
            }

            .bar {
                height: 100%;
                width: 0%;
                background: #2ea043;
                transition: width 120ms linear;
            }

            table {
                width: 100%;
                border-collapse: collapse;
            }

            th,
            td {
                padding: 10px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                font-size: 13px;
                text-align: left;
                vertical-align: middle;
            }

            th {
                opacity: 0.85;
                font-weight: 700;
            }

            .tag {
                display: inline-block;
                padding: 3px 8px;
                border-radius: 999px;
                font-size: 12px;
                background: rgba(31, 111, 235, 0.15);
                border: 1px solid rgba(31, 111, 235, 0.35);
            }

            a {
                color: #58a6ff;
                text-decoration: none;
            }

            a:hover {
                text-decoration: underline;
            }

            .log {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 12px;
                white-space: pre-wrap;
                word-break: break-word;
                max-height: 220px;
                overflow: auto;
                background: #0b0f14;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                padding: 10px;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="card">
                <h2 style="margin: 0 0 10px 0;">Binance USDT 무기한(Perp) 스캐너</h2>
                <div class="status muted">
                    조건:
                    <span class="tag">15m 2봉전 종가 &lt; 1D 99MA(현재봉 포함)</span>
                    <span class="tag">15m 1봉전 종가 &gt; 1D 99MA(현재봉 포함)</span>
                    <div style="margin-top: 8px;">
                        * 15분봉은 <b>마감된 캔들</b>만 사용(2봉전/1봉전).<br />
                        * 1일봉 99MA는 <b>현재 진행중인 일봉의 종가(실시간 갱신)</b>까지 포함하여 계산.
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="row">
                    <div>
                        <label>동시 요청(Concurrency)</label>
                        <input id="concurrency" type="number" min="1" max="20" value="5" />
                    </div>
                    <div>
                        <label>요청 딜레이(ms)</label>
                        <input id="delay" type="number" min="0" max="5000" value="80" />
                    </div>
                    <div>
                        <label>정렬</label>
                        <select id="sort">
                            <option value="symbol">심볼</option>
                            <option value="gapAsc">1봉전 - 99MA (오름)</option>
                            <option value="gapDesc" selected>1봉전 - 99MA (내림)</option>
                        </select>
                    </div>
                    <div style="margin-left: auto;">
                        <button id="btnStart" class="primary">스캔 시작</button>
                        <button id="btnStop" class="danger" disabled>중지</button>
                    </div>
                </div>

                <div style="margin-top: 14px;">
                    <div class="progress"><div class="bar" id="bar"></div></div>
                    <div class="status" style="margin-top: 10px;">
                        <div>상태: <span id="state">대기</span></div>
                        <div class="muted">진행: <span id="progressText">0 / 0</span> · 매칭: <span id="matchCount">0</span></div>
                        <div class="muted">서버시간: <span id="serverTime">-</span></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <h3 style="margin: 0;">결과</h3>
                    <div class="muted" style="font-size: 13px;">TradingView 링크 포함</div>
                </div>

                <div style="overflow: auto; margin-top: 10px;">
                    <table>
                        <thead>
                            <tr>
                                <th>심볼</th>
                                <th>1D 99MA(현재봉 포함)</th>
                                <th>15m 2봉전 종가</th>
                                <th>15m 1봉전 종가</th>
                                <th>갭(1봉전-99MA)</th>
                                <th>확인</th>
                            </tr>
                        </thead>
                        <tbody id="tbody">
                            <tr>
                                <td colspan="6" class="muted">아직 결과가 없습니다.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card">
                <div class="row" style="justify-content: space-between;">
                    <h3 style="margin: 0;">로그</h3>
                    <button id="btnClearLog">로그 비우기</button>
                </div>
                <div id="log" class="log" style="margin-top: 10px;"></div>
            </div>
        </div>

        <script>
            const BASE_URL = "https://fapi.binance.com";

            const els = {
                concurrency: document.getElementById("concurrency"),
                delay: document.getElementById("delay"),
                sort: document.getElementById("sort"),
                btnStart: document.getElementById("btnStart"),
                btnStop: document.getElementById("btnStop"),
                btnClearLog: document.getElementById("btnClearLog"),
                bar: document.getElementById("bar"),
                state: document.getElementById("state"),
                progressText: document.getElementById("progressText"),
                matchCount: document.getElementById("matchCount"),
                serverTime: document.getElementById("serverTime"),
                tbody: document.getElementById("tbody"),
                log: document.getElementById("log"),
            };

            const state = {
                running: false,
                abort: false,
                total: 0,
                done: 0,
                matches: [],
                serverTime: 0,
            };

            function logLine(text) {
                const ts = new Date().toLocaleTimeString();
                els.log.textContent += `[${ts}] ${text}\n`;
                els.log.scrollTop = els.log.scrollHeight;
            }

            function setStatus(text) {
                els.state.textContent = text;
            }

            function setProgress(done, total) {
                els.progressText.textContent = `${done} / ${total}`;
                const pct = total > 0 ? (done / total) * 100 : 0;
                els.bar.style.width = `${Math.min(100, Math.max(0, pct)).toFixed(2)}%`;
            }

            function formatNum(v, digits = 6) {
                if (!Number.isFinite(v)) return "-";
                const abs = Math.abs(v);
                const d = abs >= 100 ? 2 : abs >= 1 ? 4 : digits;
                return v.toFixed(d);
            }

            async function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            async function fetchJson(url, retry = 4) {
                let lastErr = null;

                for (let attempt = 0; attempt <= retry; attempt += 1) {
                    try {
                        const res = await fetch(url, { method: "GET" });

                        if (res.status === 429 || res.status === 418) {
                            const backoff = 400 * Math.pow(2, attempt);
                            logLine(`Rate limit 감지(${res.status}). ${backoff}ms 대기 후 재시도...`);
                            await sleep(backoff);
                            continue;
                        }

                        if (!res.ok) {
                            const t = await res.text();
                            throw new Error(`HTTP ${res.status}: ${t}`);
                        }

                        return await res.json();
                    } catch (e) {
                        lastErr = e;
                        const backoff = 250 * Math.pow(2, attempt);
                        await sleep(backoff);
                    }
                }

                throw lastErr;
            }

            function computeSMAFromTail(values, period) {
                if (values.length < period) return NaN;
                let sum = 0;
                for (let i = values.length - period; i < values.length; i += 1) {
                    sum += values[i];
                }
                return sum / period;
            }

            function isClosedKline(k, serverTimeMs) {
                const closeTime = Number(k[6]);
                return closeTime <= serverTimeMs;
            }

            async function getServerTime() {
                const data = await fetchJson(`${BASE_URL}/fapi/v1/time`);
                return Number(data.serverTime);
            }

            async function getAllUsdtPerpSymbols() {
                const info = await fetchJson(`${BASE_URL}/fapi/v1/exchangeInfo`);
                const symbols = (info.symbols || [])
                    .filter((s) => s.contractType === "PERPETUAL")
                    .filter((s) => s.quoteAsset === "USDT")
                    .filter((s) => s.status === "TRADING")
                    .map((s) => s.symbol);

                return symbols;
            }

            /**
             * ✅ 핵심 변경
             * 1D 99MA를 "현재 진행중인 일봉"까지 포함해서 계산.
             * - Binance klines에서 마지막 캔들은 진행중인 1D일 수 있고,
             *   close 값이 현재가처럼 계속 갱신됨.
             * - 따라서 closeTime 필터로 "닫힌 일봉만" 추리는 로직을 제거.
             * - 뒤에서 99개로 SMA 계산 (마지막이 현재 일봉 close 포함)
             */
            async function getDailySMA99IncludingCurrent(symbol) {
                const klines = await fetchJson(
                    `${BASE_URL}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1d&limit=120`
                );

                const closes = klines
                    .map((k) => Number(k[4]))
                    .filter((v) => Number.isFinite(v));

                return computeSMAFromTail(closes, 99);
            }

            async function get15mLastTwoClosedCloses(symbol, serverTimeMs) {
                const klines = await fetchJson(
                    `${BASE_URL}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=15m&limit=10`
                );

                const closed = klines.filter((k) => isClosedKline(k, serverTimeMs));
                if (closed.length < 3) return null;

                const k2 = closed[closed.length - 2]; // 1봉전(직전 마감)
                const k3 = closed[closed.length - 3]; // 2봉전(그 이전 마감)

                const closePrev1 = Number(k2[4]);
                const closePrev2 = Number(k3[4]);

                if (!Number.isFinite(closePrev1) || !Number.isFinite(closePrev2)) return null;

                return { closePrev1, closePrev2 };
            }

            function renderResults() {
                const sortMode = els.sort.value;
                const list = [...state.matches];

                if (sortMode === "symbol") {
                    list.sort((a, b) => a.symbol.localeCompare(b.symbol));
                } else if (sortMode === "gapAsc") {
                    list.sort((a, b) => a.gap - b.gap);
                } else if (sortMode === "gapDesc") {
                    list.sort((a, b) => b.gap - a.gap);
                }

                els.matchCount.textContent = String(list.length);

                if (list.length === 0) {
                    els.tbody.innerHTML = `<tr><td colspan="6" class="muted">조건을 만족하는 심볼이 없습니다.</td></tr>`;
                    return;
                }

                const rows = list.map((x) => {
                    const tv = `https://www.tradingview.com/chart/?symbol=BINANCE:${x.symbol}.P`;
                    const binance = `https://www.binance.com/en/futures/${x.symbol}`;
                    return `
                        <tr>
                            <td><b>${x.symbol}</b></td>
                            <td>${formatNum(x.sma99)}</td>
                            <td>${formatNum(x.closePrev2)}</td>
                            <td>${formatNum(x.closePrev1)}</td>
                            <td>${formatNum(x.gap)}</td>
                            <td>
                                <a href="${binance}" target="_blank" rel="noreferrer">Binance</a>
                                ·
                                <a href="${tv}" target="_blank" rel="noreferrer">TV</a>
                            </td>
                        </tr>
                    `;
                });

                els.tbody.innerHTML = rows.join("");
            }

            async function asyncPool(limit, items, iteratorFn) {
                const ret = [];
                const executing = [];

                for (const item of items) {
                    if (state.abort) break;

                    const p = Promise.resolve().then(() => iteratorFn(item));
                    ret.push(p);

                    if (limit <= items.length) {
                        const e = p.then(() => {
                            const idx = executing.indexOf(e);
                            if (idx >= 0) executing.splice(idx, 1);
                        });
                        executing.push(e);

                        if (executing.length >= limit) {
                            await Promise.race(executing);
                        }
                    }
                }

                return Promise.allSettled(ret);
            }

            async function scanOneSymbol(symbol, delayMs) {
                if (state.abort) return;

                try {
                    // 1) 1D 99MA (현재 일봉 포함)
                    const sma99 = await getDailySMA99IncludingCurrent(symbol);
                    if (!Number.isFinite(sma99)) return;

                    if (state.abort) return;

                    // 2) 15m 종가 2개(2봉전/1봉전) - 마감봉만
                    const c = await get15mLastTwoClosedCloses(symbol, state.serverTime);
                    if (!c) return;

                    const { closePrev1, closePrev2 } = c;

                    // 조건:
                    // 2봉전 종가 < 99MA
                    // 1봉전 종가 > 99MA
                    if (closePrev2 < sma99 && closePrev1 > sma99) {
                        const gap = closePrev1 - sma99;
                        state.matches.push({
                            symbol,
                            sma99,
                            closePrev2,
                            closePrev1,
                            gap,
                        });
                    }
                } catch (e) {
                    logLine(`${symbol} 실패: ${e.message}`);
                } finally {
                    state.done += 1;
                    setProgress(state.done, state.total);

                    if (state.done % 10 === 0) {
                        renderResults();
                    }

                    if (delayMs > 0) {
                        await sleep(delayMs);
                    }
                }
            }

            async function runScan() {
                state.running = true;
                state.abort = false;
                state.done = 0;
                state.total = 0;
                state.matches = [];
                renderResults();

                els.btnStart.disabled = true;
                els.btnStop.disabled = false;

                try {
                    setStatus("서버시간 조회...");
                    state.serverTime = await getServerTime();
                    els.serverTime.textContent = new Date(state.serverTime).toLocaleString();

                    setStatus("심볼 목록 조회...");
                    const symbols = await getAllUsdtPerpSymbols();

                    state.total = symbols.length;
                    setProgress(0, state.total);
                    logLine(`스캔 대상: ${state.total} 심볼`);

                    const limit = Math.max(1, Math.min(20, Number(els.concurrency.value || 5)));
                    const delayMs = Math.max(0, Math.min(5000, Number(els.delay.value || 0)));

                    setStatus(`스캔 중... (동시 ${limit}, 딜레이 ${delayMs}ms)`);

                    await asyncPool(limit, symbols, async (sym) => {
                        if (state.abort) return;
                        await scanOneSymbol(sym, delayMs);
                    });

                    if (!state.abort) {
                        setStatus("완료");
                        renderResults();
                        logLine(`완료. 매칭: ${state.matches.length}`);
                    } else {
                        setStatus("중지됨");
                        renderResults();
                        logLine("사용자에 의해 중지됨.");
                    }
                } catch (e) {
                    setStatus("오류");
                    logLine(`전체 오류: ${e.message}`);
                } finally {
                    state.running = false;
                    els.btnStart.disabled = false;
                    els.btnStop.disabled = true;
                }
            }

            els.btnStart.addEventListener("click", () => {
                if (state.running) return;
                runScan();
            });

            els.btnStop.addEventListener("click", () => {
                state.abort = true;
                setStatus("중지 요청...");
                els.btnStop.disabled = true;
            });

            els.btnClearLog.addEventListener("click", () => {
                els.log.textContent = "";
            });

            els.sort.addEventListener("change", () => {
                renderResults();
            });

            logLine("준비 완료. '스캔 시작'을 누르세요.");
        </script>
    </body>
</html>