<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT-PERP 15m Trend Pullback Scanner (v2)</title>
    <style>
        :root {
            --bg: #0b0f14;
            --card: #121924;
            --text: #e9eef5;
            --muted: #9fb0c3;
            --line: #223044;
            --good: #35d07f;
            --bad: #ff5c5c;
            --warn: #ffd166;
            --blue: #5aa9ff;
        }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
            background: var(--bg);
            color: var(--text);
        }
        .wrap {
            max-width: 1240px;
            margin: 0 auto;
            padding: 18px;
        }
        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        .card {
            background: var(--card);
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 14px;
        }
        .card h2 {
            margin: 0 0 8px;
            font-size: 16px;
        }
        .muted { color: var(--muted); }
        .small { font-size: 12px; }
        .btn {
            background: #1c2a3d;
            border: 1px solid var(--line);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
        }
        .btn:hover { opacity: 0.92; }
        .btn.good { background: #193a2a; }
        .btn.danger { background: #3a1c1c; }

        .input {
            background: #0e141d;
            border: 1px solid var(--line);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            outline: none;
        }
        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted);
            background: #0e141d;
        }
        .tag .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warn);
        }
        .tag.on .dot { background: var(--good); }
        .tag.off .dot { background: var(--bad); }

        .kv {
            display: grid;
            grid-template-columns: 130px 1fr;
            gap: 6px 10px;
            align-items: center;
            font-size: 14px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            border-bottom: 1px solid var(--line);
            padding: 10px 8px;
            text-align: right;
            white-space: nowrap;
        }
        th:first-child, td:first-child { text-align: left; }
        th {
            position: sticky;
            top: 0;
            background: #0e141d;
            z-index: 1;
        }
        .goodText { color: var(--good); font-weight: 800; }
        .badText { color: var(--bad); font-weight: 800; }
        .warnText { color: var(--warn); font-weight: 800; }

        .log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0e141d;
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 12px;
            height: 190px;
            overflow: auto;
            white-space: pre-wrap;
            color: #cfe0f5;
        }
        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        @media (max-width: 900px) {
            .grid2 { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="row">
        <div class="card" style="flex: 1 1 620px;">
            <h2>15m 눌림목 + 1H 추세 스캐너 (v2, 롱/숏)</h2>
            <div class="muted small">
                자동 스캔은 <b>매시 00/15/30/45분</b> 경계 직후(약 2.5초 지연)로 맞춰져 있어요.
                (KST든 UTC든 “분” 기준은 동일하게 00/15/30/45로 동작)
            </div>

            <div style="height: 10px;"></div>

            <div class="row">
                <button id="btnScan" class="btn good">Scan Now</button>
                <button id="btnStart" class="btn">Start Auto Scan</button>
                <button id="btnStop" class="btn danger" disabled>Stop</button>

                <span id="autoState" class="tag off">
                    <span class="dot"></span>
                    <span>Auto: OFF</span>
                </span>

                <span class="tag">
                    <span class="dot" style="background: var(--blue);"></span>
                    <span id="lastRun">Last Run: -</span>
                </span>
            </div>

            <div style="height: 12px;"></div>

            <div class="row" style="align-items:center;">
                <label class="muted small">Top N:</label>
                <input id="topN" class="input" type="number" value="90" min="10" max="200" style="width: 110px;" />

                <label class="muted small">min 24h QV(USDT):</label>
                <input id="minQv" class="input" type="number" value="60000000" min="0" step="1000000" style="width: 170px;" />

                <label class="muted small">RR (fallback):</label>
                <input id="rr" class="input" type="number" value="1.8" min="0.8" max="5" step="0.1" style="width: 90px;" />

                <label class="muted small">Vol x (15m):</label>
                <input id="volMult" class="input" type="number" value="1.25" min="1" max="3" step="0.05" style="width: 90px;" />

                <label class="muted small">Stop% (min~max):</label>
                <input id="stopMin" class="input" type="number" value="0.25" min="0.05" max="3" step="0.05" style="width: 85px;" />
                <span class="muted small">~</span>
                <input id="stopMax" class="input" type="number" value="1.15" min="0.1" max="5" step="0.05" style="width: 85px;" />

                <label class="muted small">Chase (ATRx):</label>
                <input id="maxChaseAtr" class="input" type="number" value="0.75" min="0.2" max="2" step="0.05" style="width: 90px;" />

                <label class="muted small">Concur:</label>
                <input id="concurrency" class="input" type="number" value="6" min="1" max="10" style="width: 90px;" />
            </div>

            <div style="height: 10px;"></div>
            <div class="muted small">
                ✅ Entry/TP/SL은 “신호봉 확정” 시점 기준 참고값. 실제 체결은 호가/슬리피지에 따라 달라질 수 있어요.
            </div>
        </div>

        <div class="card" style="flex: 1 1 560px;">
            <h2>Top Pick (점수 1등)</h2>
            <div id="topPick" class="kv">
                <div class="muted">Symbol</div><div><b>-</b></div>
                <div class="muted">Side</div><div><b>-</b></div>
                <div class="muted">Score</div><div><b>-</b></div>
                <div class="muted">Entry</div><div><b>-</b></div>
                <div class="muted">TP</div><div><b>-</b></div>
                <div class="muted">SL</div><div><b>-</b></div>
                <div class="muted">Stop%</div><div><b>-</b></div>
                <div class="muted">TP%</div><div><b>-</b></div>
                <div class="muted">Signal</div><div><b>-</b></div>
            </div>
            <div style="height: 8px;"></div>
            <div class="muted small">
                TP는 <b>스윙 타겟 우선</b>으로 잡고, 부족하면 RR 기반 TP로 대체합니다.
            </div>
        </div>
    </div>

    <div class="grid2" style="margin-top: 12px;">
        <div class="card">
            <h2>Results (상위 50)</h2>
            <div style="overflow:auto; max-height: 560px; border-radius: 12px;">
                <table>
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Score</th>
                            <th>Entry</th>
                            <th>TP</th>
                            <th>SL</th>
                            <th>Stop%</th>
                            <th>TP%</th>
                            <th>1H Trend</th>
                            <th>15m Signal</th>
                            <th>24h QV</th>
                        </tr>
                    </thead>
                    <tbody id="tbody">
                        <tr><td colspan="11" class="muted" style="text-align:center;">아직 스캔 전</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="card">
            <h2>Log</h2>
            <div id="log" class="log"></div>
        </div>
    </div>
</div>

<script>
    "use strict";

    // ----------------------------
    // Binance Futures REST endpoints
    // ----------------------------
    const BASE = "https://fapi.binance.com";
    const EP_EXCHANGE_INFO = BASE + "/fapi/v1/exchangeInfo";
    const EP_TICKER_24H = BASE + "/fapi/v1/ticker/24hr";
    const EP_KLINES = BASE + "/fapi/v1/klines";

    // ----------------------------
    // Utils
    // ----------------------------
    function logLine(msg) {
        const el = document.getElementById("log");
        const stamp = new Date().toLocaleString();
        el.textContent += `[${stamp}] ${msg}\n`;
        el.scrollTop = el.scrollHeight;
    }

    function fmt(n, digits = 6) {
        if (!isFinite(n)) return "-";
        const abs = Math.abs(n);
        if (abs >= 1000) return n.toFixed(2);
        if (abs >= 1) return n.toFixed(4);
        return n.toFixed(digits);
    }

    function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
    }

    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function fetchJson(url, opts = {}) {
        const res = await fetch(url, opts);
        if (!res.ok) {
            const text = await res.text().catch(() => "");
            throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 160)}`);
        }
        return res.json();
    }

    // Binance klines last element is usually the currently forming candle.
    function lastClosedIndex(klines) {
        const now = Date.now();
        for (let i = klines.length - 1; i >= 0; i -= 1) {
            const closeTime = Number(klines[i][6]);
            if (closeTime < now - 1000) return i;
        }
        return Math.max(0, klines.length - 2);
    }

    // ----------------------------
    // Indicators: SMA, EMA, ATR, RSI
    // ----------------------------
    function sma(values, period) {
        const out = new Array(values.length).fill(NaN);
        let sum = 0;
        for (let i = 0; i < values.length; i += 1) {
            sum += values[i];
            if (i >= period) sum -= values[i - period];
            if (i >= period - 1) out[i] = sum / period;
        }
        return out;
    }

    function ema(values, period) {
        const out = new Array(values.length).fill(NaN);
        const k = 2 / (period + 1);

        let prev = NaN;
        for (let i = 0; i < values.length; i += 1) {
            const v = values[i];
            if (!isFinite(v)) continue;

            if (!isFinite(prev)) {
                if (i + 1 >= period) {
                    let sum = 0;
                    for (let j = i - period + 1; j <= i; j += 1) sum += values[j];
                    prev = sum / period;
                    out[i] = prev;
                }
            } else {
                prev = (v - prev) * k + prev;
                out[i] = prev;
            }
        }
        return out;
    }

    function atr(high, low, close, period) {
        const tr = new Array(close.length).fill(NaN);
        for (let i = 0; i < close.length; i += 1) {
            if (i === 0) {
                tr[i] = high[i] - low[i];
                continue;
            }
            const hl = high[i] - low[i];
            const hc = Math.abs(high[i] - close[i - 1]);
            const lc = Math.abs(low[i] - close[i - 1]);
            tr[i] = Math.max(hl, hc, lc);
        }
        return ema(tr, period);
    }

    // Wilder RSI (classic)
    function rsi(close, period) {
        const out = new Array(close.length).fill(NaN);
        let gain = 0;
        let loss = 0;

        for (let i = 1; i < close.length; i += 1) {
            const chg = close[i] - close[i - 1];
            const g = chg > 0 ? chg : 0;
            const l = chg < 0 ? -chg : 0;

            if (i <= period) {
                gain += g;
                loss += l;
                if (i === period) {
                    gain /= period;
                    loss /= period;
                    const rs = loss === 0 ? 999999 : (gain / loss);
                    out[i] = 100 - (100 / (1 + rs));
                }
                continue;
            }

            gain = (gain * (period - 1) + g) / period;
            loss = (loss * (period - 1) + l) / period;

            const rs = loss === 0 ? 999999 : (gain / loss);
            out[i] = 100 - (100 / (1 + rs));
        }
        return out;
    }

    function minRange(arr, from, to) {
        let m = Infinity;
        for (let i = from; i <= to; i += 1) {
            const v = arr[i];
            if (isFinite(v)) m = Math.min(m, v);
        }
        return m;
    }

    function maxRange(arr, from, to) {
        let m = -Infinity;
        for (let i = from; i <= to; i += 1) {
            const v = arr[i];
            if (isFinite(v)) m = Math.max(m, v);
        }
        return m;
    }

    // ----------------------------
    // Strategy v2 (Long + Short)
    //  - 1H trend: EMA200 direction + EMA50 position + RSI
    //  - 15m signal: EMA20 reclaim + break confirm + RSI 50 reclaim + volume expansion
    //  - Entry: EMA20 retest limit (anti-chase) with small buffer
    //  - SL: recent swing extreme +/- ATR buffer
    //  - TP: swing target first, otherwise RR fallback
    // ----------------------------
    function evaluateSymbolV2(symbol, qv24h, kl15m, kl1h, params) {
        const rr = params.rr;
        const volMult = params.volMult;
        const stopMin = params.stopMin;
        const stopMax = params.stopMax;
        const maxChaseAtr = params.maxChaseAtr;

        const c15 = kl15m.map(k => Number(k[4]));
        const o15 = kl15m.map(k => Number(k[1]));
        const h15 = kl15m.map(k => Number(k[2]));
        const l15 = kl15m.map(k => Number(k[3]));
        const v15 = kl15m.map(k => Number(k[5]));

        const c1h = kl1h.map(k => Number(k[4]));

        const i15 = lastClosedIndex(kl15m);
        const i1h = lastClosedIndex(kl1h);

        if (i15 < 80 || i1h < 210) return null;

        // 15m indicators
        const ema20_15 = ema(c15, 20);
        const ema50_15 = ema(c15, 50);
        const atr14_15 = atr(h15, l15, c15, 14);
        const rsi14_15 = rsi(c15, 14);
        const volSma20_15 = sma(v15, 20);

        // 1H indicators
        const ema200_1h = ema(c1h, 200);
        const ema50_1h = ema(c1h, 50);
        const rsi14_1h = rsi(c1h, 14);

        const close15 = c15[i15];
        const close15_prev = c15[i15 - 1];

        const high15_prev = h15[i15 - 1];
        const low15_prev = l15[i15 - 1];

        const e20 = ema20_15[i15];
        const e20_prev = ema20_15[i15 - 1];
        const e50 = ema50_15[i15];
        const a14 = atr14_15[i15];

        const r15 = rsi14_15[i15];
        const r15_prev = rsi14_15[i15 - 1];

        const vNow = v15[i15];
        const vAvg = volSma20_15[i15];

        const close1h = c1h[i1h];
        const e200 = ema200_1h[i1h];
        const e200_prev = ema200_1h[i1h - 1];
        const e50_1h_now = ema50_1h[i1h];
        const r1h = rsi14_1h[i1h];

        if (![e20, e20_prev, e50, a14, r15, r15_prev, vAvg, e200, e200_prev, e50_1h_now, r1h].every(isFinite)) {
            return null;
        }

        // Common filters
        const volOk = vNow >= (vAvg * volMult);

        // Anti-chase: signal candle should not be too far from EMA20
        const distFromE20 = Math.abs(close15 - e20);
        const chaseOk = distFromE20 <= (maxChaseAtr * a14);

        if (!volOk || !chaseOk) return null;

        // --------------------------------
        // LONG conditions
        // --------------------------------
        const longTrendOk =
            (close1h > e200) &&
            (e50_1h_now > e200) &&
            (e200 > e200_prev) &&
            (r1h >= 52);

        const longReclaim = (close15 > e20) && (close15_prev <= e20_prev);
        const longBreakConfirm = (close15 > high15_prev);                  // stronger than just reclaim
        const longRsiConfirm = (r15_prev <= 50) && (r15 > 50);             // 50 reclaim
        const longAbove50 = (close15 > e50);
        const longTouched = (l15[i15] <= (e20 * 1.0015));                  // touch near EMA20
        const longSignalOk = longTrendOk && longReclaim && longBreakConfirm && longRsiConfirm && longAbove50 && longTouched;

        // --------------------------------
        // SHORT conditions
        // --------------------------------
        const shortTrendOk =
            (close1h < e200) &&
            (e50_1h_now < e200) &&
            (e200 < e200_prev) &&
            (r1h <= 48);

        const shortReclaim = (close15 < e20) && (close15_prev >= e20_prev);
        const shortBreakConfirm = (close15 < low15_prev);
        const shortRsiConfirm = (r15_prev >= 50) && (r15 < 50);
        const shortBelow50 = (close15 < e50);
        const shortTouched = (h15[i15] >= (e20 * 0.9985));
        const shortSignalOk = shortTrendOk && shortReclaim && shortBreakConfirm && shortRsiConfirm && shortBelow50 && shortTouched;

        // Evaluate both sides, return best (or null)
        const candidates = [];

        // Helper for TP selection (swing-first)
        function pickTpLong(entry, sl, risk) {
            const rrTp = entry + rr * risk;

            const lookback = 48;
            const from = Math.max(0, i15 - lookback);
            const swingHigh = maxRange(h15, from, i15);

            if (isFinite(swingHigh) && swingHigh > entry) {
                const swingTp = swingHigh - (0.10 * a14);
                const swingRR = (swingTp - entry) / (risk + 1e-9);
                if (swingRR >= 1.2) return { tp: swingTp, mode: "SWING" };
            }

            return { tp: rrTp, mode: "RR" };
        }

        function pickTpShort(entry, sl, risk) {
            const rrTp = entry - rr * risk;

            const lookback = 48;
            const from = Math.max(0, i15 - lookback);
            const swingLow = minRange(l15, from, i15);

            if (isFinite(swingLow) && swingLow < entry) {
                const swingTp = swingLow + (0.10 * a14);
                const swingRR = (entry - swingTp) / (risk + 1e-9);
                if (swingRR >= 1.2) return { tp: swingTp, mode: "SWING" };
            }

            return { tp: rrTp, mode: "RR" };
        }

        // LONG build
        if (longSignalOk) {
            const entry = e20 * 1.0002; // EMA20 retest limit (tiny buffer)
            const swingLow = minRange(l15, Math.max(0, i15 - 12), i15);
            const sl = swingLow - (0.35 * a14);
            if (isFinite(entry) && isFinite(sl) && sl < entry) {
                const risk = entry - sl;
                const stopPct = (risk / entry) * 100;
                if (stopPct >= stopMin && stopPct <= stopMax) {
                    const tpPick = pickTpLong(entry, sl, risk);
                    const tp = tpPick.tp;
                    const tpPct = ((tp - entry) / entry) * 100;

                    const trendStrength = ((close1h - e200) / e200) * 100;
                    const trendSlope = ((e200 - e200_prev) / e200_prev) * 100;

                    const reclaimStrength = ((close15 - e20) / e20) * 100;
                    const volBoost = clamp((vNow / (vAvg + 1e-9)) - 1, 0, 3);

                    let score = 0;
                    score += trendStrength * 2.2;
                    score += trendSlope * 140;
                    score += (r1h - 50) * 0.7;
                    score += reclaimStrength * 2.0;
                    score += volBoost * 1.3;
                    score -= clamp(stopPct / 1.2, 0, 3) * 2.0;
                    score += tpPick.mode === "SWING" ? 1.2 : 0.6;

                    candidates.push({
                        symbol,
                        side: "LONG",
                        score,
                        entry,
                        tp,
                        sl,
                        stopPct,
                        tpPct,
                        trendOk: true,
                        signalOk: true,
                        qv24h,
                        signalText: `1H↑(EMA200/50+RSI) + 15m EMA20 리클레임 + 전고 돌파 + RSI50↑ + Vol`,
                        tpMode: tpPick.mode
                    });
                }
            }
        }

        // SHORT build
        if (shortSignalOk) {
            const entry = e20 * 0.9998; // EMA20 retest limit (tiny buffer)
            const swingHigh = maxRange(h15, Math.max(0, i15 - 12), i15);
            const sl = swingHigh + (0.35 * a14);
            if (isFinite(entry) && isFinite(sl) && sl > entry) {
                const risk = sl - entry;
                const stopPct = (risk / entry) * 100;
                if (stopPct >= stopMin && stopPct <= stopMax) {
                    const tpPick = pickTpShort(entry, sl, risk);
                    const tp = tpPick.tp;
                    const tpPct = ((entry - tp) / entry) * 100;

                    const trendStrength = ((e200 - close1h) / e200) * 100;
                    const trendSlope = ((e200_prev - e200) / e200_prev) * 100;

                    const reclaimStrength = ((e20 - close15) / e20) * 100;
                    const volBoost = clamp((vNow / (vAvg + 1e-9)) - 1, 0, 3);

                    let score = 0;
                    score += trendStrength * 2.2;
                    score += trendSlope * 140;
                    score += (50 - r1h) * 0.7;
                    score += reclaimStrength * 2.0;
                    score += volBoost * 1.3;
                    score -= clamp(stopPct / 1.2, 0, 3) * 2.0;
                    score += tpPick.mode === "SWING" ? 1.2 : 0.6;

                    candidates.push({
                        symbol,
                        side: "SHORT",
                        score,
                        entry,
                        tp,
                        sl,
                        stopPct,
                        tpPct,
                        trendOk: true,
                        signalOk: true,
                        qv24h,
                        signalText: `1H↓(EMA200/50+RSI) + 15m EMA20 리클레임 + 전저 이탈 + RSI50↓ + Vol`,
                        tpMode: tpPick.mode
                    });
                }
            }
        }

        if (candidates.length === 0) return null;

        candidates.sort((a, b) => b.score - a.score);
        return candidates[0];
    }

    // ----------------------------
    // Market universe
    // ----------------------------
    async function getUsdtPerpSymbols() {
        const info = await fetchJson(EP_EXCHANGE_INFO);
        const syms = info.symbols
            .filter(s =>
                s.contractType === "PERPETUAL" &&
                s.quoteAsset === "USDT" &&
                s.status === "TRADING" &&
                s.symbol.endsWith("USDT")
            )
            .map(s => s.symbol);
        return syms;
    }

    async function get24hTickers() {
        return fetchJson(EP_TICKER_24H);
    }

    function pickTopByQuoteVolume(allTickers, allowedSymbols, topN, minQv) {
        const set = new Set(allowedSymbols);
        return allTickers
            .filter(t => set.has(t.symbol))
            .map(t => ({
                symbol: t.symbol,
                quoteVolume: Number(t.quoteVolume || 0)
            }))
            .filter(x => x.quoteVolume >= minQv)
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, topN);
    }

    async function getKlines(symbol, interval, limit) {
        const url = `${EP_KLINES}?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
        return fetchJson(url);
    }

    async function mapPool(items, worker, concurrency) {
        const out = new Array(items.length);
        let idx = 0;

        async function runOne() {
            while (idx < items.length) {
                const cur = idx;
                idx += 1;
                out[cur] = await worker(items[cur], cur);
            }
        }

        const runners = [];
        for (let i = 0; i < concurrency; i += 1) runners.push(runOne());
        await Promise.all(runners);
        return out;
    }

    // ----------------------------
    // UI render
    // ----------------------------
    function renderTopPick(best) {
        const el = document.getElementById("topPick");
        if (!best) {
            el.innerHTML = `
                <div class="muted">Symbol</div><div><b>-</b></div>
                <div class="muted">Side</div><div><b>-</b></div>
                <div class="muted">Score</div><div><b>-</b></div>
                <div class="muted">Entry</div><div><b>-</b></div>
                <div class="muted">TP</div><div><b>-</b></div>
                <div class="muted">SL</div><div><b>-</b></div>
                <div class="muted">Stop%</div><div><b>-</b></div>
                <div class="muted">TP%</div><div><b>-</b></div>
                <div class="muted">Signal</div><div><b>-</b></div>
            `;
            return;
        }

        const sideClass = best.side === "LONG" ? "goodText" : "badText";

        el.innerHTML = `
            <div class="muted">Symbol</div><div><b class="goodText">${best.symbol}</b></div>
            <div class="muted">Side</div><div><b class="${sideClass}">${best.side}</b></div>
            <div class="muted">Score</div><div><b>${fmt(best.score, 2)}</b></div>
            <div class="muted">Entry</div><div><b>${fmt(best.entry)}</b></div>
            <div class="muted">TP (${best.tpMode})</div><div><b class="goodText">${fmt(best.tp)}</b></div>
            <div class="muted">SL</div><div><b class="badText">${fmt(best.sl)}</b></div>
            <div class="muted">Stop%</div><div><b>${fmt(best.stopPct, 2)}%</b></div>
            <div class="muted">TP%</div><div><b>${fmt(best.tpPct, 2)}%</b></div>
            <div class="muted">Signal</div><div><b class="small">${best.signalText}</b></div>
        `;
    }

    function renderTable(rows) {
        const tb = document.getElementById("tbody");
        if (!rows || rows.length === 0) {
            tb.innerHTML = `<tr><td colspan="11" class="muted" style="text-align:center;">조건 충족 종목 없음</td></tr>`;
            return;
        }

        tb.innerHTML = rows.map((r) => {
            const sideClass = r.side === "LONG" ? "goodText" : "badText";
            return `
                <tr>
                    <td><b>${r.symbol}</b></td>
                    <td class="${sideClass}"><b>${r.side}</b></td>
                    <td>${fmt(r.score, 2)}</td>
                    <td>${fmt(r.entry)}</td>
                    <td class="goodText">${fmt(r.tp)} <span class="muted small">(${r.tpMode})</span></td>
                    <td class="badText">${fmt(r.sl)}</td>
                    <td>${fmt(r.stopPct, 2)}%</td>
                    <td>${fmt(r.tpPct, 2)}%</td>
                    <td><span class="goodText">OK</span></td>
                    <td><span class="goodText">YES</span></td>
                    <td>${fmt(r.qv24h, 2)}</td>
                </tr>
            `;
        }).join("");
    }

    // ----------------------------
    // Scan core
    // ----------------------------
    let scanning = false;
    let autoTimer = null;
    let autoArmed = false;

    async function scanOnce() {
        if (scanning) {
            logLine("이미 스캔 중이라 이번 실행은 건너뜁니다.");
            return;
        }

        scanning = true;
        document.getElementById("btnScan").disabled = true;

        try {
            const topN = clamp(Number(document.getElementById("topN").value || 90), 10, 200);
            const minQv = Math.max(0, Number(document.getElementById("minQv").value || 0));
            const rr = clamp(Number(document.getElementById("rr").value || 1.8), 0.8, 5);
            const volMult = clamp(Number(document.getElementById("volMult").value || 1.25), 1, 3);
            const stopMin = clamp(Number(document.getElementById("stopMin").value || 0.25), 0.05, 10);
            const stopMax = clamp(Number(document.getElementById("stopMax").value || 1.15), 0.1, 10);
            const maxChaseAtr = clamp(Number(document.getElementById("maxChaseAtr").value || 0.75), 0.2, 3);
            const concurrency = clamp(Number(document.getElementById("concurrency").value || 6), 1, 10);

            const params = { rr, volMult, stopMin, stopMax, maxChaseAtr };

            logLine(`스캔 시작: TopN=${topN}, minQv=${minQv}, RR=${rr}, Volx=${volMult}, Stop%=[${stopMin}~${stopMax}], ChaseATR=${maxChaseAtr}`);

            const [symbols, tickers] = await Promise.all([
                getUsdtPerpSymbols(),
                get24hTickers()
            ]);

            const universe = pickTopByQuoteVolume(tickers, symbols, topN, minQv);
            logLine(`대상 심볼 수: ${universe.length}개`);

            const results = [];

            const worker = async (row) => {
                const symbol = row.symbol;

                await sleep(35);

                for (let attempt = 1; attempt <= 3; attempt += 1) {
                    try {
                        const [kl15m, kl1h] = await Promise.all([
                            getKlines(symbol, "15m", 260),
                            getKlines(symbol, "1h", 260)
                        ]);

                        const r = evaluateSymbolV2(symbol, row.quoteVolume, kl15m, kl1h, params);
                        if (r) results.push(r);
                        return;
                    } catch (e) {
                        const msg = String(e && e.message ? e.message : e);
                        const isRate = msg.indexOf("HTTP 429") > -1 || msg.indexOf("HTTP 418") > -1;
                        if (isRate && attempt < 3) {
                            const backoff = attempt * 900;
                            logLine(`${symbol} rate-limit, ${backoff}ms 후 재시도 (${attempt}/3)`);
                            await sleep(backoff);
                            continue;
                        }
                        logLine(`${symbol} 실패: ${msg}`);
                        return;
                    }
                }
            };

            await mapPool(universe, worker, concurrency);

            results.sort((a, b) => b.score - a.score);

            const best = results[0] || null;
            renderTopPick(best);
            renderTable(results.slice(0, 50));

            document.getElementById("lastRun").textContent = `Last Run: ${new Date().toLocaleString()}`;
            logLine(`스캔 완료: 조건충족 ${results.length}개, TopPick=${best ? (best.symbol + " " + best.side) : "-"}`);

        } catch (e) {
            logLine(`스캔 에러: ${String(e && e.message ? e.message : e)}`);
        } finally {
            scanning = false;
            document.getElementById("btnScan").disabled = false;
        }
    }

    // ----------------------------
    // Auto schedule: next local quarter-minute + delay
    // ----------------------------
    function msUntilNextQuarter(delayMs) {
        const now = new Date();
        const m = now.getMinutes();
        const s = now.getSeconds();
        const ms = now.getMilliseconds();

        const nextQuarter = (Math.floor(m / 15) + 1) * 15;
        const next = new Date(now.getTime());

        next.setSeconds(0);
        next.setMilliseconds(0);

        if (nextQuarter >= 60) {
            next.setMinutes(0);
            next.setHours(next.getHours() + 1);
        } else {
            next.setMinutes(nextQuarter);
        }

        const diff = next.getTime() - now.getTime();
        const extra = delayMs || 2500;
        return Math.max(0, diff - (s * 1000 + ms)) + extra;
    }

    function setAutoState(on) {
        const el = document.getElementById("autoState");
        if (on) {
            el.classList.remove("off");
            el.classList.add("on");
            el.innerHTML = `<span class="dot"></span><span>Auto: ON</span>`;
        } else {
            el.classList.remove("on");
            el.classList.add("off");
            el.innerHTML = `<span class="dot"></span><span>Auto: OFF</span>`;
        }
    }

    function startAuto() {
        if (autoArmed) return;

        autoArmed = true;
        document.getElementById("btnStart").disabled = true;
        document.getElementById("btnStop").disabled = false;
        setAutoState(true);

        logLine("Auto Scan ON: 다음 00/15/30/45 경계 직후 실행 예약");

        const delay = msUntilNextQuarter(2500);
        logLine(`다음 실행까지 대기: ${(delay / 1000).toFixed(1)}s`);

        autoTimer = setTimeout(async function tick() {
            if (!autoArmed) return;

            await scanOnce();

            const nextDelay = msUntilNextQuarter(2500);
            logLine(`다음 실행 예약: ${(nextDelay / 1000).toFixed(1)}s`);
            autoTimer = setTimeout(tick, nextDelay);
        }, delay);
    }

    function stopAuto() {
        autoArmed = false;
        if (autoTimer) {
            clearTimeout(autoTimer);
            autoTimer = null;
        }
        document.getElementById("btnStart").disabled = false;
        document.getElementById("btnStop").disabled = true;
        setAutoState(false);
        logLine("Auto Scan OFF");
    }

    // ----------------------------
    // Bind UI
    // ----------------------------
    document.getElementById("btnScan").addEventListener("click", function () {
        scanOnce();
    });

    document.getElementById("btnStart").addEventListener("click", function () {
        startAuto();
    });

    document.getElementById("btnStop").addEventListener("click", function () {
        stopAuto();
    });

    logLine("준비 완료. Scan Now 또는 Start Auto Scan을 누르세요.");
</script>
</body>
</html>
