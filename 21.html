<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT-PERP 15m Trend Pullback Backtest (Date Picker)</title>
    <style>
        :root {
            --bg: #0b0f14;
            --card: #121924;
            --text: #e9eef5;
            --muted: #9fb0c3;
            --line: #223044;
            --good: #35d07f;
            --bad: #ff5c5c;
            --warn: #ffd166;
            --blue: #5aa9ff;
        }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
            background: var(--bg);
            color: var(--text);
        }
        .wrap {
            max-width: 1280px;
            margin: 0 auto;
            padding: 18px;
        }
        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        .card {
            background: var(--card);
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 14px;
        }
        .card h2 {
            margin: 0 0 8px;
            font-size: 16px;
        }
        .muted { color: var(--muted); }
        .small { font-size: 12px; }
        .btn {
            background: #1c2a3d;
            border: 1px solid var(--line);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
        }
        .btn:hover { opacity: 0.92; }
        .btn.good { background: #193a2a; }
        .btn.danger { background: #3a1c1c; }
        .btn:disabled { opacity: 0.55; cursor: not-allowed; }

        .input, .select {
            background: #0e141d;
            border: 1px solid var(--line);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            outline: none;
        }

        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted);
            background: #0e141d;
        }
        .tag .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warn);
        }

        .kv {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 6px 10px;
            align-items: center;
            font-size: 14px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            border-bottom: 1px solid var(--line);
            padding: 10px 8px;
            text-align: right;
            white-space: nowrap;
        }
        th:first-child, td:first-child { text-align: left; }
        th {
            position: sticky;
            top: 0;
            background: #0e141d;
            z-index: 1;
        }

        .goodText { color: var(--good); font-weight: 800; }
        .badText { color: var(--bad); font-weight: 800; }
        .warnText { color: var(--warn); font-weight: 800; }

        .log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0e141d;
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 12px;
            height: 190px;
            overflow: auto;
            white-space: pre-wrap;
            color: #cfe0f5;
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        @media (max-width: 900px) {
            .grid2 { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="row">
        <div class="card" style="flex: 1 1 760px;">
            <h2>날짜 선택 백테스트: 15m 눌림목 + 1H 추세 (롱/숏)</h2>
            <div class="muted small">
                선택한 날짜(하루) 동안 15분마다 조건을 만족한 시그널을 전부 찾고,
                진입(EMA20 리테스트 지정가) 체결 후 TP/SL 먼저 닿았는지 판정합니다.
            </div>

            <div style="height: 12px;"></div>

            <div class="row">
                <label class="muted small">날짜:</label>
                <input id="date" class="input" type="date" />

                <label class="muted small">기준:</label>
                <select id="tz" class="select">
                    <option value="KST" selected>KST (한국시간 00:00~23:59)</option>
                    <option value="UTC">UTC (00:00~23:59)</option>
                </select>

                <label class="muted small">모드:</label>
                <select id="mode" class="select">
                    <option value="single" selected>Single Symbol</option>
                    <option value="top">TopN by 24h QuoteVolume</option>
                </select>

                <label class="muted small">Symbol:</label>
                <input id="symbol" class="input" type="text" value="BTCUSDT" style="width: 140px;" />

                <label class="muted small">TopN:</label>
                <input id="topN" class="input" type="number" value="30" min="5" max="120" style="width: 90px;" />

                <label class="muted small">min 24h QV:</label>
                <input id="minQv" class="input" type="number" value="60000000" step="1000000" style="width: 150px;" />

                <label class="muted small">Concur:</label>
                <input id="concurrency" class="input" type="number" value="4" min="1" max="8" style="width: 80px;" />
            </div>

            <div style="height: 10px;"></div>

            <div class="row">
                <label class="muted small">RR fallback:</label>
                <input id="rr" class="input" type="number" value="1.8" min="0.8" max="5" step="0.1" style="width: 90px;" />

                <label class="muted small">Vol x (15m):</label>
                <input id="volMult" class="input" type="number" value="1.25" min="1" max="3" step="0.05" style="width: 90px;" />

                <label class="muted small">Stop% (min~max):</label>
                <input id="stopMin" class="input" type="number" value="0.25" min="0.05" max="5" step="0.05" style="width: 85px;" />
                <span class="muted small">~</span>
                <input id="stopMax" class="input" type="number" value="1.15" min="0.1" max="8" step="0.05" style="width: 85px;" />

                <label class="muted small">Chase (ATRx):</label>
                <input id="maxChaseAtr" class="input" type="number" value="0.75" min="0.2" max="2" step="0.05" style="width: 90px;" />

                <label class="muted small">Entry window (bars):</label>
                <input id="entryWindow" class="input" type="number" value="4" min="1" max="24" style="width: 80px;" />

                <label class="muted small">Max hold (bars):</label>
                <input id="maxHold" class="input" type="number" value="24" min="4" max="200" style="width: 80px;" />

                <label class="muted small">TP/SL 동시터치:</label>
                <select id="tieMode" class="select">
                    <option value="SL_FIRST" selected>보수적(SL 우선)</option>
                    <option value="TP_FIRST">낙관적(TP 우선)</option>
                </select>
            </div>

            <div style="height: 12px;"></div>

            <div class="row">
                <button id="btnRun" class="btn good">Run Backtest</button>
                <button id="btnCsv" class="btn" disabled>Export CSV</button>
                <span class="tag">
                    <span class="dot" style="background: var(--blue);"></span>
                    <span id="status">Ready</span>
                </span>
            </div>

            <div style="height: 8px;"></div>
            <div class="muted small">
                ⚠️ 캔들 데이터 기반 백테스트는 체결/순서/슬리피지/수수료를 완벽히 재현하지 못합니다.
                특히 같은 15m 캔들에서 TP/SL이 같이 닿는 경우는 “동시터치 처리” 옵션에 따라 결과가 달라집니다.
            </div>
        </div>

        <div class="card" style="flex: 1 1 480px;">
            <h2>요약</h2>
            <div id="summary" class="kv">
                <div class="muted">Signals</div><div><b>-</b></div>
                <div class="muted">Filled</div><div><b>-</b></div>
                <div class="muted">No Fill</div><div><b>-</b></div>
                <div class="muted">Wins (TP)</div><div><b>-</b></div>
                <div class="muted">Losses (SL)</div><div><b>-</b></div>
                <div class="muted">EOD/Timeout</div><div><b>-</b></div>
                <div class="muted">Win Rate</div><div><b>-</b></div>
                <div class="muted">Avg PnL%</div><div><b>-</b></div>
                <div class="muted">Total PnL%</div><div><b>-</b></div>
            </div>
        </div>
    </div>

    <div class="grid2" style="margin-top: 12px;">
        <div class="card">
            <h2>Trades (해당 날짜 시그널 전부)</h2>
            <div style="overflow:auto; max-height: 620px; border-radius: 12px;">
                <table>
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Entry</th>
                            <th>TP</th>
                            <th>SL</th>
                            <th>Outcome</th>
                            <th>PnL%</th>
                            <th>Fill</th>
                            <th>ExitTime</th>
                            <th>Note</th>
                        </tr>
                    </thead>
                    <tbody id="tbody">
                        <tr><td colspan="11" class="muted" style="text-align:center;">아직 실행 전</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="card">
            <h2>Log</h2>
            <div id="log" class="log"></div>
        </div>
    </div>
</div>

<script>
    "use strict";

    // ----------------------------
    // Binance Futures REST endpoints
    // ----------------------------
    const BASE = "https://fapi.binance.com";
    const EP_EXCHANGE_INFO = BASE + "/fapi/v1/exchangeInfo";
    const EP_TICKER_24H = BASE + "/fapi/v1/ticker/24hr";
    const EP_KLINES = BASE + "/fapi/v1/klines";

    // ----------------------------
    // Logger & helpers
    // ----------------------------
    function logLine(msg) {
        const el = document.getElementById("log");
        const stamp = new Date().toLocaleString();
        el.textContent += `[${stamp}] ${msg}\n`;
        el.scrollTop = el.scrollHeight;
    }

    function setStatus(s) {
        document.getElementById("status").textContent = s;
    }

    function fmt(n, digits = 6) {
        if (!isFinite(n)) return "-";
        const abs = Math.abs(n);
        if (abs >= 1000) return n.toFixed(2);
        if (abs >= 1) return n.toFixed(4);
        return n.toFixed(digits);
    }

    function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
    }

    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function pad2(x) {
        return String(x).padStart(2, "0");
    }

    function fmtTime(ms, tz) {
        if (!isFinite(ms)) return "-";
        if (tz === "KST") {
            const d = new Date(ms + 9 * 3600 * 1000);
            return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())} ${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}`;
        }
        const d = new Date(ms);
        return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())} ${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}`;
    }

    function getDayRangeMs(dateStr, tz) {
        // dateStr: YYYY-MM-DD
        if (!dateStr) return null;

        if (tz === "KST") {
            const start = new Date(`${dateStr}T00:00:00+09:00`).getTime();
            const end = start + 24 * 3600 * 1000;
            return { start, end };
        }

        const start = new Date(`${dateStr}T00:00:00Z`).getTime();
        const end = start + 24 * 3600 * 1000;
        return { start, end };
    }

    async function fetchJsonWithHeaders(url, opts = {}) {
        const res = await fetch(url, opts);
        const retryAfter = res.headers.get("Retry-After");
        if (!res.ok) {
            const text = await res.text().catch(() => "");
            const err = new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 160)}`);
            err.httpStatus = res.status;
            err.retryAfter = retryAfter ? Number(retryAfter) : null;
            throw err;
        }
        const json = await res.json();
        return { json, retryAfter: retryAfter ? Number(retryAfter) : null };
    }

    async function fetchJson(url) {
        return (await fetchJsonWithHeaders(url)).json;
    }

    // ----------------------------
    // Indicators: SMA, EMA, ATR, RSI
    // ----------------------------
    function sma(values, period) {
        const out = new Array(values.length).fill(NaN);
        let sum = 0;
        for (let i = 0; i < values.length; i += 1) {
            sum += values[i];
            if (i >= period) sum -= values[i - period];
            if (i >= period - 1) out[i] = sum / period;
        }
        return out;
    }

    function ema(values, period) {
        const out = new Array(values.length).fill(NaN);
        const k = 2 / (period + 1);

        let prev = NaN;
        for (let i = 0; i < values.length; i += 1) {
            const v = values[i];
            if (!isFinite(v)) continue;

            if (!isFinite(prev)) {
                if (i + 1 >= period) {
                    let sum = 0;
                    for (let j = i - period + 1; j <= i; j += 1) sum += values[j];
                    prev = sum / period;
                    out[i] = prev;
                }
            } else {
                prev = (v - prev) * k + prev;
                out[i] = prev;
            }
        }
        return out;
    }

    function atr(high, low, close, period) {
        const tr = new Array(close.length).fill(NaN);
        for (let i = 0; i < close.length; i += 1) {
            if (i === 0) {
                tr[i] = high[i] - low[i];
                continue;
            }
            const hl = high[i] - low[i];
            const hc = Math.abs(high[i] - close[i - 1]);
            const lc = Math.abs(low[i] - close[i - 1]);
            tr[i] = Math.max(hl, hc, lc);
        }
        return ema(tr, period);
    }

    function rsi(close, period) {
        const out = new Array(close.length).fill(NaN);
        let gain = 0;
        let loss = 0;

        for (let i = 1; i < close.length; i += 1) {
            const chg = close[i] - close[i - 1];
            const g = chg > 0 ? chg : 0;
            const l = chg < 0 ? -chg : 0;

            if (i <= period) {
                gain += g;
                loss += l;
                if (i === period) {
                    gain /= period;
                    loss /= period;
                    const rs = loss === 0 ? 999999 : (gain / loss);
                    out[i] = 100 - (100 / (1 + rs));
                }
                continue;
            }

            gain = (gain * (period - 1) + g) / period;
            loss = (loss * (period - 1) + l) / period;

            const rs = loss === 0 ? 999999 : (gain / loss);
            out[i] = 100 - (100 / (1 + rs));
        }
        return out;
    }

    function minRange(arr, from, to) {
        let m = Infinity;
        for (let i = from; i <= to; i += 1) {
            const v = arr[i];
            if (isFinite(v)) m = Math.min(m, v);
        }
        return m;
    }

    function maxRange(arr, from, to) {
        let m = -Infinity;
        for (let i = from; i <= to; i += 1) {
            const v = arr[i];
            if (isFinite(v)) m = Math.max(m, v);
        }
        return m;
    }

    // ----------------------------
    // Market universe
    // ----------------------------
    async function getUsdtPerpSymbolsAndTickSize() {
        const info = await fetchJson(EP_EXCHANGE_INFO);
        const mapTick = new Map();

        const syms = info.symbols
            .filter((s) =>
                s.contractType === "PERPETUAL" &&
                s.quoteAsset === "USDT" &&
                s.status === "TRADING" &&
                s.symbol.endsWith("USDT")
            )
            .map((s) => {
                let tickSize = null;
                if (Array.isArray(s.filters)) {
                    const pf = s.filters.find((f) => f.filterType === "PRICE_FILTER");
                    if (pf && pf.tickSize) tickSize = Number(pf.tickSize);
                }
                if (tickSize && isFinite(tickSize) && tickSize > 0) mapTick.set(s.symbol, tickSize);
                return s.symbol;
            });

        return { symbols: syms, tickSizeMap: mapTick };
    }

    async function get24hTickers() {
        return fetchJson(EP_TICKER_24H);
    }

    function pickTopByQuoteVolume(allTickers, allowedSymbols, topN, minQv) {
        const set = new Set(allowedSymbols);
        return allTickers
            .filter((t) => set.has(t.symbol))
            .map((t) => ({
                symbol: t.symbol,
                quoteVolume: Number(t.quoteVolume || 0)
            }))
            .filter((x) => x.quoteVolume >= minQv)
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, topN);
    }

    async function getKlines(symbol, interval, startTime, endTime, limit) {
        const url =
            `${EP_KLINES}?symbol=${encodeURIComponent(symbol)}` +
            `&interval=${encodeURIComponent(interval)}` +
            `&startTime=${startTime}` +
            `&endTime=${endTime}` +
            `&limit=${limit}`;
        return fetchJson(url);
    }

    async function mapPool(items, worker, concurrency) {
        const out = new Array(items.length);
        let idx = 0;

        async function runOne() {
            while (idx < items.length) {
                const cur = idx;
                idx += 1;
                out[cur] = await worker(items[cur], cur);
            }
        }

        const runners = [];
        for (let i = 0; i < concurrency; i += 1) runners.push(runOne());
        await Promise.all(runners);
        return out;
    }

    function roundToTick(price, tickSize) {
        if (!tickSize || !isFinite(tickSize) || tickSize <= 0) return price;
        const inv = 1 / tickSize;
        return Math.round(price * inv) / inv;
    }

    // ----------------------------
    // Build signals + backtest
    // ----------------------------
    function buildAndBacktestForSymbol(symbol, qv24h, kl15m, kl1h, tickSize, opts) {
        const tz = opts.tz;
        const dayStart = opts.dayStart;
        const dayEnd = opts.dayEnd;

        const rr = opts.rr;
        const volMult = opts.volMult;
        const stopMin = opts.stopMin;
        const stopMax = opts.stopMax;
        const maxChaseAtr = opts.maxChaseAtr;
        const entryWindow = opts.entryWindow;
        const maxHold = opts.maxHold;
        const tieMode = opts.tieMode;

        const o15 = kl15m.map((k) => Number(k[1]));
        const h15 = kl15m.map((k) => Number(k[2]));
        const l15 = kl15m.map((k) => Number(k[3]));
        const c15 = kl15m.map((k) => Number(k[4]));
        const v15 = kl15m.map((k) => Number(k[5]));
        const t15 = kl15m.map((k) => Number(k[0])); // openTime
        const ct15 = kl15m.map((k) => Number(k[6])); // closeTime

        const c1h = kl1h.map((k) => Number(k[4]));
        const t1h = kl1h.map((k) => Number(k[0]));
        const ct1h = kl1h.map((k) => Number(k[6]));

        const ema20_15 = ema(c15, 20);
        const ema50_15 = ema(c15, 50);
        const atr14_15 = atr(h15, l15, c15, 14);
        const rsi14_15 = rsi(c15, 14);
        const volSma20_15 = sma(v15, 20);

        const ema200_1h = ema(c1h, 200);
        const ema50_1h = ema(c1h, 50);
        const rsi14_1h = rsi(c1h, 14);

        // Map 15m closeTime -> last closed 1h index
        let j1h = 0;
        const trades = [];

        for (let i = 0; i < kl15m.length; i += 1) {
            const ot = t15[i];
            const closeTime = ct15[i];

            if (ot < dayStart || ot >= dayEnd) continue;
            if (i < 60) continue;

            // Move 1h pointer to last closed candle before this 15m close
            while (j1h + 1 < kl1h.length && ct1h[j1h + 1] < closeTime - 1000) {
                j1h += 1;
            }

            // Need stable 1h indicators
            if (j1h < 205) continue;

            const close15 = c15[i];
            const close15_prev = c15[i - 1];
            const high15_prev = h15[i - 1];
            const low15_prev = l15[i - 1];

            const e20 = ema20_15[i];
            const e20_prev = ema20_15[i - 1];
            const e50 = ema50_15[i];
            const a14 = atr14_15[i];
            const r15 = rsi14_15[i];
            const r15_prev = rsi14_15[i - 1];

            const vNow = v15[i];
            const vAvg = volSma20_15[i];

            const close1h = c1h[j1h];
            const e200 = ema200_1h[j1h];
            const e200_prev = ema200_1h[j1h - 1];
            const e50_1h_now = ema50_1h[j1h];
            const r1h = rsi14_1h[j1h];

            if (![e20, e20_prev, e50, a14, r15, r15_prev, vAvg, close1h, e200, e200_prev, e50_1h_now, r1h].every(isFinite)) {
                continue;
            }

            // Filters
            const volOk = vNow >= (vAvg * volMult);
            const distFromE20 = Math.abs(close15 - e20);
            const chaseOk = distFromE20 <= (maxChaseAtr * a14);
            if (!volOk || !chaseOk) continue;

            // LONG signal
            const longTrendOk =
                (close1h > e200) &&
                (e50_1h_now > e200) &&
                (e200 > e200_prev) &&
                (r1h >= 52);

            const longReclaim = (close15 > e20) && (close15_prev <= e20_prev);
            const longBreakConfirm = (close15 > high15_prev);
            const longRsiConfirm = (r15_prev <= 50) && (r15 > 50);
            const longAbove50 = (close15 > e50);
            const longTouched = (l15[i] <= (e20 * 1.0015));
            const longSignalOk = longTrendOk && longReclaim && longBreakConfirm && longRsiConfirm && longAbove50 && longTouched;

            // SHORT signal
            const shortTrendOk =
                (close1h < e200) &&
                (e50_1h_now < e200) &&
                (e200 < e200_prev) &&
                (r1h <= 48);

            const shortReclaim = (close15 < e20) && (close15_prev >= e20_prev);
            const shortBreakConfirm = (close15 < low15_prev);
            const shortRsiConfirm = (r15_prev >= 50) && (r15 < 50);
            const shortBelow50 = (close15 < e50);
            const shortTouched = (h15[i] >= (e20 * 0.9985));
            const shortSignalOk = shortTrendOk && shortReclaim && shortBreakConfirm && shortRsiConfirm && shortBelow50 && shortTouched;

            // If no signal, continue
            if (!longSignalOk && !shortSignalOk) continue;

            // Build candidate trade (LONG or SHORT)
            const side = longSignalOk ? "LONG" : "SHORT";
            const signalTime = closeTime;

            let entry;
            let sl;
            let tp;
            let note = "";
            let tpMode = "RR";

            if (side === "LONG") {
                entry = e20 * 1.0002;
                const swingLow = minRange(l15, Math.max(0, i - 12), i);
                sl = swingLow - (0.35 * a14);

                const risk = entry - sl;
                const stopPct = (risk / entry) * 100;
                if (!(stopPct >= stopMin && stopPct <= stopMax)) continue;

                // TP: swing high first
                const lookback = 48;
                const swingHigh = maxRange(h15, Math.max(0, i - lookback), i);
                const rrTp = entry + rr * risk;

                if (isFinite(swingHigh) && swingHigh > entry) {
                    const swingTp = swingHigh - (0.10 * a14);
                    const swingRR = (swingTp - entry) / (risk + 1e-9);
                    if (swingRR >= 1.2) {
                        tp = swingTp;
                        tpMode = "SWING";
                    } else {
                        tp = rrTp;
                        tpMode = "RR";
                    }
                } else {
                    tp = rrTp;
                    tpMode = "RR";
                }

                // Round
                entry = roundToTick(entry, tickSize);
                sl = roundToTick(sl, tickSize);
                tp = roundToTick(tp, tickSize);

            } else {
                entry = e20 * 0.9998;
                const swingHigh = maxRange(h15, Math.max(0, i - 12), i);
                sl = swingHigh + (0.35 * a14);

                const risk = sl - entry;
                const stopPct = (risk / entry) * 100;
                if (!(stopPct >= stopMin && stopPct <= stopMax)) continue;

                const lookback = 48;
                const swingLow = minRange(l15, Math.max(0, i - lookback), i);
                const rrTp = entry - rr * risk;

                if (isFinite(swingLow) && swingLow < entry) {
                    const swingTp = swingLow + (0.10 * a14);
                    const swingRR = (entry - swingTp) / (risk + 1e-9);
                    if (swingRR >= 1.2) {
                        tp = swingTp;
                        tpMode = "SWING";
                    } else {
                        tp = rrTp;
                        tpMode = "RR";
                    }
                } else {
                    tp = rrTp;
                    tpMode = "RR";
                }

                entry = roundToTick(entry, tickSize);
                sl = roundToTick(sl, tickSize);
                tp = roundToTick(tp, tickSize);
            }

            // Backtest: fill check in next entryWindow bars
            let filled = false;
            let fillIndex = null;

            for (let k = i + 1; k <= Math.min(i + entryWindow, kl15m.length - 1); k += 1) {
                const hi = h15[k];
                const lo = l15[k];
                if (lo <= entry && entry <= hi) {
                    filled = true;
                    fillIndex = k;
                    break;
                }
            }

            if (!filled) {
                trades.push({
                    time: signalTime,
                    symbol,
                    side,
                    entry,
                    tp,
                    sl,
                    outcome: "NO_FILL",
                    pnlPct: 0,
                    fill: "NO",
                    exitTime: null,
                    note: `entryWindow(${entryWindow}) 내 미체결 / TP:${tpMode}`
                });
                continue;
            }

            // After fill, simulate until maxHold or day end
            const startK = fillIndex;
            const endK = Math.min(startK + maxHold, kl15m.length - 1);

            let outcome = "OPEN";
            let exitPrice = null;
            let exitTime = null;

            for (let k = startK; k <= endK; k += 1) {
                // stop at end of selected day
                if (t15[k] >= dayEnd) break;

                const hi = h15[k];
                const lo = l15[k];

                if (side === "LONG") {
                    const hitSL = lo <= sl;
                    const hitTP = hi >= tp;

                    if (hitSL && hitTP) {
                        if (tieMode === "SL_FIRST") {
                            outcome = "SL";
                            exitPrice = sl;
                            exitTime = ct15[k];
                        } else {
                            outcome = "TP";
                            exitPrice = tp;
                            exitTime = ct15[k];
                        }
                        break;
                    }
                    if (hitSL) {
                        outcome = "SL";
                        exitPrice = sl;
                        exitTime = ct15[k];
                        break;
                    }
                    if (hitTP) {
                        outcome = "TP";
                        exitPrice = tp;
                        exitTime = ct15[k];
                        break;
                    }
                } else {
                    const hitSL = hi >= sl;
                    const hitTP = lo <= tp;

                    if (hitSL && hitTP) {
                        if (tieMode === "SL_FIRST") {
                            outcome = "SL";
                            exitPrice = sl;
                            exitTime = ct15[k];
                        } else {
                            outcome = "TP";
                            exitPrice = tp;
                            exitTime = ct15[k];
                        }
                        break;
                    }
                    if (hitSL) {
                        outcome = "SL";
                        exitPrice = sl;
                        exitTime = ct15[k];
                        break;
                    }
                    if (hitTP) {
                        outcome = "TP";
                        exitPrice = tp;
                        exitTime = ct15[k];
                        break;
                    }
                }
            }

            if (outcome === "OPEN") {
                // Exit at end-of-day (last close within day)
                let lastIdx = startK;
                for (let k = startK; k <= endK; k += 1) {
                    if (t15[k] >= dayEnd) break;
                    lastIdx = k;
                }
                outcome = "EOD";
                exitPrice = c15[lastIdx];
                exitTime = ct15[lastIdx];
                note = `EOD exit / TP:${tpMode}`;
            } else {
                note = `TP:${tpMode}`;
            }

            // PnL %
            let pnlPct;
            if (side === "LONG") {
                pnlPct = ((exitPrice - entry) / entry) * 100;
            } else {
                pnlPct = ((entry - exitPrice) / entry) * 100;
            }

            trades.push({
                time: signalTime,
                symbol,
                side,
                entry,
                tp,
                sl,
                outcome,
                pnlPct,
                fill: "YES",
                exitTime,
                note
            });
        }

        return trades;
    }

    // ----------------------------
    // Render
    // ----------------------------
    let LAST_TRADES = [];

    function renderSummary(trades) {
        const summaryEl = document.getElementById("summary");

        const signals = trades.length;
        const filled = trades.filter((t) => t.fill === "YES").length;
        const noFill = trades.filter((t) => t.outcome === "NO_FILL").length;
        const wins = trades.filter((t) => t.outcome === "TP").length;
        const losses = trades.filter((t) => t.outcome === "SL").length;
        const eod = trades.filter((t) => t.outcome === "EOD").length;

        const filledTrades = trades.filter((t) => t.fill === "YES");
        const avg = filledTrades.length ? (filledTrades.reduce((a, t) => a + t.pnlPct, 0) / filledTrades.length) : 0;
        const total = filledTrades.reduce((a, t) => a + t.pnlPct, 0);
        const winRate = filledTrades.length ? (wins / filledTrades.length) * 100 : 0;

        summaryEl.innerHTML = `
            <div class="muted">Signals</div><div><b>${signals}</b></div>
            <div class="muted">Filled</div><div><b>${filled}</b></div>
            <div class="muted">No Fill</div><div><b>${noFill}</b></div>
            <div class="muted">Wins (TP)</div><div><b class="goodText">${wins}</b></div>
            <div class="muted">Losses (SL)</div><div><b class="badText">${losses}</b></div>
            <div class="muted">EOD/Timeout</div><div><b class="warnText">${eod}</b></div>
            <div class="muted">Win Rate</div><div><b>${fmt(winRate, 2)}%</b></div>
            <div class="muted">Avg PnL%</div><div><b>${fmt(avg, 3)}%</b></div>
            <div class="muted">Total PnL%</div><div><b>${fmt(total, 3)}%</b></div>
        `;
    }

    function renderTrades(trades, tz) {
        const tb = document.getElementById("tbody");
        if (!trades || trades.length === 0) {
            tb.innerHTML = `<tr><td colspan="11" class="muted" style="text-align:center;">해당 날짜 조건 충족 시그널 없음</td></tr>`;
            return;
        }

        tb.innerHTML = trades.map((t) => {
            const sideClass = t.side === "LONG" ? "goodText" : "badText";
            let outClass = "muted";
            if (t.outcome === "TP") outClass = "goodText";
            if (t.outcome === "SL") outClass = "badText";
            if (t.outcome === "EOD") outClass = "warnText";
            if (t.outcome === "NO_FILL") outClass = "muted";

            const pnlClass = t.pnlPct > 0 ? "goodText" : (t.pnlPct < 0 ? "badText" : "muted");

            return `
                <tr>
                    <td>${fmtTime(t.time, tz)}</td>
                    <td><b>${t.symbol}</b></td>
                    <td class="${sideClass}"><b>${t.side}</b></td>
                    <td>${fmt(t.entry)}</td>
                    <td class="goodText">${fmt(t.tp)}</td>
                    <td class="badText">${fmt(t.sl)}</td>
                    <td class="${outClass}"><b>${t.outcome}</b></td>
                    <td class="${pnlClass}"><b>${fmt(t.pnlPct, 3)}%</b></td>
                    <td>${t.fill}</td>
                    <td>${t.exitTime ? fmtTime(t.exitTime, tz) : "-"}</td>
                    <td class="muted small">${t.note || ""}</td>
                </tr>
            `;
        }).join("");
    }

    function toCsv(trades, tz) {
        const header = ["time", "symbol", "side", "entry", "tp", "sl", "outcome", "pnlPct", "fill", "exitTime", "note"];
        const lines = [header.join(",")];
        for (const t of trades) {
            const row = [
                fmtTime(t.time, tz),
                t.symbol,
                t.side,
                String(t.entry),
                String(t.tp),
                String(t.sl),
                t.outcome,
                String(t.pnlPct),
                t.fill,
                t.exitTime ? fmtTime(t.exitTime, tz) : "",
                (t.note || "").replaceAll(",", " ")
            ];
            lines.push(row.join(","));
        }
        return lines.join("\n");
    }

    function downloadText(filename, text) {
        const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    // ----------------------------
    // Backtest runner
    // ----------------------------
    let RUNNING = false;

    async function backtest() {
        if (RUNNING) return;
        RUNNING = true;

        const btn = document.getElementById("btnRun");
        btn.disabled = true;
        document.getElementById("btnCsv").disabled = true;

        try {
            const dateStr = document.getElementById("date").value;
            const tz = document.getElementById("tz").value;

            const range = getDayRangeMs(dateStr, tz);
            if (!range) {
                alert("날짜를 선택하세요.");
                return;
            }

            const mode = document.getElementById("mode").value;
            const symbolIn = String(document.getElementById("symbol").value || "").trim().toUpperCase();

            const topN = clamp(Number(document.getElementById("topN").value || 30), 5, 120);
            const minQv = Math.max(0, Number(document.getElementById("minQv").value || 0));
            const concurrency = clamp(Number(document.getElementById("concurrency").value || 4), 1, 8);

            const opts = {
                tz,
                dayStart: range.start,
                dayEnd: range.end,
                rr: clamp(Number(document.getElementById("rr").value || 1.8), 0.8, 5),
                volMult: clamp(Number(document.getElementById("volMult").value || 1.25), 1, 3),
                stopMin: clamp(Number(document.getElementById("stopMin").value || 0.25), 0.05, 10),
                stopMax: clamp(Number(document.getElementById("stopMax").value || 1.15), 0.1, 10),
                maxChaseAtr: clamp(Number(document.getElementById("maxChaseAtr").value || 0.75), 0.2, 3),
                entryWindow: clamp(Number(document.getElementById("entryWindow").value || 4), 1, 48),
                maxHold: clamp(Number(document.getElementById("maxHold").value || 24), 4, 400),
                tieMode: document.getElementById("tieMode").value
            };

            logLine(`백테스트 시작: date=${dateStr} (${tz}), mode=${mode}, rr=${opts.rr}, volx=${opts.volMult}, stop=[${opts.stopMin}~${opts.stopMax}], entryWindow=${opts.entryWindow}, maxHold=${opts.maxHold}`);
            setStatus("Running...");

            // Lookback: 9 days before dayStart to build EMA200(1h) and 15m indicators
            const lookbackMs = 9 * 24 * 3600 * 1000;
            const startFetch = range.start - lookbackMs;
            const endFetch = range.end;

            const { symbols, tickSizeMap } = await getUsdtPerpSymbolsAndTickSize();

            let universe = [];
            if (mode === "single") {
                if (!symbolIn) {
                    alert("Symbol을 입력하세요. 예: BTCUSDT");
                    return;
                }
                if (!symbols.includes(symbolIn)) {
                    alert(`심볼이 유효하지 않거나 USDT 무기한이 아닐 수 있어요: ${symbolIn}`);
                    return;
                }
                universe = [{ symbol: symbolIn, quoteVolume: 0 }];
            } else {
                const tickers = await get24hTickers();
                universe = pickTopByQuoteVolume(tickers, symbols, topN, minQv);
            }

            logLine(`대상 심볼: ${universe.length}개`);
            setStatus(`Fetching klines for ${universe.length} symbols...`);

            const allTrades = [];

            const worker = async (row) => {
                const sym = row.symbol;
                const qv = row.quoteVolume || 0;
                const tick = tickSizeMap.get(sym) || null;

                // Throttle a bit
                await sleep(40);

                for (let attempt = 1; attempt <= 4; attempt += 1) {
                    try {
                        // 15m: limit 1000 (~10.4 days)
                        // 1h:  limit 400  (~16.6 days) - safe
                        const [kl15m, kl1h] = await Promise.all([
                            getKlines(sym, "15m", startFetch, endFetch, 1000),
                            getKlines(sym, "1h", startFetch, endFetch, 400)
                        ]);

                        const trades = buildAndBacktestForSymbol(sym, qv, kl15m, kl1h, tick, opts);
                        for (const t of trades) allTrades.push(t);
                        return;

                    } catch (e) {
                        const status = e.httpStatus || 0;
                        const isRate = status === 429 || status === 418;
                        if (isRate && attempt < 4) {
                            const ra = e.retryAfter ? e.retryAfter * 1000 : (attempt * 1200);
                            logLine(`${sym} rate-limit(HTTP ${status}), ${Math.ceil(ra / 1000)}s 대기 후 재시도 (${attempt}/4)`);
                            await sleep(ra);
                            continue;
                        }
                        logLine(`${sym} 실패: ${String(e && e.message ? e.message : e)}`);
                        return;
                    }
                }
            };

            await mapPool(universe, worker, concurrency);

            // Sort by signal time
            allTrades.sort((a, b) => a.time - b.time);

            LAST_TRADES = allTrades;
            renderSummary(allTrades);
            renderTrades(allTrades, tz);

            document.getElementById("btnCsv").disabled = allTrades.length === 0;

            setStatus(`Done (${allTrades.length} signals)`);
            logLine(`완료: 총 시그널 ${allTrades.length}개`);

        } finally {
            RUNNING = false;
            document.getElementById("btnRun").disabled = false;
        }
    }

    // ----------------------------
    // Bind & init
    // ----------------------------
    document.getElementById("btnRun").addEventListener("click", function () {
        backtest();
    });

    document.getElementById("btnCsv").addEventListener("click", function () {
        const tz = document.getElementById("tz").value;
        if (!LAST_TRADES || LAST_TRADES.length === 0) return;
        const dateStr = document.getElementById("date").value || "backtest";
        downloadText(`backtest_${dateStr}_${tz}.csv`, toCsv(LAST_TRADES, tz));
    });

    // Default date: today (local)
    (function initDate() {
        const d = new Date();
        const y = d.getFullYear();
        const m = pad2(d.getMonth() + 1);
        const dd = pad2(d.getDate());
        document.getElementById("date").value = `${y}-${m}-${dd}`;
    })();

    // Mode toggle
    document.getElementById("mode").addEventListener("change", function () {
        const mode = document.getElementById("mode").value;
        const sym = document.getElementById("symbol");
        const topN = document.getElementById("topN");
        const minQv = document.getElementById("minQv");

        if (mode === "single") {
            sym.disabled = false;
            topN.disabled = true;
            minQv.disabled = true;
        } else {
            sym.disabled = true;
            topN.disabled = false;
            minQv.disabled = false;
        }
    });
    // trigger once
    document.getElementById("mode").dispatchEvent(new Event("change"));

    logLine("준비 완료. 날짜 선택 후 Run Backtest를 누르세요.");
</script>
</body>
</html>
