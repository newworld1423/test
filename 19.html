<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT PERP - 1h 심볼 중 최근 3일 내 1h 전환만 추출</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; }
        h1 { margin: 0 0 10px; font-size: 18px; }
        .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        button { padding: 10px 12px; cursor: pointer; }
        input { padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 12px; }
        .badge { display: inline-block; padding: 3px 8px; border: 1px solid #ccc; border-radius: 999px; font-size: 12px; }
        .muted { color: #666; font-size: 12px; margin-top: 8px; white-space: pre-line; }
        table { width: 100%; border-collapse: collapse; margin-top: 12px; }
        th, td { border-top: 1px solid #eee; padding: 8px; font-size: 12px; vertical-align: middle; }
        th { text-align: left; color: #444; background: #fafafa; border-top: none; position: sticky; top: 0; z-index: 1; }
        .right { text-align: right; }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .warn { color: #b00020; }
    </style>
</head>
<body>
    <h1>USDT 무기한(Perp): 현재 1h 펀딩 심볼 중 “최근 3일 내 (4h/8h → 1h)” 전환만 추출</h1>

    <div class="row">
        <button id="run">스캔 시작</button>
        <label class="badge">
            최근
            <input id="days" type="number" min="1" max="30" value="3" style="width: 70px; margin-left: 6px;" />
            일
        </label>

        <span class="badge" id="status">idle</span>
        <span class="badge" id="progress">progress: -</span>
        <span class="badge" id="count">found: -</span>
    </div>

    <div class="muted" id="meta"></div>

    <table>
        <thead>
            <tr>
                <th>심볼</th>
                <th class="right">전환</th>
                <th>전환 시각(KST)</th>
            </tr>
        </thead>
        <tbody id="tbody">
            <tr><td colspan="3" class="muted">스캔을 실행하면 결과가 표시됩니다.</td></tr>
        </tbody>
    </table>

    <div class="muted">
        * 브라우저에서 <span class="mono">https://fapi.binance.com</span> 호출이 막히는 환경(CORS/차단)이라면,
        너의 서버(ASP/Node)에 프록시를 두고 아래 <span class="mono">FAPI_BASE</span>만 프록시 주소로 바꿔서 쓰면 됩니다.
    </div>

    <script>
        const FAPI_BASE = "https://fapi.binance.com";

        function setText(id, text) {
            const el = document.getElementById(id);
            if (el) el.textContent = text;
        }

        function fmtLocalKST(ts) {
            return new Date(ts).toLocaleString("ko-KR", {
                timeZone: "Asia/Seoul",
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
            });
        }

        function toNumber(x, fallback = NaN) {
            const n = Number(x);
            return Number.isFinite(n) ? n : fallback;
        }

        function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        async function fetchJSON(path, params = {}, timeoutMs = 15000) {
            const url = new URL(FAPI_BASE + path);
            Object.entries(params).forEach(([k, v]) => {
                if (v !== undefined && v !== null && v !== "") {
                    url.searchParams.set(k, String(v));
                }
            });

            const controller = new AbortController();
            const t = setTimeout(() => controller.abort(), timeoutMs);

            try {
                const res = await fetch(url.toString(), { method: "GET", signal: controller.signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 200)}`);
                }
                return await res.json();
            } finally {
                clearTimeout(t);
            }
        }

        async function fetchJSONWithRetry(path, params = {}, timeoutMs = 15000, retries = 3) {
            let attempt = 0;
            while (true) {
                try {
                    return await fetchJSON(path, params, timeoutMs);
                } catch (err) {
                    const msg = String(err && err.message ? err.message : err);
                    const isRateLimit = msg.includes("HTTP 429") || msg.includes("HTTP 418");
                    if (!isRateLimit || attempt >= retries) {
                        throw err;
                    }
                    await sleep(1200 * (attempt + 1));
                    attempt += 1;
                }
            }
        }

        async function getUsdtPerpSymbols() {
            const data = await fetchJSONWithRetry("/fapi/v1/exchangeInfo");
            return (data.symbols || [])
                .filter((s) =>
                    s &&
                    s.contractType === "PERPETUAL" &&
                    s.quoteAsset === "USDT" &&
                    s.status === "TRADING"
                )
                .map((s) => s.symbol);
        }

        async function getFundingIntervalMap() {
            // 조정된 심볼만 내려옴(없으면 기본 8h)
            const list = await fetchJSONWithRetry("/fapi/v1/fundingInfo");
            const map = new Map();

            (list || []).forEach((row) => {
                if (!row || !row.symbol) return;
                map.set(row.symbol, toNumber(row.fundingIntervalHours, 8));
            });

            return map;
        }

        function computeCurrentIntervals(usdtSymbols, intervalMap) {
            const intervals = {};
            for (const sym of usdtSymbols) {
                intervals[sym] = intervalMap.has(sym) ? intervalMap.get(sym) : 8;
            }
            return intervals;
        }

        function classifyIntervalHours(deltaMs) {
            const min = 60 * 1000;

            // 1h: 45~75분
            if (deltaMs >= 45 * min && deltaMs <= 75 * min) return 1;

            // 4h: 3.5~4.5시간
            if (deltaMs >= 210 * min && deltaMs <= 270 * min) return 4;

            // 8h: 7~9시간
            if (deltaMs >= 420 * min && deltaMs <= 540 * min) return 8;

            return 0;
        }

        /**
         * 현재 1h 심볼에 대해,
         * 최근 N일 내 "4h/8h → 1h" 경계를 fundingTime 간격으로 탐지.
         * - 발견 시: { ok:true, at, fromHours }
         * - 없으면: { ok:false }
         */
        async function findRecentChangeTo1h(symbol, lookbackDays) {
            const now = Date.now();
            const windowStart = now - (lookbackDays * 24 * 60 * 60 * 1000);

            // 경계 판정은 "이전 간격(4/8)"이 필요하므로 약간 더 앞 구간을 포함
            const fetchStart = windowStart - (12 * 60 * 60 * 1000);

            const list = await fetchJSONWithRetry("/fapi/v1/fundingRate", {
                symbol,
                startTime: fetchStart,
                endTime: now,
                limit: 1000
            });

            if (!Array.isArray(list) || list.length < 3) {
                return { ok: false };
            }

            const times = list
                .map((x) => toNumber(x.fundingTime, NaN))
                .filter((t) => Number.isFinite(t))
                .sort((a, b) => a - b);

            if (times.length < 3) {
                return { ok: false };
            }

            // uniq
            const uniq = [];
            for (const t of times) {
                if (uniq.length === 0 || uniq[uniq.length - 1] !== t) {
                    uniq.push(t);
                }
            }

            let bestAt = NaN;
            let bestFrom = 0;

            for (let i = 1; i < uniq.length - 1; i += 1) {
                const prevDelta = uniq[i] - uniq[i - 1];
                const nextDelta = uniq[i + 1] - uniq[i];

                const prevClass = classifyIntervalHours(prevDelta);
                const nextClass = classifyIntervalHours(nextDelta);

                // 핵심: (이전이 4h 또는 8h) && (다음이 1h)
                if ((prevClass === 4 || prevClass === 8) && nextClass === 1) {
                    // 신뢰도 보강: 1h가 한 번 더 연속이면 좋음(가능하면 확인)
                    let ok = true;
                    if (i + 2 < uniq.length) {
                        const next2Delta = uniq[i + 2] - uniq[i + 1];
                        const next2Class = classifyIntervalHours(next2Delta);
                        if (next2Class !== 0 && next2Class !== 1) ok = false;
                    }

                    // 최근 N일 내 전환만
                    if (ok && uniq[i] >= windowStart) {
                        if (!Number.isFinite(bestAt) || uniq[i] > bestAt) {
                            bestAt = uniq[i];
                            bestFrom = prevClass;
                        }
                    }
                }
            }

            if (Number.isFinite(bestAt)) {
                return { ok: true, at: bestAt, fromHours: bestFrom };
            }
            return { ok: false };
        }

        function renderRows(rows) {
            const tbody = document.getElementById("tbody");
            if (!tbody) return;

            if (!rows || rows.length === 0) {
                tbody.innerHTML = `<tr><td colspan="3" class="muted">최근 조건(전환)으로 잡힌 심볼이 없습니다.</td></tr>`;
                return;
            }

            const html = rows.map((r) => {
                return `
                    <tr>
                        <td class="mono">${r.symbol}</td>
                        <td class="right mono">${r.fromHours}h → 1h</td>
                        <td class="mono">${fmtLocalKST(r.at)}</td>
                    </tr>
                `;
            }).join("");

            tbody.innerHTML = html;
        }

        async function runScan() {
            const days = Math.max(1, parseInt(document.getElementById("days").value, 10) || 3);

            setText("status", "scanning...");
            setText("progress", "progress: -");
            setText("count", "found: -");
            setText("meta", "");

            try {
                const t0 = Date.now();

                const [symbols, intervalMap] = await Promise.all([
                    getUsdtPerpSymbols(),
                    getFundingIntervalMap()
                ]);

                const currIntervals = computeCurrentIntervals(symbols, intervalMap);
                const symbols1h = symbols.filter((s) => currIntervals[s] === 1);

                setText("meta", `현재 1h 펀딩 심볼: ${symbols1h.length}개\n최근 ${days}일 내 (4h/8h→1h) 전환 탐지 중...`);
                setText("progress", `progress: 0/${symbols1h.length}`);

                // 너무 과한 동시 호출 방지: 동시 3개 워커로 처리
                const concurrency = 3;
                const queue = symbols1h.slice();
                const found = [];
                let done = 0;

                async function worker(workerId) {
                    while (queue.length > 0) {
                        const sym = queue.shift();
                        if (!sym) break;

                        try {
                            const res = await findRecentChangeTo1h(sym, days);
                            if (res && res.ok) {
                                found.push({
                                    symbol: sym,
                                    at: res.at,
                                    fromHours: res.fromHours
                                });
                            }
                        } catch (err) {
                            // 특정 심볼에서 실패해도 전체는 계속
                            console.warn("[SYM ERROR]", sym, err);
                        } finally {
                            done += 1;
                            setText("progress", `progress: ${done}/${symbols1h.length}`);

                            // 약간 텀(레이트리밋 완화)
                            await sleep(120);
                        }
                    }
                }

                const workers = [];
                for (let i = 0; i < concurrency; i += 1) {
                    workers.push(worker(i));
                }
                await Promise.all(workers);

                // 최신 전환이 위로 오도록
                found.sort((a, b) => b.at - a.at);

                renderRows(found);
                setText("count", `found: ${found.length}`);

                setText("status", "ok");
                setText("meta",
                    `완료\n` +
                    `- 전체 USDT PERP: ${symbols.length}개\n` +
                    `- 현재 1h: ${symbols1h.length}개\n` +
                    `- 최근 ${days}일 내 (4h/8h→1h) 전환 발견: ${found.length}개\n` +
                    `- 소요: ${Date.now() - t0}ms`
                );
            } catch (err) {
                console.error(err);
                setText("status", "error");
                setText("meta", `오류: ${String(err && err.message ? err.message : err)}`);
                const tbody = document.getElementById("tbody");
                if (tbody) {
                    tbody.innerHTML = `<tr><td colspan="3" class="muted warn">스캔 실패: 콘솔/메시지 확인</td></tr>`;
                }
            }
        }

        document.getElementById("run").addEventListener("click", runScan);
    </script>
</body>
</html>
