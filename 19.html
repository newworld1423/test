<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT PERP Funding Interval + NextFunding Scanner</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; }
        h1 { margin: 0 0 10px; font-size: 18px; }
        .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        button { padding: 10px 12px; cursor: pointer; }
        .badge { display: inline-block; padding: 3px 8px; border: 1px solid #ccc; border-radius: 999px; font-size: 12px; }
        .muted { color: #666; font-size: 12px; margin-top: 8px; }
        .grid { display: grid; grid-template-columns: 1fr; gap: 16px; margin-top: 14px; }
        @media (min-width: 1100px) {
            .grid { grid-template-columns: 1fr 1fr; }
        }
        .card { border: 1px solid #e6e6e6; border-radius: 10px; padding: 12px; }
        .card h2 { margin: 0 0 8px; font-size: 14px; display: flex; gap: 8px; align-items: center; }
        .count { font-size: 12px; color: #666; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border-top: 1px solid #eee; padding: 8px; font-size: 12px; vertical-align: middle; }
        th { text-align: left; color: #444; background: #fafafa; border-top: none; }
        .right { text-align: right; }
        .neg { font-variant-numeric: tabular-nums; }
        .neg.negative { color: #b00020; font-weight: 600; }
        .neg.positive { color: #0b6b0b; font-weight: 600; }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .pill { padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; background: #fff; }
        details { margin-top: 12px; }
        summary { cursor: pointer; }
        .warn { color: #8a4b00; }
    </style>
</head>
<body>
    <h1>USDT 무기한: 펀딩 주기(1h/4h/8h) 그룹 + nextFundingTime 표시 + 음수 우선 정렬</h1>

    <div class="row">
        <button id="runNow">지금 스캔</button>
        <span class="badge" id="status">idle</span>
        <span class="badge" id="lastScan">lastScan: -</span>
        <span class="badge" id="totals">symbols: -</span>
        <span class="badge" id="negCount">negative: -</span>
    </div>

    <div class="muted" id="meta"></div>

    <div class="grid" id="cards"></div>

    <details>
        <summary class="muted">문제 발생 시(브라우저 CORS/차단) 안내</summary>
        <div class="muted">
            일부 환경에서 fapi.binance.com이 브라우저에서 차단되면(또는 회사망/보안SW),
            너의 서버(ASP/Node)에 간단 프록시를 두고 <span class="mono">FAPI_BASE</span>만 프록시 주소로 바꾸면 돼.
        </div>
    </details>

    <script>
        const FAPI_BASE = "https://fapi.binance.com";

        function setText(id, text) {
            const el = document.getElementById(id);
            if (el) el.textContent = text;
        }

        function fmtLocalKST(ts) {
            // KST 고정 표기(사용자 PC 타임존과 무관)
            return new Date(ts).toLocaleString("ko-KR", {
                timeZone: "Asia/Seoul",
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
            });
        }

        function fmtRemaining(ms) {
            if (!isFinite(ms)) return "-";
            const s = Math.max(0, Math.floor(ms / 1000));
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h > 0) return `${h}h ${m}m`;
            if (m > 0) return `${m}m ${sec}s`;
            return `${sec}s`;
        }

        function toNumber(x, fallback = NaN) {
            const n = Number(x);
            return Number.isFinite(n) ? n : fallback;
        }

        function fmtRatePct(rate) {
            if (!Number.isFinite(rate)) return "-";
            // lastFundingRate는 소수(예: 0.00038246) → % 변환
            const pct = rate * 100;
            const sign = pct > 0 ? "+" : "";
            return `${sign}${pct.toFixed(4)}%`;
        }

        async function fetchJSON(path, params = {}, timeoutMs = 15000) {
            const url = new URL(FAPI_BASE + path);
            Object.entries(params).forEach(([k, v]) => {
                if (v !== undefined && v !== null && v !== "") {
                    url.searchParams.set(k, String(v));
                }
            });

            const controller = new AbortController();
            const t = setTimeout(() => controller.abort(), timeoutMs);

            try {
                const res = await fetch(url.toString(), { method: "GET", signal: controller.signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 200)}`);
                }
                return await res.json();
            } finally {
                clearTimeout(t);
            }
        }

        async function getUsdtPerpSymbols() {
            const data = await fetchJSON("/fapi/v1/exchangeInfo");
            return (data.symbols || [])
                .filter((s) =>
                    s &&
                    s.contractType === "PERPETUAL" &&
                    s.quoteAsset === "USDT" &&
                    s.status === "TRADING"
                )
                .map((s) => s.symbol);
        }

        async function getFundingIntervalMap() {
            // 조정된 심볼만 내려옴. 없는 심볼은 기본 8h로 처리.
            const list = await fetchJSON("/fapi/v1/fundingInfo");
            const map = new Map();
            (list || []).forEach((row) => {
                if (!row || !row.symbol) return;
                map.set(row.symbol, toNumber(row.fundingIntervalHours, 8));
            });
            return map;
        }

        async function getPremiumIndexMap() {
            // symbol 없이 호출하면 배열로 전체 반환
            const list = await fetchJSON("/fapi/v1/premiumIndex");
            const map = new Map();
            (list || []).forEach((row) => {
                if (!row || !row.symbol) return;
                map.set(row.symbol, row);
            });
            return map;
        }

        function buildRows(usdtSymbols, intervalMap, premiumMap) {
            const rows = [];

            for (const sym of usdtSymbols) {
                const interval = intervalMap.has(sym) ? intervalMap.get(sym) : 8;

                const p = premiumMap.get(sym);
                const fundingRate = p ? toNumber(p.lastFundingRate, NaN) : NaN;
                const nextFundingTime = p ? toNumber(p.nextFundingTime, NaN) : NaN;
                const markPrice = p ? p.markPrice : "";

                rows.push({
                    symbol: sym,
                    intervalHours: interval,
                    fundingRate,
                    nextFundingTime,
                    markPrice
                });
            }

            return rows;
        }

        function groupRows(rows) {
            const groups = new Map();
            const keys = [1, 4, 8, "OTHER"];

            keys.forEach((k) => groups.set(k, []));

            rows.forEach((r) => {
                if (r.intervalHours === 1) groups.get(1).push(r);
                else if (r.intervalHours === 4) groups.get(4).push(r);
                else if (r.intervalHours === 8) groups.get(8).push(r);
                else groups.get("OTHER").push(r);
            });

            // 정렬: “펀딩비 음수가 높은 순서” = 더 마이너스가 위로 → fundingRate 오름차순
            for (const [k, arr] of groups.entries()) {
                arr.sort((a, b) => {
                    const ar = Number.isFinite(a.fundingRate) ? a.fundingRate : Infinity;
                    const br = Number.isFinite(b.fundingRate) ? b.fundingRate : Infinity;
                    if (ar !== br) return ar - br;
                    return a.symbol.localeCompare(b.symbol);
                });
            }

            return groups;
        }

        function makeTableHTML(rows) {
            const now = Date.now();

            const body = rows.map((r) => {
                const rateClass = Number.isFinite(r.fundingRate)
                    ? (r.fundingRate < 0 ? "negative" : (r.fundingRate > 0 ? "positive" : ""))
                    : "";

                const nextStr = Number.isFinite(r.nextFundingTime) ? fmtLocalKST(r.nextFundingTime) : "-";
                const remainStr = Number.isFinite(r.nextFundingTime) ? fmtRemaining(r.nextFundingTime - now) : "-";
                const rateStr = fmtRatePct(r.fundingRate);

                const mark = (r.markPrice !== undefined && r.markPrice !== null) ? String(r.markPrice) : "";

                return `
                    <tr>
                        <td class="mono">${r.symbol}</td>
                        <td class="neg ${rateClass} right">${rateStr}</td>
                        <td class="mono right">${mark || "-"}</td>
                        <td>
                            <div class="mono">${nextStr}</div>
                            <div class="muted">${remainStr} 후</div>
                        </td>
                    </tr>
                `;
            }).join("");

            return `
                <table>
                    <thead>
                        <tr>
                            <th>심볼</th>
                            <th class="right">펀딩률</th>
                            <th class="right">마크가격</th>
                            <th>다음 펀딩(KST)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${body || `<tr><td colspan="4" class="muted">표시할 항목이 없습니다.</td></tr>`}
                    </tbody>
                </table>
            `;
        }

        function render(groups, totals) {
            const cards = document.getElementById("cards");
            if (!cards) return;

            const order = [1, 4, 8, "OTHER"];
            const labels = {
                1: "1h 그룹",
                4: "4h 그룹",
                8: "8h 그룹",
                "OTHER": "기타(예외 주기)"
            };

            cards.innerHTML = order.map((k) => {
                const arr = groups.get(k) || [];
                const neg = arr.filter((x) => Number.isFinite(x.fundingRate) && x.fundingRate < 0).length;

                return `
                    <div class="card">
                        <h2>
                            <span class="pill">${labels[k]}</span>
                            <span class="count">총 ${arr.length}개 · 음수 ${neg}개</span>
                        </h2>
                        ${makeTableHTML(arr)}
                    </div>
                `;
            }).join("");

            setText("totals", `symbols: ${totals.symbols} / premiumIndex: ${totals.premium}`);
            setText("negCount", `negative: ${totals.negative}`);
        }

        async function scanOnce() {
            setText("status", "scanning...");
            try {
                const t0 = Date.now();

                const [usdtSymbols, intervalMap, premiumMap] = await Promise.all([
                    getUsdtPerpSymbols(),
                    getFundingIntervalMap(),
                    getPremiumIndexMap()
                ]);

                const rows = buildRows(usdtSymbols, intervalMap, premiumMap);
                const groups = groupRows(rows);

                const negative = rows.filter((r) => Number.isFinite(r.fundingRate) && r.fundingRate < 0).length;

                render(groups, {
                    symbols: usdtSymbols.length,
                    premium: premiumMap.size,
                    negative
                });

                setText("lastScan", `lastScan: ${fmtLocalKST(Date.now())}`);
                setText("meta", `스캔 완료: USDT PERP ${usdtSymbols.length}개 · 소요 ${Date.now() - t0}ms`);
                setText("status", "ok");
            } catch (err) {
                console.error(err);
                setText("status", "error");
                setText("meta", `오류: ${String(err && err.message ? err.message : err)}`);
            }
        }

        function scheduleHourly() {
            // 매 정각 + 5초에 실행
            const now = new Date();
            const next = new Date(now);
            next.setMinutes(0, 0, 0);
            next.setHours(next.getHours() + 1);
            const delay = next.getTime() - now.getTime() + 5000;

            setTimeout(async () => {
                await scanOnce();
                scheduleHourly();
            }, delay);
        }

        document.getElementById("runNow").addEventListener("click", scanOnce);

        // 최초 1회 실행 + 이후 1시간마다 자동
        scanOnce();
        scheduleHourly();
    </script>
</body>
</html>
