<!doctype html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — TF(15m/1h/4h/1d) 확률·기대값·최대레버리지 스캐너</title>
        <style>
            :root {
                color-scheme: dark;
                --bg: #0b0f17;
                --panel: #0f1623;
                --text: #e8eefc;
                --muted: rgba(232, 238, 252, 0.65);
                --line: rgba(232, 238, 252, 0.12);
                --good: #44d18f;
                --bad: #ff5a7a;
                --warn: #ffd166;
                --accent: #7aa2ff;
                --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
                    "Segoe UI Emoji";
            }

            body {
                margin: 0;
                font-family: var(--sans);
                background: radial-gradient(1200px 700px at 30% 0%, rgba(122, 162, 255, 0.14), transparent 60%),
                    radial-gradient(900px 600px at 80% 20%, rgba(68, 209, 143, 0.10), transparent 60%), var(--bg);
                color: var(--text);
            }

            .wrap {
                max-width: 1280px;
                margin: 0 auto;
                padding: 18px 16px 42px;
            }

            h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: -0.2px;
            }

            .sub {
                margin-top: 6px;
                color: var(--muted);
                font-size: 13px;
                line-height: 1.4;
            }

            .panel {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
                border: 1px solid var(--line);
                border-radius: 14px;
                padding: 14px;
            }

            .controls {
                display: grid;
                grid-template-columns: repeat(4, minmax(180px, 1fr));
                gap: 10px;
                margin-top: 14px;
            }

            @media (max-width: 1100px) {
                .controls {
                    grid-template-columns: repeat(2, minmax(180px, 1fr));
                }
            }

            @media (max-width: 640px) {
                .controls {
                    grid-template-columns: 1fr;
                }
            }

            label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin-bottom: 6px;
            }

            input[type="number"],
            input[type="text"],
            select {
                width: 100%;
                box-sizing: border-box;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.22);
                color: var(--text);
                padding: 10px 10px;
                outline: none;
                font-family: var(--sans);
            }

            input[type="checkbox"] {
                transform: translateY(1px);
            }

            .row {
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
            }

            .btn {
                border-radius: 12px;
                border: 1px solid var(--line);
                background: rgba(122, 162, 255, 0.12);
                color: var(--text);
                padding: 10px 12px;
                cursor: pointer;
                font-weight: 600;
                letter-spacing: -0.1px;
            }

            .btn:disabled {
                opacity: 0.45;
                cursor: not-allowed;
            }

            .btn.secondary {
                background: rgba(255, 255, 255, 0.06);
            }

            .status {
                display: grid;
                grid-template-columns: repeat(4, minmax(140px, 1fr));
                gap: 10px;
                margin-top: 12px;
            }

            @media (max-width: 900px) {
                .status {
                    grid-template-columns: repeat(2, minmax(140px, 1fr));
                }
            }

            .pill {
                border: 1px solid var(--line);
                border-radius: 12px;
                padding: 10px 12px;
                background: rgba(255, 255, 255, 0.03);
            }

            .pill .k {
                font-size: 12px;
                color: var(--muted);
            }

            .pill .v {
                margin-top: 6px;
                font-family: var(--mono);
                font-size: 13px;
            }

            /* ✅ 모바일 가로 스크롤 */
            .tableWrap {
                margin-top: 14px;
                border: 1px solid var(--line);
                border-radius: 14px;

                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;

                background: rgba(0, 0, 0, 0.12);
            }

            table {
                width: 100%;
                min-width: 1020px;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                z-index: 3;
                background: linear-gradient(180deg, rgba(18, 28, 45, 0.96), rgba(18, 28, 45, 0.90));
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                text-align: left;
                white-space: nowrap;
                cursor: pointer;
                user-select: none;
            }

            thead th .hint {
                color: rgba(232, 238, 252, 0.45);
                font-size: 11px;
                margin-left: 6px;
            }

            tbody td {
                border-bottom: 1px solid rgba(232, 238, 252, 0.07);
                padding: 10px 10px;
                white-space: nowrap;
                background: transparent;
            }

            tbody tr:hover {
                background: rgba(122, 162, 255, 0.06);
            }

            /* ✅ 첫 컬럼(Symbol) 고정 */
            thead th:first-child,
            tbody td:first-child {
                position: sticky;
                left: 0;
                z-index: 2;
                border-right: 1px solid rgba(232, 238, 252, 0.08);
            }

            thead th:first-child {
                z-index: 4;
            }

            tbody td:first-child {
                background: rgba(0, 0, 0, 0.30);
            }

            .right {
                text-align: right;
            }

            .mono {
                font-family: var(--mono);
            }

            .good {
                color: var(--good);
            }

            .bad {
                color: var(--bad);
            }

            .warn {
                color: var(--warn);
            }

            .muted {
                color: var(--muted);
            }

            .small {
                font-size: 12px;
            }

            .foot {
                margin-top: 10px;
                color: var(--muted);
                font-size: 12px;
                line-height: 1.5;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="panel">
                <h1>Binance USDT Perp — TF(15m/1h/4h/1d) 현재봉(C&gt;O) 확률 / 기대수익·손실 / 최대 레버리지(근사)</h1>
                <div class="sub">
                    - 확률/기대값은 <b>과거 봉 통계 기반 “추정”</b>입니다.<br />
                    - 자동 스캔은 <b>Binance 서버시간(UTC) 캔들 경계</b>에 맞춰 동작합니다. (KST 기준: 4h는 01/05/09/13/17/21시, 1d는 09:00)
                </div>

                <div class="controls">
                    <div>
                        <label>타임프레임</label>
                        <select id="timeframe">
                            <option value="15m">15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                        </select>
                    </div>

                    <div>
                        <label>히스토리 캔들 수 (타임프레임별 권장값 자동)</label>
                        <input id="historyLimit" type="number" min="120" max="1499" step="1" value="480" />
                    </div>

                    <div>
                        <label>요청 동시성(초기 히스토리 로딩 속도)</label>
                        <input id="concurrency" type="number" min="1" max="6" step="1" value="2" />
                    </div>

                    <div>
                        <label>최소 24h 거래대금(USDT) 필터 (0이면 전체)</label>
                        <input id="minQuoteVol" type="number" min="0" step="1000000" value="30000000" />
                    </div>

                    <div>
                        <label>왕복 수수료(비율) 예: 0.0008 = 0.08%</label>
                        <input id="feeRoundTrip" type="number" min="0" step="0.0001" value="0.0008" />
                    </div>

                    <div>
                        <label>안전 버퍼(비율) 예: 0.002 = 0.2%</label>
                        <input id="safetyBuffer" type="number" min="0" step="0.0005" value="0.002" />
                    </div>

                    <div>
                        <label>유지증거금(근사, 비율) 예: 0.005 = 0.5%</label>
                        <input id="mmr" type="number" min="0" step="0.0005" value="0.005" />
                    </div>

                    <div>
                        <label>심볼 검색</label>
                        <input id="search" type="text" placeholder="예: BTCUSDT" />
                    </div>

                    <div>
                        <label>조건부 통계 사용(직전봉 Up/Down)</label>
                        <div class="row">
                            <input id="useConditional" type="checkbox" checked />
                            <span class="small muted">직전봉 방향에 따른 통계 샘플이 충분하면 우선 사용</span>
                        </div>
                    </div>

                    <div>
                        <label>자동 스캔(선택 TF 캔들 경계)</label>
                        <div class="row">
                            <input id="autoScan" type="checkbox" checked />
                            <span class="small muted">15m/1h/4h/1d 경계 자동</span>
                        </div>
                    </div>

                    <div style="grid-column: 1 / -1;">
                        <div class="row">
                            <button id="btnInit" class="btn">초기 히스토리 로딩/갱신(현재 TF)</button>
                            <button id="btnScan" class="btn secondary">지금 스캔</button>
                            <button id="btnClear" class="btn secondary">캐시 삭제(전체 TF)</button>
                        </div>
                    </div>
                </div>

                <div class="status">
                    <div class="pill">
                        <div class="k">웹소켓 상태</div>
                        <div id="wsStatus" class="v">-</div>
                    </div>
                    <div class="pill">
                        <div class="k">현재 TF 마지막 스캔</div>
                        <div id="lastScan" class="v">-</div>
                    </div>
                    <div class="pill">
                        <div class="k">현재 TF 다음 자동 스캔(UTC 기준)</div>
                        <div id="nextScan" class="v">-</div>
                    </div>
                    <div class="pill">
                        <div class="k">초기 로딩 진행 (ok/fail)</div>
                        <div id="initProgress" class="v">-</div>
                    </div>
                </div>

                <div class="foot">
                    <b>주의</b>: Max Lev는 단순 근사치입니다. (격리/교차, 포지션 크기, 유지증거금 구간, 슬리피지 등에 따라 실제 청산과 다름)
                </div>
            </div>

            <div class="tableWrap">
                <table>
                    <thead>
                        <tr>
                            <th data-key="symbol">Symbol<span class="hint" id="sortHintSymbol"></span></th>
                            <th data-key="lastPrice" class="right">Last<span class="hint" id="sortHintLast"></span></th>
                            <th data-key="quoteVol" class="right">24h QVol<span class="hint" id="sortHintQ"></span></th>
                            <th data-key="pUp" class="right">P(C&gt;O)<span class="hint" id="sortHintPUp"></span></th>
                            <th data-key="pDown" class="right">P(C&lt;O)<span class="hint" id="sortHintPDown"></span></th>
                            <th data-key="muUp" class="right">E[+]%<span class="hint" id="sortHintMuUp"></span></th>
                            <th data-key="muDown" class="right">E[-]%<span class="hint" id="sortHintMuDown"></span></th>
                            <th data-key="ev" class="right">EV% (Long)<span class="hint" id="sortHintEv"></span></th>
                            <th data-key="maxLev" class="right">Max Lev*<span class="hint" id="sortHintLev"></span></th>
                            <th data-key="n" class="right">N<span class="hint" id="sortHintN"></span></th>
                            <th data-key="mode" class="right">Mode<span class="hint" id="sortHintMode"></span></th>
                        </tr>
                    </thead>
                    <tbody id="tbody"></tbody>
                </table>
            </div>

            <div class="foot">
                * Max Lev(근사): <span class="mono">floor( 1 / (E[-] + mmr + safetyBuffer) )</span>
            </div>
        </div>

        <script>
            "use strict";

            const REST_BASE = "https://fapi.binance.com";
            const WS_URL = "wss://fstream.binance.com/ws/!miniTicker@arr";

            const TIMEFRAMES = {
                "15m": { label: "15m", interval: "15m", ms: 15 * 60 * 1000, defaultHistory: 480, condMinN: 60 },
                "1h": { label: "1h", interval: "1h", ms: 60 * 60 * 1000, defaultHistory: 720, condMinN: 80 },
                "4h": { label: "4h", interval: "4h", ms: 4 * 60 * 60 * 1000, defaultHistory: 540, condMinN: 80 },
                "1d": { label: "1d", interval: "1d", ms: 24 * 60 * 60 * 1000, defaultHistory: 365, condMinN: 60 },
            };

            const CACHE_PREFIX = "binance_tf_prob_scanner_v2";

            const els = {
                timeframe: document.getElementById("timeframe"),
                historyLimit: document.getElementById("historyLimit"),
                concurrency: document.getElementById("concurrency"),
                minQuoteVol: document.getElementById("minQuoteVol"),
                feeRoundTrip: document.getElementById("feeRoundTrip"),
                safetyBuffer: document.getElementById("safetyBuffer"),
                mmr: document.getElementById("mmr"),
                useConditional: document.getElementById("useConditional"),
                autoScan: document.getElementById("autoScan"),
                search: document.getElementById("search"),
                btnInit: document.getElementById("btnInit"),
                btnScan: document.getElementById("btnScan"),
                btnClear: document.getElementById("btnClear"),
                wsStatus: document.getElementById("wsStatus"),
                lastScan: document.getElementById("lastScan"),
                nextScan: document.getElementById("nextScan"),
                initProgress: document.getElementById("initProgress"),
                tbody: document.getElementById("tbody"),
            };

            function clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            function fmtInt(n) {
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString();
            }

            function fmtPrice(n) {
                if (!Number.isFinite(n)) return "-";
                const abs = Math.abs(n);
                if (abs >= 1000) return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
                if (abs >= 1) return n.toLocaleString(undefined, { maximumFractionDigits: 4 });
                return n.toLocaleString(undefined, { maximumFractionDigits: 8 });
            }

            function fmtPct(x, digits = 2) {
                if (!Number.isFinite(x)) return "-";
                return (x * 100).toFixed(digits);
            }

            function msToKSTString(ms) {
                if (!Number.isFinite(ms)) return "-";
                return new Date(ms).toLocaleString("ko-KR", { hour12: false });
            }

            function msToUTCString(ms) {
                if (!Number.isFinite(ms)) return "-";
                return new Date(ms).toISOString().replace("T", " ").slice(0, 19) + "Z";
            }

            function bucketOpenTimeMs(serverMs, tfMs) {
                return Math.floor(serverMs / tfMs) * tfMs;
            }

            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            async function fetchJson(url, { timeoutMs = 15000, retries = 2 } = {}) {
                let lastErr = null;

                for (let attempt = 0; attempt <= retries; attempt += 1) {
                    const ctrl = new AbortController();
                    const timer = setTimeout(() => ctrl.abort(), timeoutMs);

                    try {
                        const res = await fetch(url, { signal: ctrl.signal });
                        clearTimeout(timer);

                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            throw new Error(`HTTP ${res.status} ${text}`.trim());
                        }

                        return await res.json();
                    } catch (err) {
                        clearTimeout(timer);
                        lastErr = err;

                        const backoff = 450 * Math.pow(2, attempt);
                        await sleep(backoff);
                    }
                }

                throw lastErr || new Error("fetchJson failed");
            }

            async function getServerTimeMs() {
                const data = await fetchJson(`${REST_BASE}/fapi/v1/time`, { timeoutMs: 12000, retries: 2 });
                return Number(data.serverTime);
            }

            async function getUsdtPerpSymbols() {
                const data = await fetchJson(`${REST_BASE}/fapi/v1/exchangeInfo`, { timeoutMs: 20000, retries: 2 });
                const list = Array.isArray(data.symbols) ? data.symbols : [];
                return list
                    .filter((s) => s && s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
                    .map((s) => s.symbol)
                    .sort((a, b) => a.localeCompare(b));
            }

            function makeEmptyStats() {
                return {
                    overall: { up: 0, down: 0, sumUp: 0, sumDown: 0 },
                    cond: {
                        prevUp: { up: 0, down: 0, sumUp: 0, sumDown: 0 },
                        prevDown: { up: 0, down: 0, sumUp: 0, sumDown: 0 },
                    },
                    lastDir: 0,
                    lastCloseTime: 0,
                };
            }

            function addCandleToStats(stats, open, close) {
                const o = Number(open);
                const c = Number(close);
                if (!Number.isFinite(o) || !Number.isFinite(c) || o <= 0) return;

                const ret = c / o - 1;
                let dir = 0;

                if (ret > 0) dir = 1;
                else if (ret < 0) dir = -1;

                if (dir === 1) {
                    stats.overall.up += 1;
                    stats.overall.sumUp += ret;
                } else if (dir === -1) {
                    stats.overall.down += 1;
                    stats.overall.sumDown += -ret;
                }

                const prevDir = stats.lastDir;
                if (prevDir === 1) {
                    if (dir === 1) {
                        stats.cond.prevUp.up += 1;
                        stats.cond.prevUp.sumUp += ret;
                    } else if (dir === -1) {
                        stats.cond.prevUp.down += 1;
                        stats.cond.prevUp.sumDown += -ret;
                    }
                } else if (prevDir === -1) {
                    if (dir === 1) {
                        stats.cond.prevDown.up += 1;
                        stats.cond.prevDown.sumUp += ret;
                    } else if (dir === -1) {
                        stats.cond.prevDown.down += 1;
                        stats.cond.prevDown.sumDown += -ret;
                    }
                }

                stats.lastDir = dir;
            }

            function estimateFromStats(stats, useConditional, condMinN) {
                const overallN = stats.overall.up + stats.overall.down;

                const laplace = (up, down) => {
                    const n = up + down;
                    if (n <= 0) return 0.5;
                    return (up + 1) / (n + 2);
                };

                const calcBucket = (bucket) => {
                    const n = bucket.up + bucket.down;
                    const pUp = laplace(bucket.up, bucket.down);
                    const muUp = bucket.up > 0 ? bucket.sumUp / bucket.up : 0;
                    const muDown = bucket.down > 0 ? bucket.sumDown / bucket.down : 0;
                    return { pUp, pDown: 1 - pUp, muUp, muDown, n };
                };

                if (useConditional && (stats.lastDir === 1 || stats.lastDir === -1)) {
                    const bucket = stats.lastDir === 1 ? stats.cond.prevUp : stats.cond.prevDown;
                    const n = bucket.up + bucket.down;

                    if (n >= condMinN) {
                        const est = calcBucket(bucket);
                        return {
                            pUp: est.pUp,
                            pDown: est.pDown,
                            muUp: est.muUp,
                            muDown: est.muDown,
                            n: est.n,
                            mode: stats.lastDir === 1 ? "cond(prevUp)" : "cond(prevDown)",
                        };
                    }
                }

                if (overallN > 0) {
                    const est = calcBucket(stats.overall);
                    return { pUp: est.pUp, pDown: est.pDown, muUp: est.muUp, muDown: est.muDown, n: est.n, mode: "overall" };
                }

                return { pUp: 0.5, pDown: 0.5, muUp: 0, muDown: 0, n: 0, mode: "none" };
            }

            function calcMaxLeverageFromLoss(loss, mmr, safetyBuffer, cap = 125) {
                const x = Number(loss) + Number(mmr) + Number(safetyBuffer);
                if (!Number.isFinite(x) || x <= 0) return cap;
                if (x >= 1) return 1;
                const lev = Math.floor(1 / x);
                return clamp(lev, 1, cap);
            }

            function cacheKey(tfKey) {
                return `${CACHE_PREFIX}__${tfKey}`;
            }

            function createTfState(tfKey) {
                return {
                    tfKey,
                    statsBySymbol: new Map(),
                    currentCandleOpen: new Map(),
                    currentBucketTime: 0,
                    openTimeCaptured: 0,
                    lastScanAt: 0,
                    lastInitAt: 0,
                };
            }

            const tfStates = {
                "15m": createTfState("15m"),
                "1h": createTfState("1h"),
                "4h": createTfState("4h"),
                "1d": createTfState("1d"),
            };

            let ws = null;
            let wsConnected = false;

            let allSymbols = [];
            let symbolsLoaded = false;

            const latestTicker = new Map(); // symbol -> { lastPrice, quoteVol, eventTime }

            let sortKey = "ev";
            let sortAsc = false;

            let autoScheduleToken = 0;
            let historyTouched = false;

            // ✅ 중복 로딩 방지 (TF별)
            const loadingByTf = {
                "15m": false,
                "1h": false,
                "4h": false,
                "1d": false,
            };

            function setWsStatus(text, cls = "") {
                els.wsStatus.textContent = text;
                els.wsStatus.className = "v " + cls;
            }

            function setInitProgress(text) {
                els.initProgress.textContent = text;
            }

            function setLastScanForSelected() {
                const tfKey = els.timeframe.value;
                const st = tfStates[tfKey];
                els.lastScan.textContent = st.lastScanAt ? msToKSTString(st.lastScanAt) : "-";
            }

            function setNextScanText(msUtc) {
                els.nextScan.textContent = msUtc ? msToUTCString(msUtc) : "-";
            }

            function saveCache(tfKey) {
                const st = tfStates[tfKey];
                const obj = { version: 2, savedAt: Date.now(), stats: {} };

                for (const [sym, stats] of st.statsBySymbol.entries()) {
                    obj.stats[sym] = stats;
                }

                try {
                    localStorage.setItem(cacheKey(tfKey), JSON.stringify(obj));
                } catch (err) {
                    // ignore
                }
            }

            function loadCache(tfKey) {
                const st = tfStates[tfKey];

                try {
                    const raw = localStorage.getItem(cacheKey(tfKey));
                    if (!raw) return;

                    const obj = JSON.parse(raw);
                    if (!obj || obj.version !== 2 || !obj.stats) return;

                    for (const sym of Object.keys(obj.stats)) {
                        const stats = obj.stats[sym];
                        if (stats && stats.overall && stats.cond) {
                            st.statsBySymbol.set(sym, stats);
                        }
                    }
                } catch (err) {
                    // ignore
                }
            }

            function clearAllCache() {
                for (const tfKey of Object.keys(tfStates)) {
                    try {
                        localStorage.removeItem(cacheKey(tfKey));
                    } catch (err) {
                        // ignore
                    }
                    tfStates[tfKey].statsBySymbol.clear();
                    tfStates[tfKey].currentCandleOpen.clear();
                    tfStates[tfKey].currentBucketTime = 0;
                    tfStates[tfKey].openTimeCaptured = 0;
                    tfStates[tfKey].lastScanAt = 0;
                    tfStates[tfKey].lastInitAt = 0;
                    loadingByTf[tfKey] = false;
                }
                setInitProgress("캐시 삭제 완료(전체 TF)");
                render();
                setLastScanForSelected();
                setNextScanText(0);
            }

            function updateSortHints() {
                const ids = [
                    "sortHintSymbol",
                    "sortHintLast",
                    "sortHintQ",
                    "sortHintPUp",
                    "sortHintPDown",
                    "sortHintMuUp",
                    "sortHintMuDown",
                    "sortHintEv",
                    "sortHintLev",
                    "sortHintN",
                    "sortHintMode",
                ];

                for (const id of ids) {
                    const el = document.getElementById(id);
                    if (el) el.textContent = "";
                }

                const map = {
                    symbol: "sortHintSymbol",
                    lastPrice: "sortHintLast",
                    quoteVol: "sortHintQ",
                    pUp: "sortHintPUp",
                    pDown: "sortHintPDown",
                    muUp: "sortHintMuUp",
                    muDown: "sortHintMuDown",
                    ev: "sortHintEv",
                    maxLev: "sortHintLev",
                    n: "sortHintN",
                    mode: "sortHintMode",
                };

                const hintId = map[sortKey];
                if (!hintId) return;

                const el = document.getElementById(hintId);
                if (!el) return;

                el.textContent = sortAsc ? "▲" : "▼";
            }

            function getRowData(sym) {
                const tfKey = els.timeframe.value;
                const tf = TIMEFRAMES[tfKey];
                const st = tfStates[tfKey];

                const ticker = latestTicker.get(sym) || null;
                const stats = st.statsBySymbol.get(sym) || null;

                const lastPrice = ticker ? Number(ticker.lastPrice) : NaN;
                const quoteVol = ticker ? Number(ticker.quoteVol) : NaN;

                const useConditional = !!els.useConditional.checked;
                const est = stats
                    ? estimateFromStats(stats, useConditional, tf.condMinN)
                    : { pUp: 0.5, pDown: 0.5, muUp: 0, muDown: 0, n: 0, mode: "none" };

                const fee = Number(els.feeRoundTrip.value) || 0;
                const ev = est.pUp * est.muUp - est.pDown * est.muDown - fee;

                const mmr = Number(els.mmr.value) || 0;
                const safety = Number(els.safetyBuffer.value) || 0;
                const maxLev = calcMaxLeverageFromLoss(est.muDown, mmr, safety, 125);

                return {
                    symbol: sym,
                    lastPrice,
                    quoteVol,
                    pUp: est.pUp,
                    pDown: est.pDown,
                    muUp: est.muUp,
                    muDown: est.muDown,
                    ev,
                    maxLev,
                    n: est.n,
                    mode: est.mode,
                };
            }

            function applyFilters(rows) {
                const minQ = Number(els.minQuoteVol.value) || 0;
                const q = String(els.search.value || "").trim().toUpperCase();

                return rows.filter((r) => {
                    if (Number.isFinite(minQ) && minQ > 0) {
                        if (!Number.isFinite(r.quoteVol) || r.quoteVol < minQ) return false;
                    }
                    if (q) {
                        if (!r.symbol.includes(q)) return false;
                    }
                    return true;
                });
            }

            function sortRows(rows) {
                const key = sortKey;
                const asc = sortAsc;

                const cmp = (a, b) => {
                    const av = a[key];
                    const bv = b[key];

                    if (key === "symbol" || key === "mode") {
                        const as = String(av || "");
                        const bs = String(bv || "");
                        return asc ? as.localeCompare(bs) : bs.localeCompare(as);
                    }

                    const an = Number(av);
                    const bn = Number(bv);

                    const aBad = !Number.isFinite(an);
                    const bBad = !Number.isFinite(bn);

                    if (aBad && bBad) return 0;
                    if (aBad) return 1;
                    if (bBad) return -1;

                    if (an === bn) return 0;
                    return asc ? (an < bn ? -1 : 1) : (an > bn ? -1 : 1);
                };

                rows.sort(cmp);
                return rows;
            }

            function render() {
                if (!allSymbols.length) {
                    els.tbody.replaceChildren();
                    updateSortHints();
                    return;
                }

                const rows = allSymbols.map(getRowData);
                const filtered = applyFilters(rows);
                const sorted = sortRows(filtered);

                const frag = document.createDocumentFragment();

                for (const r of sorted) {
                    const tr = document.createElement("tr");

                    const tdSymbol = document.createElement("td");
                    tdSymbol.textContent = r.symbol;
                    tdSymbol.className = "mono";
                    tr.appendChild(tdSymbol);

                    const tdLast = document.createElement("td");
                    tdLast.textContent = fmtPrice(r.lastPrice);
                    tdLast.className = "mono right";
                    tr.appendChild(tdLast);

                    const tdQ = document.createElement("td");
                    tdQ.textContent = Number.isFinite(r.quoteVol) ? fmtInt(r.quoteVol) : "-";
                    tdQ.className = "mono right";
                    tr.appendChild(tdQ);

                    const tdPUp = document.createElement("td");
                    tdPUp.textContent = Number.isFinite(r.pUp) ? fmtPct(r.pUp, 2) : "-";
                    tdPUp.className = "mono right " + (r.pUp >= 0.5 ? "good" : "muted");
                    tr.appendChild(tdPUp);

                    const tdPDown = document.createElement("td");
                    tdPDown.textContent = Number.isFinite(r.pDown) ? fmtPct(r.pDown, 2) : "-";
                    tdPDown.className = "mono right " + (r.pDown > 0.5 ? "bad" : "muted");
                    tr.appendChild(tdPDown);

                    const tdMuUp = document.createElement("td");
                    tdMuUp.textContent = Number.isFinite(r.muUp) ? fmtPct(r.muUp, 3) : "-";
                    tdMuUp.className = "mono right good";
                    tr.appendChild(tdMuUp);

                    const tdMuDown = document.createElement("td");
                    tdMuDown.textContent = Number.isFinite(r.muDown) ? fmtPct(r.muDown, 3) : "-";
                    tdMuDown.className = "mono right bad";
                    tr.appendChild(tdMuDown);

                    const tdEv = document.createElement("td");
                    tdEv.textContent = Number.isFinite(r.ev) ? fmtPct(r.ev, 3) : "-";
                    tdEv.className = "mono right " + (r.ev >= 0 ? "good" : "bad");
                    tr.appendChild(tdEv);

                    const tdLev = document.createElement("td");
                    tdLev.textContent = Number.isFinite(r.maxLev) ? String(r.maxLev) + "x" : "-";
                    tdLev.className = "mono right " + (r.maxLev >= 20 ? "good" : "warn");
                    tr.appendChild(tdLev);

                    const tdN = document.createElement("td");
                    tdN.textContent = Number.isFinite(r.n) ? fmtInt(r.n) : "-";
                    tdN.className = "mono right muted";
                    tr.appendChild(tdN);

                    const tdMode = document.createElement("td");
                    tdMode.textContent = r.mode || "-";
                    tdMode.className = "mono right muted";
                    tr.appendChild(tdMode);

                    frag.appendChild(tr);
                }

                els.tbody.replaceChildren(frag);
                updateSortHints();
            }

            function connectWs() {
                if (ws) {
                    try {
                        ws.close();
                    } catch (err) {
                        // ignore
                    }
                }

                setWsStatus("연결 중...", "warn");
                ws = new WebSocket(WS_URL);

                ws.onopen = () => {
                    wsConnected = true;
                    setWsStatus("연결됨", "good");
                };

                ws.onclose = () => {
                    wsConnected = false;
                    setWsStatus("끊김 (재연결 시도)", "bad");
                    setTimeout(() => connectWs(), 1500);
                };

                ws.onerror = () => {
                    wsConnected = false;
                    setWsStatus("에러 (재연결 시도)", "bad");
                    try {
                        ws.close();
                    } catch (err) {
                        // ignore
                    }
                };

                ws.onmessage = (ev) => {
                    try {
                        const data = JSON.parse(ev.data);
                        if (!Array.isArray(data)) return;

                        const now = Date.now();

                        for (const t of data) {
                            const sym = t && t.s;
                            if (!sym) continue;

                            const lastPrice = Number(t.c);
                            const quoteVol = Number(t.q);
                            const eventTime = Number(t.E) || now;

                            if (!Number.isFinite(lastPrice) || lastPrice <= 0) continue;
                            latestTicker.set(sym, { lastPrice, quoteVol, eventTime });
                        }
                    } catch (err) {
                        // ignore
                    }
                };
            }

            async function mapLimit(arr, limit, worker) {
                const results = new Array(arr.length);
                let idx = 0;

                const runners = new Array(limit).fill(0).map(async () => {
                    while (true) {
                        const i = idx;
                        idx += 1;
                        if (i >= arr.length) return;
                        results[i] = await worker(arr[i], i);
                    }
                });

                await Promise.all(runners);
                return results;
            }

            async function ensureSymbolsLoaded() {
                if (symbolsLoaded && allSymbols.length) return;

                setInitProgress("USDT 무기한 심볼 목록 가져오는 중...");
                allSymbols = await getUsdtPerpSymbols();
                symbolsLoaded = true;

                setInitProgress(`심볼 ${allSymbols.length}개 로딩 완료`);
                render();
            }

            function loadAllCachesOnce() {
                for (const tfKey of Object.keys(tfStates)) {
                    loadCache(tfKey);
                }
            }

            // ✅ 핵심1: ok/fail 카운트 표시 + 중복 로딩 방지
            async function loadHistorySelectedTf() {
                const tfKey = els.timeframe.value;
                const tf = TIMEFRAMES[tfKey];
                const st = tfStates[tfKey];

                if (loadingByTf[tfKey]) {
                    setInitProgress(`이미 로딩 중: TF=${tfKey}`);
                    return;
                }

                loadingByTf[tfKey] = true;
                els.btnInit.disabled = true;
                els.btnScan.disabled = true;

                try {
                    await ensureSymbolsLoaded();

                    const serverTime = await getServerTimeMs();
                    const bucketTime = bucketOpenTimeMs(serverTime, tf.ms);
                    const endTime = bucketTime - 1;

                    const limit = clamp(Number(els.historyLimit.value) || tf.defaultHistory, 120, 1499);
                    const conc = clamp(Number(els.concurrency.value) || 2, 1, 6);

                    let done = 0;
                    let ok = 0;
                    let fail = 0;

                    setInitProgress(`히스토리 로딩 시작 (TF=${tfKey}, limit=${limit}, conc=${conc}) (ok=${ok}, fail=${fail})`);

                    await mapLimit(allSymbols, conc, async (sym) => {
                        const cached = st.statsBySymbol.get(sym);

                        if (cached && Number.isFinite(cached.lastCloseTime) && cached.lastCloseTime >= endTime - tf.ms * 2) {
                            ok += 1;
                            done += 1;
                            if (done % 10 === 0) setInitProgress(`${done} / ${allSymbols.length} (ok=${ok}, fail=${fail}) (캐시)`);
                            return;
                        }

                        const url =
                            `${REST_BASE}/fapi/v1/klines?symbol=` +
                            encodeURIComponent(sym) +
                            `&interval=` +
                            encodeURIComponent(tf.interval) +
                            `&endTime=` +
                            encodeURIComponent(String(endTime)) +
                            `&limit=` +
                            encodeURIComponent(String(limit));

                        let klines = null;

                        try {
                            klines = await fetchJson(url, { timeoutMs: 20000, retries: 2 });
                        } catch (err) {
                            st.statsBySymbol.set(sym, makeEmptyStats());
                            fail += 1;
                            done += 1;

                            if (done % 10 === 0) {
                                setInitProgress(`${done} / ${allSymbols.length} (ok=${ok}, fail=${fail}) (일부 실패)`);
                            }

                            await sleep(180);
                            return;
                        }

                        const stats = makeEmptyStats();

                        if (Array.isArray(klines)) {
                            for (const k of klines) {
                                if (!Array.isArray(k) || k.length < 7) continue;

                                const open = Number(k[1]);
                                const close = Number(k[4]);
                                const closeTime = Number(k[6]);

                                if (!Number.isFinite(closeTime) || closeTime > endTime) continue;

                                addCandleToStats(stats, open, close);
                                stats.lastCloseTime = closeTime;
                            }
                        }

                        st.statsBySymbol.set(sym, stats);

                        ok += 1;
                        done += 1;

                        if (done % 10 === 0) {
                            setInitProgress(`${done} / ${allSymbols.length} (ok=${ok}, fail=${fail})`);
                        }

                        await sleep(140);
                    });

                    st.lastInitAt = Date.now();
                    saveCache(tfKey);

                    setInitProgress(`완료: TF=${tfKey}, ${allSymbols.length}개 (ok=${ok}, fail=${fail})`);
                    render();

                    st.currentBucketTime = 0;
                    st.openTimeCaptured = 0;
                    st.currentCandleOpen.clear();

                    setLastScanForSelected();
                    scheduleNextAutoScanSelected();
                } finally {
                    loadingByTf[tfKey] = false;
                    els.btnInit.disabled = false;
                    els.btnScan.disabled = false;
                }
            }

            function snapshotOpenForAllSymbols(tfKey, openTime) {
                const st = tfStates[tfKey];
                if (!wsConnected) return;

                st.currentCandleOpen.clear();

                for (const sym of allSymbols) {
                    const t = latestTicker.get(sym);
                    if (!t) continue;

                    const p = Number(t.lastPrice);
                    if (!Number.isFinite(p) || p <= 0) continue;

                    st.currentCandleOpen.set(sym, { openTime, openPrice: p });
                }

                st.openTimeCaptured = openTime;
            }

            function closePrevCandleAndUpdateStats(tfKey, prevOpenTime, closeTime) {
                const st = tfStates[tfKey];
                if (st.openTimeCaptured !== prevOpenTime) return;

                for (const sym of allSymbols) {
                    const openInfo = st.currentCandleOpen.get(sym);
                    if (!openInfo) continue;
                    if (openInfo.openTime !== prevOpenTime) continue;

                    const t = latestTicker.get(sym);
                    if (!t) continue;

                    const closePrice = Number(t.lastPrice);
                    if (!Number.isFinite(closePrice) || closePrice <= 0) continue;

                    const openPrice = Number(openInfo.openPrice);
                    if (!Number.isFinite(openPrice) || openPrice <= 0) continue;

                    const stats = st.statsBySymbol.get(sym) || makeEmptyStats();
                    addCandleToStats(stats, openPrice, closePrice);
                    stats.lastCloseTime = closeTime;
                    st.statsBySymbol.set(sym, stats);
                }

                saveCache(tfKey);
            }

            async function tickScanForTf(tfKey, tag) {
                const tf = TIMEFRAMES[tfKey];
                const st = tfStates[tfKey];
                if (!allSymbols.length) return;

                const serverTime = await getServerTimeMs();
                const bucketTime = bucketOpenTimeMs(serverTime, tf.ms);

                if (st.currentBucketTime === 0) {
                    st.currentBucketTime = bucketTime;
                    st.openTimeCaptured = 0;
                    st.currentCandleOpen.clear();
                } else if (bucketTime !== st.currentBucketTime) {
                    const prevOpenTime = st.currentBucketTime;
                    const closeTime = bucketTime - 1;

                    closePrevCandleAndUpdateStats(tfKey, prevOpenTime, closeTime);

                    st.currentBucketTime = bucketTime;
                    st.openTimeCaptured = 0;
                    st.currentCandleOpen.clear();
                }

                if (st.openTimeCaptured !== bucketTime) {
                    snapshotOpenForAllSymbols(tfKey, bucketTime);
                }

                st.lastScanAt = Date.now();

                if (els.timeframe.value === tfKey) {
                    setLastScanForSelected();
                    render();

                    const next = (Math.floor(serverTime / tf.ms) + 1) * tf.ms;
                    setNextScanText(next);
                }

                void tag;
            }

            async function scheduleNextAutoScanSelected() {
                autoScheduleToken += 1;
                const token = autoScheduleToken;

                if (!els.autoScan.checked) {
                    setNextScanText(0);
                    return;
                }

                const tfKey = els.timeframe.value;
                const tf = TIMEFRAMES[tfKey];

                let serverTime = 0;

                try {
                    serverTime = await getServerTimeMs();
                } catch (err) {
                    setNextScanText(0);
                    setTimeout(() => {
                        if (token === autoScheduleToken) scheduleNextAutoScanSelected();
                    }, 5000);
                    return;
                }

                const next = (Math.floor(serverTime / tf.ms) + 1) * tf.ms;
                setNextScanText(next);

                const delay = clamp(next - serverTime + 120, 250, tf.ms);

                setTimeout(async () => {
                    if (token !== autoScheduleToken) return;
                    if (!els.autoScan.checked) return;

                    try {
                        await tickScanForTf(tfKey, "auto");
                    } catch (err) {
                        // ignore
                    } finally {
                        if (token === autoScheduleToken) scheduleNextAutoScanSelected();
                    }
                }, delay);
            }

            function bindTableSorting() {
                const ths = document.querySelectorAll("thead th[data-key]");
                for (const th of ths) {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-key");
                        if (!key) return;

                        if (sortKey === key) {
                            sortAsc = !sortAsc;
                        } else {
                            sortKey = key;
                            sortAsc = false;
                        }

                        render();
                    });
                }
            }

            function applyRecommendedHistoryIfUntouched() {
                if (historyTouched) return;

                const tfKey = els.timeframe.value;
                const tf = TIMEFRAMES[tfKey];
                els.historyLimit.value = String(tf.defaultHistory);
            }

            function bindInputs() {
                const rerender = () => render();

                els.minQuoteVol.addEventListener("input", rerender);
                els.feeRoundTrip.addEventListener("input", rerender);
                els.safetyBuffer.addEventListener("input", rerender);
                els.mmr.addEventListener("input", rerender);
                els.useConditional.addEventListener("change", rerender);
                els.search.addEventListener("input", rerender);

                els.historyLimit.addEventListener("input", () => {
                    historyTouched = true;
                });

                // ✅ 핵심2: TF 바꾸면 통계 없을 때 자동 히스토리 로딩
                els.timeframe.addEventListener("change", () => {
                    applyRecommendedHistoryIfUntouched();
                    setLastScanForSelected();
                    scheduleNextAutoScanSelected();
                    render();

                    const tfKey = els.timeframe.value;
                    const st = tfStates[tfKey];

                    if (st.statsBySymbol.size === 0) {
                        // 자동 로딩
                        void loadHistorySelectedTf();
                    }
                });

                els.autoScan.addEventListener("change", () => {
                    scheduleNextAutoScanSelected();
                });

                els.btnInit.addEventListener("click", async () => {
                    await loadHistorySelectedTf();
                });

                els.btnScan.addEventListener("click", async () => {
                    await ensureSymbolsLoaded();
                    const tfKey = els.timeframe.value;
                    await tickScanForTf(tfKey, "manual");
                });

                els.btnClear.addEventListener("click", () => {
                    clearAllCache();
                });
            }

            async function boot() {
                bindInputs();
                bindTableSorting();
                connectWs();

                setInitProgress("대기 중 (TF를 바꾸면 통계 없을 때 자동 로딩됩니다)");
                setWsStatus("연결 시도...", "warn");

                loadAllCachesOnce();
                applyRecommendedHistoryIfUntouched();

                try {
                    await ensureSymbolsLoaded();
                } catch (err) {
                    setInitProgress("심볼 로딩 실패: 네트워크/차단 여부 확인");
                }

                render();
                setLastScanForSelected();
                scheduleNextAutoScanSelected();

                // ✅ 최초 진입 시에도: 현재 TF 통계가 비어있으면 자동 로딩
                const tfKey = els.timeframe.value;
                if (tfStates[tfKey].statsBySymbol.size === 0) {
                    void loadHistorySelectedTf();
                }
            }

            boot();
        </script>
    </body>
</html>