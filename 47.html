<!doctype html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — 15m 현재봉 (C>O 확률/기대수익·손실/최대레버리지) 스캐너</title>
        <style>
            :root {
                color-scheme: dark;
                --bg: #0b0f17;
                --panel: #0f1623;
                --panel2: #121c2d;
                --text: #e8eefc;
                --muted: rgba(232, 238, 252, 0.65);
                --line: rgba(232, 238, 252, 0.12);
                --good: #44d18f;
                --bad: #ff5a7a;
                --warn: #ffd166;
                --accent: #7aa2ff;
                --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
                    "Segoe UI Emoji";
            }

            body {
                margin: 0;
                font-family: var(--sans);
                background: radial-gradient(1200px 700px at 30% 0%, rgba(122, 162, 255, 0.14), transparent 60%),
                    radial-gradient(900px 600px at 80% 20%, rgba(68, 209, 143, 0.10), transparent 60%),
                    var(--bg);
                color: var(--text);
            }

            .wrap {
                max-width: 1280px;
                margin: 0 auto;
                padding: 18px 16px 42px;
            }

            .top {
                display: flex;
                gap: 12px;
                align-items: flex-start;
                justify-content: space-between;
                flex-wrap: wrap;
            }

            h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: -0.2px;
            }

            .sub {
                margin-top: 6px;
                color: var(--muted);
                font-size: 13px;
                line-height: 1.4;
            }

            .panel {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
                border: 1px solid var(--line);
                border-radius: 14px;
                padding: 14px;
            }

            .controls {
                display: grid;
                grid-template-columns: repeat(4, minmax(180px, 1fr));
                gap: 10px;
                margin-top: 14px;
            }

            @media (max-width: 1100px) {
                .controls {
                    grid-template-columns: repeat(2, minmax(180px, 1fr));
                }
            }

            @media (max-width: 640px) {
                .controls {
                    grid-template-columns: 1fr;
                }
            }

            label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin-bottom: 6px;
            }

            input[type="number"],
            input[type="text"],
            select {
                width: 100%;
                box-sizing: border-box;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.22);
                color: var(--text);
                padding: 10px 10px;
                outline: none;
                font-family: var(--sans);
            }

            input[type="checkbox"] {
                transform: translateY(1px);
            }

            .row {
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
            }

            .btn {
                border-radius: 12px;
                border: 1px solid var(--line);
                background: rgba(122, 162, 255, 0.12);
                color: var(--text);
                padding: 10px 12px;
                cursor: pointer;
                font-weight: 600;
                letter-spacing: -0.1px;
            }

            .btn:disabled {
                opacity: 0.45;
                cursor: not-allowed;
            }

            .btn.secondary {
                background: rgba(255, 255, 255, 0.06);
            }

            .status {
                display: grid;
                grid-template-columns: repeat(4, minmax(140px, 1fr));
                gap: 10px;
                margin-top: 12px;
            }

            @media (max-width: 900px) {
                .status {
                    grid-template-columns: repeat(2, minmax(140px, 1fr));
                }
            }

            .pill {
                border: 1px solid var(--line);
                border-radius: 12px;
                padding: 10px 12px;
                background: rgba(255, 255, 255, 0.03);
            }

            .pill .k {
                font-size: 12px;
                color: var(--muted);
            }

            .pill .v {
                margin-top: 6px;
                font-family: var(--mono);
                font-size: 13px;
            }

            .tableWrap {
                margin-top: 14px;
                border: 1px solid var(--line);
                border-radius: 14px;
                overflow: hidden;
                background: rgba(0, 0, 0, 0.12);
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                z-index: 1;
                background: linear-gradient(180deg, rgba(18, 28, 45, 0.96), rgba(18, 28, 45, 0.90));
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                text-align: left;
                white-space: nowrap;
                cursor: pointer;
                user-select: none;
            }

            thead th .hint {
                color: rgba(232, 238, 252, 0.45);
                font-size: 11px;
                margin-left: 6px;
            }

            tbody td {
                border-bottom: 1px solid rgba(232, 238, 252, 0.07);
                padding: 10px 10px;
                white-space: nowrap;
            }

            tbody tr:hover {
                background: rgba(122, 162, 255, 0.06);
            }

            .right {
                text-align: right;
            }

            .mono {
                font-family: var(--mono);
            }

            .good {
                color: var(--good);
            }

            .bad {
                color: var(--bad);
            }

            .warn {
                color: var(--warn);
            }

            .muted {
                color: var(--muted);
            }

            .small {
                font-size: 12px;
            }

            .foot {
                margin-top: 10px;
                color: var(--muted);
                font-size: 12px;
                line-height: 1.5;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="top">
                <div class="panel" style="flex: 1; min-width: 280px;">
                    <h1>Binance USDT Perp — 15m 현재봉 (C&gt;O 확률 / 기대수익·손실 / 최대레버리지) 스캐너</h1>
                    <div class="sub">
                        - 확률/기대값은 <b>과거 15분봉 통계 기반 “추정”</b>입니다.<br />
                        - 가격은 웹소켓 <span class="mono">!miniTicker@arr</span>의 last price를 캔들 경계에서 스냅샷으로 사용합니다. :contentReference[oaicite:4]{index=4}
                    </div>

                    <div class="controls">
                        <div>
                            <label>히스토리 캔들 수 (15m, 기본 480개 ≈ 5일)</label>
                            <input id="historyLimit" type="number" min="120" max="1499" step="1" value="480" />
                        </div>
                        <div>
                            <label>요청 동시성(초기 히스토리 로딩 속도)</label>
                            <input id="concurrency" type="number" min="1" max="10" step="1" value="3" />
                        </div>
                        <div>
                            <label>최소 24h 거래대금(USDT) 필터 (0이면 전체)</label>
                            <input id="minQuoteVol" type="number" min="0" step="1000000" value="30000000" />
                        </div>
                        <div>
                            <label>심볼 검색</label>
                            <input id="search" type="text" placeholder="예: BTCUSDT" />
                        </div>

                        <div>
                            <label>왕복 수수료(비율) 예: 0.0008 = 0.08%</label>
                            <input id="feeRoundTrip" type="number" min="0" step="0.0001" value="0.0008" />
                        </div>
                        <div>
                            <label>안전 버퍼(비율) 예: 0.002 = 0.2%</label>
                            <input id="safetyBuffer" type="number" min="0" step="0.0005" value="0.002" />
                        </div>
                        <div>
                            <label>유지증거금(근사, 비율) 예: 0.005 = 0.5%</label>
                            <input id="mmr" type="number" min="0" step="0.0005" value="0.005" />
                        </div>
                        <div>
                            <label>조건부(직전봉 방향) 통계 사용</label>
                            <div class="row">
                                <input id="useConditional" type="checkbox" checked />
                                <span class="small muted">직전봉이 Up/Down일 때의 다음봉 통계를 우선 사용</span>
                            </div>
                        </div>

                        <div>
                            <label>자동 스캔(00/15/30/45)</label>
                            <div class="row">
                                <input id="autoScan" type="checkbox" checked />
                                <span class="small muted">Binance 서버시간으로 캔들 경계 정렬</span>
                            </div>
                        </div>

                        <div style="grid-column: 1 / -1;">
                            <div class="row">
                                <button id="btnInit" class="btn">초기 히스토리 로딩/갱신</button>
                                <button id="btnScan" class="btn secondary">지금 스캔</button>
                                <button id="btnClear" class="btn secondary">캐시 삭제</button>
                            </div>
                        </div>
                    </div>

                    <div class="status">
                        <div class="pill">
                            <div class="k">웹소켓 상태</div>
                            <div id="wsStatus" class="v">-</div>
                        </div>
                        <div class="pill">
                            <div class="k">마지막 스캔</div>
                            <div id="lastScan" class="v">-</div>
                        </div>
                        <div class="pill">
                            <div class="k">다음 자동 스캔</div>
                            <div id="nextScan" class="v">-</div>
                        </div>
                        <div class="pill">
                            <div class="k">초기 로딩 진행</div>
                            <div id="initProgress" class="v">-</div>
                        </div>
                    </div>

                    <div class="foot">
                        <b>주의</b>: 이 도구는 “통계 기반 추정”이며, 실제 시장은 분포가 바뀌고(레짐 변화), 슬리피지/스프레드/유지증거금 구간/포지션 크기에 따라 결과가 크게 달라질 수 있어요.
                    </div>
                </div>
            </div>

            <div class="tableWrap">
                <table>
                    <thead>
                        <tr>
                            <th data-key="symbol">Symbol<span class="hint" id="sortHintSymbol"></span></th>
                            <th data-key="lastPrice" class="right">Last<span class="hint" id="sortHintLast"></span></th>
                            <th data-key="quoteVol" class="right">24h QVol<span class="hint" id="sortHintQ"></span></th>
                            <th data-key="pUp" class="right">P(C&gt;O)<span class="hint" id="sortHintPUp"></span></th>
                            <th data-key="pDown" class="right">P(C&lt;O)<span class="hint" id="sortHintPDown"></span></th>
                            <th data-key="muUp" class="right">E[+]%<span class="hint" id="sortHintMuUp"></span></th>
                            <th data-key="muDown" class="right">E[-]%<span class="hint" id="sortHintMuDown"></span></th>
                            <th data-key="ev" class="right">EV% (Long)<span class="hint" id="sortHintEv"></span></th>
                            <th data-key="maxLev" class="right">Max Lev*<span class="hint" id="sortHintLev"></span></th>
                            <th data-key="n" class="right">N<span class="hint" id="sortHintN"></span></th>
                            <th data-key="mode" class="right">Mode<span class="hint" id="sortHintMode"></span></th>
                        </tr>
                    </thead>
                    <tbody id="tbody"></tbody>
                </table>
            </div>

            <div class="foot">
                * Max Lev는 <span class="mono">1 / (예상손실률 + 유지증거금(근사) + 안전버퍼)</span> 기반의 근사치입니다. 실제 청산가 계산과 다를 수 있어요.
            </div>
        </div>

        <script>
            "use strict";

            // REST / WS endpoints (USDⓈ-M Futures)
            // REST base: https://fapi.binance.com :contentReference[oaicite:5]{index=5}
            // WS base: wss://fstream.binance.com, stream: !miniTicker@arr :contentReference[oaicite:6]{index=6}
            const REST_BASE = "https://fapi.binance.com";
            const WS_URL = "wss://fstream.binance.com/ws/!miniTicker@arr";

            const KLINE_INTERVAL_MS = 15 * 60 * 1000;

            const els = {
                historyLimit: document.getElementById("historyLimit"),
                concurrency: document.getElementById("concurrency"),
                minQuoteVol: document.getElementById("minQuoteVol"),
                feeRoundTrip: document.getElementById("feeRoundTrip"),
                safetyBuffer: document.getElementById("safetyBuffer"),
                mmr: document.getElementById("mmr"),
                useConditional: document.getElementById("useConditional"),
                autoScan: document.getElementById("autoScan"),
                search: document.getElementById("search"),
                btnInit: document.getElementById("btnInit"),
                btnScan: document.getElementById("btnScan"),
                btnClear: document.getElementById("btnClear"),
                wsStatus: document.getElementById("wsStatus"),
                lastScan: document.getElementById("lastScan"),
                nextScan: document.getElementById("nextScan"),
                initProgress: document.getElementById("initProgress"),
                tbody: document.getElementById("tbody"),
            };

            function clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            function fmtNumber(n, digits = 2) {
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString(undefined, { maximumFractionDigits: digits, minimumFractionDigits: digits });
            }

            function fmtInt(n) {
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString();
            }

            function fmtPrice(n) {
                if (!Number.isFinite(n)) return "-";
                const abs = Math.abs(n);
                if (abs >= 1000) return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
                if (abs >= 1) return n.toLocaleString(undefined, { maximumFractionDigits: 4 });
                return n.toLocaleString(undefined, { maximumFractionDigits: 8 });
            }

            function fmtPct(x, digits = 2) {
                if (!Number.isFinite(x)) return "-";
                return (x * 100).toFixed(digits);
            }

            function msToKSTString(ms) {
                if (!Number.isFinite(ms)) return "-";
                const d = new Date(ms);
                return d.toLocaleString("ko-KR", { hour12: false });
            }

            function bucketOpenTimeMs(t) {
                return Math.floor(t / KLINE_INTERVAL_MS) * KLINE_INTERVAL_MS;
            }

            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            async function fetchJson(url, { timeoutMs = 12000, retries = 2 } = {}) {
                let lastErr = null;

                for (let attempt = 0; attempt <= retries; attempt += 1) {
                    const ctrl = new AbortController();
                    const timer = setTimeout(() => ctrl.abort(), timeoutMs);

                    try {
                        const res = await fetch(url, { signal: ctrl.signal });
                        clearTimeout(timer);

                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            throw new Error(`HTTP ${res.status} ${text}`.trim());
                        }

                        return await res.json();
                    } catch (err) {
                        clearTimeout(timer);
                        lastErr = err;

                        const backoff = 350 * Math.pow(2, attempt);
                        await sleep(backoff);
                    }
                }

                throw lastErr || new Error("fetchJson failed");
            }

            async function getServerTimeMs() {
                // exchangeInfo docs recommend GET /fapi/v1/time for current server time :contentReference[oaicite:7]{index=7}
                const data = await fetchJson(`${REST_BASE}/fapi/v1/time`);
                return Number(data.serverTime);
            }

            async function getUsdtPerpSymbols() {
                // GET /fapi/v1/exchangeInfo :contentReference[oaicite:8]{index=8}
                const data = await fetchJson(`${REST_BASE}/fapi/v1/exchangeInfo`);
                const symbols = Array.isArray(data.symbols) ? data.symbols : [];
                return symbols
                    .filter((s) => s && s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
                    .map((s) => s.symbol)
                    .sort((a, b) => a.localeCompare(b));
            }

            function makeEmptyStats() {
                return {
                    overall: { up: 0, down: 0, sumUp: 0, sumDown: 0 },
                    cond: {
                        prevUp: { up: 0, down: 0, sumUp: 0, sumDown: 0 },
                        prevDown: { up: 0, down: 0, sumUp: 0, sumDown: 0 },
                    },
                    lastDir: 0,
                    lastCloseTime: 0,
                };
            }

            function addCandleToStats(stats, open, close) {
                const o = Number(open);
                const c = Number(close);
                if (!Number.isFinite(o) || !Number.isFinite(c) || o <= 0) return;

                const ret = c / o - 1;
                let dir = 0;

                if (ret > 0) dir = 1;
                else if (ret < 0) dir = -1;

                if (dir === 1) {
                    stats.overall.up += 1;
                    stats.overall.sumUp += ret;
                } else if (dir === -1) {
                    stats.overall.down += 1;
                    stats.overall.sumDown += -ret;
                }

                const prevDir = stats.lastDir;
                if (prevDir === 1) {
                    if (dir === 1) {
                        stats.cond.prevUp.up += 1;
                        stats.cond.prevUp.sumUp += ret;
                    } else if (dir === -1) {
                        stats.cond.prevUp.down += 1;
                        stats.cond.prevUp.sumDown += -ret;
                    }
                } else if (prevDir === -1) {
                    if (dir === 1) {
                        stats.cond.prevDown.up += 1;
                        stats.cond.prevDown.sumUp += ret;
                    } else if (dir === -1) {
                        stats.cond.prevDown.down += 1;
                        stats.cond.prevDown.sumDown += -ret;
                    }
                }

                stats.lastDir = dir;
            }

            function finalizeStats(stats, lastCloseTimeMs) {
                stats.lastCloseTime = Number(lastCloseTimeMs) || 0;
                return stats;
            }

            function estimateFromStats(stats, useConditional) {
                const overallN = stats.overall.up + stats.overall.down;
                let pUp = 0.5;
                let muUp = 0;
                let muDown = 0;
                let n = overallN;
                let mode = "overall";

                if (useConditional && (stats.lastDir === 1 || stats.lastDir === -1)) {
                    const bucket = stats.lastDir === 1 ? stats.cond.prevUp : stats.cond.prevDown;
                    const bucketN = bucket.up + bucket.down;

                    // 조건부 샘플이 너무 적으면 전체 통계로 폴백
                    if (bucketN >= 60) {
                        mode = stats.lastDir === 1 ? "cond(prevUp)" : "cond(prevDown)";
                        n = bucketN;

                        const denom = bucketN;
                        pUp = denom > 0 ? bucket.up / denom : 0.5;
                        muUp = bucket.up > 0 ? bucket.sumUp / bucket.up : 0;
                        muDown = bucket.down > 0 ? bucket.sumDown / bucket.down : 0;

                        return { pUp, pDown: 1 - pUp, muUp, muDown, n, mode };
                    }
                }

                if (overallN > 0) {
                    pUp = stats.overall.up / overallN;
                    muUp = stats.overall.up > 0 ? stats.overall.sumUp / stats.overall.up : 0;
                    muDown = stats.overall.down > 0 ? stats.overall.sumDown / stats.overall.down : 0;
                }

                return { pUp, pDown: 1 - pUp, muUp, muDown, n, mode };
            }

            function calcMaxLeverageFromLoss(loss, mmr, safetyBuffer, cap = 125) {
                const x = Number(loss) + Number(mmr) + Number(safetyBuffer);
                if (!Number.isFinite(x) || x <= 0) return cap;
                if (x >= 1) return 1;
                const lev = Math.floor(1 / x);
                return clamp(lev, 1, cap);
            }

            // App state
            let ws = null;
            let wsConnected = false;

            let allSymbols = [];
            let latestTicker = new Map(); // symbol -> { lastPrice, quoteVol, eventTime }
            let statsBySymbol = new Map(); // symbol -> stats
            let currentCandleOpen = new Map(); // symbol -> { openTime, openPrice }
            let currentBucketTime = 0;

            let sortKey = "ev";
            let sortAsc = false;

            const CACHE_KEY = "binance_15m_stats_cache_v1";

            function setWsStatus(text, cls = "") {
                els.wsStatus.textContent = text;
                els.wsStatus.className = "v " + cls;
            }

            function setInitProgress(text) {
                els.initProgress.textContent = text;
            }

            function setLastScan(ms) {
                els.lastScan.textContent = ms ? msToKSTString(ms) : "-";
            }

            function setNextScan(ms) {
                els.nextScan.textContent = ms ? msToKSTString(ms) : "-";
            }

            function saveCache() {
                const obj = {
                    version: 1,
                    savedAt: Date.now(),
                    stats: {},
                };

                for (const [sym, st] of statsBySymbol.entries()) {
                    obj.stats[sym] = st;
                }

                try {
                    localStorage.setItem(CACHE_KEY, JSON.stringify(obj));
                } catch (err) {
                    // ignore
                }
            }

            function loadCache() {
                try {
                    const raw = localStorage.getItem(CACHE_KEY);
                    if (!raw) return;

                    const obj = JSON.parse(raw);
                    if (!obj || obj.version !== 1 || !obj.stats) return;

                    for (const sym of Object.keys(obj.stats)) {
                        const st = obj.stats[sym];
                        if (st && st.overall && st.cond) {
                            statsBySymbol.set(sym, st);
                        }
                    }
                } catch (err) {
                    // ignore
                }
            }

            function clearCache() {
                try {
                    localStorage.removeItem(CACHE_KEY);
                } catch (err) {
                    // ignore
                }
                statsBySymbol.clear();
            }

            function updateSortHints() {
                const ids = [
                    "sortHintSymbol",
                    "sortHintLast",
                    "sortHintQ",
                    "sortHintPUp",
                    "sortHintPDown",
                    "sortHintMuUp",
                    "sortHintMuDown",
                    "sortHintEv",
                    "sortHintLev",
                    "sortHintN",
                    "sortHintMode",
                ];

                for (const id of ids) {
                    const el = document.getElementById(id);
                    if (el) el.textContent = "";
                }

                const map = {
                    symbol: "sortHintSymbol",
                    lastPrice: "sortHintLast",
                    quoteVol: "sortHintQ",
                    pUp: "sortHintPUp",
                    pDown: "sortHintPDown",
                    muUp: "sortHintMuUp",
                    muDown: "sortHintMuDown",
                    ev: "sortHintEv",
                    maxLev: "sortHintLev",
                    n: "sortHintN",
                    mode: "sortHintMode",
                };

                const hintId = map[sortKey];
                if (!hintId) return;

                const el = document.getElementById(hintId);
                if (!el) return;

                el.textContent = sortAsc ? "▲" : "▼";
            }

            function getRowData(sym) {
                const ticker = latestTicker.get(sym) || null;
                const stats = statsBySymbol.get(sym) || null;

                const lastPrice = ticker ? Number(ticker.lastPrice) : NaN;
                const quoteVol = ticker ? Number(ticker.quoteVol) : NaN;

                const useConditional = !!els.useConditional.checked;
                const est = stats ? estimateFromStats(stats, useConditional) : { pUp: 0.5, pDown: 0.5, muUp: 0, muDown: 0, n: 0, mode: "none" };

                const fee = Number(els.feeRoundTrip.value) || 0;
                const ev = est.pUp * est.muUp - est.pDown * est.muDown - fee;

                const mmr = Number(els.mmr.value) || 0;
                const safety = Number(els.safetyBuffer.value) || 0;
                const maxLev = calcMaxLeverageFromLoss(est.muDown, mmr, safety, 125);

                return {
                    symbol: sym,
                    lastPrice,
                    quoteVol,
                    pUp: est.pUp,
                    pDown: est.pDown,
                    muUp: est.muUp,
                    muDown: est.muDown,
                    ev,
                    maxLev,
                    n: est.n,
                    mode: est.mode,
                };
            }

            function applyFilters(rows) {
                const minQ = Number(els.minQuoteVol.value) || 0;
                const q = String(els.search.value || "").trim().toUpperCase();

                return rows.filter((r) => {
                    if (Number.isFinite(minQ) && minQ > 0) {
                        if (!Number.isFinite(r.quoteVol) || r.quoteVol < minQ) return false;
                    }
                    if (q) {
                        if (!r.symbol.includes(q)) return false;
                    }
                    return true;
                });
            }

            function sortRows(rows) {
                const key = sortKey;
                const asc = sortAsc;

                const cmp = (a, b) => {
                    const av = a[key];
                    const bv = b[key];

                    if (key === "symbol" || key === "mode") {
                        const as = String(av || "");
                        const bs = String(bv || "");
                        return asc ? as.localeCompare(bs) : bs.localeCompare(as);
                    }

                    const an = Number(av);
                    const bn = Number(bv);

                    const aBad = !Number.isFinite(an);
                    const bBad = !Number.isFinite(bn);

                    if (aBad && bBad) return 0;
                    if (aBad) return 1;
                    if (bBad) return -1;

                    if (an === bn) return 0;
                    return asc ? (an < bn ? -1 : 1) : (an > bn ? -1 : 1);
                };

                rows.sort(cmp);
                return rows;
            }

            function render() {
                const rows = allSymbols.map(getRowData);
                const filtered = applyFilters(rows);
                const sorted = sortRows(filtered);

                const frag = document.createDocumentFragment();

                for (const r of sorted) {
                    const tr = document.createElement("tr");

                    const tdSymbol = document.createElement("td");
                    tdSymbol.textContent = r.symbol;
                    tdSymbol.className = "mono";
                    tr.appendChild(tdSymbol);

                    const tdLast = document.createElement("td");
                    tdLast.textContent = fmtPrice(r.lastPrice);
                    tdLast.className = "mono right";
                    tr.appendChild(tdLast);

                    const tdQ = document.createElement("td");
                    tdQ.textContent = Number.isFinite(r.quoteVol) ? fmtInt(r.quoteVol) : "-";
                    tdQ.className = "mono right";
                    tr.appendChild(tdQ);

                    const tdPUp = document.createElement("td");
                    tdPUp.textContent = Number.isFinite(r.pUp) ? fmtPct(r.pUp, 2) : "-";
                    tdPUp.className = "mono right " + (r.pUp >= 0.5 ? "good" : "muted");
                    tr.appendChild(tdPUp);

                    const tdPDown = document.createElement("td");
                    tdPDown.textContent = Number.isFinite(r.pDown) ? fmtPct(r.pDown, 2) : "-";
                    tdPDown.className = "mono right " + (r.pDown > 0.5 ? "bad" : "muted");
                    tr.appendChild(tdPDown);

                    const tdMuUp = document.createElement("td");
                    tdMuUp.textContent = Number.isFinite(r.muUp) ? fmtPct(r.muUp, 3) : "-";
                    tdMuUp.className = "mono right good";
                    tr.appendChild(tdMuUp);

                    const tdMuDown = document.createElement("td");
                    tdMuDown.textContent = Number.isFinite(r.muDown) ? fmtPct(r.muDown, 3) : "-";
                    tdMuDown.className = "mono right bad";
                    tr.appendChild(tdMuDown);

                    const tdEv = document.createElement("td");
                    tdEv.textContent = Number.isFinite(r.ev) ? fmtPct(r.ev, 3) : "-";
                    tdEv.className = "mono right " + (r.ev >= 0 ? "good" : "bad");
                    tr.appendChild(tdEv);

                    const tdLev = document.createElement("td");
                    tdLev.textContent = Number.isFinite(r.maxLev) ? String(r.maxLev) + "x" : "-";
                    tdLev.className = "mono right " + (r.maxLev >= 20 ? "good" : "warn");
                    tr.appendChild(tdLev);

                    const tdN = document.createElement("td");
                    tdN.textContent = Number.isFinite(r.n) ? fmtInt(r.n) : "-";
                    tdN.className = "mono right muted";
                    tr.appendChild(tdN);

                    const tdMode = document.createElement("td");
                    tdMode.textContent = r.mode || "-";
                    tdMode.className = "mono right muted";
                    tr.appendChild(tdMode);

                    frag.appendChild(tr);
                }

                els.tbody.replaceChildren(frag);
                updateSortHints();
            }

            function connectWs() {
                if (ws) {
                    try {
                        ws.close();
                    } catch (err) {
                        // ignore
                    }
                }

                setWsStatus("연결 중...", "warn");
                ws = new WebSocket(WS_URL);

                ws.onopen = () => {
                    wsConnected = true;
                    setWsStatus("연결됨", "good");
                };

                ws.onclose = () => {
                    wsConnected = false;
                    setWsStatus("끊김 (재연결 시도)", "bad");
                    setTimeout(() => connectWs(), 1500);
                };

                ws.onerror = () => {
                    wsConnected = false;
                    setWsStatus("에러 (재연결 시도)", "bad");
                    try {
                        ws.close();
                    } catch (err) {
                        // ignore
                    }
                };

                ws.onmessage = (ev) => {
                    try {
                        const data = JSON.parse(ev.data);
                        if (!Array.isArray(data)) return;

                        const now = Date.now();

                        for (const t of data) {
                            const sym = t && t.s;
                            if (!sym) continue;

                            // !miniTicker@arr payload includes:
                            // s: symbol, c: close price(last), q: quote volume, E: event time :contentReference[oaicite:9]{index=9}
                            const lastPrice = Number(t.c);
                            const quoteVol = Number(t.q);
                            const eventTime = Number(t.E) || now;

                            if (!Number.isFinite(lastPrice) || lastPrice <= 0) continue;

                            latestTicker.set(sym, { lastPrice, quoteVol, eventTime });
                        }
                    } catch (err) {
                        // ignore
                    }
                };
            }

            async function mapLimit(arr, limit, worker) {
                const results = new Array(arr.length);
                let idx = 0;

                const runners = new Array(limit).fill(0).map(async () => {
                    while (true) {
                        const i = idx;
                        idx += 1;
                        if (i >= arr.length) return;

                        results[i] = await worker(arr[i], i);
                    }
                });

                await Promise.all(runners);
                return results;
            }

            async function loadHistoryAll() {
                els.btnInit.disabled = true;
                els.btnScan.disabled = true;

                try {
                    setInitProgress("심볼 로딩 중...");
                    const serverTime = await getServerTimeMs();
                    currentBucketTime = bucketOpenTimeMs(serverTime);

                    setInitProgress("USDT 무기한 심볼 목록 가져오는 중...");
                    allSymbols = await getUsdtPerpSymbols();

                    setInitProgress(`심볼 ${allSymbols.length}개 확인. 캐시 로딩...`);
                    loadCache();

                    // endTime을 현재 진행중 캔들 시작 직전으로 맞춰서 "닫힌 캔들"만 받기
                    const endTime = currentBucketTime - 1;

                    const limit = clamp(Number(els.historyLimit.value) || 480, 120, 1499);
                    const conc = clamp(Number(els.concurrency.value) || 3, 1, 10);

                    let done = 0;

                    setInitProgress(`히스토리 로딩 시작 (limit=${limit}, concurrency=${conc})...`);

                    await mapLimit(allSymbols, conc, async (sym) => {
                        // 이미 캐시에 있고, lastCloseTime이 최근이면 스킵(너무 공격적으로 스킵하면 안 되니 보수적으로만)
                        const cached = statsBySymbol.get(sym);
                        if (cached && Number.isFinite(cached.lastCloseTime) && cached.lastCloseTime >= endTime - KLINE_INTERVAL_MS * 2) {
                            done += 1;
                            if (done % 10 === 0) setInitProgress(`${done} / ${allSymbols.length} (캐시 활용)`);

                            return;
                        }

                        // Klines REST: GET /fapi/v1/klines (limit에 따라 weight 증가) :contentReference[oaicite:10]{index=10}
                        const url = `${REST_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(sym)}&interval=15m&endTime=${endTime}&limit=${limit}`;
                        let klines = null;

                        try {
                            klines = await fetchJson(url, { timeoutMs: 15000, retries: 2 });
                        } catch (err) {
                            // 실패하면 빈 stats라도 넣어둠
                            statsBySymbol.set(sym, makeEmptyStats());
                            done += 1;
                            if (done % 10 === 0) setInitProgress(`${done} / ${allSymbols.length} (일부 실패)`);

                            // 요청 폭주 완화
                            await sleep(90);
                            return;
                        }

                        const st = makeEmptyStats();

                        if (Array.isArray(klines)) {
                            for (const k of klines) {
                                if (!Array.isArray(k) || k.length < 7) continue;
                                const openTime = Number(k[0]);
                                const open = Number(k[1]);
                                const close = Number(k[4]);
                                const closeTime = Number(k[6]);

                                // 닫힌 캔들만 반영
                                if (!Number.isFinite(closeTime) || closeTime > endTime) continue;

                                addCandleToStats(st, open, close);
                                st.lastCloseTime = closeTime;
                            }
                        }

                        statsBySymbol.set(sym, finalizeStats(st, st.lastCloseTime));

                        done += 1;
                        if (done % 10 === 0) {
                            setInitProgress(`${done} / ${allSymbols.length}`);
                        }

                        // REST 과속 방지(418 방지용으로 매우 약하게)
                        await sleep(80);
                    });

                    saveCache();
                    setInitProgress(`완료: ${allSymbols.length}개`);
                    render();
                } finally {
                    els.btnInit.disabled = false;
                    els.btnScan.disabled = false;
                }
            }

            function snapshotOpenForAllSymbols(openTime) {
                for (const sym of allSymbols) {
                    const t = latestTicker.get(sym);
                    if (!t) continue;

                    const p = Number(t.lastPrice);
                    if (!Number.isFinite(p) || p <= 0) continue;

                    currentCandleOpen.set(sym, { openTime, openPrice: p });
                }
            }

            function closePrevCandleAndUpdateStats(prevOpenTime, closeTime, closePriceBySymbol) {
                for (const sym of allSymbols) {
                    const openInfo = currentCandleOpen.get(sym);
                    if (!openInfo) continue;
                    if (openInfo.openTime !== prevOpenTime) continue;

                    const closePrice = closePriceBySymbol.get(sym);
                    if (!Number.isFinite(closePrice) || closePrice <= 0) continue;

                    const openPrice = Number(openInfo.openPrice);
                    if (!Number.isFinite(openPrice) || openPrice <= 0) continue;

                    const st = statsBySymbol.get(sym) || makeEmptyStats();
                    addCandleToStats(st, openPrice, closePrice);
                    st.lastCloseTime = closeTime;
                    statsBySymbol.set(sym, st);
                }

                saveCache();
            }

            async function runScanNow(tag = "manual") {
                const serverTime = await getServerTimeMs();
                const bucketTime = bucketOpenTimeMs(serverTime);

                // 캔들 경계가 바뀐 경우(자동/수동 모두), "이전 캔들"을 닫고 업데이트
                if (currentBucketTime && bucketTime !== currentBucketTime) {
                    const prevOpenTime = currentBucketTime;
                    const closeTime = bucketTime - 1;

                    const closePriceBySymbol = new Map();
                    for (const sym of allSymbols) {
                        const t = latestTicker.get(sym);
                        if (!t) continue;
                        const p = Number(t.lastPrice);
                        if (!Number.isFinite(p) || p <= 0) continue;
                        closePriceBySymbol.set(sym, p);
                    }

                    closePrevCandleAndUpdateStats(prevOpenTime, closeTime, closePriceBySymbol);

                    // 새 캔들 오픈 스냅샷
                    snapshotOpenForAllSymbols(bucketTime);
                    currentBucketTime = bucketTime;
                }

                setLastScan(Date.now());
                render();

                // 다음 자동 스캔 시각 표시 업데이트
                const next = (Math.floor(serverTime / KLINE_INTERVAL_MS) + 1) * KLINE_INTERVAL_MS;
                setNextScan(next);

                // tag는 디버깅용(미사용)
                void tag;
            }

            async function scheduleNextAutoScan() {
                if (!els.autoScan.checked) {
                    setNextScan(0);
                    return;
                }

                const serverTime = await getServerTimeMs();
                const next = (Math.floor(serverTime / KLINE_INTERVAL_MS) + 1) * KLINE_INTERVAL_MS;
                setNextScan(next);

                const delay = clamp(next - serverTime + 80, 200, KLINE_INTERVAL_MS);

                setTimeout(async () => {
                    if (!els.autoScan.checked) {
                        setNextScan(0);
                        return;
                    }

                    try {
                        await runScanNow("auto");
                    } catch (err) {
                        // ignore
                    } finally {
                        scheduleNextAutoScan();
                    }
                }, delay);
            }

            function bindTableSorting() {
                const ths = document.querySelectorAll("thead th[data-key]");
                for (const th of ths) {
                    th.addEventListener("click", () => {
                        const key = th.getAttribute("data-key");
                        if (!key) return;

                        if (sortKey === key) {
                            sortAsc = !sortAsc;
                        } else {
                            sortKey = key;
                            sortAsc = false;
                        }

                        render();
                    });
                }
            }

            function bindInputs() {
                const rerender = () => render();

                els.minQuoteVol.addEventListener("input", rerender);
                els.feeRoundTrip.addEventListener("input", rerender);
                els.safetyBuffer.addEventListener("input", rerender);
                els.mmr.addEventListener("input", rerender);
                els.useConditional.addEventListener("change", rerender);
                els.search.addEventListener("input", rerender);

                els.autoScan.addEventListener("change", () => {
                    scheduleNextAutoScan();
                });

                els.btnInit.addEventListener("click", async () => {
                    await loadHistoryAll();

                    // 첫 오픈 스냅샷 (현재 진행중 캔들의 오픈을 늦게라도 잡아둠)
                    try {
                        const serverTime = await getServerTimeMs();
                        currentBucketTime = bucketOpenTimeMs(serverTime);
                        snapshotOpenForAllSymbols(currentBucketTime);
                    } catch (err) {
                        // ignore
                    }

                    scheduleNextAutoScan();
                });

                els.btnScan.addEventListener("click", async () => {
                    if (!allSymbols.length) {
                        await loadHistoryAll();
                        try {
                            const serverTime = await getServerTimeMs();
                            currentBucketTime = bucketOpenTimeMs(serverTime);
                            snapshotOpenForAllSymbols(currentBucketTime);
                        } catch (err) {
                            // ignore
                        }
                    }
                    await runScanNow("manual");
                });

                els.btnClear.addEventListener("click", () => {
                    clearCache();
                    setInitProgress("캐시 삭제 완료");
                    render();
                });
            }

            async function boot() {
                bindInputs();
                bindTableSorting();
                connectWs();

                setInitProgress("대기 중 (초기 히스토리 로딩 버튼을 누르세요)");
                setWsStatus("연결 시도...", "warn");
                updateSortHints();

                // 페이지가 켜진 채로 있으면 자동으로 다음 스캔 예약만 해둠 (히스토리 없으면 값이 빈 상태로 표시됨)
                scheduleNextAutoScan();
            }

            boot();
        </script>
    </body>
</html>
