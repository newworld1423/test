<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT-PERP 15m Pump-PreScanner (00/15/30/45 Auto)</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #121826;
            --text: #e7eefc;
            --muted: #a6b3cc;
            --line: rgba(255,255,255,0.10);
            --good: #7CFC98;
            --warn: #FFD27C;
            --bad: #FF7C7C;
        }
        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
        }
        header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: rgba(11,15,20,0.85);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--line);
        }
        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 14px 14px 24px;
        }
        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .card {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 12px;
        }
        .card h2 {
            margin: 0 0 10px;
            font-size: 14px;
            color: var(--muted);
            font-weight: 700;
            letter-spacing: 0.2px;
        }
        .ctrls {
            display: grid;
            grid-template-columns: repeat(6, minmax(140px, 1fr));
            gap: 10px;
        }
        @media (max-width: 980px) {
            .ctrls { grid-template-columns: repeat(2, minmax(140px, 1fr)); }
        }
        label {
            display: grid;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
        }
        input, select, button {
            border-radius: 10px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,0.03);
            color: var(--text);
            padding: 10px 10px;
            outline: none;
        }
        button {
            cursor: pointer;
            font-weight: 800;
        }
        button.primary {
            background: rgba(124,252,152,0.12);
            border-color: rgba(124,252,152,0.35);
        }
        button.danger {
            background: rgba(255,124,124,0.10);
            border-color: rgba(255,124,124,0.35);
        }
        .status {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            font-size: 12px;
            color: var(--muted);
        }
        .pill {
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,0.03);
            color: var(--text);
        }
        .pill.good { border-color: rgba(124,252,152,0.35); }
        .pill.warn { border-color: rgba(255,210,124,0.35); }
        .pill.bad  { border-color: rgba(255,124,124,0.35); }

        table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            border-radius: 12px;
        }
        thead th {
            position: sticky;
            top: 76px;
            background: rgba(18,24,38,0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--line);
            color: var(--muted);
            font-size: 12px;
            text-align: left;
            padding: 10px 10px;
            white-space: nowrap;
        }
        tbody td {
            border-bottom: 1px solid rgba(255,255,255,0.06);
            padding: 10px 10px;
            font-size: 13px;
            white-space: nowrap;
        }
        tbody tr:hover {
            background: rgba(255,255,255,0.03);
        }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .right { text-align: right; }
        .muted { color: var(--muted); }
        .goodTxt { color: var(--good); }
        .warnTxt { color: var(--warn); }
        .badTxt { color: var(--bad); }
        .log {
            max-height: 160px;
            overflow: auto;
            font-size: 12px;
            color: var(--muted);
            line-height: 1.4;
            white-space: pre-wrap;
        }
        a.sym {
            color: var(--text);
            text-decoration: none;
            font-weight: 900;
        }
        a.sym:hover { text-decoration: underline; }
    </style>
</head>
<body>
<header>
    <div class="wrap">
        <div class="row" style="justify-content:space-between;">
            <div>
                <div style="font-weight:900; font-size:16px;">15m 급등 직전 후보 스캐너 (USDT-PERP)</div>
                <div class="muted" style="font-size:12px; margin-top:4px;">
                    압축(변동성 수축) + OI 증가 + 펀딩 과열X + 테이커 매수우위 + (전고 근접/돌파)
                </div>
            </div>
            <div class="status">
                <span class="pill" id="pillState">STOPPED</span>
                <span class="pill" id="pillNext">Next: -</span>
                <span class="pill" id="pillLast">Last: -</span>
            </div>
        </div>
    </div>
</header>

<main class="wrap">
    <div class="card">
        <h2>설정</h2>
        <div class="ctrls">
            <label>
                Base URL
                <select id="baseUrl">
                    <option value="https://fapi.binance.com">https://fapi.binance.com</option>
                </select>
            </label>
            <label>
                Top N (거래대금 상위)
                <input id="topN" type="number" value="60" min="10" max="200" step="1" />
            </label>
            <label>
                최소 24h 거래대금 (USDT)
                <input id="minQuoteVol" type="number" value="30000000" min="0" step="1000000" />
            </label>
            <label>
                동시 요청(concurrency)
                <input id="concurrency" type="number" value="8" min="1" max="20" step="1" />
            </label>
            <label>
                박스/저항 lookback (봉)
                <input id="boxLookback" type="number" value="24" min="10" max="100" step="1" />
            </label>
            <label>
                압축(수축) lookback (봉)
                <input id="squeezeLookback" type="number" value="120" min="60" max="300" step="10" />
            </label>
            <label>
                BB 기간
                <input id="bbPeriod" type="number" value="20" min="10" max="50" step="1" />
            </label>
            <label>
                ATR 기간
                <input id="atrPeriod" type="number" value="14" min="7" max="50" step="1" />
            </label>
            <label>
                “급등 직전” 근접 기준 (%)
                <input id="nearPct" type="number" value="0.20" min="0.05" max="1.00" step="0.05" />
            </label>
            <label>
                펀딩 상한(%) (이하만 통과)
                <input id="fundingMaxPct" type="number" value="0.02" min="0" max="0.50" step="0.01" />
            </label>
            <label>
                OI 상승 기준(%) (최근 2h)
                <input id="oiMinPct" type="number" value="2.0" min="0" max="20" step="0.5" />
            </label>
            <label>
                테이커 buy/sell ratio 기준
                <input id="takerMin" type="number" value="1.15" min="1.00" max="2.50" step="0.05" />
            </label>
        </div>

        <div class="row" style="margin-top:12px; justify-content:space-between;">
            <div class="row">
                <button class="primary" id="btnStart">Start (00/15/30/45 자동)</button>
                <button id="btnScanNow">Scan now</button>
                <button class="danger" id="btnStop">Stop</button>
            </div>
            <div class="muted" style="font-size:12px;">
                ※ 투자 조언 아님. 선물은 손절/레버리지 관리 없으면 통계적으로 불리.
            </div>
        </div>
    </div>

    <div class="card" style="margin-top:12px;">
        <h2>결과 (점수 상위)</h2>
        <div class="muted" style="font-size:12px; margin-bottom:10px;">
            State = <span class="pill warn">PRE</span> (박스 상단 근접) / <span class="pill good">BREAK</span> (직전봉 종가 돌파)
        </div>

        <div style="overflow:auto; border-radius:12px; border:1px solid var(--line);">
            <table>
                <thead>
                <tr>
                    <th>#</th>
                    <th>Symbol</th>
                    <th class="right">Score</th>
                    <th>State</th>
                    <th class="right">Price</th>
                    <th class="right">Dist→BoxHigh</th>
                    <th class="right">BBWidth pctile</th>
                    <th class="right">ATR%</th>
                    <th class="right">OI(2h)%</th>
                    <th class="right">Funding%</th>
                    <th class="right">Taker(B/S)</th>
                    <th class="right">Vol24h(USDT)</th>
                    <th class="right">Entry</th>
                    <th class="right">SL</th>
                    <th class="right">TP1</th>
                    <th class="right">TP2</th>
                </tr>
                </thead>
                <tbody id="tbody"></tbody>
            </table>
        </div>
    </div>

    <div class="card" style="margin-top:12px;">
        <h2>로그</h2>
        <div class="log" id="log"></div>
    </div>
</main>

<script>
    /* -----------------------------
     * 15m Pump Pre-Scanner
     * - 00/15/30/45 자동 스캔
     * - Top 거래대금 후보만 정밀 계산
     * ----------------------------- */

    const state = {
        running: false,
        timer: null,
        countdownTimer: null,
        exchangeSymbols: [],
        lastScanAt: null
    };

    function $(id) {
        return document.getElementById(id);
    }

    function logLine(msg) {
        const el = $("log");
        const now = new Date();
        const t = now.toLocaleTimeString("ko-KR", { hour12: false });
        el.textContent = `[${t}] ${msg}\n` + el.textContent;
    }

    function setPill(id, text, kind) {
        const el = $(id);
        el.textContent = text;
        el.className = "pill" + (kind ? (" " + kind) : "");
    }

    function toNum(x) {
        const v = Number(x);
        return Number.isFinite(v) ? v : 0;
    }

    function clamp(x, a, b) {
        return Math.max(a, Math.min(b, x));
    }

    function fmt(n, d = 2) {
        if (!Number.isFinite(n)) return "-";
        return n.toLocaleString("en-US", { maximumFractionDigits: d, minimumFractionDigits: d });
    }

    function fmt0(n) {
        if (!Number.isFinite(n)) return "-";
        return n.toLocaleString("en-US", { maximumFractionDigits: 0 });
    }

    function msToNextQuarter(withDelayMs = 3000) {
        const now = new Date();
        const m = now.getMinutes();
        const nextM = (Math.floor(m / 15) * 15 + 15) % 60;
        const next = new Date(now);

        if (nextM === 0) {
            next.setHours(now.getHours() + 1);
        }
        next.setMinutes(nextM, 0, 0);
        const diff = next.getTime() - now.getTime();
        return Math.max(0, diff + withDelayMs);
    }

    function startCountdown() {
        if (state.countdownTimer) clearInterval(state.countdownTimer);
        state.countdownTimer = setInterval(() => {
            if (!state.running) {
                setPill("pillNext", "Next: -", "");
                return;
            }
            const ms = msToNextQuarter(0);
            const sec = Math.floor(ms / 1000);
            const mm = String(Math.floor(sec / 60)).padStart(2, "0");
            const ss = String(sec % 60).padStart(2, "0");
            setPill("pillNext", `Next: ${mm}:${ss}`, "warn");
        }, 250);
    }

    async function fetchJson(url, opts = {}) {
        const {
            timeoutMs = 15000,
            retries = 2
        } = opts;

        for (let attempt = 0; attempt <= retries; attempt += 1) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);

            try {
                const res = await fetch(url, { signal: ctrl.signal, cache: "no-store" });
                clearTimeout(t);

                if (!res.ok) {
                    const code = res.status;
                    const retryable = (code === 418 || code === 429 || code >= 500);
                    const text = await res.text().catch(() => "");
                    if (retryable && attempt < retries) {
                        const backoff = 600 * (attempt + 1) * (attempt + 1);
                        logLine(`HTTP ${code} retry in ${backoff}ms: ${url}`);
                        await new Promise(r => setTimeout(r, backoff));
                        continue;
                    }
                    throw new Error(`HTTP ${code} ${text.slice(0, 160)}`);
                }

                return await res.json();
            } catch (e) {
                clearTimeout(t);
                if (attempt < retries) {
                    const backoff = 600 * (attempt + 1) * (attempt + 1);
                    logLine(`Fetch error retry in ${backoff}ms: ${e.message}`);
                    await new Promise(r => setTimeout(r, backoff));
                    continue;
                }
                throw e;
            }
        }
        throw new Error("unreachable");
    }

    async function loadExchangeInfo() {
        const base = $("baseUrl").value.trim();
        const url = `${base}/fapi/v1/exchangeInfo`;
        const json = await fetchJson(url, { timeoutMs: 20000, retries: 2 });
        const list = Array.isArray(json.symbols) ? json.symbols : [];

        state.exchangeSymbols = list
            .filter(s => s && s.status === "TRADING")
            .filter(s => String(s.contractType || "").toUpperCase() === "PERPETUAL")
            .filter(s => String(s.symbol || "").endsWith("USDT"));

        logLine(`exchangeInfo loaded: ${state.exchangeSymbols.length} symbols`);
    }

    async function loadTickers24h() {
        const base = $("baseUrl").value.trim();
        const url = `${base}/fapi/v1/ticker/24hr`;
        const arr = await fetchJson(url, { timeoutMs: 20000, retries: 2 });
        return Array.isArray(arr) ? arr : [];
    }

    function computeSMA(values, period) {
        const out = new Array(values.length).fill(null);
        let sum = 0;
        for (let i = 0; i < values.length; i += 1) {
            sum += values[i];
            if (i >= period) sum -= values[i - period];
            if (i >= period - 1) out[i] = sum / period;
        }
        return out;
    }

    function computeStd(values, period, smaArr) {
        const out = new Array(values.length).fill(null);
        for (let i = 0; i < values.length; i += 1) {
            if (i < period - 1) continue;
            const mean = smaArr[i];
            let v = 0;
            for (let k = i - period + 1; k <= i; k += 1) {
                const d = values[k] - mean;
                v += d * d;
            }
            out[i] = Math.sqrt(v / period);
        }
        return out;
    }

    function computeATR(high, low, close, period) {
        const tr = new Array(close.length).fill(null);
        for (let i = 0; i < close.length; i += 1) {
            if (i === 0) {
                tr[i] = high[i] - low[i];
                continue;
            }
            const a = high[i] - low[i];
            const b = Math.abs(high[i] - close[i - 1]);
            const c = Math.abs(low[i] - close[i - 1]);
            tr[i] = Math.max(a, b, c);
        }
        const atr = computeSMA(tr.map(v => v ?? 0), period);
        return atr;
    }

    function percentileRank(arr, value) {
        const clean = arr.filter(v => Number.isFinite(v));
        if (clean.length === 0) return null;
        clean.sort((a, b) => a - b);
        let lo = 0;
        let hi = clean.length;
        while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (clean[mid] <= value) lo = mid + 1;
            else hi = mid;
        }
        return lo / clean.length; // 0..1
    }

    function poolMap(items, worker, concurrency) {
        return new Promise((resolve) => {
            const out = new Array(items.length);
            let idx = 0;
            let done = 0;

            async function runOne() {
                const my = idx;
                idx += 1;
                if (my >= items.length) return;

                try {
                    out[my] = await worker(items[my], my);
                } catch (e) {
                    out[my] = { __error: true, error: e.message };
                } finally {
                    done += 1;
                    if (done >= items.length) return resolve(out);
                    runOne();
                }
            }

            const n = Math.min(concurrency, items.length);
            for (let i = 0; i < n; i += 1) runOne();
        });
    }

    async function analyzeSymbol(symbol, tickerMap, cfg) {
        const base = cfg.base;
        const klineLimit = Math.max(cfg.squeezeLookback + 5, cfg.boxLookback + 5);
        const limit = clamp(klineLimit, 80, 300);

        const ticker = tickerMap.get(symbol);
        const lastPrice = toNum(ticker?.lastPrice);
        const quoteVol = toNum(ticker?.quoteVolume);

        // 15m klines
        const kUrl = `${base}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=15m&limit=${limit}`;
        const kl = await fetchJson(kUrl, { timeoutMs: 20000, retries: 1 });
        if (!Array.isArray(kl) || kl.length < Math.max(cfg.bbPeriod, cfg.atrPeriod) + 10) {
            throw new Error("klines insufficient");
        }

        // close된 직전봉 = 마지막-1
        const candles = kl.map(x => ({
            t: toNum(x[0]),
            o: toNum(x[1]),
            h: toNum(x[2]),
            l: toNum(x[3]),
            c: toNum(x[4])
        }));

        const lastClosedIdx = candles.length - 2;
        const closes = candles.map(x => x.c);
        const highs = candles.map(x => x.h);
        const lows  = candles.map(x => x.l);

        const sma = computeSMA(closes, cfg.bbPeriod);
        const std = computeStd(closes, cfg.bbPeriod, sma);

        const bbWidth = closes.map((_, i) => {
            if (!Number.isFinite(sma[i]) || !Number.isFinite(std[i])) return null;
            const mid = sma[i];
            const upper = mid + 2 * std[i];
            const lower = mid - 2 * std[i];
            if (!Number.isFinite(mid) || mid === 0) return null;
            return (upper - lower) / mid; // ratio
        });

        const atr = computeATR(highs, lows, closes, cfg.atrPeriod);
        const lastClose = candles[lastClosedIdx].c;

        // 박스(저항) = 최근 boxLookback 봉(직전봉 제외) 최고/최저
        const start = Math.max(0, lastClosedIdx - cfg.boxLookback);
        let boxHigh = -Infinity;
        let boxLow = Infinity;
        for (let i = start; i < lastClosedIdx; i += 1) {
            boxHigh = Math.max(boxHigh, candles[i].h);
            boxLow = Math.min(boxLow, candles[i].l);
        }

        const distToHigh = (boxHigh - lastClose) / lastClose; // 양수: 아래, 음수: 돌파
        const near = distToHigh >= 0 && distToHigh <= (cfg.nearPct / 100);
        const breakout = lastClose > boxHigh * 1.0005;

        // 압축: BBWidth percentile (낮을수록 압축)
        const squeezeSliceStart = Math.max(0, lastClosedIdx - cfg.squeezeLookback);
        const bbSlice = bbWidth.slice(squeezeSliceStart, lastClosedIdx).filter(v => Number.isFinite(v));
        const lastBb = bbWidth[lastClosedIdx];
        const bbPctile = (Number.isFinite(lastBb) && bbSlice.length) ? percentileRank(bbSlice, lastBb) : null;

        const lastAtr = atr[lastClosedIdx];
        const atrPct = (Number.isFinite(lastAtr) && lastClose > 0) ? (lastAtr / lastClose) * 100 : null;

        // OI (15m, 최근 2h = 8개)
        const oiUrl = `${base}/futures/data/openInterestHist?symbol=${encodeURIComponent(symbol)}&period=15m&limit=9`;
        const oiArr = await fetchJson(oiUrl, { timeoutMs: 15000, retries: 1 });
        let oiChangePct = null;
        if (Array.isArray(oiArr) && oiArr.length >= 2) {
            const first = toNum(oiArr[0].sumOpenInterestValue);
            const last  = toNum(oiArr[oiArr.length - 1].sumOpenInterestValue);
            if (first > 0) oiChangePct = ((last - first) / first) * 100;
        }

        // Taker buy/sell ratio (15m)
        const takerUrl = `${base}/futures/data/takerlongshortRatio?symbol=${encodeURIComponent(symbol)}&period=15m&limit=2`;
        const takerArr = await fetchJson(takerUrl, { timeoutMs: 15000, retries: 1 });
        let takerRatio = null;
        if (Array.isArray(takerArr) && takerArr.length) {
            takerRatio = toNum(takerArr[takerArr.length - 1].buySellRatio);
        }

        // Funding (가장 최근 1~2개)
        const fUrl = `${base}/fapi/v1/fundingRate?symbol=${encodeURIComponent(symbol)}&limit=2`;
        const fArr = await fetchJson(fUrl, { timeoutMs: 15000, retries: 1 });
        let fundingPct = null;
        if (Array.isArray(fArr) && fArr.length) {
            const r = toNum(fArr[fArr.length - 1].fundingRate);
            fundingPct = r * 100;
        }

        // 필터(급등 직전 후보군)
        const passLiquidity = quoteVol >= cfg.minQuoteVol;
        const passSqueeze = (bbPctile !== null) ? (bbPctile <= 0.25) : false;
        const passOI = (oiChangePct !== null) ? (oiChangePct >= cfg.oiMinPct) : false;
        const passFunding = (fundingPct !== null) ? (fundingPct <= cfg.fundingMaxPct) : false;
        const passTaker = (takerRatio !== null) ? (takerRatio >= cfg.takerMin) : false;
        const passState = near || breakout;

        if (!(passLiquidity && passSqueeze && passOI && passFunding && passTaker && passState)) {
            return null;
        }

        // 스코어링(0~100 근사)
        const liqScore = clamp(Math.log10(Math.max(1, quoteVol)) / 10, 0, 1);
        const squeezeScore = (bbPctile === null) ? 0 : clamp(1 - bbPctile, 0, 1);
        const oiScore = (oiChangePct === null) ? 0 : clamp(oiChangePct / 8, 0, 1);
        const takerScore = (takerRatio === null) ? 0 : clamp((takerRatio - 1) / 0.8, 0, 1);
        const fundingScore = (fundingPct === null) ? 0 : (fundingPct <= 0 ? clamp((-fundingPct) / 0.10, 0, 1) : clamp(1 - (fundingPct / cfg.fundingMaxPct), 0, 1));
        const stateScore = breakout ? 1 : (near ? 0.75 : 0);

        const score = 100 * (
            0.15 * liqScore +
            0.25 * squeezeScore +
            0.20 * oiScore +
            0.15 * takerScore +
            0.15 * fundingScore +
            0.10 * stateScore
        );

        // 진입/손절/익절(가이드)
        const entry = breakout ? lastClose : (boxHigh * 1.0007);
        const sl = Math.min(boxLow, lastClose * 0.995);
        const risk = Math.max(0, entry - sl);

        const tp1 = entry + risk * 1.2;
        const tp2 = entry + risk * 2.0;

        return {
            symbol,
            score,
            state: breakout ? "BREAK" : "PRE",
            lastClose,
            distToHigh,
            bbPctile,
            atrPct,
            oiChangePct,
            fundingPct,
            takerRatio,
            quoteVol,
            entry,
            sl,
            tp1,
            tp2
        };
    }

    function renderRows(rows) {
        const tb = $("tbody");
        tb.innerHTML = "";

        rows.forEach((r, i) => {
            const tr = document.createElement("tr");

            const statePill = r.state === "BREAK"
                ? `<span class="pill good">BREAK</span>`
                : `<span class="pill warn">PRE</span>`;

            const distTxt = (r.distToHigh <= 0)
                ? `<span class="goodTxt">${fmt(r.distToHigh * 100, 2)}%</span>`
                : `<span class="${r.distToHigh * 100 <= 0.20 ? "warnTxt" : "muted"}">${fmt(r.distToHigh * 100, 2)}%</span>`;

            const bbTxt = (r.bbPctile !== null)
                ? `${fmt(r.bbPctile * 100, 0)}`
                : "-";

            const fundingCls = (r.fundingPct !== null && r.fundingPct <= 0) ? "goodTxt" : "muted";

            tr.innerHTML = `
                <td class="mono">${i + 1}</td>
                <td>
                    <a class="sym" href="https://www.binance.com/en/futures/${encodeURIComponent(r.symbol)}" target="_blank" rel="noreferrer">${r.symbol}</a>
                </td>
                <td class="right mono">${fmt(r.score, 1)}</td>
                <td>${statePill}</td>
                <td class="right mono">${fmt(r.lastClose, 6)}</td>
                <td class="right mono">${distTxt}</td>
                <td class="right mono">${bbTxt}</td>
                <td class="right mono">${r.atrPct === null ? "-" : fmt(r.atrPct, 2)}</td>
                <td class="right mono">${r.oiChangePct === null ? "-" : fmt(r.oiChangePct, 2)}</td>
                <td class="right mono"><span class="${fundingCls}">${r.fundingPct === null ? "-" : fmt(r.fundingPct, 4)}</span></td>
                <td class="right mono">${r.takerRatio === null ? "-" : fmt(r.takerRatio, 3)}</td>
                <td class="right mono">${fmt0(r.quoteVol)}</td>
                <td class="right mono">${fmt(r.entry, 6)}</td>
                <td class="right mono">${fmt(r.sl, 6)}</td>
                <td class="right mono">${fmt(r.tp1, 6)}</td>
                <td class="right mono">${fmt(r.tp2, 6)}</td>
            `;
            tb.appendChild(tr);
        });

        if (rows.length === 0) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td colspan="16" class="muted">조건을 만족하는 후보가 없습니다. (Top N/거래대금/기준값을 완화해보세요)</td>`;
            tb.appendChild(tr);
        }
    }

    async function scanOnce() {
        const cfg = {
            base: $("baseUrl").value.trim(),
            topN: clamp(toNum($("topN").value), 10, 200),
            minQuoteVol: Math.max(0, toNum($("minQuoteVol").value)),
            concurrency: clamp(toNum($("concurrency").value), 1, 20),
            boxLookback: clamp(toNum($("boxLookback").value), 10, 100),
            squeezeLookback: clamp(toNum($("squeezeLookback").value), 60, 300),
            bbPeriod: clamp(toNum($("bbPeriod").value), 10, 50),
            atrPeriod: clamp(toNum($("atrPeriod").value), 7, 50),
            nearPct: clamp(toNum($("nearPct").value), 0.05, 1.0),
            fundingMaxPct: clamp(toNum($("fundingMaxPct").value), 0, 0.5),
            oiMinPct: clamp(toNum($("oiMinPct").value), 0, 30),
            takerMin: clamp(toNum($("takerMin").value), 1.0, 3.0)
        };

        try {
            setPill("pillState", "RUNNING", "warn");
            logLine("scan started...");

            if (!state.exchangeSymbols.length) {
                await loadExchangeInfo();
            }

            const tickers = await loadTickers24h();
            const tickerMap = new Map();
            for (const t of tickers) tickerMap.set(String(t.symbol || ""), t);

            // USDT PERP + 거래대금 필터 후 상위 TopN만
            const candidates = state.exchangeSymbols
                .map(s => String(s.symbol || ""))
                .filter(sym => tickerMap.has(sym))
                .map(sym => ({ sym, qv: toNum(tickerMap.get(sym).quoteVolume) }))
                .filter(x => x.qv >= cfg.minQuoteVol)
                .sort((a, b) => b.qv - a.qv)
                .slice(0, cfg.topN)
                .map(x => x.sym);

            logLine(`candidates: ${candidates.length} (TopN=${cfg.topN}, minVol=${fmt0(cfg.minQuoteVol)})`);

            const results = await poolMap(candidates, async (sym) => {
                return await analyzeSymbol(sym, tickerMap, cfg);
            }, cfg.concurrency);

            const rows = results
                .filter(x => x && !x.__error)
                .filter(Boolean)
                .sort((a, b) => b.score - a.score)
                .slice(0, 40);

            renderRows(rows);

            const now = new Date();
            state.lastScanAt = now;
            setPill("pillLast", `Last: ${now.toLocaleTimeString("ko-KR", { hour12: false })}`, "good");
            logLine(`scan done. hits=${rows.length}`);
        } catch (e) {
            logLine(`scan failed: ${e.message}`);
            setPill("pillState", "ERROR", "bad");
        } finally {
            if (!state.running) {
                setPill("pillState", "STOPPED", "");
            }
        }
    }

    function scheduleNext() {
        if (!state.running) return;

        const wait = msToNextQuarter(3500);
        const next = new Date(Date.now() + wait);
        logLine(`next scheduled: ${next.toLocaleTimeString("ko-KR", { hour12: false })}`);

        if (state.timer) clearTimeout(state.timer);
        state.timer = setTimeout(async () => {
            if (!state.running) return;
            await scanOnce();
            scheduleNext();
        }, wait);
    }

    function start() {
        if (state.running) return;
        state.running = true;
        setPill("pillState", "RUNNING", "warn");
        startCountdown();
        scheduleNext();
        logLine("auto mode ON (00/15/30/45)");
    }

    function stop() {
        state.running = false;
        if (state.timer) clearTimeout(state.timer);
        state.timer = null;
        setPill("pillState", "STOPPED", "");
        logLine("auto mode OFF");
    }

    $("btnStart").addEventListener("click", start);
    $("btnStop").addEventListener("click", stop);
    $("btnScanNow").addEventListener("click", async () => {
        await scanOnce();
    });

    // 첫 로딩 때 기본 정보 로드(느리면 버튼 눌렀을 때 로드해도 됨)
    (async () => {
        try {
            await loadExchangeInfo();
            setPill("pillState", "READY", "good");
        } catch (e) {
            logLine(`init failed: ${e.message}`);
            setPill("pillState", "READY (load fail)", "warn");
        }
        startCountdown();
    })();
</script>
</body>
</html>
