<!doctype html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — 현재까지 이어지는 횡보(롱 반복형) 스캐너</title>
        <style>
            :root {
                --bg: #0b1020;
                --panel: rgba(255, 255, 255, 0.06);
                --text: rgba(255, 255, 255, 0.92);
                --muted: rgba(255, 255, 255, 0.65);
                --line: rgba(255, 255, 255, 0.12);
                --good: #7ee787;
                --bad: #ff7b72;
                --warn: #ffa657;
                --btn: rgba(255, 255, 255, 0.10);
                --btnHover: rgba(255, 255, 255, 0.16);
                --shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
                --radius: 14px;
            }

            * { box-sizing: border-box; }
            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, sans-serif;
                color: var(--text);
                background:
                    radial-gradient(1000px 600px at 10% 0%, rgba(99, 102, 241, 0.20), transparent 60%),
                    radial-gradient(1000px 700px at 90% 10%, rgba(16, 185, 129, 0.12), transparent 60%),
                    radial-gradient(900px 600px at 50% 100%, rgba(244, 63, 94, 0.10), transparent 60%),
                    var(--bg);
            }

            .wrap {
                max-width: 1420px;
                margin: 0 auto;
                padding: 22px 16px 40px;
            }

            header {
                display: flex;
                flex-wrap: wrap;
                align-items: flex-end;
                justify-content: space-between;
                gap: 12px;
                margin-bottom: 14px;
            }

            h1 {
                font-size: 20px;
                margin: 0;
                letter-spacing: -0.3px;
            }

            .sub {
                font-size: 12px;
                color: var(--muted);
                margin-top: 6px;
                line-height: 1.55;
            }

            .grid {
                display: grid;
                grid-template-columns: 1.2fr 0.8fr;
                gap: 14px;
                align-items: start;
            }

            @media (max-width: 980px) {
                .grid { grid-template-columns: 1fr; }
            }

            .card {
                background: var(--panel);
                border: 1px solid var(--line);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                overflow: hidden;
            }

            .cardHead {
                padding: 14px 14px 10px;
                border-bottom: 1px solid var(--line);
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }

            .cardTitle {
                font-weight: 650;
                font-size: 13px;
                color: rgba(255, 255, 255, 0.88);
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .badge {
                font-size: 11px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: var(--muted);
            }

            .tag {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 11px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: rgba(255, 255, 255, 0.86);
                white-space: nowrap;
            }

            .tagNow {
                border-color: rgba(126, 231, 135, 0.45);
                background: rgba(126, 231, 135, 0.16);
                color: var(--good);
                font-weight: 700;
            }

            .tagWait {
                border-color: rgba(255, 166, 87, 0.40);
                background: rgba(255, 166, 87, 0.14);
                color: var(--warn);
                font-weight: 700;
            }

            .cardBody { padding: 14px; }

            .controls {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }

            @media (max-width: 980px) {
                .controls { grid-template-columns: repeat(2, 1fr); }
            }

            .field label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin: 0 0 6px;
            }

            select, input[type="number"], input[type="text"] {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.25);
                color: var(--text);
                outline: none;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-top: 12px;
                align-items: center;
            }

            .btn {
                appearance: none;
                border: 1px solid var(--line);
                background: var(--btn);
                color: var(--text);
                border-radius: 12px;
                padding: 10px 12px;
                font-weight: 650;
                cursor: pointer;
                transition: 140ms ease;
            }

            .btn:hover { background: var(--btnHover); }
            .btn:disabled { opacity: 0.55; cursor: not-allowed; }

            .btnPrimary {
                border-color: rgba(16, 185, 129, 0.35);
                background: rgba(16, 185, 129, 0.14);
            }
            .btnPrimary:hover { background: rgba(16, 185, 129, 0.20); }

            .btnDanger {
                border-color: rgba(244, 63, 94, 0.38);
                background: rgba(244, 63, 94, 0.14);
            }
            .btnDanger:hover { background: rgba(244, 63, 94, 0.20); }

            .switch {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                font-size: 12px;
                color: var(--muted);
                user-select: none;
            }

            .switch input { width: 18px; height: 18px; }

            .progressBox {
                margin-top: 12px;
                padding: 12px;
                border: 1px solid var(--line);
                border-radius: 12px;
                background: rgba(0, 0, 0, 0.18);
            }

            .progressTop {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
                margin-bottom: 8px;
            }

            .mono {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }

            .bar {
                height: 10px;
                border-radius: 999px;
                overflow: hidden;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid var(--line);
            }

            .bar > div {
                height: 100%;
                width: 0%;
                background: linear-gradient(90deg, rgba(16, 185, 129, 0.9), rgba(99, 102, 241, 0.9));
                transition: width 120ms ease;
            }

            .smallGrid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 3px 9px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: rgba(255, 255, 255, 0.86);
                font-size: 12px;
                white-space: nowrap;
            }

            .good { color: var(--good); }
            .bad { color: var(--bad); }
            .warn { color: var(--warn); }
            .muted { color: var(--muted); }
            .right { text-align: right; }

            .kv {
                display: grid;
                grid-template-columns: 130px 1fr;
                gap: 10px;
                align-items: center;
                font-size: 12px;
                color: var(--muted);
                margin-top: 8px;
            }

            .kv b {
                color: rgba(255, 255, 255, 0.82);
                font-weight: 700;
            }

            .log {
                height: 220px;
                overflow: auto;
                padding: 10px;
                border-radius: 12px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.22);
                font-size: 12px;
                color: rgba(255, 255, 255, 0.80);
                line-height: 1.5;
                white-space: pre-wrap;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                background: rgba(10, 14, 28, 0.85);
                backdrop-filter: blur(6px);
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                text-align: left;
                color: rgba(255, 255, 255, 0.82);
                font-weight: 700;
                white-space: nowrap;
            }

            tbody td {
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                padding: 9px 10px;
                vertical-align: middle;
                white-space: nowrap;
            }

            tbody tr:hover { background: rgba(255, 255, 255, 0.04); }

            .cellNow {
                color: var(--good);
                font-weight: 800;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <header>
                <div>
                    <h1>바이낸스 USDT 무기한 — “현재까지 이어지는 횡보” 스캐너</h1>
                    <div class="sub">
                        최근 <b>X일</b> 윈도우 안에서, <b>마지막 캔들(현재)까지 이어지는 횡보 구간</b>을 심볼별로 1개씩 찾습니다.<br />
                        정렬: <b>현재까지 이어지는 횡보 길이(바 수)</b> 긴 순 → (동률이면) <b>폭 좁은 순</b>.<br />
                        <b>Entry Mode</b>: <span class="tag tagNow">NOW</span> = 현재가가 Entry Zone 안(Entry Suggested = Now), <span class="tag tagWait">WAIT</span> = Entry Line까지 대기.
                    </div>
                </div>
                <div class="pill mono">API: fapi.binance.com</div>
            </header>

            <div class="grid">
                <section class="card">
                    <div class="cardHead">
                        <div class="cardTitle">
                            설정
                            <span class="badge">기본값: 15m 추천</span>
                        </div>
                        <div class="badge mono" id="statusBadge">IDLE</div>
                    </div>
                    <div class="cardBody">
                        <div class="controls">
                            <div class="field">
                                <label>타임프레임</label>
                                <select id="tfSelect">
                                    <option value="15m" selected>15m</option>
                                    <option value="1h">1h</option>
                                    <option value="4h">4h</option>
                                    <option value="1d">1d</option>
                                </select>
                            </div>

                            <div class="field">
                                <label>최근 X일</label>
                                <input id="daysInput" type="number" min="1" max="365" step="1" value="14" />
                            </div>

                            <div class="field">
                                <label>Band (폭% ≤)</label>
                                <input id="bandInput" type="number" min="0.5" max="60" step="0.1" value="10.0" />
                            </div>

                            <div class="field">
                                <label>Drift (시작~현재% ≤)</label>
                                <input id="driftInput" type="number" min="0.1" max="60" step="0.1" value="6.0" />
                            </div>

                            <div class="field">
                                <label>Entry (하단% ≤)</label>
                                <input id="entryZoneInput" type="number" min="5" max="45" step="1" value="30" />
                            </div>

                            <div class="field">
                                <label>Target (상단% ≥)</label>
                                <input id="targetZoneInput" type="number" min="50" max="95" step="1" value="67" />
                            </div>

                            <div class="field">
                                <label>Stop Buffer(저점 아래 %)</label>
                                <input id="stopBufInput" type="number" min="0.0" max="12" step="0.1" value="1.8" />
                            </div>

                            <div class="field">
                                <label>Min Range (폭% ≥)</label>
                                <input id="minRangeInput" type="number" min="0.0" max="60" step="0.1" value="0.9" />
                            </div>

                            <div class="field">
                                <label>최소 Bounce(N)</label>
                                <input id="minBouncesInput" type="number" min="0" max="50" step="1" value="2" />
                            </div>

                            <div class="field">
                                <label>표시 Top N</label>
                                <input id="topInput" type="number" min="10" max="500" step="10" value="150" />
                            </div>

                            <div class="field">
                                <label>동시 요청(concurrency)</label>
                                <input id="concInput" type="number" min="1" max="12" step="1" value="4" />
                            </div>

                            <div class="field">
                                <label>요청 간 딜레이(ms)</label>
                                <input id="delayInput" type="number" min="0" max="2000" step="10" value="220" />
                            </div>

                            <div class="field">
                                <label>검색(심볼)</label>
                                <input id="searchInput" type="text" placeholder="예: BTC, ETH, SOL..." />
                            </div>
                        </div>

                        <div class="row">
                            <label class="switch">
                                <input id="wicksToggle" type="checkbox" />
                                레인지 계산에 윅 포함(고/저) — 더 보수적
                            </label>

                            <label class="switch">
                                <input id="bounceFilterToggle" type="checkbox" checked />
                                Bounce 조건 적용 (롱 반복성 필터)
                            </label>

                            <label class="switch">
                                <input id="liveToggle" type="checkbox" checked />
                                실시간 표 갱신
                            </label>
                        </div>

                        <div class="row">
                            <button class="btn btnPrimary" id="startBtn">스캔 시작</button>
                            <button class="btn btnDanger" id="stopBtn" disabled>중지</button>
                            <button class="btn" id="clearBtn">초기화</button>
                            <button class="btn" id="exportBtn" disabled>CSV 내보내기</button>
                        </div>

                        <div class="progressBox">
                            <div class="progressTop">
                                <div class="mono" id="progressText">대기 중</div>
                                <div class="mono muted" id="progressMeta">0 / 0</div>
                            </div>
                            <div class="bar"><div id="progressBar"></div></div>

                            <div class="kv">
                                <b>윈도우 바 수</b>
                                <span class="mono muted" id="barsInfo">-</span>

                                <b>횡보 판정</b>
                                <span class="mono muted" id="ruleText">-</span>

                                <b>Entry Mode</b>
                                <span class="muted">
                                    <span class="tag tagNow">NOW</span>면 Entry Suggested가 “Now(최근 종가)”로 표시됩니다.
                                </span>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="card">
                    <div class="cardHead">
                        <div class="cardTitle">
                            로그 / 상태
                            <span class="badge">429 자동 백오프</span>
                        </div>
                        <div class="badge mono" id="elapsedText">00:00</div>
                    </div>
                    <div class="cardBody">
                        <div class="smallGrid">
                            <div class="pill">
                                <span class="muted">심볼</span>
                                <span class="mono" id="symCount">-</span>
                            </div>
                            <div class="pill">
                                <span class="muted">성공</span>
                                <span class="mono good" id="okCount">0</span>
                            </div>
                            <div class="pill">
                                <span class="muted">실패</span>
                                <span class="mono bad" id="errCount">0</span>
                            </div>
                            <div class="pill">
                                <span class="muted">결과</span>
                                <span class="mono" id="resCount">0</span>
                            </div>
                        </div>

                        <div style="height: 10px;"></div>
                        <div class="log mono" id="logBox"></div>
                    </div>
                </section>
            </div>

            <div style="height: 14px;"></div>

            <section class="card">
                <div class="cardHead">
                    <div class="cardTitle">
                        결과 (현재까지 이어지는 횡보 길이 순)
                        <span class="badge">Len ↓ / 폭 ↑</span>
                    </div>
                    <div class="badge mono" id="renderInfo">-</div>
                </div>
                <div class="cardBody" style="padding: 0;">
                    <div style="overflow: auto; max-height: 720px;">
                        <table>
                            <thead>
                                <tr>
                                    <th class="right">#</th>
                                    <th>Symbol</th>
                                    <th class="right">Len(bars)</th>
                                    <th class="right">Len(시간)</th>
                                    <th class="right">폭%</th>
                                    <th class="right">Drift%</th>
                                    <th class="right">Bounce</th>
                                    <th class="right">Now(종가)</th>
                                    <th class="right">Pos%</th>
                                    <th>Entry Mode</th>
                                    <th class="right">Entry Sug</th>
                                    <th class="right">Entry Line</th>
                                    <th class="right">Target</th>
                                    <th class="right">Stop</th>
                                    <th class="right">Low</th>
                                    <th class="right">High</th>
                                    <th>시작(서울)</th>
                                </tr>
                            </thead>
                            <tbody id="tbody">
                                <tr>
                                    <td colspan="17" class="muted" style="padding: 14px;">
                                        아직 결과가 없습니다. “스캔 시작”을 눌러주세요.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </div>

        <script>
            "use strict";

            const BASE_URL = "https://fapi.binance.com";
            const PAGE_LIMIT = 499;

            const els = {
                statusBadge: document.getElementById("statusBadge"),
                elapsedText: document.getElementById("elapsedText"),

                tfSelect: document.getElementById("tfSelect"),
                daysInput: document.getElementById("daysInput"),
                bandInput: document.getElementById("bandInput"),
                driftInput: document.getElementById("driftInput"),
                entryZoneInput: document.getElementById("entryZoneInput"),
                targetZoneInput: document.getElementById("targetZoneInput"),
                stopBufInput: document.getElementById("stopBufInput"),
                minRangeInput: document.getElementById("minRangeInput"),
                minBouncesInput: document.getElementById("minBouncesInput"),
                topInput: document.getElementById("topInput"),
                concInput: document.getElementById("concInput"),
                delayInput: document.getElementById("delayInput"),
                searchInput: document.getElementById("searchInput"),

                wicksToggle: document.getElementById("wicksToggle"),
                bounceFilterToggle: document.getElementById("bounceFilterToggle"),
                liveToggle: document.getElementById("liveToggle"),

                startBtn: document.getElementById("startBtn"),
                stopBtn: document.getElementById("stopBtn"),
                clearBtn: document.getElementById("clearBtn"),
                exportBtn: document.getElementById("exportBtn"),

                progressText: document.getElementById("progressText"),
                progressMeta: document.getElementById("progressMeta"),
                progressBar: document.getElementById("progressBar"),
                barsInfo: document.getElementById("barsInfo"),
                ruleText: document.getElementById("ruleText"),

                symCount: document.getElementById("symCount"),
                okCount: document.getElementById("okCount"),
                errCount: document.getElementById("errCount"),
                resCount: document.getElementById("resCount"),

                logBox: document.getElementById("logBox"),
                renderInfo: document.getElementById("renderInfo"),
                tbody: document.getElementById("tbody")
            };

            const state = {
                isRunning: false,
                abortController: null,
                startedAt: 0,
                tickTimer: null,

                symbols: [],
                queue: [],
                ok: 0,
                err: 0,
                done: 0,

                results: []
            };

            function logLine(msg, type = "info") {
                const ts = new Date().toLocaleTimeString("ko-KR", { hour12: false });
                const prefix = type === "err" ? "[ERR]" : (type === "warn" ? "[WARN]" : "[LOG]");
                els.logBox.textContent += `${ts} ${prefix} ${msg}\n`;
                els.logBox.scrollTop = els.logBox.scrollHeight;
            }

            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            function clampNum(n, min, max, fallback) {
                const x = Number(n);
                if (!Number.isFinite(x)) return fallback;
                return Math.min(max, Math.max(min, x));
            }

            function intervalToMs(interval) {
                const m = String(interval).match(/^(\d+)([mhdwM])$/);
                if (!m) return null;
                const num = Number(m[1]);
                const unit = m[2];

                if (unit === "m") return num * 60 * 1000;
                if (unit === "h") return num * 60 * 60 * 1000;
                if (unit === "d") return num * 24 * 60 * 60 * 1000;
                if (unit === "w") return num * 7 * 24 * 60 * 60 * 1000;
                if (unit === "M") return num * 30 * 24 * 60 * 60 * 1000;
                return null;
            }

            function calcBarsNeeded(days, interval) {
                const ms = intervalToMs(interval);
                if (!ms) return 0;
                const dayMs = 24 * 60 * 60 * 1000;
                return Math.ceil((days * dayMs) / ms);
            }

            function fmtDuration(bars, interval) {
                const ms = intervalToMs(interval);
                if (!ms) return "-";
                const totalMin = Math.floor((bars * ms) / 60000);

                const days = Math.floor(totalMin / (60 * 24));
                const hours = Math.floor((totalMin - days * 60 * 24) / 60);
                const mins = totalMin % 60;

                if (days > 0) return `${days}d ${hours}h`;
                if (hours > 0) return `${hours}h ${mins}m`;
                return `${mins}m`;
            }

            function toSeoul(ts) {
                try {
                    return new Date(ts).toLocaleString("ko-KR", { timeZone: "Asia/Seoul", hour12: false });
                } catch (_) {
                    return new Date(ts).toISOString().replace(".000Z", "Z");
                }
            }

            function widthPct(minVal, maxVal) {
                const mid = (minVal + maxVal) / 2;
                if (!Number.isFinite(mid) || mid === 0) return Infinity;
                return ((maxVal - minVal) / mid) * 100;
            }

            function clamp(x, min, max) {
                return Math.min(max, Math.max(min, x));
            }

            async function fetchJsonWithBackoff(url, signal, maxRetries = 6) {
                let attempt = 0;

                while (true) {
                    attempt += 1;

                    let res;
                    try {
                        res = await fetch(url, { method: "GET", headers: { "accept": "application/json" }, signal });
                    } catch (e) {
                        if (signal && signal.aborted) {
                            throw new Error("aborted");
                        }
                        throw e;
                    }

                    if (res.ok) {
                        return res.json();
                    }

                    const status = res.status;
                    const retryAfterHeader = res.headers.get("retry-after");
                    const retryAfterSec = retryAfterHeader ? Number(retryAfterHeader) : NaN;

                    let bodyText = "";
                    try {
                        bodyText = await res.text();
                    } catch (_) {
                        bodyText = "";
                    }

                    const isRate = (status === 429 || status === 418);
                    if (isRate && attempt <= maxRetries) {
                        let waitSec = retryAfterSec;
                        if (!Number.isFinite(waitSec) || waitSec <= 0) {
                            waitSec = Math.min(60, Math.pow(1.8, attempt));
                        }
                        logLine(`${status} 레이트리밋 → ${waitSec.toFixed(1)}s 백오프`, "warn");
                        await sleep(Math.floor(waitSec * 1000));
                        continue;
                    }

                    throw new Error(`HTTP ${status} :: ${bodyText.slice(0, 240)}`);
                }
            }

            async function getUsdtPerpSymbols(signal) {
                const url = `${BASE_URL}/fapi/v1/exchangeInfo`;
                const data = await fetchJsonWithBackoff(url, signal);

                const list = Array.isArray(data?.symbols) ? data.symbols : [];
                const syms = list
                    .filter((s) => {
                        if (!s) return false;
                        if (s.contractType !== "PERPETUAL") return false;
                        if (s.quoteAsset !== "USDT") return false;
                        if (s.status !== "TRADING") return false;
                        return true;
                    })
                    .map((s) => s.symbol);

                return Array.from(new Set(syms));
            }

            async function getKlinesPage(symbol, interval, limit, endTime, signal) {
                const qs = new URLSearchParams({
                    symbol,
                    interval,
                    limit: String(limit)
                });
                if (Number.isFinite(endTime) && endTime > 0) {
                    qs.set("endTime", String(Math.floor(endTime)));
                }
                const url = `${BASE_URL}/fapi/v1/klines?${qs.toString()}`;
                return fetchJsonWithBackoff(url, signal);
            }

            async function fetchKlinesWindow(symbol, interval, barsNeeded, signal) {
                const maxPages = Math.min(12, Math.max(1, Math.ceil(barsNeeded / PAGE_LIMIT)));
                const want = Math.min(barsNeeded, maxPages * PAGE_LIMIT);

                let endTime = Date.now();
                let all = [];
                let pages = 0;

                while (all.length < want && pages < maxPages) {
                    pages += 1;

                    const remaining = want - all.length;
                    const limit = Math.min(PAGE_LIMIT, remaining);

                    const batch = await getKlinesPage(symbol, interval, limit, endTime, signal);
                    if (!Array.isArray(batch) || batch.length === 0) break;

                    all = batch.concat(all);

                    const firstOpen = Number(batch[0]?.[0]);
                    if (!Number.isFinite(firstOpen)) break;

                    endTime = firstOpen - 1;
                }

                if (all.length > want) {
                    all = all.slice(all.length - want);
                }

                return {
                    candles: all,
                    effectiveBars: all.length,
                    pagesUsed: pages,
                    maxPages
                };
            }

            function countBouncesInSegment(klines, segStartIdx, rangeLow, rangeHigh, cfg) {
                const n = klines.length;
                const last = n - 1;

                if (segStartIdx >= last) return 0;

                const rangeAbs = rangeHigh - rangeLow;
                if (!(rangeAbs > 0)) return 0;

                const entryUpper = rangeLow + rangeAbs * (cfg.entryZonePct / 100);
                const targetLevel = rangeLow + rangeAbs * (cfg.targetZonePct / 100);
                const stopLevel = rangeLow * (1 - cfg.stopBufferPct / 100);

                const minProfitPct = cfg.minProfitPct;

                let bounces = 0;
                let i = segStartIdx;

                while (i < n) {
                    // Entry trigger: close <= entryUpper
                    while (i < n) {
                        const close = Number(klines[i][4]);
                        if (Number.isFinite(close) && close <= entryUpper) break;
                        i += 1;
                    }
                    if (i >= n) break;

                    const entryPrice = Number(klines[i][4]);
                    let j = i + 1;
                    let succeeded = false;

                    while (j < n) {
                        const high = Number(klines[j][2]);
                        const low = Number(klines[j][3]);
                        const close = Number(klines[j][4]);

                        if (cfg.useWicks) {
                            if (Number.isFinite(low) && low < stopLevel) break;
                            if (Number.isFinite(high) && high >= targetLevel) {
                                succeeded = true;
                                break;
                            }
                        } else {
                            if (Number.isFinite(close) && close < stopLevel) break;
                            if (Number.isFinite(close) && close >= targetLevel) {
                                succeeded = true;
                                break;
                            }
                        }
                        j += 1;
                    }

                    if (succeeded) {
                        const profitPct = (Number.isFinite(entryPrice) && entryPrice > 0)
                            ? ((targetLevel - entryPrice) / entryPrice) * 100
                            : 0;

                        if (profitPct >= minProfitPct) {
                            bounces += 1;
                        }
                        i = j + 1;
                    } else {
                        i = j + 1;
                    }
                }

                return bounces;
            }

            function findOngoingRangeSegment(klines, cfg) {
                const n = klines.length;
                if (n < 50) return null;

                const times = new Array(n);
                const closes = new Array(n);
                const highs = new Array(n);
                const lows = new Array(n);

                for (let i = 0; i < n; i += 1) {
                    const k = klines[i];
                    times[i] = Number(k[0]);
                    highs[i] = Number(k[2]);
                    lows[i] = Number(k[3]);
                    closes[i] = Number(k[4]);
                }

                const useMin = (idx) => (cfg.useWicks ? lows[idx] : closes[idx]);
                const useMax = (idx) => (cfg.useWicks ? highs[idx] : closes[idx]);

                const sufMin = new Array(n);
                const sufMax = new Array(n);

                sufMin[n - 1] = useMin(n - 1);
                sufMax[n - 1] = useMax(n - 1);

                for (let i = n - 2; i >= 0; i -= 1) {
                    const vMin = useMin(i);
                    const vMax = useMax(i);
                    sufMin[i] = Math.min(sufMin[i + 1], vMin);
                    sufMax[i] = Math.max(sufMax[i + 1], vMax);
                }

                const lastClose = closes[n - 1];

                const candidateIdx = [];
                for (let i = 0; i < n - 1; i += 1) {
                    const rangeLow = sufMin[i];
                    const rangeHigh = sufMax[i];

                    if (!Number.isFinite(rangeLow) || !Number.isFinite(rangeHigh) || rangeLow <= 0 || rangeHigh <= 0) {
                        continue;
                    }

                    const w = widthPct(rangeLow, rangeHigh);
                    if (!(w <= cfg.bandPct)) continue;
                    if (!(w >= cfg.minRangePct)) continue;

                    const startClose = closes[i];
                    const drift = (Number.isFinite(startClose) && startClose > 0)
                        ? (Math.abs(lastClose - startClose) / startClose) * 100
                        : Infinity;

                    if (!(drift <= cfg.driftMaxPct)) continue;

                    candidateIdx.push(i);
                }

                if (candidateIdx.length === 0) return null;

                const K = cfg.bounceFilterEnabled ? 50 : 1;
                const limit = Math.min(K, candidateIdx.length);

                for (let c = 0; c < limit; c += 1) {
                    const i = candidateIdx[c];
                    const rangeLow = sufMin[i];
                    const rangeHigh = sufMax[i];

                    const w = widthPct(rangeLow, rangeHigh);
                    const startClose = closes[i];
                    const drift = (Number.isFinite(startClose) && startClose > 0)
                        ? (Math.abs(lastClose - startClose) / startClose) * 100
                        : Infinity;

                    const rangeAbs = rangeHigh - rangeLow;
                    if (!(rangeAbs > 0)) continue;

                    const entryLine = rangeLow + rangeAbs * (cfg.entryZonePct / 100);
                    const targetLevel = rangeLow + rangeAbs * (cfg.targetZonePct / 100);
                    const stopLevel = rangeLow * (1 - cfg.stopBufferPct / 100);

                    const posPct = clamp(((lastClose - rangeLow) / rangeAbs) * 100, 0, 100);

                    let bounces = 0;
                    if (cfg.bounceFilterEnabled || cfg.alwaysComputeBounce) {
                        bounces = countBouncesInSegment(klines, i, rangeLow, rangeHigh, cfg);
                    }

                    if (!cfg.bounceFilterEnabled || bounces >= cfg.minBounces) {
                        const nowInEntryZone = (Number.isFinite(lastClose) && lastClose <= entryLine);
                        const entryMode = nowInEntryZone ? "NOW" : "WAIT";
                        const entrySuggested = nowInEntryZone ? lastClose : entryLine;

                        return {
                            startIndex: i,
                            startTime: times[i],
                            lenBars: n - i,
                            widthPct: w,
                            driftPct: drift,
                            bounces,
                            rangeLow,
                            rangeHigh,
                            lastClose,
                            posPct,
                            entryMode,
                            nowInEntryZone,
                            entrySuggested,
                            entryLine,
                            targetLevel,
                            stopLevel
                        };
                    }
                }

                return null;
            }

            function setRunningUI(running) {
                els.startBtn.disabled = running;
                els.stopBtn.disabled = !running;
                els.exportBtn.disabled = running || state.results.length === 0;
                els.statusBadge.textContent = running ? "RUNNING" : "IDLE";
            }

            function updateCountersUI() {
                els.symCount.textContent = state.symbols.length ? String(state.symbols.length) : "-";
                els.okCount.textContent = String(state.ok);
                els.errCount.textContent = String(state.err);
                els.resCount.textContent = String(state.results.length);
            }

            function updateProgressUI() {
                const total = state.symbols.length || 0;
                const done = state.done || 0;
                const pct = total > 0 ? Math.min(100, (done / total) * 100) : 0;

                els.progressMeta.textContent = `${done} / ${total}`;
                els.progressBar.style.width = `${pct.toFixed(2)}%`;
                els.progressText.textContent = state.isRunning ? `스캔 중... (${pct.toFixed(1)}%)` : "대기 중";
            }

            function tickElapsed() {
                const sec = Math.floor((Date.now() - state.startedAt) / 1000);
                const mm = String(Math.floor(sec / 60)).padStart(2, "0");
                const ss = String(sec % 60).padStart(2, "0");
                els.elapsedText.textContent = `${mm}:${ss}`;
            }

            function getConfig() {
                const interval = els.tfSelect.value;
                const days = Math.floor(clampNum(els.daysInput.value, 1, 365, 14));

                const bandPct = clampNum(els.bandInput.value, 0.5, 60, 10.0);
                const driftMaxPct = clampNum(els.driftInput.value, 0.1, 60, 6.0);

                const entryZonePct = Math.floor(clampNum(els.entryZoneInput.value, 5, 45, 30));
                const targetZonePct = Math.floor(clampNum(els.targetZoneInput.value, 50, 95, 67));

                const stopBufferPct = clampNum(els.stopBufInput.value, 0.0, 12, 1.8);
                const minRangePct = clampNum(els.minRangeInput.value, 0.0, 60, 0.9);

                const minBounces = Math.floor(clampNum(els.minBouncesInput.value, 0, 50, 2));
                const topN = Math.floor(clampNum(els.topInput.value, 10, 500, 150));

                const concurrency = Math.floor(clampNum(els.concInput.value, 1, 12, 4));
                const delayMs = Math.floor(clampNum(els.delayInput.value, 0, 2000, 220));

                const useWicks = !!els.wicksToggle.checked;
                const bounceFilterEnabled = !!els.bounceFilterToggle.checked;
                const liveRender = !!els.liveToggle.checked;

                const minProfitPct = 0.3;
                const alwaysComputeBounce = true;

                const barsNeeded = calcBarsNeeded(days, interval);
                const pagesNeeded = Math.min(12, Math.max(1, Math.ceil(barsNeeded / PAGE_LIMIT)));

                els.barsInfo.textContent = `${barsNeeded} bars (auto pages=${pagesNeeded})`;
                els.ruleText.textContent =
                    `윈도우=${days}d · 폭 ${minRangePct}~${bandPct}% · drift≤${driftMaxPct}% · entry≤${entryZonePct}% · target≥${targetZonePct}% · stop=${stopBufferPct}% · bounce≥${minBounces}${bounceFilterEnabled ? "" : " (OFF)"}`;

                return {
                    interval,
                    days,
                    barsNeeded,
                    bandPct,
                    driftMaxPct,
                    entryZonePct,
                    targetZonePct,
                    stopBufferPct,
                    minRangePct,
                    minBounces,
                    topN,
                    concurrency,
                    delayMs,
                    useWicks,
                    bounceFilterEnabled,
                    liveRender,
                    minProfitPct,
                    alwaysComputeBounce
                };
            }

            function sortResults(arr) {
                const out = arr.slice();
                out.sort((a, b) => {
                    if (b.lenBars !== a.lenBars) return b.lenBars - a.lenBars;
                    if (a.widthPct !== b.widthPct) return a.widthPct - b.widthPct;
                    if (a.driftPct !== b.driftPct) return a.driftPct - b.driftPct;
                    if (b.bounces !== a.bounces) return b.bounces - a.bounces;
                    return a.symbol.localeCompare(b.symbol);
                });
                return out;
            }

            function filterResults(arr, q) {
                const query = String(q || "").trim().toUpperCase();
                if (!query) return arr;
                return arr.filter((r) => r.symbol.includes(query));
            }

            function renderTable() {
                const cfg = getConfig();
                const sorted = sortResults(state.results);
                const filtered = filterResults(sorted, els.searchInput.value);
                const view = filtered.slice(0, cfg.topN);

                els.renderInfo.textContent = `표시 ${view.length} / 필터 ${filtered.length} / 전체 ${state.results.length}`;

                if (view.length === 0) {
                    els.tbody.innerHTML = `
                        <tr>
                            <td colspan="17" class="muted" style="padding: 14px;">
                                결과가 없습니다. (Band/Drift 완화, Bounce 조건 OFF, 또는 15m에서 wicks OFF 유지 권장)
                            </td>
                        </tr>
                    `;
                    return;
                }

                let html = "";
                for (let i = 0; i < view.length; i += 1) {
                    const r = view[i];
                    const modeTag = r.entryMode === "NOW"
                        ? `<span class="tag tagNow">NOW</span>`
                        : `<span class="tag tagWait">WAIT</span>`;

                    const entrySugClass = r.entryMode === "NOW" ? "cellNow" : "";

                    html += `
                        <tr>
                            <td class="right mono muted">${i + 1}</td>
                            <td class="mono"><b>${r.symbol}</b></td>
                            <td class="right mono">${r.lenBars}</td>
                            <td class="right mono muted">${fmtDuration(r.lenBars, cfg.interval)}</td>
                            <td class="right mono">${r.widthPct.toFixed(3)}</td>
                            <td class="right mono muted">${r.driftPct.toFixed(3)}</td>
                            <td class="right mono">${r.bounces}</td>
                            <td class="right mono">${r.lastClose.toFixed(6)}</td>
                            <td class="right mono muted">${r.posPct.toFixed(1)}</td>
                            <td>${modeTag}</td>
                            <td class="right mono ${entrySugClass}">${r.entrySuggested.toFixed(6)}</td>
                            <td class="right mono muted">${r.entryLine.toFixed(6)}</td>
                            <td class="right mono muted">${r.targetLevel.toFixed(6)}</td>
                            <td class="right mono muted">${r.stopLevel.toFixed(6)}</td>
                            <td class="right mono">${r.rangeLow.toFixed(6)}</td>
                            <td class="right mono">${r.rangeHigh.toFixed(6)}</td>
                            <td class="mono muted">${toSeoul(r.startTime)}</td>
                        </tr>
                    `;
                }

                els.tbody.innerHTML = html;
            }

            function toCsv(rows, interval) {
                const header = [
                    "symbol",
                    "lenBars",
                    "lenDuration",
                    "widthPct",
                    "driftPct",
                    "bounces",
                    "lastClose",
                    "posPct",
                    "entryMode",
                    "entrySuggested",
                    "entryLine",
                    "targetLevel",
                    "stopLevel",
                    "rangeLow",
                    "rangeHigh",
                    "rangeStartSeoul"
                ];
                const lines = [header.join(",")];

                for (const r of rows) {
                    const line = [
                        r.symbol,
                        r.lenBars,
                        `"${fmtDuration(r.lenBars, interval)}"`,
                        r.widthPct.toFixed(6),
                        r.driftPct.toFixed(6),
                        r.bounces,
                        r.lastClose,
                        r.posPct.toFixed(3),
                        `"${r.entryMode}"`,
                        r.entrySuggested,
                        r.entryLine,
                        r.targetLevel,
                        r.stopLevel,
                        r.rangeLow,
                        r.rangeHigh,
                        `"${toSeoul(r.startTime)}"`
                    ].join(",");
                    lines.push(line);
                }

                return lines.join("\n");
            }

            function downloadText(filename, text) {
                const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            }

            async function workerLoop(cfg) {
                const signal = state.abortController.signal;

                while (state.queue.length > 0 && state.isRunning) {
                    if (signal.aborted) break;

                    const symbol = state.queue.shift();
                    if (!symbol) continue;

                    try {
                        if (cfg.delayMs > 0) {
                            await sleep(cfg.delayMs);
                        }

                        const data = await fetchKlinesWindow(symbol, cfg.interval, cfg.barsNeeded, signal);
                        const klines = data.candles;

                        if (!Array.isArray(klines) || klines.length < Math.min(60, cfg.barsNeeded)) {
                            state.err += 1;
                            state.done += 1;
                            continue;
                        }

                        const seg = findOngoingRangeSegment(klines, cfg);
                        if (seg) {
                            state.results.push({
                                symbol,
                                ...seg
                            });
                        }

                        state.ok += 1;
                        state.done += 1;

                        if (cfg.liveRender && (state.done % 10 === 0 || state.done === state.symbols.length)) {
                            renderTable();
                        }
                    } catch (e) {
                        const msg = e?.message || String(e);
                        if (msg !== "aborted") {
                            state.err += 1;
                            logLine(`${symbol}: ${msg}`, "err");
                        }
                        state.done += 1;
                    } finally {
                        updateCountersUI();
                        updateProgressUI();
                    }
                }
            }

            async function startScan() {
                const cfg = getConfig();
                if (state.isRunning) return;

                if (cfg.targetZonePct <= cfg.entryZonePct + 5) {
                    logLine("Target(%)는 Entry(%)보다 충분히 커야 해요. (권장: Entry 30 / Target 65~70)", "warn");
                }

                state.isRunning = true;
                state.abortController = new AbortController();
                state.startedAt = Date.now();

                setRunningUI(true);
                els.exportBtn.disabled = true;

                state.symbols = [];
                state.queue = [];
                state.ok = 0;
                state.err = 0;
                state.done = 0;
                state.results = [];

                els.logBox.textContent = "";
                els.tbody.innerHTML = `
                    <tr>
                        <td colspan="17" class="muted" style="padding: 14px;">
                            스캔 준비 중...
                        </td>
                    </tr>
                `;

                updateCountersUI();
                updateProgressUI();

                logLine(`스캔 시작 · TF=${cfg.interval}, 최근=${cfg.days}일(${cfg.barsNeeded} bars)`);
                logLine(`폭 ${cfg.minRangePct}~${cfg.bandPct}%, drift≤${cfg.driftMaxPct}%, wicks=${cfg.useWicks ? "ON" : "OFF"}`);
                logLine(`Entry≤${cfg.entryZonePct}%, Target≥${cfg.targetZonePct}%, StopBuf=${cfg.stopBufferPct}%`);
                logLine(`BounceFilter=${cfg.bounceFilterEnabled ? `ON(bounce≥${cfg.minBounces})` : "OFF"} · concurrency=${cfg.concurrency}, delayMs=${cfg.delayMs}`);

                state.tickTimer = setInterval(() => {
                    if (state.isRunning) tickElapsed();
                }, 250);

                try {
                    els.progressText.textContent = "심볼 목록 불러오는 중...";
                    state.symbols = await getUsdtPerpSymbols(state.abortController.signal);
                    state.queue = state.symbols.slice();

                    updateCountersUI();
                    updateProgressUI();
                    logLine(`심볼 ${state.symbols.length}개 로드 완료`);

                    const workers = [];
                    for (let i = 0; i < cfg.concurrency; i += 1) {
                        workers.push(workerLoop(cfg));
                    }

                    await Promise.all(workers);

                    if (state.isRunning) {
                        logLine("스캔 완료");
                    } else {
                        logLine("스캔 중지됨", "warn");
                    }
                } catch (e) {
                    logLine(`전체 오류: ${e?.message || String(e)}`, "err");
                } finally {
                    stopScan(false);
                    renderTable();
                    els.exportBtn.disabled = state.results.length === 0;
                    updateCountersUI();
                    updateProgressUI();
                }
            }

            function stopScan(userClick = true) {
                if (!state.isRunning && userClick) return;

                state.isRunning = false;

                if (state.abortController) {
                    try { state.abortController.abort(); } catch (_) {}
                }
                state.abortController = null;

                if (state.tickTimer) {
                    clearInterval(state.tickTimer);
                    state.tickTimer = null;
                }

                setRunningUI(false);
                els.exportBtn.disabled = state.results.length === 0;

                if (userClick) logLine("중지 요청", "warn");
            }

            function clearAll() {
                if (state.isRunning) stopScan(true);

                state.symbols = [];
                state.queue = [];
                state.ok = 0;
                state.err = 0;
                state.done = 0;
                state.results = [];

                els.logBox.textContent = "";
                els.progressText.textContent = "대기 중";
                els.progressMeta.textContent = "0 / 0";
                els.progressBar.style.width = "0%";
                els.elapsedText.textContent = "00:00";
                els.renderInfo.textContent = "-";

                els.tbody.innerHTML = `
                    <tr>
                        <td colspan="17" class="muted" style="padding: 14px;">
                            아직 결과가 없습니다. “스캔 시작”을 눌러주세요.
                        </td>
                    </tr>
                `;

                setRunningUI(false);
                updateCountersUI();
                getConfig();
                logLine("초기화 완료");
            }

            // Events
            els.startBtn.addEventListener("click", () => startScan());
            els.stopBtn.addEventListener("click", () => stopScan(true));
            els.clearBtn.addEventListener("click", () => clearAll());
            els.searchInput.addEventListener("input", () => renderTable());

            els.exportBtn.addEventListener("click", () => {
                const cfg = getConfig();
                const sorted = sortResults(state.results);
                const filtered = filterResults(sorted, els.searchInput.value);
                const csv = toCsv(filtered, cfg.interval);
                const filename = `ongoing_range_${cfg.interval}_${cfg.days}d_band${cfg.bandPct}_drift${cfg.driftMaxPct}.csv`;
                downloadText(filename, csv);
            });

            function init() {
                setRunningUI(false);
                updateCountersUI();
                getConfig();
                logLine("준비 완료. 기본값은 15m 추천 세팅입니다.");
                logLine("표의 Entry Mode가 NOW면: Entry Suggested = Now(최근 종가)로 표시됩니다.");
                logLine("결과가 너무 적으면: (1) Bounce 조건 OFF, (2) Band/Drift 완화, (3) wicks OFF 유지 권장");
            }

            init();
        </script>
    </body>
</html>
