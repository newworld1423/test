<!doctype html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — 횡보 하단 롱 반복 스캐너 (RepeatScore)</title>
        <style>
            :root {
                --bg: #0b1020;
                --panel: rgba(255, 255, 255, 0.06);
                --text: rgba(255, 255, 255, 0.92);
                --muted: rgba(255, 255, 255, 0.65);
                --line: rgba(255, 255, 255, 0.12);
                --good: #7ee787;
                --bad: #ff7b72;
                --warn: #ffa657;
                --btn: rgba(255, 255, 255, 0.10);
                --btnHover: rgba(255, 255, 255, 0.16);
                --shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
                --radius: 14px;
            }

            * { box-sizing: border-box; }
            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, sans-serif;
                color: var(--text);
                background:
                    radial-gradient(1000px 600px at 10% 0%, rgba(99, 102, 241, 0.20), transparent 60%),
                    radial-gradient(1000px 700px at 90% 10%, rgba(16, 185, 129, 0.12), transparent 60%),
                    radial-gradient(900px 600px at 50% 100%, rgba(244, 63, 94, 0.10), transparent 60%),
                    var(--bg);
            }

            .wrap {
                max-width: 1420px;
                margin: 0 auto;
                padding: 22px 16px 40px;
            }

            header {
                display: flex;
                flex-wrap: wrap;
                align-items: flex-end;
                justify-content: space-between;
                gap: 12px;
                margin-bottom: 14px;
            }

            h1 {
                font-size: 20px;
                margin: 0;
                letter-spacing: -0.3px;
            }

            .sub {
                font-size: 12px;
                color: var(--muted);
                margin-top: 6px;
                line-height: 1.55;
            }

            .grid {
                display: grid;
                grid-template-columns: 1.2fr 0.8fr;
                gap: 14px;
                align-items: start;
            }

            @media (max-width: 980px) {
                .grid { grid-template-columns: 1fr; }
            }

            .card {
                background: var(--panel);
                border: 1px solid var(--line);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                overflow: hidden;
            }

            .cardHead {
                padding: 14px 14px 10px;
                border-bottom: 1px solid var(--line);
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }

            .cardTitle {
                font-weight: 650;
                font-size: 13px;
                color: rgba(255, 255, 255, 0.88);
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .badge {
                font-size: 11px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: var(--muted);
            }

            .tag {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 11px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: rgba(255, 255, 255, 0.86);
                white-space: nowrap;
            }

            .tagNow {
                border-color: rgba(126, 231, 135, 0.45);
                background: rgba(126, 231, 135, 0.16);
                color: var(--good);
                font-weight: 700;
            }

            .tagWait {
                border-color: rgba(255, 166, 87, 0.40);
                background: rgba(255, 166, 87, 0.14);
                color: var(--warn);
                font-weight: 700;
            }

            .cardBody { padding: 14px; }

            .controls {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }

            @media (max-width: 980px) {
                .controls { grid-template-columns: repeat(2, 1fr); }
            }

            .field label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin: 0 0 6px;
            }

            select, input[type="number"], input[type="text"] {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.25);
                color: var(--text);
                outline: none;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-top: 12px;
                align-items: center;
            }

            .btn {
                appearance: none;
                border: 1px solid var(--line);
                background: var(--btn);
                color: var(--text);
                border-radius: 12px;
                padding: 10px 12px;
                font-weight: 650;
                cursor: pointer;
                transition: 140ms ease;
            }

            .btn:hover { background: var(--btnHover); }
            .btn:disabled { opacity: 0.55; cursor: not-allowed; }

            .btnPrimary {
                border-color: rgba(16, 185, 129, 0.35);
                background: rgba(16, 185, 129, 0.14);
            }
            .btnPrimary:hover { background: rgba(16, 185, 129, 0.20); }

            .btnDanger {
                border-color: rgba(244, 63, 94, 0.38);
                background: rgba(244, 63, 94, 0.14);
            }
            .btnDanger:hover { background: rgba(244, 63, 94, 0.20); }

            .switch {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                font-size: 12px;
                color: var(--muted);
                user-select: none;
            }

            .switch input { width: 18px; height: 18px; }

            .progressBox {
                margin-top: 12px;
                padding: 12px;
                border: 1px solid var(--line);
                border-radius: 12px;
                background: rgba(0, 0, 0, 0.18);
            }

            .progressTop {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
                margin-bottom: 8px;
            }

            .mono {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }

            .bar {
                height: 10px;
                border-radius: 999px;
                overflow: hidden;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid var(--line);
            }

            .bar > div {
                height: 100%;
                width: 0%;
                background: linear-gradient(90deg, rgba(16, 185, 129, 0.9), rgba(99, 102, 241, 0.9));
                transition: width 120ms ease;
            }

            .smallGrid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 3px 9px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: rgba(255, 255, 255, 0.86);
                font-size: 12px;
                white-space: nowrap;
            }

            .good { color: var(--good); }
            .bad { color: var(--bad); }
            .warn { color: var(--warn); }
            .muted { color: var(--muted); }
            .right { text-align: right; }

            .kv {
                display: grid;
                grid-template-columns: 130px 1fr;
                gap: 10px;
                align-items: center;
                font-size: 12px;
                color: var(--muted);
                margin-top: 8px;
            }

            .kv b {
                color: rgba(255, 255, 255, 0.82);
                font-weight: 700;
            }

            .log {
                height: 220px;
                overflow: auto;
                padding: 10px;
                border-radius: 12px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.22);
                font-size: 12px;
                color: rgba(255, 255, 255, 0.80);
                line-height: 1.5;
                white-space: pre-wrap;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                background: rgba(10, 14, 28, 0.85);
                backdrop-filter: blur(6px);
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                text-align: left;
                color: rgba(255, 255, 255, 0.82);
                font-weight: 700;
                white-space: nowrap;
            }

            thead th.sortable {
                cursor: pointer;
                user-select: none;
            }

            thead th.sortable:hover {
                background: rgba(255, 255, 255, 0.06);
            }

            thead th.sortable:focus {
                outline: 2px solid rgba(99, 102, 241, 0.50);
                outline-offset: -2px;
            }

            thead th .sortIcon {
                display: inline-block;
                margin-left: 6px;
                font-size: 11px;
                opacity: 0.85;
            }

            tbody td {
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                padding: 9px 10px;
                vertical-align: middle;
                white-space: nowrap;
            }

            tbody tr:hover { background: rgba(255, 255, 255, 0.04); }

            .cellNow {
                color: var(--good);
                font-weight: 800;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <header>
                <div>
                    <h1>바이낸스 USDT 무기한 — “횡보 하단 롱 반복” 스캐너 (RepeatScore)</h1>
                    <div class="sub">
                        최근 <b>X일</b> 윈도우 안에서, <b>마지막 캔들(현재)까지 이어지는 횡보</b>를 심볼별로 1개씩 찾습니다.<br />
                        기본 정렬: <b>RepeatScore</b> 높은 순 (하단 롱 → 상단 익절 반복 적합도).<br />
                        <b>TP%/SL%</b>: Entry Suggested(진입가) 기준 목표/손절 도달 시 수익률·손실률(%).<br />
                        <b>Entry Mode</b>: <span class="tag tagNow">NOW</span> = 현재가가 하단 진입존(Entry Suggested = Now), <span class="tag tagWait">WAIT</span> = Entry Line까지 대기.
                    </div>
                </div>
                <div class="pill mono">API: fapi.binance.com</div>
            </header>

            <div class="grid">
                <section class="card">
                    <div class="cardHead">
                        <div class="cardTitle">
                            설정
                            <span class="badge">기본값: 15m 추천</span>
                        </div>
                        <div class="badge mono" id="statusBadge">IDLE</div>
                    </div>
                    <div class="cardBody">
                        <div class="controls">
                            <div class="field">
                                <label>타임프레임</label>
                                <select id="tfSelect">
                                    <option value="15m" selected>15m</option>
                                    <option value="1h">1h</option>
                                    <option value="4h">4h</option>
                                    <option value="1d">1d</option>
                                </select>
                            </div>

                            <div class="field">
                                <label>최근 X일</label>
                                <input id="daysInput" type="number" min="1" max="365" step="1" value="14" />
                            </div>

                            <div class="field">
                                <label>Band (폭% ≤)</label>
                                <input id="bandInput" type="number" min="0.5" max="60" step="0.1" value="10.0" />
                            </div>

                            <div class="field">
                                <label>Drift (시작~현재% ≤)</label>
                                <input id="driftInput" type="number" min="0.1" max="60" step="0.1" value="6.0" />
                            </div>

                            <div class="field">
                                <label>Entry (하단% ≤)</label>
                                <input id="entryZoneInput" type="number" min="5" max="45" step="1" value="30" />
                            </div>

                            <div class="field">
                                <label>Target (상단% ≥)</label>
                                <input id="targetZoneInput" type="number" min="50" max="95" step="1" value="67" />
                            </div>

                            <div class="field">
                                <label>Stop Buffer(저점 아래 %)</label>
                                <input id="stopBufInput" type="number" min="0.0" max="12" step="0.1" value="1.8" />
                            </div>

                            <div class="field">
                                <label>Min Range (폭% ≥)</label>
                                <input id="minRangeInput" type="number" min="0.0" max="60" step="0.1" value="0.9" />
                            </div>

                            <div class="field">
                                <label>최소 Bounce(N)</label>
                                <input id="minBouncesInput" type="number" min="0" max="50" step="1" value="2" />
                            </div>

                            <div class="field">
                                <label>표시 Top N</label>
                                <input id="topInput" type="number" min="10" max="500" step="10" value="150" />
                            </div>

                            <div class="field">
                                <label>동시 요청(concurrency)</label>
                                <input id="concInput" type="number" min="1" max="12" step="1" value="4" />
                            </div>

                            <div class="field">
                                <label>요청 간 딜레이(ms)</label>
                                <input id="delayInput" type="number" min="0" max="2000" step="10" value="220" />
                            </div>

                            <div class="field">
                                <label>검색(심볼)</label>
                                <input id="searchInput" type="text" placeholder="예: BTC, ETH, SOL..." />
                            </div>
                        </div>

                        <div class="row">
                            <label class="switch">
                                <input id="wicksToggle" type="checkbox" />
                                레인지 계산에 윅 포함(고/저) — 더 보수적
                            </label>

                            <label class="switch">
                                <input id="bounceFilterToggle" type="checkbox" checked />
                                Bounce 조건 적용 (하단→상단 반복 필터)
                            </label>

                            <label class="switch">
                                <input id="liveToggle" type="checkbox" checked />
                                실시간 표 갱신
                            </label>
                        </div>

                        <div class="row">
                            <button class="btn btnPrimary" id="startBtn">스캔 시작</button>
                            <button class="btn btnDanger" id="stopBtn" disabled>중지</button>
                            <button class="btn" id="clearBtn">초기화</button>
                            <button class="btn" id="exportBtn" disabled>CSV 내보내기</button>
                        </div>

                        <div class="progressBox">
                            <div class="progressTop">
                                <div class="mono" id="progressText">대기 중</div>
                                <div class="mono muted" id="progressMeta">0 / 0</div>
                            </div>
                            <div class="bar"><div id="progressBar"></div></div>

                            <div class="kv">
                                <b>윈도우 바 수</b>
                                <span class="mono muted" id="barsInfo">-</span>

                                <b>횡보 판정</b>
                                <span class="mono muted" id="ruleText">-</span>

                                <b>RepeatScore</b>
                                <span class="muted">
                                    Bounce(성공 반복) + Entry 근접 + TP/RR + 안정성(Drift/폭/Vol) − 하단체류(LowStreak) 패널티
                                </span>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="card">
                    <div class="cardHead">
                        <div class="cardTitle">
                            로그 / 상태
                            <span class="badge">429 자동 백오프</span>
                        </div>
                        <div class="badge mono" id="elapsedText">00:00</div>
                    </div>
                    <div class="cardBody">
                        <div class="smallGrid">
                            <div class="pill">
                                <span class="muted">심볼</span>
                                <span class="mono" id="symCount">-</span>
                            </div>
                            <div class="pill">
                                <span class="muted">성공</span>
                                <span class="mono good" id="okCount">0</span>
                            </div>
                            <div class="pill">
                                <span class="muted">실패</span>
                                <span class="mono bad" id="errCount">0</span>
                            </div>
                            <div class="pill">
                                <span class="muted">결과</span>
                                <span class="mono" id="resCount">0</span>
                            </div>
                        </div>

                        <div style="height: 10px;"></div>
                        <div class="log mono" id="logBox"></div>
                    </div>
                </section>
            </div>

            <div style="height: 14px;"></div>

            <section class="card">
                <div class="cardHead">
                    <div class="cardTitle">
                        결과 (RepeatScore 높은 순)
                        <span class="badge">RepeatScore ↓</span>
                    </div>
                    <div class="badge mono" id="renderInfo">-</div>
                </div>
                <div class="cardBody" style="padding: 0;">
                    <div style="overflow: auto; max-height: 720px;">
                        <table>
                            <thead>
                                <tr>
                                    <th class="right">#</th>

                                    <th class="sortable" data-key="symbol" data-type="string" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Symbol<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="repeatScore" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        RepeatScore<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="entryMode" data-type="enum" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Entry Mode<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="gapToEntryPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Gap%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="bounces" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Bounce<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="avgHitBars" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        AvgHit(bars)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lastBounceAgo" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        LastHitAgo<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="entrySuggested" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Entry(진입)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="tpPct" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        TP%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="slPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        SL%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="rr" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        RR<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lenBars" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Len(bars)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lenDuration" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Len(시간)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="widthPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        폭%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="driftPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Drift%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="posPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Pos%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="volRangePct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Vol%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lowStreakEnd" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        LowStreak<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lastClose" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Now(종가)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="entryLine" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        EntryLine<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="targetLevel" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Target<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="stopLevel" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Stop<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="rangeLow" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Low<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="rangeHigh" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        High<span class="sortIcon"></span>
                                    </th>

                                    <th class="sortable" data-key="startTime" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        시작(서울)<span class="sortIcon"></span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="tbody">
                                <tr>
                                    <td colspan="26" class="muted" style="padding: 14px;">
                                        아직 결과가 없습니다. “스캔 시작”을 눌러주세요.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </div>

        <script>
            "use strict";

            const BASE_URL = "https://fapi.binance.com";
            const PAGE_LIMIT = 499;

            const DEFAULT_SORT = {
                key: "repeatScore",
                dir: "desc"
            };

            const els = {
                statusBadge: document.getElementById("statusBadge"),
                elapsedText: document.getElementById("elapsedText"),

                tfSelect: document.getElementById("tfSelect"),
                daysInput: document.getElementById("daysInput"),
                bandInput: document.getElementById("bandInput"),
                driftInput: document.getElementById("driftInput"),
                entryZoneInput: document.getElementById("entryZoneInput"),
                targetZoneInput: document.getElementById("targetZoneInput"),
                stopBufInput: document.getElementById("stopBufInput"),
                minRangeInput: document.getElementById("minRangeInput"),
                minBouncesInput: document.getElementById("minBouncesInput"),
                topInput: document.getElementById("topInput"),
                concInput: document.getElementById("concInput"),
                delayInput: document.getElementById("delayInput"),
                searchInput: document.getElementById("searchInput"),

                wicksToggle: document.getElementById("wicksToggle"),
                bounceFilterToggle: document.getElementById("bounceFilterToggle"),
                liveToggle: document.getElementById("liveToggle"),

                startBtn: document.getElementById("startBtn"),
                stopBtn: document.getElementById("stopBtn"),
                clearBtn: document.getElementById("clearBtn"),
                exportBtn: document.getElementById("exportBtn"),

                progressText: document.getElementById("progressText"),
                progressMeta: document.getElementById("progressMeta"),
                progressBar: document.getElementById("progressBar"),
                barsInfo: document.getElementById("barsInfo"),
                ruleText: document.getElementById("ruleText"),

                symCount: document.getElementById("symCount"),
                okCount: document.getElementById("okCount"),
                errCount: document.getElementById("errCount"),
                resCount: document.getElementById("resCount"),

                logBox: document.getElementById("logBox"),
                renderInfo: document.getElementById("renderInfo"),
                tbody: document.getElementById("tbody")
            };

            const state = {
                isRunning: false,
                abortController: null,
                startedAt: 0,
                tickTimer: null,

                symbols: [],
                queue: [],
                ok: 0,
                err: 0,
                done: 0,

                results: [],

                sortKey: DEFAULT_SORT.key,
                sortDir: DEFAULT_SORT.dir
            };

            function logLine(msg, type = "info") {
                const ts = new Date().toLocaleTimeString("ko-KR", { hour12: false });
                const prefix = type === "err" ? "[ERR]" : (type === "warn" ? "[WARN]" : "[LOG]");
                els.logBox.textContent += `${ts} ${prefix} ${msg}\n`;
                els.logBox.scrollTop = els.logBox.scrollHeight;
            }

            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            function clampNum(n, min, max, fallback) {
                const x = Number(n);
                if (!Number.isFinite(x)) return fallback;
                return Math.min(max, Math.max(min, x));
            }

            function clamp(x, min, max) {
                return Math.min(max, Math.max(min, x));
            }

            function intervalToMs(interval) {
                const m = String(interval).match(/^(\d+)([mhdwM])$/);
                if (!m) return null;
                const num = Number(m[1]);
                const unit = m[2];

                if (unit === "m") return num * 60 * 1000;
                if (unit === "h") return num * 60 * 60 * 1000;
                if (unit === "d") return num * 24 * 60 * 60 * 1000;
                if (unit === "w") return num * 7 * 24 * 60 * 60 * 1000;
                if (unit === "M") return num * 30 * 24 * 60 * 60 * 1000;
                return null;
            }

            function calcBarsNeeded(days, interval) {
                const ms = intervalToMs(interval);
                if (!ms) return 0;
                const dayMs = 24 * 60 * 60 * 1000;
                return Math.ceil((days * dayMs) / ms);
            }

            function fmtDuration(bars, interval) {
                const ms = intervalToMs(interval);
                if (!ms) return "-";
                const totalMin = Math.floor((bars * ms) / 60000);

                const days = Math.floor(totalMin / (60 * 24));
                const hours = Math.floor((totalMin - days * 60 * 24) / 60);
                const mins = totalMin % 60;

                if (days > 0) return `${days}d ${hours}h`;
                if (hours > 0) return `${hours}h ${mins}m`;
                return `${mins}m`;
            }

            function toSeoul(ts) {
                try {
                    return new Date(ts).toLocaleString("ko-KR", { timeZone: "Asia/Seoul", hour12: false });
                } catch (_) {
                    return new Date(ts).toISOString().replace(".000Z", "Z");
                }
            }

            function widthPct(minVal, maxVal) {
                const mid = (minVal + maxVal) / 2;
                if (!Number.isFinite(mid) || mid === 0) return Infinity;
                return ((maxVal - minVal) / mid) * 100;
            }

            function calcRR(entrySuggested, targetLevel, stopLevel) {
                const e = Number(entrySuggested);
                const t = Number(targetLevel);
                const s = Number(stopLevel);

                if (!Number.isFinite(e) || !Number.isFinite(t) || !Number.isFinite(s)) return NaN;

                const reward = t - e;
                const risk = e - s;

                if (!(reward > 0) || !(risk > 0)) return NaN;

                return reward / risk;
            }

            function calcTpPct(entrySuggested, targetLevel) {
                const e = Number(entrySuggested);
                const t = Number(targetLevel);
                if (!Number.isFinite(e) || !Number.isFinite(t) || !(e > 0)) return NaN;
                return ((t - e) / e) * 100;
            }

            function calcSlPct(entrySuggested, stopLevel) {
                const e = Number(entrySuggested);
                const s = Number(stopLevel);
                if (!Number.isFinite(e) || !Number.isFinite(s) || !(e > 0)) return NaN;
                return ((e - s) / e) * 100;
            }

            function calcGapToEntryPct(lastClose, entryLine) {
                const c = Number(lastClose);
                const e = Number(entryLine);
                if (!Number.isFinite(c) || !Number.isFinite(e) || !(c > 0)) return NaN;
                if (c <= e) return 0;
                return ((c - e) / c) * 100;
            }

            function getRepeatLookbackBars(cfg) {
                const ms = intervalToMs(cfg.interval) || 0;
                const targetMs = 36 * 60 * 60 * 1000; // 36h
                let bars = ms > 0 ? Math.floor(targetMs / ms) : 60;
                bars = Math.floor(clamp(bars, 12, 120));
                return bars;
            }

            function analyzeBouncesInSegment(klines, segStartIdx, rangeLow, rangeHigh, cfg) {
                const n = klines.length;
                const last = n - 1;

                if (segStartIdx >= last) {
                    return { bounces: 0, avgHitBars: NaN, lastBounceAgo: NaN };
                }

                const rangeAbs = rangeHigh - rangeLow;
                if (!(rangeAbs > 0)) {
                    return { bounces: 0, avgHitBars: NaN, lastBounceAgo: NaN };
                }

                const entryUpper = rangeLow + rangeAbs * (cfg.entryZonePct / 100);
                const targetLevel = rangeLow + rangeAbs * (cfg.targetZonePct / 100);
                const stopLevel = rangeLow * (1 - cfg.stopBufferPct / 100);

                const minProfitPct = cfg.minProfitPct;

                let bounces = 0;
                let hitBarsSum = 0;
                let hitCount = 0;
                let lastHitIndex = -1;

                let i = segStartIdx;

                while (i < n) {
                    while (i < n) {
                        const close = Number(klines[i][4]);
                        if (Number.isFinite(close) && close <= entryUpper) break;
                        i += 1;
                    }
                    if (i >= n) break;

                    const entryIdx = i;
                    const entryPrice = Number(klines[i][4]);
                    let j = i + 1;
                    let succeeded = false;

                    while (j < n) {
                        const high = Number(klines[j][2]);
                        const low = Number(klines[j][3]);
                        const close = Number(klines[j][4]);

                        if (cfg.useWicks) {
                            if (Number.isFinite(low) && low < stopLevel) break;
                            if (Number.isFinite(high) && high >= targetLevel) {
                                succeeded = true;
                                break;
                            }
                        } else {
                            if (Number.isFinite(close) && close < stopLevel) break;
                            if (Number.isFinite(close) && close >= targetLevel) {
                                succeeded = true;
                                break;
                            }
                        }
                        j += 1;
                    }

                    if (succeeded) {
                        const profitPct = (Number.isFinite(entryPrice) && entryPrice > 0)
                            ? ((targetLevel - entryPrice) / entryPrice) * 100
                            : 0;

                        if (profitPct >= minProfitPct) {
                            bounces += 1;
                            hitBarsSum += (j - entryIdx);
                            hitCount += 1;
                            lastHitIndex = j;
                        }
                        i = j + 1;
                    } else {
                        i = j + 1;
                    }
                }

                const avgHitBars = hitCount > 0 ? (hitBarsSum / hitCount) : NaN;
                const lastBounceAgo = lastHitIndex >= 0 ? (n - 1 - lastHitIndex) : NaN;

                return { bounces, avgHitBars, lastBounceAgo };
            }

            function computeVolAndLowStreak(klines, seg, cfg) {
                const n = klines.length;
                const rangeAbs = seg.rangeHigh - seg.rangeLow;
                if (!(rangeAbs > 0)) {
                    return { volRatio: NaN, volRangePct: NaN, lowStreakEnd: 0 };
                }

                const lookback = Math.min(getRepeatLookbackBars(cfg), Math.max(1, seg.lenBars));
                const from = Math.max(0, n - lookback);

                let sumHL = 0;
                let cntHL = 0;

                for (let i = from; i < n; i += 1) {
                    const hi = Number(klines[i][2]);
                    const lo = Number(klines[i][3]);
                    if (Number.isFinite(hi) && Number.isFinite(lo) && hi > 0 && lo > 0) {
                        sumHL += (hi - lo);
                        cntHL += 1;
                    }
                }

                const avgHL = cntHL > 0 ? (sumHL / cntHL) : NaN;
                const volRatio = (Number.isFinite(avgHL) && rangeAbs > 0) ? (avgHL / rangeAbs) : NaN;
                const volRangePct = Number.isFinite(volRatio) ? (volRatio * 100) : NaN;

                let streak = 0;
                for (let i = n - 1; i >= 0; i -= 1) {
                    const k = klines[i];
                    const close = Number(k[4]);
                    const low = Number(k[3]);

                    const touchedLow = cfg.useWicks
                        ? (Number.isFinite(low) && low <= seg.entryLine)
                        : (Number.isFinite(close) && close <= seg.entryLine);

                    if (touchedLow) streak += 1;
                    else break;
                }

                return { volRatio, volRangePct, lowStreakEnd: streak };
            }

            function calcRepeatScore(r, cfg) {
                const rr = Number(r.rr);
                const tp = Number(r.tpPct);
                const sl = Number(r.slPct);

                const bounceBase = Math.max(1, cfg.minBounces + 3);
                const bounceScore = clamp((Number(r.bounces) || 0) / bounceBase, 0, 1);

                const gap = Number(r.gapToEntryPct);
                const entryNow = r.entryMode === "NOW" ? 1 : 0;
                const gapDen = Math.max(0.15, Math.min(3.0, (Number(r.widthPct) || 1) * 0.60));
                const proxScore = entryNow ? 1 : (Number.isFinite(gap) ? (1 - clamp(gap / gapDen, 0, 1)) : 0);

                const posEntryDen = Math.max(1, cfg.entryZonePct);
                const posEntryScore = 1 - clamp((Number(r.posPct) || 0) / posEntryDen, 0, 1);

                const driftDen = Math.max(0.0001, cfg.driftMaxPct);
                const driftScore = 1 - clamp((Number(r.driftPct) || 0) / driftDen, 0, 1);

                const widthDen = Math.max(0.0001, (cfg.bandPct - cfg.minRangePct));
                const widthNorm = ((Number(r.widthPct) || 0) - cfg.minRangePct) / widthDen;
                const widthScore = 1 - clamp(widthNorm, 0, 1);

                const volScore = Number.isFinite(Number(r.volRatio))
                    ? (1 - clamp(Number(r.volRatio) / 0.40, 0, 1))
                    : 0.5;

                const lookback = Math.max(12, Math.min(120, Number(r.repeatLookbackBars) || getRepeatLookbackBars(cfg)));
                const speedScore = Number.isFinite(Number(r.avgHitBars))
                    ? (1 - clamp(Number(r.avgHitBars) / lookback, 0, 1))
                    : 0.5;

                const recentScore = Number.isFinite(Number(r.lastBounceAgo))
                    ? (1 - clamp(Number(r.lastBounceAgo) / lookback, 0, 1))
                    : 0.4;

                const rrScore = Number.isFinite(rr) ? clamp((rr - 0.9) / 1.6, 0, 1) : 0;
                const tpScore = Number.isFinite(tp) ? clamp((tp - 0.25) / 1.5, 0, 1) : 0;

                const slPenalty = Number.isFinite(sl) ? clamp((sl - 0.6) / 2.0, 0, 1) : 0.6;
                const streakPenalty = Number.isFinite(Number(r.lowStreakEnd))
                    ? clamp(Number(r.lowStreakEnd) / Math.max(4, cfg.minBounces * 3), 0, 1)
                    : 0;

                let score = 100 * (
                    0.18 * proxScore +
                    0.18 * posEntryScore +
                    0.24 * bounceScore +
                    0.08 * speedScore +
                    0.06 * recentScore +
                    0.08 * rrScore +
                    0.10 * tpScore +
                    0.08 * driftScore +
                    0.06 * widthScore +
                    0.04 * volScore
                );

                score -= 12 * streakPenalty;
                score -= 8 * slPenalty;

                return clamp(score, 0, 100);
            }

            async function fetchJsonWithBackoff(url, signal, maxRetries = 6) {
                let attempt = 0;

                while (true) {
                    attempt += 1;

                    let res;
                    try {
                        res = await fetch(url, { method: "GET", headers: { "accept": "application/json" }, signal });
                    } catch (e) {
                        if (signal && signal.aborted) {
                            throw new Error("aborted");
                        }
                        throw e;
                    }

                    if (res.ok) {
                        return res.json();
                    }

                    const status = res.status;
                    const retryAfterHeader = res.headers.get("retry-after");
                    const retryAfterSec = retryAfterHeader ? Number(retryAfterHeader) : NaN;

                    let bodyText = "";
                    try {
                        bodyText = await res.text();
                    } catch (_) {
                        bodyText = "";
                    }

                    const isRate = (status === 429 || status === 418);
                    if (isRate && attempt <= maxRetries) {
                        let waitSec = retryAfterSec;
                        if (!Number.isFinite(waitSec) || waitSec <= 0) {
                            waitSec = Math.min(60, Math.pow(1.8, attempt));
                        }
                        logLine(`${status} 레이트리밋 → ${waitSec.toFixed(1)}s 백오프`, "warn");
                        await sleep(Math.floor(waitSec * 1000));
                        continue;
                    }

                    throw new Error(`HTTP ${status} :: ${bodyText.slice(0, 240)}`);
                }
            }

            async function getUsdtPerpSymbols(signal) {
                const url = `${BASE_URL}/fapi/v1/exchangeInfo`;
                const data = await fetchJsonWithBackoff(url, signal);

                const list = Array.isArray(data?.symbols) ? data.symbols : [];
                const syms = list
                    .filter((s) => {
                        if (!s) return false;
                        if (s.contractType !== "PERPETUAL") return false;
                        if (s.quoteAsset !== "USDT") return false;
                        if (s.status !== "TRADING") return false;
                        return true;
                    })
                    .map((s) => s.symbol);

                return Array.from(new Set(syms));
            }

            async function getKlinesPage(symbol, interval, limit, endTime, signal) {
                const qs = new URLSearchParams({
                    symbol,
                    interval,
                    limit: String(limit)
                });
                if (Number.isFinite(endTime) && endTime > 0) {
                    qs.set("endTime", String(Math.floor(endTime)));
                }
                const url = `${BASE_URL}/fapi/v1/klines?${qs.toString()}`;
                return fetchJsonWithBackoff(url, signal);
            }

            async function fetchKlinesWindow(symbol, interval, barsNeeded, signal) {
                const maxPages = Math.min(12, Math.max(1, Math.ceil(barsNeeded / PAGE_LIMIT)));
                const want = Math.min(barsNeeded, maxPages * PAGE_LIMIT);

                let endTime = Date.now();
                let all = [];
                let pages = 0;

                while (all.length < want && pages < maxPages) {
                    pages += 1;

                    const remaining = want - all.length;
                    const limit = Math.min(PAGE_LIMIT, remaining);

                    const batch = await getKlinesPage(symbol, interval, limit, endTime, signal);
                    if (!Array.isArray(batch) || batch.length === 0) break;

                    all = batch.concat(all);

                    const firstOpen = Number(batch[0]?.[0]);
                    if (!Number.isFinite(firstOpen)) break;

                    endTime = firstOpen - 1;
                }

                if (all.length > want) {
                    all = all.slice(all.length - want);
                }

                return {
                    candles: all,
                    effectiveBars: all.length,
                    pagesUsed: pages,
                    maxPages
                };
            }

            function findOngoingRangeSegment(klines, cfg) {
                const n = klines.length;
                if (n < 50) return null;

                const times = new Array(n);
                const closes = new Array(n);
                const highs = new Array(n);
                const lows = new Array(n);

                for (let i = 0; i < n; i += 1) {
                    const k = klines[i];
                    times[i] = Number(k[0]);
                    highs[i] = Number(k[2]);
                    lows[i] = Number(k[3]);
                    closes[i] = Number(k[4]);
                }

                const useMin = (idx) => (cfg.useWicks ? lows[idx] : closes[idx]);
                const useMax = (idx) => (cfg.useWicks ? highs[idx] : closes[idx]);

                const sufMin = new Array(n);
                const sufMax = new Array(n);

                sufMin[n - 1] = useMin(n - 1);
                sufMax[n - 1] = useMax(n - 1);

                for (let i = n - 2; i >= 0; i -= 1) {
                    const vMin = useMin(i);
                    const vMax = useMax(i);
                    sufMin[i] = Math.min(sufMin[i + 1], vMin);
                    sufMax[i] = Math.max(sufMax[i + 1], vMax);
                }

                const lastClose = closes[n - 1];

                const candidateIdx = [];
                for (let i = 0; i < n - 1; i += 1) {
                    const rangeLow = sufMin[i];
                    const rangeHigh = sufMax[i];

                    if (!Number.isFinite(rangeLow) || !Number.isFinite(rangeHigh) || rangeLow <= 0 || rangeHigh <= 0) {
                        continue;
                    }

                    const w = widthPct(rangeLow, rangeHigh);
                    if (!(w <= cfg.bandPct)) continue;
                    if (!(w >= cfg.minRangePct)) continue;

                    const startClose = closes[i];
                    const drift = (Number.isFinite(startClose) && startClose > 0)
                        ? (Math.abs(lastClose - startClose) / startClose) * 100
                        : Infinity;

                    if (!(drift <= cfg.driftMaxPct)) continue;

                    candidateIdx.push(i);
                }

                if (candidateIdx.length === 0) return null;

                const K = cfg.bounceFilterEnabled ? 50 : 1;
                const limit = Math.min(K, candidateIdx.length);

                for (let c = 0; c < limit; c += 1) {
                    const i = candidateIdx[c];
                    const rangeLow = sufMin[i];
                    const rangeHigh = sufMax[i];

                    const w = widthPct(rangeLow, rangeHigh);
                    const startClose = closes[i];
                    const drift = (Number.isFinite(startClose) && startClose > 0)
                        ? (Math.abs(lastClose - startClose) / startClose) * 100
                        : Infinity;

                    const rangeAbs = rangeHigh - rangeLow;
                    if (!(rangeAbs > 0)) continue;

                    const entryLine = rangeLow + rangeAbs * (cfg.entryZonePct / 100);
                    const targetLevel = rangeLow + rangeAbs * (cfg.targetZonePct / 100);
                    const stopLevel = rangeLow * (1 - cfg.stopBufferPct / 100);

                    const posPct = clamp(((lastClose - rangeLow) / rangeAbs) * 100, 0, 100);

                    let bounceRes = { bounces: 0, avgHitBars: NaN, lastBounceAgo: NaN };
                    if (cfg.bounceFilterEnabled || cfg.alwaysComputeBounce) {
                        bounceRes = analyzeBouncesInSegment(klines, i, rangeLow, rangeHigh, cfg);
                    }

                    if (!cfg.bounceFilterEnabled || bounceRes.bounces >= cfg.minBounces) {
                        const nowInEntryZone = (Number.isFinite(lastClose) && lastClose <= entryLine);
                        const entryMode = nowInEntryZone ? "NOW" : "WAIT";
                        const entrySuggested = nowInEntryZone ? lastClose : entryLine;

                        return {
                            startIndex: i,
                            startTime: times[i],
                            lenBars: n - i,
                            widthPct: w,
                            driftPct: drift,

                            bounces: bounceRes.bounces,
                            avgHitBars: bounceRes.avgHitBars,
                            lastBounceAgo: bounceRes.lastBounceAgo,

                            rangeLow,
                            rangeHigh,
                            lastClose,
                            posPct,

                            entryMode,
                            nowInEntryZone,
                            entrySuggested,

                            entryLine,
                            targetLevel,
                            stopLevel
                        };
                    }
                }

                return null;
            }

            function setRunningUI(running) {
                els.startBtn.disabled = running;
                els.stopBtn.disabled = !running;
                els.exportBtn.disabled = running || state.results.length === 0;
                els.statusBadge.textContent = running ? "RUNNING" : "IDLE";
            }

            function updateCountersUI() {
                els.symCount.textContent = state.symbols.length ? String(state.symbols.length) : "-";
                els.okCount.textContent = String(state.ok);
                els.errCount.textContent = String(state.err);
                els.resCount.textContent = String(state.results.length);
            }

            function updateProgressUI() {
                const total = state.symbols.length || 0;
                const done = state.done || 0;
                const pct = total > 0 ? Math.min(100, (done / total) * 100) : 0;

                els.progressMeta.textContent = `${done} / ${total}`;
                els.progressBar.style.width = `${pct.toFixed(2)}%`;
                els.progressText.textContent = state.isRunning ? `스캔 중... (${pct.toFixed(1)}%)` : "대기 중";
            }

            function tickElapsed() {
                const sec = Math.floor((Date.now() - state.startedAt) / 1000);
                const mm = String(Math.floor(sec / 60)).padStart(2, "0");
                const ss = String(sec % 60).padStart(2, "0");
                els.elapsedText.textContent = `${mm}:${ss}`;
            }

            function getConfig() {
                const interval = els.tfSelect.value;
                const days = Math.floor(clampNum(els.daysInput.value, 1, 365, 14));

                const bandPct = clampNum(els.bandInput.value, 0.5, 60, 10.0);
                const driftMaxPct = clampNum(els.driftInput.value, 0.1, 60, 6.0);

                const entryZonePct = Math.floor(clampNum(els.entryZoneInput.value, 5, 45, 30));
                const targetZonePct = Math.floor(clampNum(els.targetZoneInput.value, 50, 95, 67));

                const stopBufferPct = clampNum(els.stopBufInput.value, 0.0, 12, 1.8);
                const minRangePct = clampNum(els.minRangeInput.value, 0.0, 60, 0.9);

                const minBounces = Math.floor(clampNum(els.minBouncesInput.value, 0, 50, 2));
                const topN = Math.floor(clampNum(els.topInput.value, 10, 500, 150));

                const concurrency = Math.floor(clampNum(els.concInput.value, 1, 12, 4));
                const delayMs = Math.floor(clampNum(els.delayInput.value, 0, 2000, 220));

                const useWicks = !!els.wicksToggle.checked;
                const bounceFilterEnabled = !!els.bounceFilterToggle.checked;
                const liveRender = !!els.liveToggle.checked;

                const minProfitPct = 0.3;
                const alwaysComputeBounce = true;

                const barsNeeded = calcBarsNeeded(days, interval);
                const pagesNeeded = Math.min(12, Math.max(1, Math.ceil(barsNeeded / PAGE_LIMIT)));

                els.barsInfo.textContent = `${barsNeeded} bars (auto pages=${pagesNeeded})`;
                els.ruleText.textContent =
                    `윈도우=${days}d · 폭 ${minRangePct}~${bandPct}% · drift≤${driftMaxPct}% · entry≤${entryZonePct}% · target≥${targetZonePct}% · stop=${stopBufferPct}% · bounce≥${minBounces}${bounceFilterEnabled ? "" : " (OFF)"}`;

                return {
                    interval,
                    days,
                    barsNeeded,

                    bandPct,
                    driftMaxPct,

                    entryZonePct,
                    targetZonePct,

                    stopBufferPct,
                    minRangePct,

                    minBounces,
                    topN,

                    concurrency,
                    delayMs,

                    useWicks,
                    bounceFilterEnabled,
                    liveRender,

                    minProfitPct,
                    alwaysComputeBounce
                };
            }

            function filterResults(arr, q) {
                const query = String(q || "").trim().toUpperCase();
                if (!query) return arr;
                return arr.filter((r) => r.symbol.includes(query));
            }

            function getSortValue(r, key, cfg) {
                if (!r) return null;

                if (key === "lenDuration") {
                    const ms = intervalToMs(cfg.interval) || 0;
                    return r.lenBars * ms;
                }

                if (key === "entryMode") {
                    return r.entryMode === "NOW" ? 0 : 1;
                }

                return r[key];
            }

            function defaultSortComparator(a, b) {
                if (b.repeatScore !== a.repeatScore) return b.repeatScore - a.repeatScore;
                if (a.entryMode !== b.entryMode) return (a.entryMode === "NOW" ? -1 : 1);
                if (b.bounces !== a.bounces) return b.bounces - a.bounces;
                if (a.driftPct !== b.driftPct) return a.driftPct - b.driftPct;
                if (a.widthPct !== b.widthPct) return a.widthPct - b.widthPct;
                return a.symbol.localeCompare(b.symbol);
            }

            function sortResults(arr, cfg) {
                const out = arr.slice();

                const key = state.sortKey;
                const dir = state.sortDir;

                if (!key) {
                    out.sort(defaultSortComparator);
                    return out;
                }

                const safeKey = (CSS && CSS.escape) ? CSS.escape(key) : key;
                const th = document.querySelector(`thead th[data-key="${safeKey}"]`);
                const type = th?.dataset?.type || "auto";

                out.sort((a, b) => {
                    const va = getSortValue(a, key, cfg);
                    const vb = getSortValue(b, key, cfg);

                    let cmp = 0;

                    if (type === "string") {
                        cmp = String(va ?? "").localeCompare(String(vb ?? ""));
                    } else {
                        const na = Number(va);
                        const nb = Number(vb);

                        const fa = Number.isFinite(na);
                        const fb = Number.isFinite(nb);

                        if (!fa && !fb) cmp = 0;
                        else if (!fa) cmp = 1;
                        else if (!fb) cmp = -1;
                        else cmp = na - nb;
                    }

                    if (cmp === 0) {
                        cmp = a.symbol.localeCompare(b.symbol);
                        if (cmp === 0) cmp = defaultSortComparator(a, b);
                    }

                    return dir === "asc" ? cmp : -cmp;
                });

                return out;
            }

            function updateSortIcons() {
                const ths = document.querySelectorAll("thead th.sortable[data-key]");
                ths.forEach((th) => {
                    const key = th.dataset.key;
                    const icon = th.querySelector(".sortIcon");
                    if (!icon) return;

                    if (key === state.sortKey) {
                        const isAsc = state.sortDir === "asc";
                        icon.textContent = isAsc ? "▲" : "▼";
                        th.setAttribute("aria-sort", isAsc ? "ascending" : "descending");
                    } else {
                        icon.textContent = "";
                        th.setAttribute("aria-sort", "none");
                    }
                });
            }

            function onSortHeaderClick(th) {
                const key = th?.dataset?.key;
                if (!key) return;

                const defaultDir = th.dataset.defaultDir || ((th.dataset.type === "string") ? "asc" : "desc");

                if (state.sortKey === key) {
                    state.sortDir = state.sortDir === "asc" ? "desc" : "asc";
                } else {
                    state.sortKey = key;
                    state.sortDir = defaultDir;
                }

                updateSortIcons();
                renderTable();
            }

            function bindSortingHeaders() {
                const ths = document.querySelectorAll("thead th.sortable[data-key]");
                ths.forEach((th) => {
                    th.addEventListener("click", () => onSortHeaderClick(th));
                    th.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            onSortHeaderClick(th);
                        }
                    });
                });

                updateSortIcons();
            }

            function renderTable() {
                const cfg = getConfig();
                const sorted = sortResults(state.results, cfg);
                const filtered = filterResults(sorted, els.searchInput.value);
                const view = filtered.slice(0, cfg.topN);

                updateSortIcons();
                els.renderInfo.textContent = `표시 ${view.length} / 필터 ${filtered.length} / 전체 ${state.results.length}`;

                if (view.length === 0) {
                    els.tbody.innerHTML = `
                        <tr>
                            <td colspan="26" class="muted" style="padding: 14px;">
                                결과가 없습니다. (Band/Drift 완화, Bounce 조건 OFF, 또는 15m에서 wicks OFF 유지 권장)
                            </td>
                        </tr>
                    `;
                    return;
                }

                let html = "";
                for (let i = 0; i < view.length; i += 1) {
                    const r = view[i];

                    const modeTag = r.entryMode === "NOW"
                        ? `<span class="tag tagNow">NOW</span>`
                        : `<span class="tag tagWait">WAIT</span>`;

                    const entrySugClass = r.entryMode === "NOW" ? "cellNow" : "";

                    const tpText = Number.isFinite(Number(r.tpPct)) ? Number(r.tpPct).toFixed(2) : "—";
                    const slText = Number.isFinite(Number(r.slPct)) ? Number(r.slPct).toFixed(2) : "—";
                    const rrText = Number.isFinite(Number(r.rr)) ? Number(r.rr).toFixed(2) : "—";
                    const gapText = Number.isFinite(Number(r.gapToEntryPct)) ? Number(r.gapToEntryPct).toFixed(2) : "—";
                    const hitText = Number.isFinite(Number(r.avgHitBars)) ? Number(r.avgHitBars).toFixed(1) : "—";
                    const agoText = Number.isFinite(Number(r.lastBounceAgo)) ? String(Math.floor(Number(r.lastBounceAgo))) : "—";
                    const volText = Number.isFinite(Number(r.volRangePct)) ? Number(r.volRangePct).toFixed(1) : "—";

                    html += `
                        <tr>
                            <td class="right mono muted">${i + 1}</td>
                            <td class="mono"><b>${r.symbol}</b></td>

                            <td class="right mono"><b>${r.repeatScore.toFixed(1)}</b></td>
                            <td class="right">${modeTag}</td>
                            <td class="right mono muted">${gapText}</td>

                            <td class="right mono">${r.bounces}</td>
                            <td class="right mono muted">${hitText}</td>
                            <td class="right mono muted">${agoText}</td>

                            <td class="right mono ${entrySugClass}">${r.entrySuggested.toFixed(6)}</td>
                            <td class="right mono">${tpText}</td>
                            <td class="right mono muted">${slText}</td>
                            <td class="right mono">${rrText}</td>

                            <td class="right mono">${r.lenBars}</td>
                            <td class="right mono muted">${fmtDuration(r.lenBars, cfg.interval)}</td>
                            <td class="right mono">${r.widthPct.toFixed(3)}</td>
                            <td class="right mono muted">${r.driftPct.toFixed(3)}</td>
                            <td class="right mono muted">${r.posPct.toFixed(1)}</td>
                            <td class="right mono muted">${volText}</td>
                            <td class="right mono muted">${r.lowStreakEnd}</td>

                            <td class="right mono">${r.lastClose.toFixed(6)}</td>
                            <td class="right mono muted">${r.entryLine.toFixed(6)}</td>
                            <td class="right mono muted">${r.targetLevel.toFixed(6)}</td>
                            <td class="right mono muted">${r.stopLevel.toFixed(6)}</td>
                            <td class="right mono">${r.rangeLow.toFixed(6)}</td>
                            <td class="right mono">${r.rangeHigh.toFixed(6)}</td>
                            <td class="mono muted">${toSeoul(r.startTime)}</td>
                        </tr>
                    `;
                }

                els.tbody.innerHTML = html;
            }

            function toCsv(rows, interval) {
                const header = [
                    "symbol",
                    "repeatScore",
                    "entryMode",
                    "gapToEntryPct",
                    "bounces",
                    "avgHitBars",
                    "lastBounceAgo",
                    "entrySuggested",
                    "tpPct",
                    "slPct",
                    "rr",
                    "lenBars",
                    "lenDuration",
                    "widthPct",
                    "driftPct",
                    "posPct",
                    "volRangePct",
                    "lowStreakEnd",
                    "lastClose",
                    "entryLine",
                    "targetLevel",
                    "stopLevel",
                    "rangeLow",
                    "rangeHigh",
                    "rangeStartSeoul"
                ];
                const lines = [header.join(",")];

                for (const r of rows) {
                    const line = [
                        r.symbol,
                        r.repeatScore,
                        `"${r.entryMode}"`,
                        r.gapToEntryPct,
                        r.bounces,
                        r.avgHitBars,
                        r.lastBounceAgo,
                        r.entrySuggested,
                        r.tpPct,
                        r.slPct,
                        r.rr,
                        r.lenBars,
                        `"${fmtDuration(r.lenBars, interval)}"`,
                        r.widthPct,
                        r.driftPct,
                        r.posPct,
                        r.volRangePct,
                        r.lowStreakEnd,
                        r.lastClose,
                        r.entryLine,
                        r.targetLevel,
                        r.stopLevel,
                        r.rangeLow,
                        r.rangeHigh,
                        `"${toSeoul(r.startTime)}"`
                    ].join(",");
                    lines.push(line);
                }

                return lines.join("\n");
            }

            function downloadText(filename, text) {
                const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            }

            async function workerLoop(cfg) {
                const signal = state.abortController.signal;

                while (state.queue.length > 0 && state.isRunning) {
                    if (signal.aborted) break;

                    const symbol = state.queue.shift();
                    if (!symbol) continue;

                    try {
                        if (cfg.delayMs > 0) {
                            await sleep(cfg.delayMs);
                        }

                        const data = await fetchKlinesWindow(symbol, cfg.interval, cfg.barsNeeded, signal);
                        const klines = data.candles;

                        if (!Array.isArray(klines) || klines.length < Math.min(60, cfg.barsNeeded)) {
                            state.err += 1;
                            state.done += 1;
                            continue;
                        }

                        const seg = findOngoingRangeSegment(klines, cfg);
                        if (seg) {
                            const tpPct = calcTpPct(seg.entrySuggested, seg.targetLevel);
                            const slPct = calcSlPct(seg.entrySuggested, seg.stopLevel);
                            const rr = calcRR(seg.entrySuggested, seg.targetLevel, seg.stopLevel);
                            const gapToEntryPct = calcGapToEntryPct(seg.lastClose, seg.entryLine);

                            const volAndStreak = computeVolAndLowStreak(klines, seg, cfg);
                            const repeatLookbackBars = Math.min(getRepeatLookbackBars(cfg), Math.max(1, seg.lenBars));

                            const tmp = {
                                symbol,
                                ...seg,

                                tpPct,
                                slPct,
                                rr,
                                gapToEntryPct,

                                volRatio: volAndStreak.volRatio,
                                volRangePct: volAndStreak.volRangePct,
                                lowStreakEnd: volAndStreak.lowStreakEnd,

                                repeatLookbackBars
                            };

                            const repeatScore = calcRepeatScore(tmp, cfg);

                            state.results.push({
                                ...tmp,
                                repeatScore
                            });
                        }

                        state.ok += 1;
                        state.done += 1;

                        if (cfg.liveRender && (state.done % 10 === 0 || state.done === state.symbols.length)) {
                            renderTable();
                        }
                    } catch (e) {
                        const msg = e?.message || String(e);
                        if (msg !== "aborted") {
                            state.err += 1;
                            logLine(`${symbol}: ${msg}`, "err");
                        }
                        state.done += 1;
                    } finally {
                        updateCountersUI();
                        updateProgressUI();
                    }
                }
            }

            async function startScan() {
                const cfg = getConfig();
                if (state.isRunning) return;

                if (cfg.targetZonePct <= cfg.entryZonePct + 5) {
                    logLine("Target(%)는 Entry(%)보다 충분히 커야 해요. (권장: Entry 30 / Target 65~70)", "warn");
                }

                state.isRunning = true;
                state.abortController = new AbortController();
                state.startedAt = Date.now();

                setRunningUI(true);
                els.exportBtn.disabled = true;

                state.symbols = [];
                state.queue = [];
                state.ok = 0;
                state.err = 0;
                state.done = 0;
                state.results = [];

                els.logBox.textContent = "";
                els.tbody.innerHTML = `
                    <tr>
                        <td colspan="26" class="muted" style="padding: 14px;">
                            스캔 준비 중...
                        </td>
                    </tr>
                `;

                updateCountersUI();
                updateProgressUI();

                logLine(`스캔 시작 · TF=${cfg.interval}, 최근=${cfg.days}일(${cfg.barsNeeded} bars)`);
                logLine(`폭 ${cfg.minRangePct}~${cfg.bandPct}%, drift≤${cfg.driftMaxPct}%, wicks=${cfg.useWicks ? "ON" : "OFF"}`);
                logLine(`Entry≤${cfg.entryZonePct}%, Target≥${cfg.targetZonePct}%, StopBuf=${cfg.stopBufferPct}%`);
                logLine(`BounceFilter=${cfg.bounceFilterEnabled ? `ON(bounce≥${cfg.minBounces})` : "OFF"} · concurrency=${cfg.concurrency}, delayMs=${cfg.delayMs}`);
                logLine("RepeatScore 기준: Entry 근접/NOW + Bounce 반복 + TP/RR + 안정성 − LowStreak/SL 패널티");

                state.tickTimer = setInterval(() => {
                    if (state.isRunning) tickElapsed();
                }, 250);

                try {
                    els.progressText.textContent = "심볼 목록 불러오는 중...";
                    state.symbols = await getUsdtPerpSymbols(state.abortController.signal);
                    state.queue = state.symbols.slice();

                    updateCountersUI();
                    updateProgressUI();
                    logLine(`심볼 ${state.symbols.length}개 로드 완료`);

                    const workers = [];
                    for (let i = 0; i < cfg.concurrency; i += 1) {
                        workers.push(workerLoop(cfg));
                    }

                    await Promise.all(workers);

                    if (state.isRunning) {
                        logLine("스캔 완료");
                    } else {
                        logLine("스캔 중지됨", "warn");
                    }
                } catch (e) {
                    logLine(`전체 오류: ${e?.message || String(e)}`, "err");
                } finally {
                    stopScan(false);
                    renderTable();
                    els.exportBtn.disabled = state.results.length === 0;
                    updateCountersUI();
                    updateProgressUI();
                }
            }

            function stopScan(userClick = true) {
                if (!state.isRunning && userClick) return;

                state.isRunning = false;

                if (state.abortController) {
                    try { state.abortController.abort(); } catch (_) {}
                }
                state.abortController = null;

                if (state.tickTimer) {
                    clearInterval(state.tickTimer);
                    state.tickTimer = null;
                }

                setRunningUI(false);
                els.exportBtn.disabled = state.results.length === 0;

                if (userClick) logLine("중지 요청", "warn");
            }

            function clearAll() {
                if (state.isRunning) stopScan(true);

                state.symbols = [];
                state.queue = [];
                state.ok = 0;
                state.err = 0;
                state.done = 0;
                state.results = [];

                state.sortKey = DEFAULT_SORT.key;
                state.sortDir = DEFAULT_SORT.dir;

                els.logBox.textContent = "";
                els.progressText.textContent = "대기 중";
                els.progressMeta.textContent = "0 / 0";
                els.progressBar.style.width = "0%";
                els.elapsedText.textContent = "00:00";
                els.renderInfo.textContent = "-";

                els.tbody.innerHTML = `
                    <tr>
                        <td colspan="26" class="muted" style="padding: 14px;">
                            아직 결과가 없습니다. “스캔 시작”을 눌러주세요.
                        </td>
                    </tr>
                `;

                setRunningUI(false);
                updateCountersUI();
                getConfig();
                updateSortIcons();
                logLine("초기화 완료");
            }

            els.startBtn.addEventListener("click", () => startScan());
            els.stopBtn.addEventListener("click", () => stopScan(true));
            els.clearBtn.addEventListener("click", () => clearAll());
            els.searchInput.addEventListener("input", () => renderTable());

            els.exportBtn.addEventListener("click", () => {
                const cfg = getConfig();
                const sorted = sortResults(state.results, cfg);
                const filtered = filterResults(sorted, els.searchInput.value);
                const csv = toCsv(filtered, cfg.interval);
                const filename = `repeat_long_range_${cfg.interval}_${cfg.days}d.csv`;
                downloadText(filename, csv);
            });

            function init() {
                setRunningUI(false);
                updateCountersUI();
                getConfig();
                bindSortingHeaders();

                logLine("준비 완료. 기본 정렬은 RepeatScore(하단 롱 반복 적합도) 내림차순입니다.");
                logLine("Gap%: NOW면 0, WAIT이면 EntryLine까지 필요한 하락 거리(%). 낮을수록 진입 가까움.");
                logLine("AvgHit(bars): 하단 진입존 → Target 도달 평균 바수(낮을수록 ‘되돌림’이 빠름).");
                logLine("LowStreak: 최근 연속으로 하단(EntryLine) 아래를 터치한 바 수(길면 깨질 위험 패널티).");
            }

            init();
        </script>
    </body>
</html>
