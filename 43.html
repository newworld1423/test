<!doctype html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — 횡보 하단 롱 반복 스캐너 (WinRate/AvgR Score)</title>
        <style>
            :root {
                --bg: #0b1020;
                --panel: rgba(255, 255, 255, 0.06);
                --text: rgba(255, 255, 255, 0.92);
                --muted: rgba(255, 255, 255, 0.65);
                --line: rgba(255, 255, 255, 0.12);
                --good: #7ee787;
                --bad: #ff7b72;
                --warn: #ffa657;
                --btn: rgba(255, 255, 255, 0.10);
                --btnHover: rgba(255, 255, 255, 0.16);
                --shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
                --radius: 14px;
            }

            * { box-sizing: border-box; }
            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, sans-serif;
                color: var(--text);
                background:
                    radial-gradient(1000px 600px at 10% 0%, rgba(99, 102, 241, 0.20), transparent 60%),
                    radial-gradient(1000px 700px at 90% 10%, rgba(16, 185, 129, 0.12), transparent 60%),
                    radial-gradient(900px 600px at 50% 100%, rgba(244, 63, 94, 0.10), transparent 60%),
                    var(--bg);
            }

            .wrap {
                max-width: 1420px;
                margin: 0 auto;
                padding: 22px 16px 40px;
            }

            header {
                display: flex;
                flex-wrap: wrap;
                align-items: flex-end;
                justify-content: space-between;
                gap: 12px;
                margin-bottom: 14px;
            }

            h1 {
                font-size: 20px;
                margin: 0;
                letter-spacing: -0.3px;
            }

            .sub {
                font-size: 12px;
                color: var(--muted);
                margin-top: 6px;
                line-height: 1.55;
            }

            .grid {
                display: grid;
                grid-template-columns: 1.2fr 0.8fr;
                gap: 14px;
                align-items: start;
            }

            @media (max-width: 980px) {
                .grid { grid-template-columns: 1fr; }
            }

            .card {
                background: var(--panel);
                border: 1px solid var(--line);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                overflow: hidden;
            }

            .cardHead {
                padding: 14px 14px 10px;
                border-bottom: 1px solid var(--line);
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }

            .cardTitle {
                font-weight: 650;
                font-size: 13px;
                color: rgba(255, 255, 255, 0.88);
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .badge {
                font-size: 11px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: var(--muted);
            }

            .tag {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 11px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: rgba(255, 255, 255, 0.86);
                white-space: nowrap;
            }

            .tagNow {
                border-color: rgba(126, 231, 135, 0.45);
                background: rgba(126, 231, 135, 0.16);
                color: var(--good);
                font-weight: 700;
            }

            .tagWait {
                border-color: rgba(255, 166, 87, 0.40);
                background: rgba(255, 166, 87, 0.14);
                color: var(--warn);
                font-weight: 700;
            }

            .cardBody { padding: 14px; }

            .controls {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }

            @media (max-width: 980px) {
                .controls { grid-template-columns: repeat(2, 1fr); }
            }

            .field label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin: 0 0 6px;
            }

            select, input[type="number"], input[type="text"] {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.25);
                color: var(--text);
                outline: none;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-top: 12px;
                align-items: center;
            }

            .btn {
                appearance: none;
                border: 1px solid var(--line);
                background: var(--btn);
                color: var(--text);
                border-radius: 12px;
                padding: 10px 12px;
                font-weight: 650;
                cursor: pointer;
                transition: 140ms ease;
            }

            .btn:hover { background: var(--btnHover); }
            .btn:disabled { opacity: 0.55; cursor: not-allowed; }

            .btnPrimary {
                border-color: rgba(16, 185, 129, 0.35);
                background: rgba(16, 185, 129, 0.14);
            }
            .btnPrimary:hover { background: rgba(16, 185, 129, 0.20); }

            .btnDanger {
                border-color: rgba(244, 63, 94, 0.38);
                background: rgba(244, 63, 94, 0.14);
            }
            .btnDanger:hover { background: rgba(244, 63, 94, 0.20); }

            .switch {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                font-size: 12px;
                color: var(--muted);
                user-select: none;
            }

            .switch input { width: 18px; height: 18px; }

            .progressBox {
                margin-top: 12px;
                padding: 12px;
                border: 1px solid var(--line);
                border-radius: 12px;
                background: rgba(0, 0, 0, 0.18);
            }

            .progressTop {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
                margin-bottom: 8px;
            }

            .mono {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }

            .bar {
                height: 10px;
                border-radius: 999px;
                overflow: hidden;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid var(--line);
            }

            .bar > div {
                height: 100%;
                width: 0%;
                background: linear-gradient(90deg, rgba(16, 185, 129, 0.9), rgba(99, 102, 241, 0.9));
                transition: width 120ms ease;
            }

            .smallGrid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 3px 9px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.06);
                color: rgba(255, 255, 255, 0.86);
                font-size: 12px;
                white-space: nowrap;
            }

            .good { color: var(--good); }
            .bad { color: var(--bad); }
            .warn { color: var(--warn); }
            .muted { color: var(--muted); }
            .right { text-align: right; }

            .kv {
                display: grid;
                grid-template-columns: 130px 1fr;
                gap: 10px;
                align-items: center;
                font-size: 12px;
                color: var(--muted);
                margin-top: 8px;
            }

            .kv b {
                color: rgba(255, 255, 255, 0.82);
                font-weight: 700;
            }

            .log {
                height: 220px;
                overflow: auto;
                padding: 10px;
                border-radius: 12px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.22);
                font-size: 12px;
                color: rgba(255, 255, 255, 0.80);
                line-height: 1.5;
                white-space: pre-wrap;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }

            thead th {
                position: sticky;
                top: 0;
                background: rgba(10, 14, 28, 0.85);
                backdrop-filter: blur(6px);
                border-bottom: 1px solid var(--line);
                padding: 10px 10px;
                text-align: left;
                color: rgba(255, 255, 255, 0.82);
                font-weight: 700;
                white-space: nowrap;
            }

            thead th.sortable {
                cursor: pointer;
                user-select: none;
            }

            thead th.sortable:hover {
                background: rgba(255, 255, 255, 0.06);
            }

            thead th.sortable:focus {
                outline: 2px solid rgba(99, 102, 241, 0.50);
                outline-offset: -2px;
            }

            thead th .sortIcon {
                display: inline-block;
                margin-left: 6px;
                font-size: 11px;
                opacity: 0.85;
            }

            tbody td {
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                padding: 9px 10px;
                vertical-align: middle;
                white-space: nowrap;
            }

            tbody tr:hover { background: rgba(255, 255, 255, 0.04); }

            .cellNow {
                color: var(--good);
                font-weight: 800;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <header>
                <div>
                    <h1>바이낸스 USDT 무기한 — “횡보 하단 롱 반복” 스캐너 (WinRate/AvgR Score)</h1>
                    <div class="sub">
                        네 전략에 맞게 <b>과거 시도(Attempts) 대비 승률(WinRate) + 평균 기대R(AvgR)</b>을 계산해 점수를 매깁니다.<br />
                        기본 정렬: <b>RepeatScore</b> 높은 순 (하단 롱 반복 적합도).<br />
                        <b>TP%/SL%</b>: Entry(진입가) 기준 목표/손절 도달 시 수익률·손실률(%).
                    </div>
                </div>
                <div class="pill mono">API: fapi.binance.com</div>
            </header>

            <div class="grid">
                <section class="card">
                    <div class="cardHead">
                        <div class="cardTitle">
                            설정
                            <span class="badge">기본값: 15m 추천</span>
                        </div>
                        <div class="badge mono" id="statusBadge">IDLE</div>
                    </div>
                    <div class="cardBody">
                        <div class="controls">
                            <div class="field">
                                <label>타임프레임</label>
                                <select id="tfSelect">
                                    <option value="15m" selected>15m</option>
                                    <option value="1h">1h</option>
                                    <option value="4h">4h</option>
                                    <option value="1d">1d</option>
                                </select>
                            </div>

                            <div class="field">
                                <label>최근 X일</label>
                                <input id="daysInput" type="number" min="1" max="365" step="1" value="14" />
                            </div>

                            <div class="field">
                                <label>Band (폭% ≤)</label>
                                <input id="bandInput" type="number" min="0.5" max="60" step="0.1" value="10.0" />
                            </div>

                            <div class="field">
                                <label>Drift (시작~현재% ≤)</label>
                                <input id="driftInput" type="number" min="0.1" max="60" step="0.1" value="6.0" />
                            </div>

                            <div class="field">
                                <label>Entry (하단% ≤)</label>
                                <input id="entryZoneInput" type="number" min="5" max="45" step="1" value="30" />
                            </div>

                            <div class="field">
                                <label>Target (상단% ≥)</label>
                                <input id="targetZoneInput" type="number" min="50" max="95" step="1" value="67" />
                            </div>

                            <div class="field">
                                <label>Stop Buffer(저점 아래 %)</label>
                                <input id="stopBufInput" type="number" min="0.0" max="12" step="0.1" value="1.8" />
                            </div>

                            <div class="field">
                                <label>Min Range (폭% ≥)</label>
                                <input id="minRangeInput" type="number" min="0.0" max="60" step="0.1" value="0.9" />
                            </div>

                            <div class="field">
                                <label>최소 Bounce(N)</label>
                                <input id="minBouncesInput" type="number" min="0" max="50" step="1" value="2" />
                            </div>

                            <div class="field">
                                <label>최소 Attempts(시도)</label>
                                <input id="minAttemptsInput" type="number" min="0" max="100" step="1" value="3" />
                            </div>

                            <div class="field">
                                <label>Min WinRate(%)</label>
                                <input id="minWinRateInput" type="number" min="0" max="100" step="1" value="55" />
                            </div>

                            <div class="field">
                                <label>표시 Top N</label>
                                <input id="topInput" type="number" min="10" max="500" step="10" value="150" />
                            </div>

                            <div class="field">
                                <label>동시 요청(concurrency)</label>
                                <input id="concInput" type="number" min="1" max="12" step="1" value="4" />
                            </div>

                            <div class="field">
                                <label>요청 간 딜레이(ms)</label>
                                <input id="delayInput" type="number" min="0" max="2000" step="10" value="220" />
                            </div>

                            <div class="field">
                                <label>검색(심볼)</label>
                                <input id="searchInput" type="text" placeholder="예: BTC, ETH, SOL..." />
                            </div>
                        </div>

                        <div class="row">
                            <label class="switch">
                                <input id="wicksToggle" type="checkbox" />
                                레인지 계산에 윅 포함(고/저) — 더 보수적
                            </label>

                            <label class="switch">
                                <input id="bounceFilterToggle" type="checkbox" checked />
                                Bounce 조건 적용
                            </label>

                            <label class="switch">
                                <input id="winrateFilterToggle" type="checkbox" checked />
                                WinRate/Attempts 필터 적용(권장)
                            </label>

                            <label class="switch">
                                <input id="liveToggle" type="checkbox" checked />
                                실시간 표 갱신
                            </label>
                        </div>

                        <div class="row">
                            <button class="btn btnPrimary" id="startBtn">스캔 시작</button>
                            <button class="btn btnDanger" id="stopBtn" disabled>중지</button>
                            <button class="btn" id="clearBtn">초기화</button>
                            <button class="btn" id="exportBtn" disabled>CSV 내보내기</button>
                        </div>

                        <div class="progressBox">
                            <div class="progressTop">
                                <div class="mono" id="progressText">대기 중</div>
                                <div class="mono muted" id="progressMeta">0 / 0</div>
                            </div>
                            <div class="bar"><div id="progressBar"></div></div>

                            <div class="kv">
                                <b>윈도우 바 수</b>
                                <span class="mono muted" id="barsInfo">-</span>

                                <b>횡보 판정</b>
                                <span class="mono muted" id="ruleText">-</span>

                                <b>RepeatScore</b>
                                <span class="muted">
                                    WinRate·AvgR·Entry근접·안정성(Drift/폭/Vol) − 하단체류/하방침범 패널티
                                </span>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="card">
                    <div class="cardHead">
                        <div class="cardTitle">
                            로그 / 상태
                            <span class="badge">429 자동 백오프</span>
                        </div>
                        <div class="badge mono" id="elapsedText">00:00</div>
                    </div>
                    <div class="cardBody">
                        <div class="smallGrid">
                            <div class="pill">
                                <span class="muted">심볼</span>
                                <span class="mono" id="symCount">-</span>
                            </div>
                            <div class="pill">
                                <span class="muted">성공</span>
                                <span class="mono good" id="okCount">0</span>
                            </div>
                            <div class="pill">
                                <span class="muted">실패</span>
                                <span class="mono bad" id="errCount">0</span>
                            </div>
                            <div class="pill">
                                <span class="muted">결과</span>
                                <span class="mono" id="resCount">0</span>
                            </div>
                        </div>

                        <div style="height: 10px;"></div>
                        <div class="log mono" id="logBox"></div>
                    </div>
                </section>
            </div>

            <div style="height: 14px;"></div>

            <section class="card">
                <div class="cardHead">
                    <div class="cardTitle">
                        결과 (RepeatScore 높은 순)
                        <span class="badge">Score ↓</span>
                    </div>
                    <div class="badge mono" id="renderInfo">-</div>
                </div>
                <div class="cardBody" style="padding: 0;">
                    <div style="overflow: auto; max-height: 720px;">
                        <table>
                            <thead>
                                <tr>
                                    <th class="right">#</th>

                                    <th class="sortable" data-key="symbol" data-type="string" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Symbol<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="repeatScore" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        RepeatScore<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="entryMode" data-type="enum" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Entry Mode<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="gapToEntryPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Gap%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="attempts" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Attempts<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="winRatePct" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        WinRate%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="avgR" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        AvgR<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="bounces" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Wins(Bounce)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lastBounceAgo" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        LastWinAgo<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="entrySuggested" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Entry(진입)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="tpPct" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        TP%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="slPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        SL%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="rr" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        RR<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lenBars" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Len(bars)<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="widthPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        폭%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="driftPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Drift%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="posPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Pos%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="volRangePct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Vol%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lowStreakEnd" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        LowStreak<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="breachDepthPct" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        Breach%<span class="sortIcon"></span>
                                    </th>

                                    <th class="right sortable" data-key="lastClose" data-type="number" data-default-dir="desc" tabindex="0" role="button" aria-sort="none">
                                        Now(종가)<span class="sortIcon"></span>
                                    </th>

                                    <th class="sortable" data-key="startTime" data-type="number" data-default-dir="asc" tabindex="0" role="button" aria-sort="none">
                                        시작(서울)<span class="sortIcon"></span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="tbody">
                                <tr>
                                    <td colspan="23" class="muted" style="padding: 14px;">
                                        아직 결과가 없습니다. “스캔 시작”을 눌러주세요.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </div>

        <script>
            "use strict";

            const BASE_URL = "https://fapi.binance.com";
            const PAGE_LIMIT = 499;

            const DEFAULT_SORT = {
                key: "repeatScore",
                dir: "desc"
            };

            const els = {
                statusBadge: document.getElementById("statusBadge"),
                elapsedText: document.getElementById("elapsedText"),

                tfSelect: document.getElementById("tfSelect"),
                daysInput: document.getElementById("daysInput"),
                bandInput: document.getElementById("bandInput"),
                driftInput: document.getElementById("driftInput"),
                entryZoneInput: document.getElementById("entryZoneInput"),
                targetZoneInput: document.getElementById("targetZoneInput"),
                stopBufInput: document.getElementById("stopBufInput"),
                minRangeInput: document.getElementById("minRangeInput"),
                minBouncesInput: document.getElementById("minBouncesInput"),
                minAttemptsInput: document.getElementById("minAttemptsInput"),
                minWinRateInput: document.getElementById("minWinRateInput"),
                topInput: document.getElementById("topInput"),
                concInput: document.getElementById("concInput"),
                delayInput: document.getElementById("delayInput"),
                searchInput: document.getElementById("searchInput"),

                wicksToggle: document.getElementById("wicksToggle"),
                bounceFilterToggle: document.getElementById("bounceFilterToggle"),
                winrateFilterToggle: document.getElementById("winrateFilterToggle"),
                liveToggle: document.getElementById("liveToggle"),

                startBtn: document.getElementById("startBtn"),
                stopBtn: document.getElementById("stopBtn"),
                clearBtn: document.getElementById("clearBtn"),
                exportBtn: document.getElementById("exportBtn"),

                progressText: document.getElementById("progressText"),
                progressMeta: document.getElementById("progressMeta"),
                progressBar: document.getElementById("progressBar"),
                barsInfo: document.getElementById("barsInfo"),
                ruleText: document.getElementById("ruleText"),

                symCount: document.getElementById("symCount"),
                okCount: document.getElementById("okCount"),
                errCount: document.getElementById("errCount"),
                resCount: document.getElementById("resCount"),

                logBox: document.getElementById("logBox"),
                renderInfo: document.getElementById("renderInfo"),
                tbody: document.getElementById("tbody")
            };

            const state = {
                isRunning: false,
                abortController: null,
                startedAt: 0,
                tickTimer: null,

                symbols: [],
                queue: [],
                ok: 0,
                err: 0,
                done: 0,

                results: [],

                sortKey: DEFAULT_SORT.key,
                sortDir: DEFAULT_SORT.dir
            };

            function logLine(msg, type = "info") {
                const ts = new Date().toLocaleTimeString("ko-KR", { hour12: false });
                const prefix = type === "err" ? "[ERR]" : (type === "warn" ? "[WARN]" : "[LOG]");
                els.logBox.textContent += `${ts} ${prefix} ${msg}\n`;
                els.logBox.scrollTop = els.logBox.scrollHeight;
            }

            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            function clampNum(n, min, max, fallback) {
                const x = Number(n);
                if (!Number.isFinite(x)) return fallback;
                return Math.min(max, Math.max(min, x));
            }

            function clamp(x, min, max) {
                return Math.min(max, Math.max(min, x));
            }

            function intervalToMs(interval) {
                const m = String(interval).match(/^(\d+)([mhdwM])$/);
                if (!m) return null;
                const num = Number(m[1]);
                const unit = m[2];

                if (unit === "m") return num * 60 * 1000;
                if (unit === "h") return num * 60 * 60 * 1000;
                if (unit === "d") return num * 24 * 60 * 60 * 1000;
                if (unit === "w") return num * 7 * 24 * 60 * 60 * 1000;
                if (unit === "M") return num * 30 * 24 * 60 * 60 * 1000;
                return null;
            }

            function calcBarsNeeded(days, interval) {
                const ms = intervalToMs(interval);
                if (!ms) return 0;
                const dayMs = 24 * 60 * 60 * 1000;
                return Math.ceil((days * dayMs) / ms);
            }

            function toSeoul(ts) {
                try {
                    return new Date(ts).toLocaleString("ko-KR", { timeZone: "Asia/Seoul", hour12: false });
                } catch (_) {
                    return new Date(ts).toISOString().replace(".000Z", "Z");
                }
            }

            function widthPct(minVal, maxVal) {
                const mid = (minVal + maxVal) / 2;
                if (!Number.isFinite(mid) || mid === 0) return Infinity;
                return ((maxVal - minVal) / mid) * 100;
            }

            function calcRR(entry, target, stop) {
                const e = Number(entry);
                const t = Number(target);
                const s = Number(stop);

                if (!Number.isFinite(e) || !Number.isFinite(t) || !Number.isFinite(s)) return NaN;

                const reward = t - e;
                const risk = e - s;

                if (!(reward > 0) || !(risk > 0)) return NaN;

                return reward / risk;
            }

            function calcTpPct(entry, target) {
                const e = Number(entry);
                const t = Number(target);
                if (!Number.isFinite(e) || !Number.isFinite(t) || !(e > 0)) return NaN;
                return ((t - e) / e) * 100;
            }

            function calcSlPct(entry, stop) {
                const e = Number(entry);
                const s = Number(stop);
                if (!Number.isFinite(e) || !Number.isFinite(s) || !(e > 0)) return NaN;
                return ((e - s) / e) * 100;
            }

            function calcGapToEntryPct(lastClose, entryLine) {
                const c = Number(lastClose);
                const e = Number(entryLine);
                if (!Number.isFinite(c) || !Number.isFinite(e) || !(c > 0)) return NaN;
                if (c <= e) return 0;
                return ((c - e) / c) * 100;
            }

            function getRepeatLookbackBars(cfg) {
                const ms = intervalToMs(cfg.interval) || 0;
                const targetMs = 36 * 60 * 60 * 1000;
                let bars = ms > 0 ? Math.floor(targetMs / ms) : 60;
                bars = Math.floor(clamp(bars, 12, 120));
                return bars;
            }

            function analyzeAttemptsAndWins(klines, segStartIdx, rangeLow, rangeHigh, cfg) {
                const n = klines.length;
                const last = n - 1;

                if (segStartIdx >= last) {
                    return {
                        wins: 0,
                        losses: 0,
                        attempts: 0,
                        winRatePct: NaN,
                        avgR: NaN,
                        lastWinAgo: NaN
                    };
                }

                const rangeAbs = rangeHigh - rangeLow;
                if (!(rangeAbs > 0)) {
                    return {
                        wins: 0,
                        losses: 0,
                        attempts: 0,
                        winRatePct: NaN,
                        avgR: NaN,
                        lastWinAgo: NaN
                    };
                }

                const entryUpper = rangeLow + rangeAbs * (cfg.entryZonePct / 100);
                const targetLevel = rangeLow + rangeAbs * (cfg.targetZonePct / 100);
                const stopLevel = rangeLow * (1 - cfg.stopBufferPct / 100);

                let wins = 0;
                let losses = 0;
                let attempts = 0;

                let rSum = 0;
                let rCount = 0;

                let lastWinIndex = -1;

                let i = segStartIdx;

                while (i < n) {
                    while (i < n) {
                        const close = Number(klines[i][4]);
                        if (Number.isFinite(close) && close <= entryUpper) break;
                        i += 1;
                    }
                    if (i >= n) break;

                    const entryIdx = i;
                    const entryPrice = Number(klines[i][4]);
                    if (!Number.isFinite(entryPrice) || !(entryPrice > 0)) {
                        i += 1;
                        continue;
                    }

                    const rr = calcRR(entryPrice, targetLevel, stopLevel);
                    const isRRFinite = Number.isFinite(rr) && rr > 0;

                    let j = i + 1;
                    let outcome = "none";

                    while (j < n) {
                        const high = Number(klines[j][2]);
                        const low = Number(klines[j][3]);
                        const close = Number(klines[j][4]);

                        if (cfg.useWicks) {
                            if (Number.isFinite(low) && low < stopLevel) {
                                outcome = "loss";
                                break;
                            }
                            if (Number.isFinite(high) && high >= targetLevel) {
                                outcome = "win";
                                break;
                            }
                        } else {
                            if (Number.isFinite(close) && close < stopLevel) {
                                outcome = "loss";
                                break;
                            }
                            if (Number.isFinite(close) && close >= targetLevel) {
                                outcome = "win";
                                break;
                            }
                        }

                        j += 1;
                    }

                    if (outcome === "win") {
                        wins += 1;
                        attempts += 1;
                        lastWinIndex = j;

                        if (isRRFinite) {
                            rSum += rr;
                            rCount += 1;
                        }

                        i = j + 1;
                        continue;
                    }

                    if (outcome === "loss") {
                        losses += 1;
                        attempts += 1;

                        rSum += -1;
                        rCount += 1;

                        i = j + 1;
                        continue;
                    }

                    i = n;
                }

                const winRatePct = attempts > 0 ? (wins / attempts) * 100 : NaN;
                const avgR = rCount > 0 ? (rSum / rCount) : NaN;
                const lastWinAgo = lastWinIndex >= 0 ? (n - 1 - lastWinIndex) : NaN;

                return {
                    wins,
                    losses,
                    attempts,
                    winRatePct,
                    avgR,
                    lastWinAgo
                };
            }

            function computeVolStreakBreach(klines, seg, cfg) {
                const n = klines.length;
                const rangeAbs = seg.rangeHigh - seg.rangeLow;
                if (!(rangeAbs > 0)) {
                    return { volRatio: NaN, volRangePct: NaN, lowStreakEnd: 0, breachDepthPct: NaN };
                }

                const lookback = Math.min(getRepeatLookbackBars(cfg), Math.max(1, seg.lenBars));
                const from = Math.max(0, n - lookback);

                let sumHL = 0;
                let cntHL = 0;
                let minLow = Infinity;

                for (let i = from; i < n; i += 1) {
                    const hi = Number(klines[i][2]);
                    const lo = Number(klines[i][3]);

                    if (Number.isFinite(hi) && Number.isFinite(lo) && hi > 0 && lo > 0) {
                        sumHL += (hi - lo);
                        cntHL += 1;
                        minLow = Math.min(minLow, lo);
                    }
                }

                const avgHL = cntHL > 0 ? (sumHL / cntHL) : NaN;
                const volRatio = (Number.isFinite(avgHL) && rangeAbs > 0) ? (avgHL / rangeAbs) : NaN;
                const volRangePct = Number.isFinite(volRatio) ? (volRatio * 100) : NaN;

                let streak = 0;
                for (let i = n - 1; i >= 0; i -= 1) {
                    const close = Number(klines[i][4]);
                    const low = Number(klines[i][3]);

                    const touchedLow = cfg.useWicks
                        ? (Number.isFinite(low) && low <= seg.entryLine)
                        : (Number.isFinite(close) && close <= seg.entryLine);

                    if (touchedLow) streak += 1;
                    else break;
                }

                const breachDepthPct = (Number.isFinite(minLow) && minLow < seg.rangeLow && seg.rangeLow > 0)
                    ? ((seg.rangeLow - minLow) / seg.rangeLow) * 100
                    : 0;

                return { volRatio, volRangePct, lowStreakEnd: streak, breachDepthPct };
            }

            function calcRepeatScore(r, cfg) {
                const entryNow = r.entryMode === "NOW" ? 1 : 0;

                const gap = Number(r.gapToEntryPct);
                const gapDen = Math.max(0.15, Math.min(3.0, (Number(r.widthPct) || 1) * 0.60));
                const proxScore = entryNow ? 1 : (Number.isFinite(gap) ? (1 - clamp(gap / gapDen, 0, 1)) : 0);

                const driftDen = Math.max(0.0001, cfg.driftMaxPct);
                const driftScore = 1 - clamp((Number(r.driftPct) || 0) / driftDen, 0, 1);

                const widthDen = Math.max(0.0001, (cfg.bandPct - cfg.minRangePct));
                const widthNorm = ((Number(r.widthPct) || 0) - cfg.minRangePct) / widthDen;
                const widthScore = 1 - clamp(widthNorm, 0, 1);

                const volScore = Number.isFinite(Number(r.volRatio))
                    ? (1 - clamp(Number(r.volRatio) / 0.40, 0, 1))
                    : 0.5;

                const lookback = Math.max(12, Math.min(120, Number(r.repeatLookbackBars) || getRepeatLookbackBars(cfg)));
                const recentScore = Number.isFinite(Number(r.lastWinAgo))
                    ? (1 - clamp(Number(r.lastWinAgo) / lookback, 0, 1))
                    : 0.4;

                const winRate = Number(r.winRatePct);
                const winRateScore = Number.isFinite(winRate) ? clamp((winRate - 45) / 35, 0, 1) : 0;

                const avgR = Number(r.avgR);
                const avgRScore = Number.isFinite(avgR) ? clamp((avgR + 0.2) / 1.0, 0, 1) : 0;

                const attempts = Number(r.attempts);
                const minAttempts = Math.max(1, cfg.minAttempts);
                const attemptsScore = Number.isFinite(attempts) ? clamp(attempts / Math.max(minAttempts, 3), 0, 1) : 0;

                const rr = Number(r.rr);
                const rrScore = Number.isFinite(rr) ? clamp((rr - 0.9) / 1.6, 0, 1) : 0;

                const tp = Number(r.tpPct);
                const tpScore = Number.isFinite(tp) ? clamp((tp - 0.25) / 1.5, 0, 1) : 0;

                const sl = Number(r.slPct);
                const slPenalty = Number.isFinite(sl) ? clamp((sl - 0.6) / 2.0, 0, 1) : 0.6;

                const streakPenalty = Number.isFinite(Number(r.lowStreakEnd))
                    ? clamp(Number(r.lowStreakEnd) / Math.max(4, cfg.minBounces * 3), 0, 1)
                    : 0;

                const breachPenalty = Number.isFinite(Number(r.breachDepthPct))
                    ? clamp(Number(r.breachDepthPct) / Math.max(0.2, cfg.stopBufferPct), 0, 1)
                    : 0;

                let score = 100 * (
                    0.24 * winRateScore +
                    0.18 * avgRScore +
                    0.10 * attemptsScore +
                    0.14 * proxScore +
                    0.08 * rrScore +
                    0.08 * tpScore +
                    0.06 * recentScore +
                    0.06 * driftScore +
                    0.04 * widthScore +
                    0.02 * volScore
                );

                score -= 16 * streakPenalty;
                score -= 10 * breachPenalty;
                score -= 8 * slPenalty;

                return clamp(score, 0, 100);
            }

            async function fetchJsonWithBackoff(url, signal, maxRetries = 6) {
                let attempt = 0;

                while (true) {
                    attempt += 1;

                    let res;
                    try {
                        res = await fetch(url, { method: "GET", headers: { "accept": "application/json" }, signal });
                    } catch (e) {
                        if (signal && signal.aborted) {
                            throw new Error("aborted");
                        }
                        throw e;
                    }

                    if (res.ok) {
                        return res.json();
                    }

                    const status = res.status;
                    const retryAfterHeader = res.headers.get("retry-after");
                    const retryAfterSec = retryAfterHeader ? Number(retryAfterHeader) : NaN;

                    let bodyText = "";
                    try {
                        bodyText = await res.text();
                    } catch (_) {
                        bodyText = "";
                    }

                    const isRate = (status === 429 || status === 418);
                    if (isRate && attempt <= maxRetries) {
                        let waitSec = retryAfterSec;
                        if (!Number.isFinite(waitSec) || waitSec <= 0) {
                            waitSec = Math.min(60, Math.pow(1.8, attempt));
                        }
                        logLine(`${status} 레이트리밋 → ${waitSec.toFixed(1)}s 백오프`, "warn");
                        await sleep(Math.floor(waitSec * 1000));
                        continue;
                    }

                    throw new Error(`HTTP ${status} :: ${bodyText.slice(0, 240)}`);
                }
            }

            async function getUsdtPerpSymbols(signal) {
                const url = `${BASE_URL}/fapi/v1/exchangeInfo`;
                const data = await fetchJsonWithBackoff(url, signal);

                const list = Array.isArray(data?.symbols) ? data.symbols : [];
                const syms = list
                    .filter((s) => {
                        if (!s) return false;
                        if (s.contractType !== "PERPETUAL") return false;
                        if (s.quoteAsset !== "USDT") return false;
                        if (s.status !== "TRADING") return false;
                        return true;
                    })
                    .map((s) => s.symbol);

                return Array.from(new Set(syms));
            }

            async function getKlinesPage(symbol, interval, limit, endTime, signal) {
                const qs = new URLSearchParams({
                    symbol,
                    interval,
                    limit: String(limit)
                });
                if (Number.isFinite(endTime) && endTime > 0) {
                    qs.set("endTime", String(Math.floor(endTime)));
                }
                const url = `${BASE_URL}/fapi/v1/klines?${qs.toString()}`;
                return fetchJsonWithBackoff(url, signal);
            }

            async function fetchKlinesWindow(symbol, interval, barsNeeded, signal) {
                const maxPages = Math.min(12, Math.max(1, Math.ceil(barsNeeded / PAGE_LIMIT)));
                const want = Math.min(barsNeeded, maxPages * PAGE_LIMIT);

                let endTime = Date.now();
                let all = [];
                let pages = 0;

                while (all.length < want && pages < maxPages) {
                    pages += 1;

                    const remaining = want - all.length;
                    const limit = Math.min(PAGE_LIMIT, remaining);

                    const batch = await getKlinesPage(symbol, interval, limit, endTime, signal);
                    if (!Array.isArray(batch) || batch.length === 0) break;

                    all = batch.concat(all);

                    const firstOpen = Number(batch[0]?.[0]);
                    if (!Number.isFinite(firstOpen)) break;

                    endTime = firstOpen - 1;
                }

                if (all.length > want) {
                    all = all.slice(all.length - want);
                }

                return { candles: all };
            }

            function findOngoingRangeSegment(klines, cfg) {
                const n = klines.length;
                if (n < 50) return null;

                const times = new Array(n);
                const closes = new Array(n);
                const highs = new Array(n);
                const lows = new Array(n);

                for (let i = 0; i < n; i += 1) {
                    const k = klines[i];
                    times[i] = Number(k[0]);
                    highs[i] = Number(k[2]);
                    lows[i] = Number(k[3]);
                    closes[i] = Number(k[4]);
                }

                const useMin = (idx) => (cfg.useWicks ? lows[idx] : closes[idx]);
                const useMax = (idx) => (cfg.useWicks ? highs[idx] : closes[idx]);

                const sufMin = new Array(n);
                const sufMax = new Array(n);

                sufMin[n - 1] = useMin(n - 1);
                sufMax[n - 1] = useMax(n - 1);

                for (let i = n - 2; i >= 0; i -= 1) {
                    const vMin = useMin(i);
                    const vMax = useMax(i);
                    sufMin[i] = Math.min(sufMin[i + 1], vMin);
                    sufMax[i] = Math.max(sufMax[i + 1], vMax);
                }

                const lastClose = closes[n - 1];

                const candidateIdx = [];
                for (let i = 0; i < n - 1; i += 1) {
                    const rangeLow = sufMin[i];
                    const rangeHigh = sufMax[i];

                    if (!Number.isFinite(rangeLow) || !Number.isFinite(rangeHigh) || rangeLow <= 0 || rangeHigh <= 0) {
                        continue;
                    }

                    const w = widthPct(rangeLow, rangeHigh);
                    if (!(w <= cfg.bandPct)) continue;
                    if (!(w >= cfg.minRangePct)) continue;

                    const startClose = closes[i];
                    const drift = (Number.isFinite(startClose) && startClose > 0)
                        ? (Math.abs(lastClose - startClose) / startClose) * 100
                        : Infinity;

                    if (!(drift <= cfg.driftMaxPct)) continue;

                    candidateIdx.push(i);
                }

                if (candidateIdx.length === 0) return null;

                const K = 50;
                const limit = Math.min(K, candidateIdx.length);

                for (let c = 0; c < limit; c += 1) {
                    const i = candidateIdx[c];

                    const rangeLow = sufMin[i];
                    const rangeHigh = sufMax[i];

                    const w = widthPct(rangeLow, rangeHigh);

                    const startClose = closes[i];
                    const drift = (Number.isFinite(startClose) && startClose > 0)
                        ? (Math.abs(lastClose - startClose) / startClose) * 100
                        : Infinity;

                    const rangeAbs = rangeHigh - rangeLow;
                    if (!(rangeAbs > 0)) continue;

                    const entryLine = rangeLow + rangeAbs * (cfg.entryZonePct / 100);
                    const targetLevel = rangeLow + rangeAbs * (cfg.targetZonePct / 100);
                    const stopLevel = rangeLow * (1 - cfg.stopBufferPct / 100);

                    const posPct = clamp(((lastClose - rangeLow) / rangeAbs) * 100, 0, 100);

                    const stats = analyzeAttemptsAndWins(klines, i, rangeLow, rangeHigh, cfg);

                    const bounceOk = !cfg.bounceFilterEnabled || stats.wins >= cfg.minBounces;
                    const winrateOk = !cfg.winrateFilterEnabled
                        || (
                            stats.attempts >= cfg.minAttempts
                            && Number.isFinite(stats.winRatePct)
                            && stats.winRatePct >= cfg.minWinRatePct
                        );

                    if (bounceOk && winrateOk) {
                        const nowInEntryZone = (Number.isFinite(lastClose) && lastClose <= entryLine);
                        const entryMode = nowInEntryZone ? "NOW" : "WAIT";
                        const entrySuggested = nowInEntryZone ? lastClose : entryLine;

                        return {
                            startIndex: i,
                            startTime: times[i],
                            lenBars: n - i,

                            widthPct: w,
                            driftPct: drift,

                            rangeLow,
                            rangeHigh,
                            lastClose,
                            posPct,

                            entryMode,
                            entrySuggested,
                            entryLine,
                            targetLevel,
                            stopLevel,

                            // win/loss stats
                            bounces: stats.wins,
                            losses: stats.losses,
                            attempts: stats.attempts,
                            winRatePct: stats.winRatePct,
                            avgR: stats.avgR,
                            lastWinAgo: stats.lastWinAgo
                        };
                    }
                }

                return null;
            }

            function setRunningUI(running) {
                els.startBtn.disabled = running;
                els.stopBtn.disabled = !running;
                els.exportBtn.disabled = running || state.results.length === 0;
                els.statusBadge.textContent = running ? "RUNNING" : "IDLE";
            }

            function updateCountersUI() {
                els.symCount.textContent = state.symbols.length ? String(state.symbols.length) : "-";
                els.okCount.textContent = String(state.ok);
                els.errCount.textContent = String(state.err);
                els.resCount.textContent = String(state.results.length);
            }

            function updateProgressUI() {
                const total = state.symbols.length || 0;
                const done = state.done || 0;
                const pct = total > 0 ? Math.min(100, (done / total) * 100) : 0;

                els.progressMeta.textContent = `${done} / ${total}`;
                els.progressBar.style.width = `${pct.toFixed(2)}%`;
                els.progressText.textContent = state.isRunning ? `스캔 중... (${pct.toFixed(1)}%)` : "대기 중";
            }

            function tickElapsed() {
                const sec = Math.floor((Date.now() - state.startedAt) / 1000);
                const mm = String(Math.floor(sec / 60)).padStart(2, "0");
                const ss = String(sec % 60).padStart(2, "0");
                els.elapsedText.textContent = `${mm}:${ss}`;
            }

            function getConfig() {
                const interval = els.tfSelect.value;
                const days = Math.floor(clampNum(els.daysInput.value, 1, 365, 14));

                const bandPct = clampNum(els.bandInput.value, 0.5, 60, 10.0);
                const driftMaxPct = clampNum(els.driftInput.value, 0.1, 60, 6.0);

                const entryZonePct = Math.floor(clampNum(els.entryZoneInput.value, 5, 45, 30));
                const targetZonePct = Math.floor(clampNum(els.targetZoneInput.value, 50, 95, 67));

                const stopBufferPct = clampNum(els.stopBufInput.value, 0.0, 12, 1.8);
                const minRangePct = clampNum(els.minRangeInput.value, 0.0, 60, 0.9);

                const minBounces = Math.floor(clampNum(els.minBouncesInput.value, 0, 50, 2));
                const minAttempts = Math.floor(clampNum(els.minAttemptsInput.value, 0, 100, 3));
                const minWinRatePct = clampNum(els.minWinRateInput.value, 0, 100, 55);

                const topN = Math.floor(clampNum(els.topInput.value, 10, 500, 150));

                const concurrency = Math.floor(clampNum(els.concInput.value, 1, 12, 4));
                const delayMs = Math.floor(clampNum(els.delayInput.value, 0, 2000, 220));

                const useWicks = !!els.wicksToggle.checked;
                const bounceFilterEnabled = !!els.bounceFilterToggle.checked;
                const winrateFilterEnabled = !!els.winrateFilterToggle.checked;
                const liveRender = !!els.liveToggle.checked;

                const barsNeeded = calcBarsNeeded(days, interval);
                const pagesNeeded = Math.min(12, Math.max(1, Math.ceil(barsNeeded / PAGE_LIMIT)));

                els.barsInfo.textContent = `${barsNeeded} bars (auto pages=${pagesNeeded})`;
                els.ruleText.textContent =
                    `윈도우=${days}d · 폭 ${minRangePct}~${bandPct}% · drift≤${driftMaxPct}% · entry≤${entryZonePct}% · target≥${targetZonePct}% · stop=${stopBufferPct}% · wins≥${minBounces}${bounceFilterEnabled ? "" : " (OFF)"} · attempts≥${minAttempts}, winrate≥${minWinRatePct}%${winrateFilterEnabled ? "" : " (OFF)"}`;

                return {
                    interval,
                    days,
                    barsNeeded,

                    bandPct,
                    driftMaxPct,

                    entryZonePct,
                    targetZonePct,

                    stopBufferPct,
                    minRangePct,

                    minBounces,
                    minAttempts,
                    minWinRatePct,

                    concurrency,
                    delayMs,

                    useWicks,
                    bounceFilterEnabled,
                    winrateFilterEnabled,
                    liveRender,

                    topN
                };
            }

            function filterResults(arr, q) {
                const query = String(q || "").trim().toUpperCase();
                if (!query) return arr;
                return arr.filter((r) => r.symbol.includes(query));
            }

            function getSortValue(r, key) {
                if (!r) return null;
                if (key === "entryMode") return r.entryMode === "NOW" ? 0 : 1;
                return r[key];
            }

            function defaultSortComparator(a, b) {
                if (b.repeatScore !== a.repeatScore) return b.repeatScore - a.repeatScore;
                if (a.entryMode !== b.entryMode) return (a.entryMode === "NOW" ? -1 : 1);
                if (b.winRatePct !== a.winRatePct) return (b.winRatePct || 0) - (a.winRatePct || 0);
                if (b.avgR !== a.avgR) return (b.avgR || -999) - (a.avgR || -999);
                if (b.attempts !== a.attempts) return (b.attempts || 0) - (a.attempts || 0);
                return a.symbol.localeCompare(b.symbol);
            }

            function sortResults(arr) {
                const out = arr.slice();

                const key = state.sortKey;
                const dir = state.sortDir;

                if (!key) {
                    out.sort(defaultSortComparator);
                    return out;
                }

                const safeKey = (CSS && CSS.escape) ? CSS.escape(key) : key;
                const th = document.querySelector(`thead th[data-key="${safeKey}"]`);
                const type = th?.dataset?.type || "auto";

                out.sort((a, b) => {
                    const va = getSortValue(a, key);
                    const vb = getSortValue(b, key);

                    let cmp = 0;

                    if (type === "string") {
                        cmp = String(va ?? "").localeCompare(String(vb ?? ""));
                    } else {
                        const na = Number(va);
                        const nb = Number(vb);

                        const fa = Number.isFinite(na);
                        const fb = Number.isFinite(nb);

                        if (!fa && !fb) cmp = 0;
                        else if (!fa) cmp = 1;
                        else if (!fb) cmp = -1;
                        else cmp = na - nb;
                    }

                    if (cmp === 0) {
                        cmp = a.symbol.localeCompare(b.symbol);
                        if (cmp === 0) cmp = defaultSortComparator(a, b);
                    }

                    return dir === "asc" ? cmp : -cmp;
                });

                return out;
            }

            function updateSortIcons() {
                const ths = document.querySelectorAll("thead th.sortable[data-key]");
                ths.forEach((th) => {
                    const key = th.dataset.key;
                    const icon = th.querySelector(".sortIcon");
                    if (!icon) return;

                    if (key === state.sortKey) {
                        const isAsc = state.sortDir === "asc";
                        icon.textContent = isAsc ? "▲" : "▼";
                        th.setAttribute("aria-sort", isAsc ? "ascending" : "descending");
                    } else {
                        icon.textContent = "";
                        th.setAttribute("aria-sort", "none");
                    }
                });
            }

            function onSortHeaderClick(th) {
                const key = th?.dataset?.key;
                if (!key) return;

                const defaultDir = th.dataset.defaultDir || ((th.dataset.type === "string") ? "asc" : "desc");

                if (state.sortKey === key) {
                    state.sortDir = state.sortDir === "asc" ? "desc" : "asc";
                } else {
                    state.sortKey = key;
                    state.sortDir = defaultDir;
                }

                updateSortIcons();
                renderTable();
            }

            function bindSortingHeaders() {
                const ths = document.querySelectorAll("thead th.sortable[data-key]");
                ths.forEach((th) => {
                    th.addEventListener("click", () => onSortHeaderClick(th));
                    th.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            onSortHeaderClick(th);
                        }
                    });
                });

                updateSortIcons();
            }

            function renderTable() {
                const cfg = getConfig();
                const sorted = sortResults(state.results);
                const filtered = filterResults(sorted, els.searchInput.value);
                const view = filtered.slice(0, cfg.topN);

                updateSortIcons();
                els.renderInfo.textContent = `표시 ${view.length} / 필터 ${filtered.length} / 전체 ${state.results.length}`;

                if (view.length === 0) {
                    els.tbody.innerHTML = `
                        <tr>
                            <td colspan="23" class="muted" style="padding: 14px;">
                                결과가 없습니다. (필터를 완화하거나 WinRate/Attempts 필터 OFF를 시도해보세요)
                            </td>
                        </tr>
                    `;
                    return;
                }

                let html = "";
                for (let i = 0; i < view.length; i += 1) {
                    const r = view[i];

                    const modeTag = r.entryMode === "NOW"
                        ? `<span class="tag tagNow">NOW</span>`
                        : `<span class="tag tagWait">WAIT</span>`;

                    const entrySugClass = r.entryMode === "NOW" ? "cellNow" : "";

                    const gapText = Number.isFinite(Number(r.gapToEntryPct)) ? Number(r.gapToEntryPct).toFixed(2) : "—";
                    const winText = Number.isFinite(Number(r.winRatePct)) ? Number(r.winRatePct).toFixed(1) : "—";
                    const avgRText = Number.isFinite(Number(r.avgR)) ? Number(r.avgR).toFixed(2) : "—";
                    const lastWinAgoText = Number.isFinite(Number(r.lastWinAgo)) ? String(Math.floor(Number(r.lastWinAgo))) : "—";

                    const tpText = Number.isFinite(Number(r.tpPct)) ? Number(r.tpPct).toFixed(2) : "—";
                    const slText = Number.isFinite(Number(r.slPct)) ? Number(r.slPct).toFixed(2) : "—";
                    const rrText = Number.isFinite(Number(r.rr)) ? Number(r.rr).toFixed(2) : "—";

                    const volText = Number.isFinite(Number(r.volRangePct)) ? Number(r.volRangePct).toFixed(1) : "—";
                    const breachText = Number.isFinite(Number(r.breachDepthPct)) ? Number(r.breachDepthPct).toFixed(2) : "—";

                    html += `
                        <tr>
                            <td class="right mono muted">${i + 1}</td>
                            <td class="mono"><b>${r.symbol}</b></td>

                            <td class="right mono"><b>${r.repeatScore.toFixed(1)}</b></td>
                            <td class="right">${modeTag}</td>
                            <td class="right mono muted">${gapText}</td>

                            <td class="right mono">${r.attempts}</td>
                            <td class="right mono">${winText}</td>
                            <td class="right mono">${avgRText}</td>

                            <td class="right mono">${r.bounces}</td>
                            <td class="right mono muted">${lastWinAgoText}</td>

                            <td class="right mono ${entrySugClass}">${r.entrySuggested.toFixed(6)}</td>
                            <td class="right mono">${tpText}</td>
                            <td class="right mono muted">${slText}</td>
                            <td class="right mono">${rrText}</td>

                            <td class="right mono">${r.lenBars}</td>
                            <td class="right mono">${r.widthPct.toFixed(3)}</td>
                            <td class="right mono muted">${r.driftPct.toFixed(3)}</td>
                            <td class="right mono muted">${r.posPct.toFixed(1)}</td>
                            <td class="right mono muted">${volText}</td>
                            <td class="right mono muted">${r.lowStreakEnd}</td>
                            <td class="right mono muted">${breachText}</td>

                            <td class="right mono">${r.lastClose.toFixed(6)}</td>
                            <td class="mono muted">${toSeoul(r.startTime)}</td>
                        </tr>
                    `;
                }

                els.tbody.innerHTML = html;
            }

            function toCsv(rows) {
                const header = [
                    "symbol",
                    "repeatScore",
                    "entryMode",
                    "gapToEntryPct",
                    "attempts",
                    "winRatePct",
                    "avgR",
                    "wins",
                    "losses",
                    "lastWinAgo",
                    "entrySuggested",
                    "tpPct",
                    "slPct",
                    "rr",
                    "lenBars",
                    "widthPct",
                    "driftPct",
                    "posPct",
                    "volRangePct",
                    "lowStreakEnd",
                    "breachDepthPct",
                    "lastClose",
                    "rangeStartSeoul"
                ];
                const lines = [header.join(",")];

                for (const r of rows) {
                    const line = [
                        r.symbol,
                        r.repeatScore,
                        `"${r.entryMode}"`,
                        r.gapToEntryPct,
                        r.attempts,
                        r.winRatePct,
                        r.avgR,
                        r.bounces,
                        r.losses,
                        r.lastWinAgo,
                        r.entrySuggested,
                        r.tpPct,
                        r.slPct,
                        r.rr,
                        r.lenBars,
                        r.widthPct,
                        r.driftPct,
                        r.posPct,
                        r.volRangePct,
                        r.lowStreakEnd,
                        r.breachDepthPct,
                        r.lastClose,
                        `"${toSeoul(r.startTime)}"`
                    ].join(",");
                    lines.push(line);
                }

                return lines.join("\n");
            }

            function downloadText(filename, text) {
                const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            }

            async function workerLoop(cfg) {
                const signal = state.abortController.signal;

                while (state.queue.length > 0 && state.isRunning) {
                    if (signal.aborted) break;

                    const symbol = state.queue.shift();
                    if (!symbol) continue;

                    try {
                        if (cfg.delayMs > 0) {
                            await sleep(cfg.delayMs);
                        }

                        const data = await fetchKlinesWindow(symbol, cfg.interval, cfg.barsNeeded, signal);
                        const klines = data.candles;

                        if (!Array.isArray(klines) || klines.length < Math.min(60, cfg.barsNeeded)) {
                            state.err += 1;
                            state.done += 1;
                            continue;
                        }

                        const seg = findOngoingRangeSegment(klines, cfg);
                        if (seg) {
                            const tpPct = calcTpPct(seg.entrySuggested, seg.targetLevel);
                            const slPct = calcSlPct(seg.entrySuggested, seg.stopLevel);
                            const rr = calcRR(seg.entrySuggested, seg.targetLevel, seg.stopLevel);
                            const gapToEntryPct = calcGapToEntryPct(seg.lastClose, seg.entryLine);

                            const vol = computeVolStreakBreach(klines, seg, cfg);
                            const repeatLookbackBars = Math.min(getRepeatLookbackBars(cfg), Math.max(1, seg.lenBars));

                            const tmp = {
                                symbol,
                                ...seg,

                                tpPct,
                                slPct,
                                rr,
                                gapToEntryPct,

                                volRatio: vol.volRatio,
                                volRangePct: vol.volRangePct,
                                lowStreakEnd: vol.lowStreakEnd,
                                breachDepthPct: vol.breachDepthPct,

                                repeatLookbackBars
                            };

                            const repeatScore = calcRepeatScore(tmp, cfg);

                            state.results.push({
                                ...tmp,
                                repeatScore
                            });
                        }

                        state.ok += 1;
                        state.done += 1;

                        if (cfg.liveRender && (state.done % 10 === 0 || state.done === state.symbols.length)) {
                            renderTable();
                        }
                    } catch (e) {
                        const msg = e?.message || String(e);
                        if (msg !== "aborted") {
                            state.err += 1;
                            logLine(`${symbol}: ${msg}`, "err");
                        }
                        state.done += 1;
                    } finally {
                        updateCountersUI();
                        updateProgressUI();
                    }
                }
            }

            async function startScan() {
                const cfg = getConfig();
                if (state.isRunning) return;

                state.isRunning = true;
                state.abortController = new AbortController();
                state.startedAt = Date.now();

                setRunningUI(true);
                els.exportBtn.disabled = true;

                state.symbols = [];
                state.queue = [];
                state.ok = 0;
                state.err = 0;
                state.done = 0;
                state.results = [];

                els.logBox.textContent = "";
                els.tbody.innerHTML = `
                    <tr>
                        <td colspan="23" class="muted" style="padding: 14px;">
                            스캔 준비 중...
                        </td>
                    </tr>
                `;

                updateCountersUI();
                updateProgressUI();

                logLine(`스캔 시작 · TF=${cfg.interval}, 최근=${cfg.days}일(${cfg.barsNeeded} bars)`);
                logLine(`WinRate/AvgR 기반 Score 적용 · WinRate 필터=${cfg.winrateFilterEnabled ? "ON" : "OFF"}`);

                state.tickTimer = setInterval(() => {
                    if (state.isRunning) tickElapsed();
                }, 250);

                try {
                    els.progressText.textContent = "심볼 목록 불러오는 중...";
                    state.symbols = await getUsdtPerpSymbols(state.abortController.signal);
                    state.queue = state.symbols.slice();

                    updateCountersUI();
                    updateProgressUI();
                    logLine(`심볼 ${state.symbols.length}개 로드 완료`);

                    const workers = [];
                    for (let i = 0; i < cfg.concurrency; i += 1) {
                        workers.push(workerLoop(cfg));
                    }

                    await Promise.all(workers);

                    if (state.isRunning) {
                        logLine("스캔 완료");
                    } else {
                        logLine("스캔 중지됨", "warn");
                    }
                } catch (e) {
                    logLine(`전체 오류: ${e?.message || String(e)}`, "err");
                } finally {
                    stopScan(false);
                    renderTable();
                    els.exportBtn.disabled = state.results.length === 0;
                    updateCountersUI();
                    updateProgressUI();
                }
            }

            function stopScan(userClick = true) {
                if (!state.isRunning && userClick) return;

                state.isRunning = false;

                if (state.abortController) {
                    try { state.abortController.abort(); } catch (_) {}
                }
                state.abortController = null;

                if (state.tickTimer) {
                    clearInterval(state.tickTimer);
                    state.tickTimer = null;
                }

                setRunningUI(false);
                els.exportBtn.disabled = state.results.length === 0;

                if (userClick) logLine("중지 요청", "warn");
            }

            function clearAll() {
                if (state.isRunning) stopScan(true);

                state.symbols = [];
                state.queue = [];
                state.ok = 0;
                state.err = 0;
                state.done = 0;
                state.results = [];

                state.sortKey = DEFAULT_SORT.key;
                state.sortDir = DEFAULT_SORT.dir;

                els.logBox.textContent = "";
                els.progressText.textContent = "대기 중";
                els.progressMeta.textContent = "0 / 0";
                els.progressBar.style.width = "0%";
                els.elapsedText.textContent = "00:00";
                els.renderInfo.textContent = "-";

                els.tbody.innerHTML = `
                    <tr>
                        <td colspan="23" class="muted" style="padding: 14px;">
                            아직 결과가 없습니다. “스캔 시작”을 눌러주세요.
                        </td>
                    </tr>
                `;

                setRunningUI(false);
                updateCountersUI();
                getConfig();
                updateSortIcons();
                logLine("초기화 완료");
            }

            els.startBtn.addEventListener("click", () => startScan());
            els.stopBtn.addEventListener("click", () => stopScan(true));
            els.clearBtn.addEventListener("click", () => clearAll());
            els.searchInput.addEventListener("input", () => renderTable());

            els.exportBtn.addEventListener("click", () => {
                const cfg = getConfig();
                const sorted = sortResults(state.results);
                const filtered = filterResults(sorted, els.searchInput.value);
                const csv = toCsv(filtered);
                const filename = `repeat_long_range_${cfg.interval}_${cfg.days}d_winrate.csv`;
                downloadText(filename, csv);
            });

            function init() {
                setRunningUI(false);
                updateCountersUI();
                getConfig();
                bindSortingHeaders();

                logLine("준비 완료. 기본 정렬=RepeatScore 내림차순.");
                logLine("중요: NOW라도 LowStreak/Breach%가 크면 ‘깨지는 레인지’일 확률이 있어 Score에서 강하게 패널티 줍니다.");
                logLine("WinRate/Attempts 필터 ON(권장): 최소 시도수/승률 기준을 통과한 후보만 보여줍니다.");
            }

            init();
        </script>
    </body>
</html>
