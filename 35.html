<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Binance USDT Perp - 멀티TF 컨펌 스윙 스캐너</title>
    <style>
        :root {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
        }
        body {
            margin: 20px;
            background: #0b0f14;
            color: #e6edf3;
        }
        .panel {
            display: grid;
            gap: 12px;
            padding: 16px;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            background: rgba(255,255,255,0.03);
            max-width: 1200px;
        }
        .row {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            gap: 10px;
        }
        .row > label {
            display: grid;
            gap: 6px;
            font-size: 12px;
            opacity: 0.95;
        }
        input, button, select {
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.16);
            background: rgba(255,255,255,0.04);
            color: #e6edf3;
            outline: none;
        }
        button {
            cursor: pointer;
            font-weight: 700;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.04);
        }
        .ok { border-color: rgba(0, 255, 171, 0.35); }
        .warn { border-color: rgba(255, 183, 77, 0.35); }
        .err { border-color: rgba(255, 77, 110, 0.45); }
        .muted { opacity: 0.7; font-size: 12px; }
        .progress { font-size: 12px; opacity: 0.85; }
        table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 16px;
            max-width: 1600px;
        }
        th, td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            font-size: 13px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background: rgba(255,255,255,0.05);
            position: sticky;
            top: 0;
        }
        tr:hover td { background: rgba(255,255,255,0.03); }
        a { color: #77b7ff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .log {
            white-space: pre-wrap;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            opacity: 0.85;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.03);
            max-width: 1600px;
            margin-top: 16px;
        }
        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.16);
            font-size: 12px;
        }
        .pillH { border-color: rgba(255, 110, 140, 0.55); }
        .pillL { border-color: rgba(0, 255, 171, 0.45); }
        .pillB { border-color: rgba(255, 210, 120, 0.55); }
        code.inline {
            padding: 1px 6px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.04);
        }
    </style>
</head>
<body>
    <h1 id="pageTitle" style="margin: 0 0 12px 0; font-size: 18px;">
        Binance USDT Perp - 멀티TF 컨펌 스윙 스캐너
    </h1>

    <div class="panel">
        <div class="row">
            <label>
                Interval (최종 스캔)
                <select id="interval">
                    <option value="15m">15m (1M+1w+1d+4h+1h+15m)</option>
                    <option value="1h">1h (1M+1w+1d+4h+1h)</option>
                    <option value="4h" selected>4h (1M+1w+1d+4h)</option>
                    <option value="1d">1d (1M+1w+1d)</option>
                    <option value="1w">1w (1M+1w)</option>
                    <option value="1M">1M (1M만)</option>
                </select>
            </label>

            <label>
                스윙 판정 방식 (고정)
                <select id="swingMode" disabled>
                    <option value="MONO" selected>계단형(단조): ↑↑ 후 ↓↓ / ↓↓ 후 ↑↑</option>
                </select>
            </label>

            <label>
                동시 요청 수 (concurrency)
                <input id="concurrency" type="number" min="1" max="25" value="8" />
            </label>

            <label>
                최대 심볼 수 (0=전체)
                <input id="maxSymbols" type="number" min="0" max="2000" value="0" />
            </label>

            <label>
                타입 필터
                <select id="typeFilter">
                    <option value="ALL" selected>전체(H/L/BOTH)</option>
                    <option value="H">스윙고점(H)</option>
                    <option value="L">스윙저점(L)</option>
                    <option value="BOTH">둘다(BOTH)</option>
                </select>
            </label>

            <label>
                정렬 기준(최종 interval 최근 5개 합)
                <select id="sortMode">
                    <option value="QUOTE" selected>거래대금(USDT) 합 (quoteVolume)</option>
                    <option value="BASE">거래량 합 (baseVolume)</option>
                </select>
            </label>

            <label>
                최소 거래대금(USDT) 합 (0=미사용)
                <input id="minQuoteSum" type="number" min="0" step="0.01" value="0" />
            </label>

            <label>
                최소 거래량 합 (0=미사용)
                <input id="minBaseSum" type="number" min="0" step="0.0001" value="0" />
            </label>
        </div>

        <div class="actions">
            <button id="startBtn">스캔 시작</button>
            <button id="stopBtn" disabled>중지</button>
            <span id="status" class="badge muted">대기</span>
            <span id="progress" class="progress"></span>
            <span class="muted">
                ※ 스윙판정: 닫힌 캔들 5개(현재봉 제외). 추가 필터:
                <b>각 TF에서 현재봉 low &lt; 직전봉 low면 제외</b>
            </span>
        </div>

        <div id="desc" class="muted"></div>
    </div>

    <table>
        <thead>
            <tr>
                <th style="width: 110px;">Final TF</th>
                <th style="width: 140px;">Symbol</th>
                <th style="width: 110px;">Type</th>
                <th style="width: 220px;">Pivot Time (3봉전)</th>
                <th style="width: 220px;">Pivot Price</th>
                <th style="width: 190px;">Chain (1M→…)</th>
                <th style="width: 170px;">Σ QuoteVol</th>
                <th style="width: 170px;">Σ BaseVol</th>
                <th style="width: 140px;">Last Close</th>
                <th>Links</th>
            </tr>
        </thead>
        <tbody id="tbody"></tbody>
    </table>

    <div id="log" class="log"></div>

    <script>
        const API_BASE = "https://fapi.binance.com";

        const LS_PREFIX = "multiTfSwingScanner:v4:";
        const LS_LAST_RESULTS = `${LS_PREFIX}lastResults`;
        const LS_TF_CACHE = `${LS_PREFIX}tfCache`;

        const TF_CACHE_SYMBOL_LIMIT = 800;
        const ANCHOR_SYMBOL = "BTCUSDT";

        const state = {
            running: false,
            aborter: null
        };

        function el(id) {
            return document.getElementById(id);
        }

        function setStatus(text, kind) {
            const badge = el("status");
            badge.textContent = text;
            badge.className = `badge ${kind || "muted"}`;
        }

        function logLine(msg) {
            const log = el("log");
            log.textContent = `${msg}\n${log.textContent}`.slice(0, 28000);
        }

        function fmtTime(ms) {
            try {
                return new Date(ms).toLocaleString("ko-KR", { timeZone: "Asia/Seoul" });
            } catch {
                return new Date(ms).toISOString();
            }
        }

        function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function readNumber(id, min, max, fallback) {
            const v = Number(el(id).value);
            if (!Number.isFinite(v)) return fallback;
            return Math.max(min, Math.min(max, v));
        }

        function readString(id, fallback) {
            const v = String(el(id).value || "").trim();
            return v || fallback;
        }

        function sum(values) {
            let s = 0;
            for (const v of values) s += v;
            return s;
        }

        function getIntervalChain(finalInterval) {
            if (finalInterval === "1M") return ["1M"];
            if (finalInterval === "1w") return ["1M", "1w"];
            if (finalInterval === "1d") return ["1M", "1w", "1d"];
            if (finalInterval === "4h") return ["1M", "1w", "1d", "4h"];
            if (finalInterval === "1h") return ["1M", "1w", "1d", "4h", "1h"];
            return ["1M", "1w", "1d", "4h", "1h", "15m"];
        }

        function updateTitleAndDesc() {
            const interval = readString("interval", "4h");
            const chain = getIntervalChain(interval);

            const title = `Binance USDT Perp - 멀티TF 컨펌 스윙 스캐너 (Final: ${interval.toUpperCase()})`;
            el("pageTitle").textContent = title;
            document.title = title;

            const desc = el("desc");
            desc.innerHTML = [
                `멀티TF 컨펌: <code class="inline">${chain.map((x) => x.toUpperCase()).join(" → ")}</code>`,
                `- 최상위(1M) 타입이 먼저 나와야 하고, 아래 TF로 내려갈수록 <b>동일 타입</b> 유지`,
                `- 캐시 유효(기준봉 동일) 시: <b>캐시 심볼만 선별 스캔</b>`,
                `- 캐시 무효(기준봉 변경) 시: <b>전체 스캔</b>`,
                `- 추가 필터: 각 TF 현재봉 low < 직전봉 low면 제외`
            ].join("<br />");
        }

        async function fetchJson(url, signal, retry) {
            const maxRetry = Number.isFinite(retry) ? retry : 4;

            for (let attempt = 0; attempt <= maxRetry; attempt++) {
                const res = await fetch(url, { signal });

                if (res.status === 429 || res.status === 418) {
                    const wait = Math.min(2000 * (attempt + 1), 12000);
                    logLine(`[rate] ${res.status} 백오프 ${wait}ms: ${url}`);
                    await sleep(wait);
                    continue;
                }

                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    if (attempt < maxRetry) {
                        const wait = Math.min(600 * (attempt + 1), 4000);
                        logLine(`[http] ${res.status} 재시도 ${attempt + 1}/${maxRetry} (${wait}ms): ${text.slice(0, 160)}`);
                        await sleep(wait);
                        continue;
                    }
                    throw new Error(`HTTP ${res.status} ${text}`);
                }

                return await res.json();
            }

            throw new Error("fetchJson retry exceeded");
        }

        async function getUsdtPerpSymbols(signal) {
            const url = `${API_BASE}/fapi/v1/exchangeInfo`;
            const data = await fetchJson(url, signal, 4);

            return (data?.symbols || [])
                .filter((s) => s?.status === "TRADING")
                .filter((s) => s?.contractType === "PERPETUAL")
                .filter((s) => s?.quoteAsset === "USDT")
                .map((s) => s.symbol);
        }

        async function getKlines(symbol, interval, limit, signal) {
            const url = `${API_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(String(limit))}`;
            const raw = await fetchJson(url, signal, 4);

            return raw.map((k) => ({
                openTime: Number(k[0]),
                high: Number(k[2]),
                low: Number(k[3]),
                close: Number(k[4]),
                baseVol: Number(k[5]),
                closeTime: Number(k[6]),
                quoteVol: Number(k[7])
            }));
        }

        async function getBasisOpenTimeForInterval(interval, signal) {
            const kl = await getKlines(ANCHOR_SYMBOL, interval, 2, signal);
            if (!kl || kl.length < 1) return null;
            const current = kl[kl.length - 1];
            return Number.isFinite(current?.openTime) ? current.openTime : null;
        }

        async function passesCurrentLowRule(symbol, interval, signal) {
            // "현재봉 low < 직전봉 low면 제외"를 실시간으로 확인 (limit=2만)
            const kl2 = await getKlines(symbol, interval, 2, signal);
            if (!kl2 || kl2.length < 2) return false;

            const prev = kl2[0];
            const curr = kl2[1];

            if (!Number.isFinite(prev?.low) || !Number.isFinite(curr?.low)) return false;
            return curr.low >= prev.low;
        }

        function swingMonotonicType(b0, b1, b2, b3, b4) {
            const isH = (b0.high < b1.high) &&
                        (b1.high < b2.high) &&
                        (b2.high > b3.high) &&
                        (b3.high > b4.high);

            const isL = (b0.low > b1.low) &&
                        (b1.low > b2.low) &&
                        (b2.low < b3.low) &&
                        (b3.low < b4.low);

            return { isH, isL };
        }

        function decideSwingMonotonicOnly(closed5) {
            const b0 = closed5[0];
            const b1 = closed5[1];
            const b2 = closed5[2];
            const b3 = closed5[3];
            const b4 = closed5[4];

            const mono = swingMonotonicType(b0, b1, b2, b3, b4);
            const isH = mono.isH;
            const isL = mono.isL;

            if (!isH && !isL) return { type: "NONE", pivot: b2, pivotPriceDisplay: "-" };

            if (isH && isL) {
                return { type: "BOTH", pivot: b2, pivotPriceDisplay: `H:${b2.high} / L:${b2.low}` };
            }

            if (isH) return { type: "H", pivot: b2, pivotPriceDisplay: String(b2.high) };

            return { type: "L", pivot: b2, pivotPriceDisplay: String(b2.low) };
        }

        function typePill(type) {
            if (type === "H") return `<span class="pill pillH">H</span>`;
            if (type === "L") return `<span class="pill pillL">L</span>`;
            if (type === "BOTH") return `<span class="pill pillB">BOTH</span>`;
            return `<span class="pill">-</span>`;
        }

        function chainText(chain, chainTypes) {
            return chain.map((tf) => `${tf.toUpperCase()}:${chainTypes[tf] || "-"}`).join(" | ");
        }

        function rowHtml(item) {
            const chartUrl = `https://www.binance.com/en/futures/${encodeURIComponent(item.symbol)}`;
            const tvUrl = `https://www.tradingview.com/symbols/${encodeURIComponent(item.symbol)}/`;

            return `
                <tr>
                    <td>${item.finalInterval.toUpperCase()}</td>
                    <td><strong>${item.symbol}</strong></td>
                    <td>${typePill(item.type)}</td>
                    <td>${fmtTime(item.pivotTime)}</td>
                    <td>${item.pivotPriceDisplay}</td>
                    <td>${item.chainInfo}</td>
                    <td>${item.quoteSum.toFixed(2)}</td>
                    <td>${item.baseSum.toFixed(6)}</td>
                    <td>${item.lastClose}</td>
                    <td>
                        <a href="${chartUrl}" target="_blank" rel="noopener">Binance</a>
                        &nbsp;|&nbsp;
                        <a href="${tvUrl}" target="_blank" rel="noopener">TV</a>
                    </td>
                </tr>
            `;
        }

        async function runPool(items, worker, concurrency, onProgress) {
            const results = [];
            let idx = 0;

            const runners = Array.from({ length: concurrency }, async () => {
                while (idx < items.length) {
                    const current = items[idx++];
                    const res = await worker(current);
                    if (res !== null && res !== undefined) results.push(res);
                    if (onProgress) onProgress(idx, items.length);
                }
            });

            await Promise.all(runners);
            return results;
        }

        function clearUI() {
            el("tbody").innerHTML = "";
            el("log").textContent = "";
            el("progress").textContent = "";
        }

        function matchesSameType(childType, requiredType) {
            return childType === requiredType;
        }

        function safeJsonParse(text) {
            try { return JSON.parse(text); } catch { return null; }
        }

        function loadLastResults() {
            const raw = localStorage.getItem(LS_LAST_RESULTS);
            if (!raw) return null;
            return safeJsonParse(raw);
        }

        function saveLastResults(payload) {
            try {
                localStorage.setItem(LS_LAST_RESULTS, JSON.stringify(payload));
            } catch (err) {
                logLine(`[ls] lastResults 저장 실패: ${String(err?.message || err).slice(0, 160)}`);
            }
        }

        function loadTfCache() {
            const raw = localStorage.getItem(LS_TF_CACHE);
            if (!raw) return { updatedAt: 0, basisByTf: {}, data: {} };

            const parsed = safeJsonParse(raw);
            if (!parsed || typeof parsed !== "object") return { updatedAt: 0, basisByTf: {}, data: {} };

            if (!parsed.data || typeof parsed.data !== "object") parsed.data = {};
            if (!parsed.basisByTf || typeof parsed.basisByTf !== "object") parsed.basisByTf = {};
            if (!Number.isFinite(parsed.updatedAt)) parsed.updatedAt = 0;

            return parsed;
        }

        function pruneTfCache(cache) {
            const data = cache.data || {};

            const symbolTimes = Object.entries(data).map(([symbol, perTf]) => {
                const times = Object.values(perTf || {}).map((x) => Number(x?.savedAt) || 0);
                const t = times.length ? Math.max(...times) : 0;
                return { symbol, t };
            });

            symbolTimes.sort((a, b) => b.t - a.t);

            const keep = new Set(symbolTimes.slice(0, TF_CACHE_SYMBOL_LIMIT).map((x) => x.symbol));
            for (const symbol of Object.keys(data)) {
                if (!keep.has(symbol)) delete data[symbol];
            }

            cache.data = data;
        }

        function saveTfCache(cache) {
            pruneTfCache(cache);
            cache.updatedAt = Date.now();

            try {
                localStorage.setItem(LS_TF_CACHE, JSON.stringify(cache));
            } catch (err) {
                logLine(`[ls] tfCache 저장 실패: ${String(err?.message || err).slice(0, 160)}`);
            }
        }

        function invalidateTfEntriesIfBasisChanged(cache, basisNowByTf) {
            const basisPrevByTf = cache.basisByTf || {};
            const data = cache.data || {};

            for (const [tf, basisNow] of Object.entries(basisNowByTf)) {
                const prev = basisPrevByTf[tf];
                if (!prev || !basisNow || prev === basisNow) continue;

                logLine(`[cache] basis changed for ${tf}: ${fmtTime(prev)} -> ${fmtTime(basisNow)} (invalidate all ${tf})`);

                for (const symbol of Object.keys(data)) {
                    if (data[symbol] && data[symbol][tf]) delete data[symbol][tf];
                }
            }

            cache.data = data;
            cache.basisByTf = { ...basisPrevByTf, ...basisNowByTf };
        }

        function isCacheValidForChain(cache, chain, basisNowByTf) {
            const basisPrevByTf = cache.basisByTf || {};

            for (const tf of chain) {
                const now = basisNowByTf[tf];
                const prev = basisPrevByTf[tf];
                if (!now || !prev) return false;
                if (now !== prev) return false;
            }
            return true;
        }

        function getCachedSignal(cache, symbol, tf, requiredBasisOpenTime) {
            const perTf = cache.data?.[symbol];
            if (!perTf) return null;

            const rec = perTf[tf];
            if (!rec) return null;

            if (requiredBasisOpenTime && rec.basisOpenTime !== requiredBasisOpenTime) {
                return null;
            }

            return rec;
        }

        function setCachedSignal(cache, symbol, tf, rec) {
            if (!cache.data) cache.data = {};
            if (!cache.data[symbol]) cache.data[symbol] = {};
            cache.data[symbol][tf] = rec;
        }

        function renderResults(results) {
            el("tbody").innerHTML = results.map(rowHtml).join("")
                || `<tr><td colspan="10" class="muted">결과 없음</td></tr>`;
        }

        function restoreFromLocalStorageIfAny() {
            const last = loadLastResults();
            if (last && Array.isArray(last.results)) {
                renderResults(last.results);
                setStatus("로컬 결과 표시", "ok");
                el("progress").textContent = `로컬: ${last.results.length}개`;
                logLine(`[restore] lastResults loaded: ${last.results.length} (savedAt=${fmtTime(last.savedAt || 0)})`);
            }

            const cache = loadTfCache();
            const count = Object.keys(cache.data || {}).length;
            if (count > 0) {
                logLine(`[restore] tfCache symbols=${count} (updatedAt=${fmtTime(cache.updatedAt || 0)})`);
                const basisText = Object.entries(cache.basisByTf || {})
                    .map(([tf, t]) => `${tf}:${t ? fmtTime(t) : "-"}`)
                    .join(" | ");
                if (basisText) logLine(`[restore] cached basisByTf: ${basisText}`);
            }
        }

        async function scanOneIntervalSignalFetch(symbol, interval, signal) {
            // 최근 7개: 현재봉 + 직전봉 + 닫힌캔들 5개(스윙용)
            const kl7 = await getKlines(symbol, interval, 7, signal);
            if (!kl7 || kl7.length < 7) return null;

            const now = Date.now();

            const current = kl7[kl7.length - 1];
            const prev = kl7[kl7.length - 2];

            // 현재봉 저점 < 직전봉 저점이면 제외
            if (Number.isFinite(current?.low) && Number.isFinite(prev?.low)) {
                if (current.low < prev.low) {
                    return null;
                }
            } else {
                return null;
            }

            const closed = kl7.filter((k) => k.closeTime <= now);
            if (closed.length < 5) return null;

            const closed5 = closed.slice(-5);
            const swing = decideSwingMonotonicOnly(closed5);
            if (swing.type === "NONE") return null;

            const quoteSum = sum(closed5.map((k) => k.quoteVol));
            const baseSum = sum(closed5.map((k) => k.baseVol));
            const lastClose = closed5[4].close;

            const basisOpenTime = Number.isFinite(current?.openTime) ? current.openTime : null;

            return {
                interval,
                type: swing.type,
                pivotTime: swing.pivot.openTime,
                pivotPriceDisplay: swing.pivotPriceDisplay,
                quoteSum,
                baseSum,
                lastClose: String(lastClose),
                basisOpenTime
            };
        }

        async function getSignalWithCache(cache, symbol, tf, requiredBasisOpenTime, signal) {
            const cached = getCachedSignal(cache, symbol, tf, requiredBasisOpenTime);
            if (cached) return cached;

            const fresh = await scanOneIntervalSignalFetch(symbol, tf, signal);
            if (!fresh) return null;

            const rec = {
                savedAt: Date.now(),
                interval: tf,
                type: fresh.type,
                pivotTime: fresh.pivotTime,
                pivotPriceDisplay: fresh.pivotPriceDisplay,
                quoteSum: fresh.quoteSum,
                baseSum: fresh.baseSum,
                lastClose: fresh.lastClose,
                basisOpenTime: fresh.basisOpenTime
            };

            setCachedSignal(cache, symbol, tf, rec);
            return rec;
        }

        function buildResultsFromCacheOnly(cache, chain, basisNowByTf, typeFilter, minQuoteSum, minBaseSum, finalInterval) {
            const symbols = Object.keys(cache.data || {});
            const results = [];

            for (const symbol of symbols) {
                const chainTypes = {};
                const chainSignals = {};

                let requiredType = null;
                let ok = true;

                for (let i = 0; i < chain.length; i++) {
                    const tf = chain[i];
                    const requiredBasis = basisNowByTf[tf] || null;

                    const sig = getCachedSignal(cache, symbol, tf, requiredBasis);
                    if (!sig) {
                        ok = false;
                        break;
                    }

                    chainSignals[tf] = sig;
                    chainTypes[tf] = sig.type;

                    if (i === 0) {
                        requiredType = sig.type;
                        if (typeFilter !== "ALL" && requiredType !== typeFilter) {
                            ok = false;
                            break;
                        }
                    } else {
                        if (!matchesSameType(sig.type, requiredType)) {
                            ok = false;
                            break;
                        }
                    }
                }

                if (!ok) continue;

                const finalSig = chainSignals[finalInterval];
                if (!finalSig) continue;

                if (minQuoteSum > 0 && finalSig.quoteSum < minQuoteSum) continue;
                if (minBaseSum > 0 && finalSig.baseSum < minBaseSum) continue;

                results.push({
                    finalInterval,
                    symbol,
                    type: finalSig.type,
                    pivotTime: finalSig.pivotTime,
                    pivotPriceDisplay: finalSig.pivotPriceDisplay,
                    chainInfo: chainText(chain, chainTypes),
                    quoteSum: finalSig.quoteSum,
                    baseSum: finalSig.baseSum,
                    lastClose: finalSig.lastClose
                });
            }

            return results;
        }

        el("interval").addEventListener("change", updateTitleAndDesc);
        updateTitleAndDesc();
        restoreFromLocalStorageIfAny();

        el("startBtn").addEventListener("click", async () => {
            if (state.running) return;

            clearUI();

            const finalInterval = readString("interval", "4h");
            const chain = getIntervalChain(finalInterval);

            const concurrency = readNumber("concurrency", 1, 25, 8);
            const maxSymbols = readNumber("maxSymbols", 0, 2000, 0);

            const typeFilter = readString("typeFilter", "ALL");
            const sortMode = readString("sortMode", "QUOTE");

            const minQuoteSum = Math.max(0, Number(el("minQuoteSum").value) || 0);
            const minBaseSum = Math.max(0, Number(el("minBaseSum").value) || 0);

            const aborter = new AbortController();
            state.aborter = aborter;
            state.running = true;

            el("startBtn").disabled = true;
            el("stopBtn").disabled = false;

            const cache = loadTfCache();

            try {
                // 1) 기준봉 동기화
                setStatus("기준봉 동기화", "warn");
                const basisNowByTf = {};

                for (const tf of chain) {
                    if (aborter.signal.aborted) throw new Error("aborted");
                    const basis = await getBasisOpenTimeForInterval(tf, aborter.signal);
                    basisNowByTf[tf] = basis;
                    logLine(`[basis] ${tf} current openTime = ${basis ? fmtTime(basis) : "N/A"}`);
                }

                const cacheValid = isCacheValidForChain(cache, chain, basisNowByTf);

                // 2) 캐시 유효면: "캐시 심볼만" + "캐시로 조건 선필터" 후에 "low-rule만 실시간 검증"
                if (cacheValid && Object.keys(cache.data || {}).length > 0) {
                    setStatus("캐시 선별 스캔", "warn");
                    logLine(`[mode] cache-only candidates (basis unchanged)`);

                    let candidates = buildResultsFromCacheOnly(
                        cache,
                        chain,
                        basisNowByTf,
                        typeFilter,
                        minQuoteSum,
                        minBaseSum,
                        finalInterval
                    );

                    // maxSymbols 적용(캐시심볼 기반 모드에서도)
                    if (maxSymbols > 0) {
                        candidates = candidates.slice(0, maxSymbols);
                    }

                    logLine(`[cache] prefiltered candidates=${candidates.length}`);
                    el("progress").textContent = `0 / ${candidates.length}`;

                    // low-rule 실시간 검증은 candidates만 대상으로
                    const worker = async (item) => {
                        if (aborter.signal.aborted) return null;

                        try {
                            for (const tf of chain) {
                                const pass = await passesCurrentLowRule(item.symbol, tf, aborter.signal);
                                if (!pass) return null;
                            }
                            return item;
                        } catch (err) {
                            logLine(`[err] low-check ${item.symbol}: ${String(err?.message || err).slice(0, 160)}`);
                            return null;
                        }
                    };

                    let results = await runPool(
                        candidates,
                        worker,
                        concurrency,
                        (done, total) => {
                            el("progress").textContent = `${done} / ${total}`;
                        }
                    );

                    results.sort((a, b) => {
                        if (sortMode === "BASE") return b.baseSum - a.baseSum;
                        return b.quoteSum - a.quoteSum;
                    });

                    renderResults(results);

                    saveLastResults({
                        savedAt: Date.now(),
                        settings: { finalInterval, chain, concurrency, maxSymbols, typeFilter, sortMode, minQuoteSum, minBaseSum, mode: "CACHE_ONLY" },
                        results
                    });

                    setStatus("완료", "ok");
                    logLine(`[done] mode=CACHE_ONLY final=${finalInterval}, results=${results.length}`);
                    return;
                }

                // 3) 캐시 무효면: 기준봉 변경된 TF 캐시 무효화 후 전체 스캔
                setStatus("전체 스캔 준비", "warn");
                invalidateTfEntriesIfBasisChanged(cache, basisNowByTf);

                setStatus("심볼 로딩", "warn");
                logLine(`[mode] FULL_SCAN (basis changed or no cache)`);

                let symbols = await getUsdtPerpSymbols(aborter.signal);
                logLine(`[symbols] USDT PERP TRADING: ${symbols.length}`);

                if (maxSymbols > 0) {
                    symbols = symbols.slice(0, maxSymbols);
                    logLine(`[symbols] capped to ${symbols.length}`);
                }

                el("progress").textContent = `0 / ${symbols.length}`;
                setStatus("스캔중", "warn");

                const worker = async (symbol) => {
                    if (aborter.signal.aborted) return null;

                    try {
                        const chainTypes = {};
                        const chainSignals = {};
                        let requiredType = null;

                        for (let i = 0; i < chain.length; i++) {
                            const tf = chain[i];
                            const requiredBasis = basisNowByTf[tf] || null;

                            const sig = await getSignalWithCache(cache, symbol, tf, requiredBasis, aborter.signal);
                            if (!sig) return null;

                            chainTypes[tf] = sig.type;
                            chainSignals[tf] = sig;

                            if (i === 0) {
                                requiredType = sig.type;
                                if (typeFilter !== "ALL" && requiredType !== typeFilter) return null;
                            } else {
                                if (!matchesSameType(sig.type, requiredType)) return null;
                            }
                        }

                        const finalSig = chainSignals[finalInterval];
                        if (!finalSig) return null;

                        if (minQuoteSum > 0 && finalSig.quoteSum < minQuoteSum) return null;
                        if (minBaseSum > 0 && finalSig.baseSum < minBaseSum) return null;

                        return {
                            finalInterval,
                            symbol,
                            type: finalSig.type,
                            pivotTime: finalSig.pivotTime,
                            pivotPriceDisplay: finalSig.pivotPriceDisplay,
                            chainInfo: chainText(chain, chainTypes),
                            quoteSum: finalSig.quoteSum,
                            baseSum: finalSig.baseSum,
                            lastClose: finalSig.lastClose
                        };
                    } catch (err) {
                        logLine(`[err] ${symbol}: ${String(err?.message || err).slice(0, 200)}`);
                        return null;
                    }
                };

                let results = await runPool(
                    symbols,
                    worker,
                    concurrency,
                    (done, total) => {
                        el("progress").textContent = `${done} / ${total}`;
                    }
                );

                results.sort((a, b) => {
                    if (sortMode === "BASE") return b.baseSum - a.baseSum;
                    return b.quoteSum - a.quoteSum;
                });

                renderResults(results);

                saveLastResults({
                    savedAt: Date.now(),
                    settings: { finalInterval, chain, concurrency, maxSymbols, typeFilter, sortMode, minQuoteSum, minBaseSum, mode: "FULL_SCAN" },
                    results
                });

                saveTfCache(cache);

                setStatus("완료", "ok");
                logLine(`[done] mode=FULL_SCAN final=${finalInterval}, results=${results.length}`);
            } catch (err) {
                setStatus("실패", "err");
                logLine(`[fatal] ${String(err?.message || err)}`);
            } finally {
                state.running = false;
                state.aborter = null;
                el("startBtn").disabled = false;
                el("stopBtn").disabled = true;
            }
        });

        el("stopBtn").addEventListener("click", () => {
            if (state.aborter) {
                state.aborter.abort();
                setStatus("중지됨", "err");
                logLine("[stop] aborted by user");
            }
        });
    </script>
</body>
</html>
