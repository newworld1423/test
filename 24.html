<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance Futures Scanner - 4H EMA200 Trend + 15m Pullback Break</title>
    <style>
        :root {
            --bg: #0b0f17;
            --panel: #121a27;
            --panel2: #0f1622;
            --text: #e8eefc;
            --muted: #9fb0d0;
            --line: rgba(255,255,255,.08);
            --good: #35d07f;
            --bad: #ff5c7a;
            --warn: #ffcf5a;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
        }

        .wrap {
            max-width: 1120px;
            margin: 0 auto;
            padding: 16px;
        }

        h1 {
            font-size: 18px;
            margin: 0 0 10px;
            letter-spacing: .2px;
        }

        .sub {
            color: var(--muted);
            font-size: 12px;
            line-height: 1.45;
            margin-bottom: 14px;
        }

        .panel {
            background: linear-gradient(180deg, var(--panel), var(--panel2));
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 12px;
            margin-bottom: 14px;
            box-shadow: 0 10px 30px rgba(0,0,0,.25);
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 10px;
        }

        @media (max-width: 980px) {
            .controls { grid-template-columns: 1fr 1fr; }
        }

        @media (max-width: 520px) {
            .controls { grid-template-columns: 1fr; }
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        input, select, button {
            width: 100%;
            padding: 10px 10px;
            border-radius: 12px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.03);
            color: var(--text);
            outline: none;
        }

        input[type="number"] { font-family: var(--mono); }

        button {
            cursor: pointer;
            background: rgba(255,255,255,.06);
            font-weight: 700;
        }

        button:hover { background: rgba(255,255,255,.09); }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.03);
            font-size: 12px;
            color: var(--muted);
        }

        .pill b { color: var(--text); }

        .topPick {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        @media (max-width: 900px) {
            .topPick { grid-template-columns: 1fr; }
        }

        .card {
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 12px;
            background: rgba(255,255,255,.03);
        }

        .card h2 {
            font-size: 13px;
            margin: 0 0 8px;
            color: var(--muted);
            font-weight: 700;
        }

        .big {
            font-size: 18px;
            font-family: var(--mono);
            font-weight: 800;
            margin: 0 0 6px;
        }

        .kv {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 6px 10px;
            font-size: 12px;
            line-height: 1.4;
        }

        .kv .k { color: var(--muted); }
        .kv .v { font-family: var(--mono); }

        .good { color: var(--good); }
        .bad { color: var(--bad); }
        .warn { color: var(--warn); }

        table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            border-radius: 14px;
            border: 1px solid var(--line);
        }
        th, td {
            border-bottom: 1px solid var(--line);
            padding: 10px;
            font-size: 12px;
            text-align: left;
            vertical-align: top;
        }
        th {
            color: var(--muted);
            background: rgba(255,255,255,.03);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        td { font-family: var(--mono); }
        tr:hover td { background: rgba(255,255,255,.02); }

        .muted { color: var(--muted); font-family: inherit; }
        .small { font-size: 11px; color: var(--muted); font-family: inherit; }
        .log {
            height: 140px;
            overflow: auto;
            background: rgba(0,0,0,.25);
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 10px;
            font-family: var(--mono);
            font-size: 11px;
            line-height: 1.45;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Binance Futures 스캐너 (4H EMA200 추세 + 15m 되돌림 후 재돌파)</h1>
    <div class="sub">
        - 00/15/30/45분에 자동 스캔(브라우저 켜져 있어야 함).<br>
        - 공개 API만 사용하며, 요청량을 줄이기 위해 “24h 거래대금 상위 N개”만 스캔하도록 기본값을 둠(레이트리밋 방지).<br>
        <span class="warn">※ 투자 조언 아님. 이 스캐너는 “규칙 지키기/신호 찾기” 보조용.</span>
    </div>

    <div class="panel">
        <div class="controls">
            <div>
                <label>스캔 대상(24h 거래대금 상위 N개)</label>
                <input id="topN" type="number" min="10" max="200" step="10" value="60" />
            </div>
            <div>
                <label>방향</label>
                <select id="direction">
                    <option value="both">롱/숏 모두</option>
                    <option value="long">롱만</option>
                    <option value="short">숏만</option>
                </select>
            </div>
            <div>
                <label>15m 되돌림 룩백(N봉)</label>
                <input id="lookback" type="number" min="10" max="60" step="1" value="20" />
            </div>
            <div>
                <label>브레이크 확인(직전 M봉 최고/최저)</label>
                <input id="breakN" type="number" min="3" max="20" step="1" value="5" />
            </div>

            <div>
                <label>손절폭(%) 최소</label>
                <input id="minStopPct" type="number" min="0.05" max="5" step="0.05" value="0.30" />
            </div>
            <div>
                <label>손절폭(%) 최대</label>
                <input id="maxStopPct" type="number" min="0.1" max="10" step="0.1" value="2.50" />
            </div>
            <div>
                <label>익절 R 배수</label>
                <input id="tpR" type="number" min="1" max="5" step="0.1" value="2" />
            </div>
            <div>
                <label>최소 24h 거래대금(USDT)</label>
                <input id="minQuoteVol" type="number" min="0" step="1000000" value="20000000" />
            </div>
        </div>

        <div class="row">
            <button id="btnScan">지금 즉시 스캔</button>
            <button id="btnAuto">자동 스캔 시작(00/15/30/45)</button>
            <button id="btnStop">중지</button>
        </div>

        <div class="row">
            <div class="pill">상태: <b id="status">대기</b></div>
            <div class="pill">마지막 스캔: <b id="lastScan">-</b></div>
            <div class="pill">다음 자동 스캔까지: <b id="nextIn">-</b></div>
        </div>

        <div class="topPick" id="topPick"></div>
    </div>

    <div class="panel">
        <div class="row" style="justify-content: space-between; align-items: center;">
            <div class="pill">후보 개수: <b id="count">0</b></div>
            <div class="pill">정렬: <b>Score ↓</b></div>
        </div>

        <div style="overflow: auto; max-height: 520px; border-radius: 14px; margin-top: 10px;">
            <table>
                <thead>
                    <tr>
                        <th>Score</th>
                        <th>Symbol</th>
                        <th>Side</th>
                        <th>Entry</th>
                        <th>SL</th>
                        <th>TP</th>
                        <th>Stop%</th>
                        <th>RR</th>
                        <th>24h QuoteVol</th>
                        <th>Why</th>
                    </tr>
                </thead>
                <tbody id="tbody"></tbody>
            </table>
        </div>
    </div>

    <div class="panel">
        <div class="small">로그(레이트리밋/에러 확인용)</div>
        <div class="log" id="log"></div>
    </div>
</div>

<script>
    const API = "https://fapi.binance.com";

    let autoTimer = null;
    let tickTimer = null;
    let currentAbort = null;

    function $(id) {
        return document.getElementById(id);
    }

    function logLine(msg) {
        const el = $("log");
        const t = new Date().toLocaleString("ko-KR");
        el.textContent = `[${t}] ${msg}\n` + el.textContent;
    }

    function setStatus(text) {
        $("status").textContent = text;
    }

    function fmt(n, d = 6) {
        if (!isFinite(n)) return "-";
        const x = Number(n);
        if (Math.abs(x) >= 1000) return x.toFixed(2);
        if (Math.abs(x) >= 10) return x.toFixed(4);
        return x.toFixed(d);
    }

    function sleep(ms, signal) {
        return new Promise((resolve, reject) => {
            const t = setTimeout(resolve, ms);
            if (signal) {
                signal.addEventListener("abort", () => {
                    clearTimeout(t);
                    reject(new DOMException("Aborted", "AbortError"));
                }, { once: true });
            }
        });
    }

    async function fetchWithRetry(url, opts = {}, retries = 4) {
        const signal = opts.signal;

        for (let i = 0; i <= retries; i += 1) {
            const res = await fetch(url, { ...opts, cache: "no-store" });

            if (res.ok) return res;

            const status = res.status;
            const isRate = status === 429 || status === 418;

            if (!isRate && status < 500) {
                return res;
            }

            const retryAfter = Number(res.headers.get("Retry-After") || "0");
            const backoff = retryAfter > 0 ? retryAfter * 1000 : (800 * Math.pow(2, i));
            const jitter = Math.floor(Math.random() * 250);

            logLine(`HTTP ${status} - retry in ${(backoff + jitter)}ms (${url.split("?")[0]})`);

            if (i === retries) return res;

            await sleep(backoff + jitter, signal);
        }

        throw new Error("fetchWithRetry failed");
    }

    function ema(values, period) {
        const out = new Array(values.length).fill(null);
        if (!values || values.length < period) return out;

        const k = 2 / (period + 1);
        let sma = 0;

        for (let i = 0; i < period; i += 1) sma += values[i];
        let prev = sma / period;
        out[period - 1] = prev;

        for (let i = period; i < values.length; i += 1) {
            const v = values[i];
            const next = (v * k) + (prev * (1 - k));
            out[i] = next;
            prev = next;
        }

        return out;
    }

    function parseKlines(arr) {
        return arr.map(k => ({
            openTime: k[0],
            open: Number(k[1]),
            high: Number(k[2]),
            low: Number(k[3]),
            close: Number(k[4]),
            volume: Number(k[5])
        }));
    }

    function highestHigh(candles, fromIdx, toIdx) {
        let m = -Infinity;
        for (let i = fromIdx; i <= toIdx; i += 1) {
            if (candles[i].high > m) m = candles[i].high;
        }
        return m;
    }

    function lowestLow(candles, fromIdx, toIdx) {
        let m = Infinity;
        for (let i = fromIdx; i <= toIdx; i += 1) {
            if (candles[i].low < m) m = candles[i].low;
        }
        return m;
    }

    function argMinLow(candles, fromIdx, toIdx) {
        let idx = fromIdx;
        let m = Infinity;
        for (let i = fromIdx; i <= toIdx; i += 1) {
            if (candles[i].low < m) {
                m = candles[i].low;
                idx = i;
            }
        }
        return idx;
    }

    function argMaxHigh(candles, fromIdx, toIdx) {
        let idx = fromIdx;
        let m = -Infinity;
        for (let i = fromIdx; i <= toIdx; i += 1) {
            if (candles[i].high > m) {
                m = candles[i].high;
                idx = i;
            }
        }
        return idx;
    }

    function analyzeSymbol(symbol, qVol, kl4h, kl15m, cfg) {
        // 4H EMA200 trend filter
        const c4 = kl4h.map(x => x.close);
        const e200 = ema(c4, 200);
        const lastIdx4 = kl4h.length - 1;
        const lastClose4 = c4[lastIdx4];
        const ema200Last = e200[lastIdx4];
        const ema200Prev = e200[lastIdx4 - 1];

        if (!ema200Last || !ema200Prev) return null;

        const trendUp = ema200Last > ema200Prev;
        const trendDown = ema200Last < ema200Prev;

        const longBias = (lastClose4 > ema200Last) && trendUp;
        const shortBias = (lastClose4 < ema200Last) && trendDown;

        // 15m pullback + break
        const c15 = kl15m.map(x => x.close);
        const e20 = ema(c15, 20);
        const lastIdx15 = kl15m.length - 1;

        const lookback = cfg.lookback;
        const breakN = cfg.breakN;

        const start = Math.max(0, lastIdx15 - lookback);
        const end = lastIdx15;

        const minStopPct = cfg.minStopPct / 100;
        const maxStopPct = cfg.maxStopPct / 100;
        const tpR = cfg.tpR;

        const lastClose15 = kl15m[lastIdx15].close;
        const ema20Last = e20[lastIdx15];

        if (!ema20Last) return null;

        const prevRangeStart = Math.max(0, lastIdx15 - breakN);
        const prevRangeEnd = lastIdx15 - 1;
        if (prevRangeEnd <= prevRangeStart) return null;

        // buffer: 0.08% (너무 타이트하게 안 잡히게)
        const buffer = 0.0008;

        // LONG setup
        if ((cfg.direction === "both" || cfg.direction === "long") && longBias) {
            const pbIdx = argMinLow(kl15m, start, end);
            const pbLow = kl15m[pbIdx].low;
            const ema20AtPb = e20[pbIdx];

            // pullback: low <= ema20 at pullback time
            const touched = isFinite(ema20AtPb) && (pbLow <= ema20AtPb);

            // break: last close > highest high of previous breakN candles
            const prevHigh = highestHigh(kl15m, prevRangeStart, prevRangeEnd);
            const broke = lastClose15 > prevHigh;

            // regain: last close > ema20
            const regain = lastClose15 > ema20Last;

            // pullback recency: pullback within last 12 candles
            const recent = (lastIdx15 - pbIdx) <= 12;

            if (touched && regain && broke && recent) {
                const entry = lastClose15;
                const sl = pbLow * (1 - buffer);
                const stopPct = (entry - sl) / entry;

                if (stopPct >= minStopPct && stopPct <= maxStopPct) {
                    const tp = entry + (entry - sl) * tpR;
                    const rr = (tp - entry) / (entry - sl);

                    const trendStrength = Math.abs((lastClose4 - ema200Last) / ema200Last);
                    const score = (Math.log10(qVol + 1) * (trendStrength + 0.02)) / (stopPct + 1e-9);

                    return {
                        symbol,
                        side: "LONG",
                        entry,
                        sl,
                        tp,
                        stopPct: stopPct * 100,
                        rr,
                        qVol,
                        score,
                        why: `4H: close>EMA200 & EMA200↑ | 15m: EMA20 터치 후 복귀 + 직전${breakN}봉 고점 돌파`
                    };
                }
            }
        }

        // SHORT setup
        if ((cfg.direction === "both" || cfg.direction === "short") && shortBias) {
            const pbIdx = argMaxHigh(kl15m, start, end);
            const pbHigh = kl15m[pbIdx].high;
            const ema20AtPb = e20[pbIdx];

            // pullback: high >= ema20 at pullback time (아래 추세에서 EMA20까지 되돌림)
            const touched = isFinite(ema20AtPb) && (pbHigh >= ema20AtPb);

            // break: last close < lowest low of previous breakN candles
            const prevLow = lowestLow(kl15m, prevRangeStart, prevRangeEnd);
            const broke = lastClose15 < prevLow;

            // regain (down): last close < ema20
            const regain = lastClose15 < ema20Last;

            const recent = (lastIdx15 - pbIdx) <= 12;

            if (touched && regain && broke && recent) {
                const entry = lastClose15;
                const sl = pbHigh * (1 + buffer);
                const stopPct = (sl - entry) / entry;

                if (stopPct >= minStopPct && stopPct <= maxStopPct) {
                    const tp = entry - (sl - entry) * tpR;
                    const rr = (entry - tp) / (sl - entry);

                    const trendStrength = Math.abs((lastClose4 - ema200Last) / ema200Last);
                    const score = (Math.log10(qVol + 1) * (trendStrength + 0.02)) / (stopPct + 1e-9);

                    return {
                        symbol,
                        side: "SHORT",
                        entry,
                        sl,
                        tp,
                        stopPct: stopPct * 100,
                        rr,
                        qVol,
                        score,
                        why: `4H: close<EMA200 & EMA200↓ | 15m: EMA20 되돌림 후 재하락 + 직전${breakN}봉 저점 이탈`
                    };
                }
            }
        }

        return null;
    }

    async function mapLimit(arr, limit, fn) {
        const out = new Array(arr.length);
        let idx = 0;

        async function worker() {
            while (true) {
                const i = idx;
                idx += 1;
                if (i >= arr.length) break;
                out[i] = await fn(arr[i], i);
            }
        }

        const workers = [];
        for (let i = 0; i < limit; i += 1) workers.push(worker());
        await Promise.all(workers);
        return out;
    }

    async function getExchangeInfo(signal) {
        const url = `${API}/fapi/v1/exchangeInfo`;
        const res = await fetchWithRetry(url, { signal });
        if (!res.ok) throw new Error(`exchangeInfo HTTP ${res.status}`);
        return res.json();
    }

    async function getTickers24h(signal) {
        const url = `${API}/fapi/v1/ticker/24hr`;
        const res = await fetchWithRetry(url, { signal });
        if (!res.ok) throw new Error(`ticker/24hr HTTP ${res.status}`);
        return res.json();
    }

    async function getKlines(symbol, interval, limit, signal) {
        const url = `${API}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${interval}&limit=${limit}`;
        const res = await fetchWithRetry(url, { signal });
        if (!res.ok) return null;
        return res.json();
    }

    function clearTable() {
        $("tbody").innerHTML = "";
        $("count").textContent = "0";
        $("topPick").innerHTML = "";
    }

    function renderResults(rows) {
        const tbody = $("tbody");
        tbody.innerHTML = "";

        const sorted = rows.slice().sort((a, b) => b.score - a.score);
        $("count").textContent = String(sorted.length);

        for (const r of sorted) {
            const tr = document.createElement("tr");

            const sideClass = r.side === "LONG" ? "good" : "bad";
            tr.innerHTML = `
                <td>${fmt(r.score, 4)}</td>
                <td><b>${r.symbol}</b></td>
                <td class="${sideClass}"><b>${r.side}</b></td>
                <td>${fmt(r.entry)}</td>
                <td>${fmt(r.sl)}</td>
                <td>${fmt(r.tp)}</td>
                <td>${fmt(r.stopPct, 3)}%</td>
                <td>${fmt(r.rr, 2)}R</td>
                <td>${fmt(r.qVol, 2)}</td>
                <td class="muted">${r.why}</td>
            `;
            tbody.appendChild(tr);
        }

        renderTopPick(sorted[0] || null);
    }

    function renderTopPick(pick) {
        const box = $("topPick");
        box.innerHTML = "";

        if (!pick) {
            box.innerHTML = `<div class="card"><h2>Top Pick</h2><div class="muted">조건 충족 종목 없음</div></div>`;
            return;
        }

        const sideClass = pick.side === "LONG" ? "good" : "bad";
        const riskAbs = Math.abs(pick.entry - pick.sl);
        const tpAbs = Math.abs(pick.tp - pick.entry);

        box.innerHTML = `
            <div class="card">
                <h2>Top Pick (Score 1등)</h2>
                <div class="big">${pick.symbol} <span class="${sideClass}">${pick.side}</span></div>
                <div class="kv">
                    <div class="k">Entry</div><div class="v">${fmt(pick.entry)}</div>
                    <div class="k">SL</div><div class="v">${fmt(pick.sl)} <span class="muted">(${fmt(pick.stopPct, 3)}%)</span></div>
                    <div class="k">TP</div><div class="v">${fmt(pick.tp)} <span class="muted">(≈ ${fmt(tpAbs)} USDT move)</span></div>
                    <div class="k">RR</div><div class="v">${fmt(pick.rr, 2)}R</div>
                </div>
                <div class="small" style="margin-top: 8px;">${pick.why}</div>
            </div>
            <div class="card">
                <h2>리스크 가이드(예시)</h2>
                <div class="muted" style="font-size:12px; line-height:1.5;">
                    1회 손실허용(Risk)을 먼저 정하고, <b>손절폭</b>으로 포지션 크기를 계산하세요.<br>
                    <span class="muted">노출(Notional) ≈ RiskUSDT / (Stop%/100)</span><br>
                    예: Risk 10USDT, Stop ${fmt(pick.stopPct, 3)}%라면<br>
                    노출 ≈ 10 / (${fmt(pick.stopPct, 3)}/100) = <b>${fmt(10 / (pick.stopPct / 100), 2)} USDT</b>
                </div>
            </div>
            <div class="card">
                <h2>체크</h2>
                <div class="muted" style="font-size:12px; line-height:1.6;">
                    - 손절은 <b>절대 미루지 않기</b><br>
                    - 연속 2번 손절이면 그날 종료<br>
                    - 레버리지는 “수익 증가”가 아니라 “증거금 감소”로만 사용
                </div>
            </div>
        `;
    }

    function readConfig() {
        return {
            topN: Math.max(10, Math.min(200, Number($("topN").value || 60))),
            direction: $("direction").value,
            lookback: Math.max(10, Math.min(60, Number($("lookback").value || 20))),
            breakN: Math.max(3, Math.min(20, Number($("breakN").value || 5))),
            minStopPct: Math.max(0.05, Number($("minStopPct").value || 0.30)),
            maxStopPct: Math.max(0.10, Number($("maxStopPct").value || 2.50)),
            tpR: Math.max(1, Math.min(5, Number($("tpR").value || 2))),
            minQuoteVol: Math.max(0, Number($("minQuoteVol").value || 0))
        };
    }

    async function scanOnce() {
        const cfg = readConfig();

        clearTable();
        setStatus("스캔 중...");
        $("lastScan").textContent = "-";

        if (currentAbort) currentAbort.abort();
        currentAbort = new AbortController();

        try {
            const signal = currentAbort.signal;

            // 1) tradable USDT perpetual symbols
            const info = await getExchangeInfo(signal);

            const tradable = info.symbols
                .filter(s =>
                    s.contractType === "PERPETUAL" &&
                    s.quoteAsset === "USDT" &&
                    s.status === "TRADING"
                )
                .map(s => s.symbol);

            // 2) 24h quoteVolume to choose topN (reduce rate limit)
            const tickers = await getTickers24h(signal);

            const tickerMap = new Map();
            for (const t of tickers) {
                tickerMap.set(t.symbol, {
                    quoteVol: Number(t.quoteVolume || 0),
                    lastPrice: Number(t.lastPrice || 0)
                });
            }

            const universe = tradable
                .map(sym => ({
                    symbol: sym,
                    quoteVol: (tickerMap.get(sym)?.quoteVol) || 0
                }))
                .filter(x => x.quoteVol >= cfg.minQuoteVol)
                .sort((a, b) => b.quoteVol - a.quoteVol)
                .slice(0, cfg.topN);

            logLine(`Universe: ${universe.length} symbols (TopN=${cfg.topN}, minQuoteVol=${cfg.minQuoteVol})`);

            const rows = [];

            // 3) scan with concurrency limit
            const limit = 6;

            await mapLimit(universe, limit, async (it) => {
                const symbol = it.symbol;
                const qVol = it.quoteVol;

                // Need enough candles for EMA200: at least 200+ a few
                const [k4, k15] = await Promise.all([
                    getKlines(symbol, "4h", 260, signal),
                    getKlines(symbol, "15m", 220, signal)
                ]);

                if (!k4 || !k15) return null;

                const kl4h = parseKlines(k4);
                const kl15m = parseKlines(k15);

                // Basic sanity
                if (kl4h.length < 205 || kl15m.length < 50) return null;

                const r = analyzeSymbol(symbol, qVol, kl4h, kl15m, cfg);
                if (r) rows.push(r);

                return null;
            });

            rows.sort((a, b) => b.score - a.score);

            renderResults(rows);

            const now = new Date();
            $("lastScan").textContent = now.toLocaleString("ko-KR");

            setStatus(`완료 (${rows.length}개 후보)`);

            if (rows.length === 0) {
                logLine("No setups found. (Try increasing TopN or loosening stop% range.)");
            } else {
                logLine(`TopPick: ${rows[0].symbol} ${rows[0].side} score=${rows[0].score.toFixed(4)}`);
            }
        } catch (e) {
            if (e && e.name === "AbortError") {
                setStatus("중지됨");
                logLine("Scan aborted.");
                return;
            }
            setStatus("에러");
            logLine(`ERROR: ${e.message || e}`);
        }
    }

    function msUntilNextQuarter() {
        const now = new Date();
        const m = now.getMinutes();
        const s = now.getSeconds();
        const ms = now.getMilliseconds();

        const nextQ = (Math.floor(m / 15) + 1) * 15;
        const nextMin = nextQ % 60;
        const addHour = nextQ >= 60 ? 1 : 0;

        const next = new Date(now);
        next.setHours(now.getHours() + addHour);
        next.setMinutes(nextMin);
        next.setSeconds(0);
        next.setMilliseconds(0);

        return next.getTime() - now.getTime();
    }

    function startAuto() {
        stopAuto();

        setStatus("자동 대기 중...");
        logLine("Auto scan enabled (00/15/30/45).");

        const tick = () => {
            const ms = msUntilNextQuarter();
            const sec = Math.max(0, Math.floor(ms / 1000));
            $("nextIn").textContent = `${sec}s`;
        };

        tickTimer = setInterval(tick, 250);

        const schedule = async () => {
            const wait = msUntilNextQuarter();
            autoTimer = setTimeout(async () => {
                await scanOnce();
                schedule();
            }, wait);
        };

        schedule();
    }

    function stopAuto() {
        if (autoTimer) {
            clearTimeout(autoTimer);
            autoTimer = null;
        }
        if (tickTimer) {
            clearInterval(tickTimer);
            tickTimer = null;
        }
        $("nextIn").textContent = "-";
    }

    $("btnScan").addEventListener("click", () => {
        scanOnce();
    });

    $("btnAuto").addEventListener("click", () => {
        startAuto();
    });

    $("btnStop").addEventListener("click", () => {
        stopAuto();
        if (currentAbort) currentAbort.abort();
        setStatus("중지됨");
        logLine("Stopped by user.");
    });

    // initial hint
    renderTopPick(null);
</script>
</body>
</html>
