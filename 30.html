<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT-PERP 1M ATL + Sideways Box Scanner</title>
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
            background: #0b0f19;
            color: #e8eefc;
        }
        .wrap {
            max-width: 1180px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            margin: 0 0 12px;
            font-size: 20px;
            letter-spacing: -0.2px;
        }
        .card {
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(255, 255, 255, 0.04);
            border-radius: 14px;
            padding: 14px;
            margin-bottom: 12px;
            backdrop-filter: blur(10px);
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 10px;
        }
        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .field label {
            font-size: 12px;
            opacity: 0.85;
        }
        .field input, .field select {
            height: 36px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.25);
            color: #e8eefc;
            padding: 0 10px;
            outline: none;
        }
        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            height: 38px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.08);
            color: #e8eefc;
            padding: 0 12px;
            cursor: pointer;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .muted {
            opacity: 0.75;
            font-size: 12px;
            line-height: 1.4;
        }
        .progress {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            overflow: hidden;
        }
        .bar {
            height: 100%;
            width: 0%;
            background: rgba(120, 170, 255, 0.8);
            transition: width 0.15s linear;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            border-radius: 12px;
        }
        th, td {
            padding: 10px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            text-align: right;
            font-size: 12.5px;
            white-space: nowrap;
        }
        th {
            text-align: right;
            font-size: 12px;
            opacity: 0.85;
            background: rgba(255, 255, 255, 0.05);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        .tag {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            font-size: 11px;
            opacity: 0.95;
        }
        .tag.buy {
            border-color: rgba(80, 220, 160, 0.45);
        }
        .tag.sell {
            border-color: rgba(255, 140, 140, 0.45);
        }
        .tag.mid {
            border-color: rgba(180, 180, 255, 0.35);
        }
        .right {
            text-align: right;
        }
        .foot {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .small {
            font-size: 11px;
            opacity: 0.75;
        }
        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Binance USDT-PERP: 1M ATL 근접 + 월봉 횡보(박스) 스캐너</h1>

    <div class="card">
        <div class="grid">
            <div class="field" style="grid-column: span 2;">
                <label>ATL 근접 허용치 (%)</label>
                <input id="atlPct" type="number" value="30" min="1" step="1" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>횡보 판단 기간 (마감 월봉 개월)</label>
                <input id="sideMonths" type="number" value="6" min="3" step="1" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>박스폭 최대 (%)</label>
                <input id="maxRangePct" type="number" value="35" min="5" step="1" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>추세 최대 (기간 누적, %)</label>
                <input id="maxTrendPct" type="number" value="12" min="1" step="1" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>박스 하단이 ATL 위로 허용 (%)</label>
                <input id="boxLowAboveAtlPct" type="number" value="10" min="0" step="1" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>최소 24h 거래대금 (USDT)</label>
                <input id="minQuoteVol" type="number" value="20000000" min="0" step="1000000" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>무릎 비율 (0~1)</label>
                <input id="kneeRatio" type="number" value="0.25" min="0.05" max="0.45" step="0.01" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>어깨 비율 (0~1)</label>
                <input id="shoulderRatio" type="number" value="0.75" min="0.55" max="0.95" step="0.01" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>동시 요청 수(낮출수록 안전)</label>
                <input id="concurrency" type="number" value="3" min="1" max="8" step="1" />
            </div>
            <div class="field" style="grid-column: span 2;">
                <label>요청 간 딜레이(ms)</label>
                <input id="delayMs" type="number" value="180" min="0" max="5000" step="10" />
            </div>
            <div class="field" style="grid-column: span 4;">
                <label>정렬</label>
                <select id="sortMode">
                    <option value="score">종합점수</option>
                    <option value="atlDist">ATL 근접(가까울수록)</option>
                    <option value="rangeTight">박스폭(좁을수록)</option>
                    <option value="liquidity">거래대금(높을수록)</option>
                    <option value="upside">(무릎→어깨) 잠재%</option>
                </select>
            </div>
        </div>

        <div class="row" style="margin-top: 12px;">
            <button id="btnStart">스캔 시작</button>
            <button id="btnStop" disabled>중지</button>
            <button id="btnExport" disabled>CSV 내보내기</button>
            <span class="muted" id="status">대기 중</span>
        </div>

        <div style="margin-top: 10px;">
            <div class="progress"><div class="bar" id="bar"></div></div>
            <div class="foot" style="margin-top: 8px;">
                <div class="small" id="progressText">0 / 0</div>
                <div class="small mono" id="rateText"></div>
            </div>
        </div>

        <div class="muted" style="margin-top: 10px;">
            ⚠️ 이 스캐너는 “박스권 반복매매” 후보를 찾는 도구입니다. 박스 하단 이탈(추세 전환) 리스크가 크니, 손절/포지션 사이즈는 별도로 관리하세요.
        </div>
    </div>

    <div class="card">
        <div style="max-height: 65vh; overflow: auto; border-radius: 12px;">
            <table>
                <thead>
                <tr>
                    <th>심볼</th>
                    <th>상태</th>
                    <th>점수</th>
                    <th>현재가</th>
                    <th>ATL</th>
                    <th>ATL거리%</th>
                    <th>박스Low</th>
                    <th>박스High</th>
                    <th>박스폭%</th>
                    <th>추세%</th>
                    <th>무릎</th>
                    <th>어깨</th>
                    <th>무릎→어깨%</th>
                    <th>24h 거래대금(USDT)</th>
                </tr>
                </thead>
                <tbody id="tbody">
                <tr><td colspan="14" class="muted">스캔 결과가 여기에 표시됩니다.</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="muted">
        참고: 429/418이 발생하면 <span class="mono">Retry-After</span> 헤더를 따라 대기 후 재시도합니다(자동 백오프). :contentReference[oaicite:3]{index=3}
    </div>
</div>

<script>
    "use strict";

    const BASE = "https://fapi.binance.com";

    const $ = (id) => document.getElementById(id);

    function toNum(x) {
        const n = Number(x);
        return Number.isFinite(n) ? n : NaN;
    }

    function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
    }

    function fmt(n, d = 6) {
        if (!Number.isFinite(n)) return "-";
        if (Math.abs(n) >= 1000) return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
        return n.toLocaleString(undefined, { maximumFractionDigits: d });
    }

    function fmtPct(n, d = 2) {
        if (!Number.isFinite(n)) return "-";
        return n.toFixed(d);
    }

    function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }

    async function fetchJson(url, { signal, retries = 6, baseDelayMs = 300 } = {}) {
        let lastErr = null;

        for (let i = 0; i <= retries; i++) {
            try {
                const res = await fetch(url, { signal });

                if (res.status === 429 || res.status === 418) {
                    const ra = res.headers.get("Retry-After");
                    const waitSec = ra ? Number(ra) : NaN;
                    const waitMs = Number.isFinite(waitSec)
                        ? Math.max(1000, waitSec * 1000)
                        : (baseDelayMs * Math.pow(2, i));

                    lastErr = new Error(`Rate limited: ${res.status}, retry after ${waitMs}ms`);
                    await sleep(waitMs);
                    continue;
                }

                if (!res.ok) {
                    const t = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status}: ${t.slice(0, 180)}`);
                }

                return await res.json();
            } catch (e) {
                lastErr = e;
                if (signal && signal.aborted) throw e;

                const waitMs = baseDelayMs * Math.pow(2, i);
                await sleep(waitMs);
            }
        }

        throw lastErr || new Error("fetchJson failed");
    }

    function calcTrendPct(closes) {
        if (!closes || closes.length < 2) return NaN;
        const first = closes[0];
        const last = closes[closes.length - 1];
        if (first <= 0) return NaN;
        return ((last - first) / first) * 100;
    }

    function calcBox(candles) {
        // candles: [{ high, low, close }]
        if (!candles || candles.length < 3) return null;

        let boxLow = Infinity;
        let boxHigh = -Infinity;
        const closes = [];

        for (const c of candles) {
            if (c.low < boxLow) boxLow = c.low;
            if (c.high > boxHigh) boxHigh = c.high;
            closes.push(c.close);
        }

        if (!Number.isFinite(boxLow) || !Number.isFinite(boxHigh) || boxLow <= 0) return null;

        const rangePct = ((boxHigh - boxLow) / boxLow) * 100;
        const trendPct = calcTrendPct(closes);

        return { boxLow, boxHigh, rangePct, trendPct };
    }

    function classifyPriceZone(price, knee, shoulder) {
        if (!(price > 0 && knee > 0 && shoulder > 0)) return { text: "N/A", cls: "mid" };
        if (price <= knee) return { text: "매수권(무릎↓)", cls: "buy" };
        if (price >= shoulder) return { text: "매도권(어깨↑)", cls: "sell" };
        return { text: "중간(대기)", cls: "mid" };
    }

    function toCsv(rows) {
        const header = [
            "symbol", "status", "score", "price", "atl", "atlDistPct",
            "boxLow", "boxHigh", "boxRangePct", "trendPct",
            "knee", "shoulder", "kneeToShoulderPct", "quoteVolume"
        ];

        const lines = [header.join(",")];

        for (const r of rows) {
            const line = [
                r.symbol,
                r.zoneText,
                r.score.toFixed(4),
                r.price,
                r.atl,
                r.atlDistPct,
                r.boxLow,
                r.boxHigh,
                r.boxRangePct,
                r.trendPct,
                r.knee,
                r.shoulder,
                r.kneeToShoulderPct,
                r.quoteVolume
            ].map((v) => `"${String(v).replace(/"/g, '""')}"`).join(",");

            lines.push(line);
        }

        return lines.join("\n");
    }

    async function getSymbols(signal) {
        const info = await fetchJson(`${BASE}/fapi/v1/exchangeInfo`, { signal });
        const symbols = (info.symbols || [])
            .filter((s) =>
                s
                && s.contractType === "PERPETUAL"
                && s.quoteAsset === "USDT"
                && s.status === "TRADING"
            )
            .map((s) => s.symbol);

        return symbols;
    }

    async function getTickers24h(signal) {
        // 한 번에 전 심볼 받기
        const arr = await fetchJson(`${BASE}/fapi/v1/ticker/24hr`, { signal });
        const map = new Map();
        for (const t of arr || []) {
            if (!t || !t.symbol) continue;
            map.set(t.symbol, t);
        }
        return map;
    }

    async function getMonthlyKlines(symbol, signal) {
        // 1M 월봉은 일반적으로 1000 limit이면 “상장 이후 전부” 커버 가능 (월봉 1000개 = 약 83년)
        const url = `${BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1M&limit=1000`;
        const raw = await fetchJson(url, { signal });

        // [
        //  0 openTime, 1 open, 2 high, 3 low, 4 close, 5 volume,
        //  6 closeTime, ...
        // ]
        const candles = (raw || []).map((k) => {
            return {
                openTime: Number(k[0]),
                high: Number(k[2]),
                low: Number(k[3]),
                close: Number(k[4]),
                closeTime: Number(k[6])
            };
        }).filter((c) => Number.isFinite(c.low) && Number.isFinite(c.high) && Number.isFinite(c.close));

        return candles;
    }

    function scoreRow(row, params) {
        const atlScore = clamp(1 - (row.atlDistPct / params.atlPct), 0, 1);
        const tightScore = clamp(1 - (row.boxRangePct / params.maxRangePct), 0, 1);
        const trendScore = clamp(1 - (Math.abs(row.trendPct) / params.maxTrendPct), 0, 1);

        // liquidityScore: 로그 스케일 (너무 큰 거래대금에 쏠리지 않게)
        const lv = Math.max(0, row.quoteVolume);
        const liqScore = clamp(Math.log10(lv + 1) / 10, 0, 1); // 대략 1e10에서 1 근접

        // 종합: “ATL 근접 + 박스 타이트”에 더 가중
        const score =
            (0.45 * atlScore) +
            (0.35 * tightScore) +
            (0.10 * trendScore) +
            (0.10 * liqScore);

        return clamp(score, 0, 1);
    }

    function sortRows(rows, mode) {
        const copy = rows.slice();
        if (mode === "atlDist") {
            copy.sort((a, b) => a.atlDistPct - b.atlDistPct);
        } else if (mode === "rangeTight") {
            copy.sort((a, b) => a.boxRangePct - b.boxRangePct);
        } else if (mode === "liquidity") {
            copy.sort((a, b) => b.quoteVolume - a.quoteVolume);
        } else if (mode === "upside") {
            copy.sort((a, b) => b.kneeToShoulderPct - a.kneeToShoulderPct);
        } else {
            copy.sort((a, b) => b.score - a.score);
        }
        return copy;
    }

    function render(rows) {
        const tbody = $("tbody");
        tbody.innerHTML = "";

        if (!rows.length) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 14;
            td.className = "muted";
            td.textContent = "조건을 만족하는 후보가 없습니다. (필터를 완화해 보세요)";
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }

        for (const r of rows) {
            const tr = document.createElement("tr");

            const td0 = document.createElement("td");
            td0.textContent = r.symbol;
            tr.appendChild(td0);

            const td1 = document.createElement("td");
            td1.innerHTML = `<span class="tag ${r.zoneCls}">${r.zoneText}</span>`;
            tr.appendChild(td1);

            const td2 = document.createElement("td");
            td2.textContent = r.score.toFixed(4);
            tr.appendChild(td2);

            const cols = [
                fmt(r.price, 8),
                fmt(r.atl, 8),
                fmtPct(r.atlDistPct),
                fmt(r.boxLow, 8),
                fmt(r.boxHigh, 8),
                fmtPct(r.boxRangePct),
                fmtPct(r.trendPct),
                fmt(r.knee, 8),
                fmt(r.shoulder, 8),
                fmtPct(r.kneeToShoulderPct),
                fmt(r.quoteVolume, 0)
            ];

            for (const v of cols) {
                const td = document.createElement("td");
                td.textContent = v;
                tr.appendChild(td);
            }

            tbody.appendChild(tr);
        }
    }

    async function runScan() {
        const btnStart = $("btnStart");
        const btnStop = $("btnStop");
        const btnExport = $("btnExport");
        const status = $("status");
        const bar = $("bar");
        const progressText = $("progressText");
        const rateText = $("rateText");

        const params = {
            atlPct: toNum($("atlPct").value),
            sideMonths: Math.floor(toNum($("sideMonths").value)),
            maxRangePct: toNum($("maxRangePct").value),
            maxTrendPct: toNum($("maxTrendPct").value),
            boxLowAboveAtlPct: toNum($("boxLowAboveAtlPct").value),
            minQuoteVol: toNum($("minQuoteVol").value),
            kneeRatio: toNum($("kneeRatio").value),
            shoulderRatio: toNum($("shoulderRatio").value),
            concurrency: Math.floor(toNum($("concurrency").value)),
            delayMs: Math.floor(toNum($("delayMs").value)),
            sortMode: $("sortMode").value
        };

        if (!(params.atlPct > 0 && params.sideMonths >= 3 && params.maxRangePct > 0 && params.maxTrendPct > 0)) {
            alert("입력값을 확인해 주세요.");
            return;
        }
        if (!(params.kneeRatio > 0 && params.kneeRatio < params.shoulderRatio && params.shoulderRatio < 1)) {
            alert("무릎/어깨 비율을 확인해 주세요. (무릎 < 어깨)");
            return;
        }

        btnStart.disabled = true;
        btnStop.disabled = false;
        btnExport.disabled = true;
        status.textContent = "심볼 로딩 중...";
        bar.style.width = "0%";
        progressText.textContent = "0 / 0";
        rateText.textContent = "";

        const controller = new AbortController();
        const signal = controller.signal;

        // Stop 버튼 핸들
        const onStop = () => {
            controller.abort();
        };
        btnStop.onclick = onStop;

        const t0 = performance.now();
        let lastUi = performance.now();
        let done = 0;

        const results = [];

        try {
            const symbols = await getSymbols(signal);
            status.textContent = `24h 티커 로딩 중... (심볼 ${symbols.length}개)`;
            const tickers = await getTickers24h(signal);

            const total = symbols.length;
            progressText.textContent = `${done} / ${total}`;

            const queue = symbols.slice();
            const workers = [];
            const now = Date.now();

            const worker = async () => {
                while (queue.length) {
                    if (signal.aborted) break;

                    const sym = queue.shift();
                    if (!sym) break;

                    const t = tickers.get(sym);
                    const price = t ? Number(t.lastPrice) : NaN;
                    const quoteVol = t ? Number(t.quoteVolume) : 0;

                    // 유동성 필터(너무 얇은 종목 제외)
                    if (!(quoteVol >= params.minQuoteVol) || !(price > 0)) {
                        done++;
                        continue;
                    }

                    try {
                        await sleep(params.delayMs);

                        const candlesAll = await getMonthlyKlines(sym, signal);
                        if (!candlesAll || candlesAll.length < (params.sideMonths + 2)) {
                            done++;
                            continue;
                        }

                        // ATL: 전체 low 최솟값 (마감 여부 무관)
                        let atl = Infinity;
                        for (const c of candlesAll) {
                            if (c.low < atl) atl = c.low;
                        }
                        if (!(atl > 0 && atl < Infinity)) {
                            done++;
                            continue;
                        }

                        const atlDistPct = ((price / atl) - 1) * 100;
                        if (!(atlDistPct <= params.atlPct)) {
                            done++;
                            continue;
                        }

                        // 횡보 박스: "마감된 월봉"만으로 최근 sideMonths개
                        const closed = candlesAll.filter((c) => c.closeTime < now);
                        if (closed.length < params.sideMonths) {
                            done++;
                            continue;
                        }
                        const win = closed.slice(-params.sideMonths);

                        const box = calcBox(win);
                        if (!box) {
                            done++;
                            continue;
                        }

                        // “ATL 근처에서 횡보” 강화조건: boxLow가 ATL에서 너무 멀면 제외
                        const boxLowAboveAtlPct = ((box.boxLow / atl) - 1) * 100;
                        if (boxLowAboveAtlPct > params.boxLowAboveAtlPct) {
                            done++;
                            continue;
                        }

                        const isSideways =
                            (box.rangePct <= params.maxRangePct) &&
                            (Math.abs(box.trendPct) <= params.maxTrendPct);

                        if (!isSideways) {
                            done++;
                            continue;
                        }

                        const knee = box.boxLow + (box.boxHigh - box.boxLow) * params.kneeRatio;
                        const shoulder = box.boxLow + (box.boxHigh - box.boxLow) * params.shoulderRatio;
                        const kneeToShoulderPct = knee > 0 ? ((shoulder / knee) - 1) * 100 : NaN;

                        const z = classifyPriceZone(price, knee, shoulder);

                        const row = {
                            symbol: sym,
                            price,
                            quoteVolume: quoteVol,
                            atl,
                            atlDistPct,
                            boxLow: box.boxLow,
                            boxHigh: box.boxHigh,
                            boxRangePct: box.rangePct,
                            trendPct: box.trendPct,
                            knee,
                            shoulder,
                            kneeToShoulderPct,
                            zoneText: z.text,
                            zoneCls: z.cls,
                            score: 0
                        };

                        row.score = scoreRow(row, params);
                        results.push(row);

                    } catch (e) {
                        // 심볼별 오류는 스킵 (429/418은 fetchJson에서 백오프 처리)
                    } finally {
                        done++;
                    }

                    const tn = performance.now();
                    if (tn - lastUi > 120) {
                        lastUi = tn;
                        const pct = total > 0 ? (done / total) * 100 : 0;
                        bar.style.width = `${pct.toFixed(2)}%`;
                        progressText.textContent = `${done} / ${total}`;

                        const elapsed = (tn - t0) / 1000;
                        const rps = elapsed > 0 ? (done / elapsed) : 0;
                        rateText.textContent = `처리속도 ~ ${rps.toFixed(2)} sym/s`;
                        status.textContent = `스캔 중... 후보 ${results.length}개`;
                    }
                }
            };

            const conc = clamp(params.concurrency, 1, 8);
            for (let i = 0; i < conc; i++) {
                workers.push(worker());
            }
            await Promise.all(workers);

            // 정렬 & 렌더
            const sorted = sortRows(results, params.sortMode);
            render(sorted);

            btnExport.disabled = !sorted.length;
            status.textContent = signal.aborted ? "중지됨" : `완료: 후보 ${sorted.length}개`;

            // CSV export
            btnExport.onclick = () => {
                const csv = toCsv(sorted);
                const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `binance_atl_box_candidates_${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            };

        } catch (e) {
            status.textContent = (signal.aborted) ? "중지됨" : `오류: ${e && e.message ? e.message : e}`;
        } finally {
            btnStart.disabled = false;
            btnStop.disabled = true;
        }
    }

    $("btnStart").addEventListener("click", () => runScan());
</script>
</body>
</html>
