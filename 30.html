<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT-PERP 1M ATL + 24H Sideways Box Scanner</title>
    <style>
        :root { color-scheme: dark; }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
            background: #0b0f19;
            color: #e8eefc;
        }
        .wrap { max-width: 1180px; margin: 0 auto; padding: 20px; }
        h1 { margin: 0 0 12px; font-size: 20px; letter-spacing: -0.2px; }
        .card {
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(255, 255, 255, 0.04);
            border-radius: 14px;
            padding: 14px;
            margin-bottom: 12px;
            backdrop-filter: blur(10px);
        }
        .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
        .field { display: flex; flex-direction: column; gap: 6px; }
        .field label { font-size: 12px; opacity: 0.85; }
        .field input, .field select {
            height: 36px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.25);
            color: #e8eefc;
            padding: 0 10px;
            outline: none;
        }
        .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        button {
            height: 38px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.08);
            color: #e8eefc;
            padding: 0 12px;
            cursor: pointer;
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .muted { opacity: 0.75; font-size: 12px; line-height: 1.4; }
        .progress { width: 100%; height: 10px; border-radius: 999px; background: rgba(255, 255, 255, 0.08); overflow: hidden; }
        .bar { height: 100%; width: 0%; background: rgba(120, 170, 255, 0.8); transition: width 0.15s linear; }
        table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
        th, td {
            padding: 10px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            text-align: right;
            font-size: 12.5px;
            white-space: nowrap;
        }
        th {
            text-align: right;
            font-size: 12px;
            opacity: 0.85;
            background: rgba(255, 255, 255, 0.05);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        th:first-child, td:first-child { text-align: left; }
        .tag {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            font-size: 11px;
            opacity: 0.95;
        }
        .tag.buy { border-color: rgba(80, 220, 160, 0.45); }
        .tag.sell { border-color: rgba(255, 140, 140, 0.45); }
        .tag.mid { border-color: rgba(180, 180, 255, 0.35); }
        .foot { display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; align-items: center; }
        .small { font-size: 11px; opacity: 0.75; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Binance USDT-PERP: 1M ATL 근접 + 최근 24시간 횡보(박스) 스캐너</h1>

    <div class="card">
        <div class="grid">
            <div class="field" style="grid-column: span 2;">
                <label>ATL 근접 허용치 (%)</label>
                <input id="atlPct" type="number" value="30" min="1" step="1" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>24h 횡보 봉 간격</label>
                <select id="sideInterval">
                    <option value="1m">1m</option>
                    <option value="5m">5m</option>
                    <option value="15m" selected>15m</option>
                    <option value="1h">1h</option>
                </select>
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>24h 박스폭 최대 (%)</label>
                <input id="maxRangePct24h" type="number" value="8" min="1" step="0.5" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>24h 추세 최대 (누적, %)</label>
                <input id="maxTrendPct24h" type="number" value="3" min="0.5" step="0.5" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>24h 박스Low가 ATL 위로 허용 (%)</label>
                <input id="boxLowAboveAtlPct" type="number" value="12" min="0" step="1" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>동시 요청 수(낮출수록 안전)</label>
                <input id="concurrency" type="number" value="2" min="1" max="8" step="1" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>요청 간 딜레이(ms)</label>
                <input id="delayMs" type="number" value="220" min="0" max="5000" step="10" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>무릎 비율 (0~1)</label>
                <input id="kneeRatio" type="number" value="0.25" min="0.05" max="0.45" step="0.01" />
            </div>

            <div class="field" style="grid-column: span 2;">
                <label>어깨 비율 (0~1)</label>
                <input id="shoulderRatio" type="number" value="0.75" min="0.55" max="0.95" step="0.01" />
            </div>

            <div class="field" style="grid-column: span 4;">
                <label>정렬</label>
                <select id="sortMode">
                    <option value="score">종합점수</option>
                    <option value="atlDist">ATL 근접(가까울수록)</option>
                    <option value="rangeTight">24h 박스폭(좁을수록)</option>
                    <option value="upside">(무릎→어깨) 잠재%</option>
                    <option value="liquidity">24h 거래대금(높을수록)</option>
                </select>
            </div>
        </div>

        <div class="row" style="margin-top: 12px;">
            <button id="btnStart">스캔 시작</button>
            <button id="btnStop" disabled>중지</button>
            <button id="btnExport" disabled>CSV 내보내기</button>
            <span class="muted" id="status">대기 중</span>
        </div>

        <div style="margin-top: 10px;">
            <div class="progress"><div class="bar" id="bar"></div></div>
            <div class="foot" style="margin-top: 8px;">
                <div class="small" id="progressText">0 / 0</div>
                <div class="small mono" id="rateText"></div>
            </div>
        </div>

        <div class="muted" style="margin-top: 10px;">
            ✅ “ATL 근처 + 최근 24시간 박스권” 후보를 찾는 용도.<br/>
            ⚠️ 박스 하단 이탈/뉴스/상폐/리브랜딩 등 변동성 리스크는 별도 관리 필요.
        </div>
    </div>

    <div class="card">
        <div style="max-height: 65vh; overflow: auto; border-radius: 12px;">
            <table>
                <thead>
                <tr>
                    <th>심볼</th>
                    <th>상태</th>
                    <th>점수</th>
                    <th>현재가</th>
                    <th>ATL(1M)</th>
                    <th>ATL거리%</th>
                    <th>24h 박스Low</th>
                    <th>24h 박스High</th>
                    <th>24h 박스폭%</th>
                    <th>24h 추세%</th>
                    <th>무릎</th>
                    <th>어깨</th>
                    <th>무릎→어깨%</th>
                    <th>24h 거래대금(USDT)</th>
                </tr>
                </thead>
                <tbody id="tbody">
                <tr><td colspan="14" class="muted">스캔 결과가 여기에 표시됩니다.</td></tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
    "use strict";

    const BASE = "https://fapi.binance.com";

    const $ = (id) => document.getElementById(id);

    function toNum(x) {
        const n = Number(x);
        return Number.isFinite(n) ? n : NaN;
    }

    function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
    }

    function fmt(n, d = 6) {
        if (!Number.isFinite(n)) return "-";
        if (Math.abs(n) >= 1000) return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
        return n.toLocaleString(undefined, { maximumFractionDigits: d });
    }

    function fmtPct(n, d = 2) {
        if (!Number.isFinite(n)) return "-";
        return n.toFixed(d);
    }

    function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }

    async function fetchJson(url, { signal, retries = 6, baseDelayMs = 300 } = {}) {
        let lastErr = null;

        for (let i = 0; i <= retries; i++) {
            try {
                const res = await fetch(url, { signal });

                if (res.status === 429 || res.status === 418) {
                    const ra = res.headers.get("Retry-After");
                    const waitSec = ra ? Number(ra) : NaN;
                    const waitMs = Number.isFinite(waitSec)
                        ? Math.max(1000, waitSec * 1000)
                        : (baseDelayMs * Math.pow(2, i));

                    lastErr = new Error(`Rate limited: ${res.status}, retry after ${waitMs}ms`);
                    await sleep(waitMs);
                    continue;
                }

                if (!res.ok) {
                    const t = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status}: ${t.slice(0, 180)}`);
                }

                return await res.json();
            } catch (e) {
                lastErr = e;
                if (signal && signal.aborted) throw e;

                const waitMs = baseDelayMs * Math.pow(2, i);
                await sleep(waitMs);
            }
        }

        throw lastErr || new Error("fetchJson failed");
    }

    function calcTrendPct(closes) {
        if (!closes || closes.length < 2) return NaN;
        const first = closes[0];
        const last = closes[closes.length - 1];
        if (first <= 0) return NaN;
        return ((last - first) / first) * 100;
    }

    function calcBox(candles) {
        if (!candles || candles.length < 3) return null;

        let boxLow = Infinity;
        let boxHigh = -Infinity;
        const closes = [];

        for (const c of candles) {
            if (c.low < boxLow) boxLow = c.low;
            if (c.high > boxHigh) boxHigh = c.high;
            closes.push(c.close);
        }

        if (!Number.isFinite(boxLow) || !Number.isFinite(boxHigh) || boxLow <= 0) return null;

        const rangePct = ((boxHigh - boxLow) / boxLow) * 100;
        const trendPct = calcTrendPct(closes);

        return { boxLow, boxHigh, rangePct, trendPct };
    }

    function classifyPriceZone(price, knee, shoulder) {
        if (!(price > 0 && knee > 0 && shoulder > 0)) return { text: "N/A", cls: "mid" };
        if (price <= knee) return { text: "매수권(무릎↓)", cls: "buy" };
        if (price >= shoulder) return { text: "매도권(어깨↑)", cls: "sell" };
        return { text: "중간(대기)", cls: "mid" };
    }

    function toCsv(rows) {
        const header = [
            "symbol", "status", "score", "price", "atl", "atlDistPct",
            "boxLow24h", "boxHigh24h", "boxRangePct24h", "trendPct24h",
            "knee", "shoulder", "kneeToShoulderPct", "quoteVolume"
        ];

        const lines = [header.join(",")];

        for (const r of rows) {
            const line = [
                r.symbol,
                r.zoneText,
                r.score.toFixed(4),
                r.price,
                r.atl,
                r.atlDistPct,
                r.boxLow,
                r.boxHigh,
                r.boxRangePct,
                r.trendPct,
                r.knee,
                r.shoulder,
                r.kneeToShoulderPct,
                r.quoteVolume
            ].map((v) => `"${String(v).replace(/"/g, '""')}"`).join(",");

            lines.push(line);
        }

        return lines.join("\n");
    }

    async function getSymbols(signal) {
        const info = await fetchJson(`${BASE}/fapi/v1/exchangeInfo`, { signal });
        return (info.symbols || [])
            .filter((s) =>
                s
                && s.contractType === "PERPETUAL"
                && s.quoteAsset === "USDT"
                && s.status === "TRADING"
            )
            .map((s) => s.symbol);
    }

    async function getTickers24h(signal) {
        const arr = await fetchJson(`${BASE}/fapi/v1/ticker/24hr`, { signal });
        const map = new Map();
        for (const t of arr || []) {
            if (!t || !t.symbol) continue;
            map.set(t.symbol, t);
        }
        return map;
    }

    async function getMonthlyKlines(symbol, signal) {
        const url = `${BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1M&limit=1000`;
        const raw = await fetchJson(url, { signal });

        return (raw || []).map((k) => {
            return {
                openTime: Number(k[0]),
                high: Number(k[2]),
                low: Number(k[3]),
                close: Number(k[4]),
                closeTime: Number(k[6])
            };
        }).filter((c) => Number.isFinite(c.low) && Number.isFinite(c.high) && Number.isFinite(c.close));
    }

    async function getKlines24h(symbol, interval, signal) {
        const now = Date.now();
        const startTime = now - (24 * 60 * 60 * 1000);

        // limit은 interval에 따라 충분히 크게
        const limitMap = { "1m": 1500, "5m": 1000, "15m": 500, "1h": 200 };
        const limit = limitMap[interval] || 500;

        const url =
            `${BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&startTime=${startTime}&limit=${limit}`;

        const raw = await fetchJson(url, { signal });

        const candles = (raw || []).map((k) => {
            return {
                openTime: Number(k[0]),
                high: Number(k[2]),
                low: Number(k[3]),
                close: Number(k[4]),
                closeTime: Number(k[6])
            };
        }).filter((c) =>
            Number.isFinite(c.low) && Number.isFinite(c.high) && Number.isFinite(c.close)
        );

        // "최근 24시간"에 해당하는 구간만 엄밀하게 컷
        const cut = candles.filter((c) => c.closeTime >= startTime && c.openTime <= now);

        // 진행 중인 캔들(마감 안 된 캔들)이 섞이면 박스가 넓어질 수 있으니 제외
        const closed = cut.filter((c) => c.closeTime < now);

        return closed;
    }

    function scoreRow(row, params) {
        const atlScore = clamp(1 - (row.atlDistPct / params.atlPct), 0, 1);
        const tightScore = clamp(1 - (row.boxRangePct / params.maxRangePct24h), 0, 1);
        const trendScore = clamp(1 - (Math.abs(row.trendPct) / params.maxTrendPct24h), 0, 1);

        // 거래대금은 필터링은 안 하지만, 점수에 아주 약하게 반영(원하면 0으로 바꿔도 됨)
        const lv = Math.max(0, row.quoteVolume);
        const liqScore = clamp(Math.log10(lv + 1) / 10, 0, 1);

        const score =
            (0.48 * atlScore) +
            (0.34 * tightScore) +
            (0.14 * trendScore) +
            (0.04 * liqScore);

        return clamp(score, 0, 1);
    }

    function sortRows(rows, mode) {
        const copy = rows.slice();
        if (mode === "atlDist") copy.sort((a, b) => a.atlDistPct - b.atlDistPct);
        else if (mode === "rangeTight") copy.sort((a, b) => a.boxRangePct - b.boxRangePct);
        else if (mode === "upside") copy.sort((a, b) => b.kneeToShoulderPct - a.kneeToShoulderPct);
        else if (mode === "liquidity") copy.sort((a, b) => b.quoteVolume - a.quoteVolume);
        else copy.sort((a, b) => b.score - a.score);
        return copy;
    }

    function render(rows) {
        const tbody = $("tbody");
        tbody.innerHTML = "";

        if (!rows.length) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 14;
            td.className = "muted";
            td.textContent = "조건을 만족하는 후보가 없습니다. (필터를 완화해 보세요)";
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }

        for (const r of rows) {
            const tr = document.createElement("tr");

            const td0 = document.createElement("td");
            td0.textContent = r.symbol;
            tr.appendChild(td0);

            const td1 = document.createElement("td");
            td1.innerHTML = `<span class="tag ${r.zoneCls}">${r.zoneText}</span>`;
            tr.appendChild(td1);

            const td2 = document.createElement("td");
            td2.textContent = r.score.toFixed(4);
            tr.appendChild(td2);

            const cols = [
                fmt(r.price, 8),
                fmt(r.atl, 8),
                fmtPct(r.atlDistPct),
                fmt(r.boxLow, 8),
                fmt(r.boxHigh, 8),
                fmtPct(r.boxRangePct),
                fmtPct(r.trendPct),
                fmt(r.knee, 8),
                fmt(r.shoulder, 8),
                fmtPct(r.kneeToShoulderPct),
                fmt(r.quoteVolume, 0)
            ];

            for (const v of cols) {
                const td = document.createElement("td");
                td.textContent = v;
                tr.appendChild(td);
            }

            tbody.appendChild(tr);
        }
    }

    async function runScan() {
        const btnStart = $("btnStart");
        const btnStop = $("btnStop");
        const btnExport = $("btnExport");
        const status = $("status");
        const bar = $("bar");
        const progressText = $("progressText");
        const rateText = $("rateText");

        const params = {
            atlPct: toNum($("atlPct").value),
            sideInterval: $("sideInterval").value,
            maxRangePct24h: toNum($("maxRangePct24h").value),
            maxTrendPct24h: toNum($("maxTrendPct24h").value),
            boxLowAboveAtlPct: toNum($("boxLowAboveAtlPct").value),
            kneeRatio: toNum($("kneeRatio").value),
            shoulderRatio: toNum($("shoulderRatio").value),
            concurrency: Math.floor(toNum($("concurrency").value)),
            delayMs: Math.floor(toNum($("delayMs").value)),
            sortMode: $("sortMode").value
        };

        if (!(params.atlPct > 0 && params.maxRangePct24h > 0 && params.maxTrendPct24h > 0)) {
            alert("입력값을 확인해 주세요.");
            return;
        }
        if (!(params.kneeRatio > 0 && params.kneeRatio < params.shoulderRatio && params.shoulderRatio < 1)) {
            alert("무릎/어깨 비율을 확인해 주세요. (무릎 < 어깨)");
            return;
        }

        btnStart.disabled = true;
        btnStop.disabled = false;
        btnExport.disabled = true;

        status.textContent = "심볼 로딩 중...";
        bar.style.width = "0%";
        progressText.textContent = "0 / 0";
        rateText.textContent = "";

        const controller = new AbortController();
        const signal = controller.signal;

        btnStop.onclick = () => controller.abort();

        const t0 = performance.now();
        let lastUi = performance.now();
        let done = 0;
        const results = [];

        try {
            const symbols = await getSymbols(signal);
            status.textContent = `24h 티커 로딩 중... (심볼 ${symbols.length}개)`;
            const tickers = await getTickers24h(signal);

            const total = symbols.length;
            progressText.textContent = `${done} / ${total}`;

            const queue = symbols.slice();
            const workers = [];

            const worker = async () => {
                while (queue.length) {
                    if (signal.aborted) break;

                    const sym = queue.shift();
                    if (!sym) break;

                    const t = tickers.get(sym);
                    const price = t ? Number(t.lastPrice) : NaN;
                    const quoteVol = t ? Number(t.quoteVolume) : 0;

                    if (!(price > 0)) {
                        done++;
                        continue;
                    }

                    try {
                        await sleep(params.delayMs);

                        // 1) ATL (1M)
                        const monthly = await getMonthlyKlines(sym, signal);
                        if (!monthly || monthly.length < 5) {
                            done++;
                            continue;
                        }

                        let atl = Infinity;
                        for (const c of monthly) {
                            if (c.low < atl) atl = c.low;
                        }
                        if (!(atl > 0 && atl < Infinity)) {
                            done++;
                            continue;
                        }

                        const atlDistPct = ((price / atl) - 1) * 100;
                        if (!(atlDistPct <= params.atlPct)) {
                            done++;
                            continue;
                        }

                        // 2) 최근 24h 박스(선택 interval)
                        const c24 = await getKlines24h(sym, params.sideInterval, signal);
                        if (!c24 || c24.length < 10) {
                            done++;
                            continue;
                        }

                        const box = calcBox(c24);
                        if (!box) {
                            done++;
                            continue;
                        }

                        // “ATL 근처에서 횡보” 강화조건: 24h 박스 low가 ATL에서 너무 멀면 제외
                        const boxLowAboveAtlPct = ((box.boxLow / atl) - 1) * 100;
                        if (boxLowAboveAtlPct > params.boxLowAboveAtlPct) {
                            done++;
                            continue;
                        }

                        const isSideways =
                            (box.rangePct <= params.maxRangePct24h) &&
                            (Math.abs(box.trendPct) <= params.maxTrendPct24h);

                        if (!isSideways) {
                            done++;
                            continue;
                        }

                        const knee = box.boxLow + (box.boxHigh - box.boxLow) * params.kneeRatio;
                        const shoulder = box.boxLow + (box.boxHigh - box.boxLow) * params.shoulderRatio;
                        const kneeToShoulderPct = knee > 0 ? ((shoulder / knee) - 1) * 100 : NaN;

                        const z = classifyPriceZone(price, knee, shoulder);

                        const row = {
                            symbol: sym,
                            price,
                            quoteVolume: quoteVol,
                            atl,
                            atlDistPct,
                            boxLow: box.boxLow,
                            boxHigh: box.boxHigh,
                            boxRangePct: box.rangePct,
                            trendPct: box.trendPct,
                            knee,
                            shoulder,
                            kneeToShoulderPct,
                            zoneText: z.text,
                            zoneCls: z.cls,
                            score: 0
                        };

                        row.score = scoreRow(row, params);
                        results.push(row);

                    } catch (e) {
                        // 심볼별 오류는 스킵 (429/418은 fetchJson에서 백오프 처리)
                    } finally {
                        done++;
                    }

                    const tn = performance.now();
                    if (tn - lastUi > 120) {
                        lastUi = tn;
                        const pct = total > 0 ? (done / total) * 100 : 0;
                        bar.style.width = `${pct.toFixed(2)}%`;
                        progressText.textContent = `${done} / ${total}`;

                        const elapsed = (tn - t0) / 1000;
                        const rps = elapsed > 0 ? (done / elapsed) : 0;
                        rateText.textContent = `처리속도 ~ ${rps.toFixed(2)} sym/s`;
                        status.textContent = `스캔 중... 후보 ${results.length}개`;
                    }
                }
            };

            const conc = clamp(params.concurrency, 1, 8);
            for (let i = 0; i < conc; i++) {
                workers.push(worker());
            }
            await Promise.all(workers);

            const sorted = sortRows(results, params.sortMode);
            render(sorted);

            btnExport.disabled = !sorted.length;
            status.textContent = signal.aborted ? "중지됨" : `완료: 후보 ${sorted.length}개`;

            btnExport.onclick = () => {
                const csv = toCsv(sorted);
                const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = `binance_atl_24h_box_candidates_${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();

                URL.revokeObjectURL(url);
            };

        } catch (e) {
            status.textContent = (signal.aborted) ? "중지됨" : `오류: ${e && e.message ? e.message : e}`;
        } finally {
            btnStart.disabled = false;
            btnStop.disabled = true;
        }
    }

    $("btnStart").addEventListener("click", () => runScan());
</script>
</body>
</html>
