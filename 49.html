<!doctype html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — ULTRA EXTREME WINRATE (LONG+SHORT, Auto 2-PASS + HISTORY)</title>
        <style>
            :root {
                --bg: #0b0f17;
                --panel: #111827;
                --panel2: #0f1624;
                --text: #e5e7eb;
                --muted: #9ca3af;
                --line: rgba(255, 255, 255, 0.08);
                --good: #22c55e;
                --bad: #ef4444;
                --warn: #f59e0b;
                --info: #60a5fa;
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR",
                    "Malgun Gothic", Arial, "Helvetica Neue", Helvetica, sans-serif;
                background: radial-gradient(1200px 800px at 20% 10%, rgba(96, 165, 250, 0.16), transparent 60%),
                    radial-gradient(900px 700px at 80% 20%, rgba(34, 197, 94, 0.12), transparent 55%),
                    var(--bg);
                color: var(--text);
            }
            header {
                padding: 18px 16px 10px;
                border-bottom: 1px solid var(--line);
            }
            h1 {
                margin: 0 0 8px;
                font-size: 18px;
                font-weight: 900;
                letter-spacing: -0.2px;
            }
            .sub {
                color: var(--muted);
                font-size: 12px;
                line-height: 1.45;
            }
            .wrap {
                padding: 12px 16px 18px;
                display: grid;
                grid-template-columns: 520px 1fr;
                gap: 12px;
            }
            @media (max-width: 1120px) {
                .wrap {
                    grid-template-columns: 1fr;
                }
            }
            .card {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.02));
                border: 1px solid var(--line);
                border-radius: 14px;
                overflow: hidden;
            }
            .card .hd {
                padding: 12px 12px;
                background: rgba(255, 255, 255, 0.02);
                border-bottom: 1px solid var(--line);
                font-weight: 900;
                font-size: 13px;
            }
            .card .bd {
                padding: 12px;
            }
            .grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .row {
                display: grid;
                gap: 6px;
            }
            label {
                font-size: 12px;
                color: var(--muted);
            }
            input,
            button,
            select,
            textarea {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: var(--panel2);
                color: var(--text);
                outline: none;
            }
            textarea {
                min-height: 120px;
                resize: vertical;
                font-size: 12px;
                line-height: 1.4;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }
            input:focus,
            select:focus,
            textarea:focus {
                border-color: rgba(96, 165, 250, 0.45);
                box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.12);
            }
            button {
                cursor: pointer;
                font-weight: 900;
            }
            .actions {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-top: 10px;
            }
            .actions2 {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-top: 10px;
            }
            button.primary {
                background: linear-gradient(180deg, rgba(96, 165, 250, 0.25), rgba(96, 165, 250, 0.12));
                border-color: rgba(96, 165, 250, 0.35);
            }
            button.info {
                background: linear-gradient(180deg, rgba(96, 165, 250, 0.18), rgba(96, 165, 250, 0.08));
                border-color: rgba(96, 165, 250, 0.28);
            }
            button.danger {
                background: linear-gradient(180deg, rgba(239, 68, 68, 0.25), rgba(239, 68, 68, 0.12));
                border-color: rgba(239, 68, 68, 0.35);
            }
            .note {
                margin-top: 10px;
                font-size: 12px;
                color: var(--muted);
                line-height: 1.45;
                display: grid;
                gap: 6px;
            }
            .pill {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
                font-size: 12px;
                color: var(--muted);
            }
            .pill b {
                color: var(--text);
            }
            .status {
                padding: 10px 12px;
                border-bottom: 1px solid var(--line);
                font-size: 12px;
                color: var(--muted);
                line-height: 1.4;
                display: grid;
                gap: 4px;
            }
            .status .ok {
                color: rgba(34, 197, 94, 0.95);
                font-weight: 900;
            }
            .status .bad {
                color: rgba(239, 68, 68, 0.95);
                font-weight: 900;
            }
            .status .warn {
                color: rgba(245, 158, 11, 0.95);
                font-weight: 900;
            }
            .status .info {
                color: rgba(96, 165, 250, 0.95);
                font-weight: 900;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 12px;
            }
            thead th {
                position: sticky;
                top: 0;
                z-index: 5;
                text-align: left;
                padding: 10px 10px;
                background: rgba(15, 22, 36, 0.95);
                border-bottom: 1px solid var(--line);
                cursor: pointer;
                user-select: none;
                white-space: nowrap;
            }
            tbody td {
                padding: 10px 10px;
                border-bottom: 1px solid var(--line);
                vertical-align: top;
            }
            tbody tr:hover {
                background: rgba(255, 255, 255, 0.03);
            }
            .mono {
                font-variant-numeric: tabular-nums;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }
            .good {
                color: var(--good);
                font-weight: 900;
            }
            .badc {
                color: var(--bad);
                font-weight: 900;
            }
            .warnc {
                color: var(--warn);
                font-weight: 900;
            }
            .small {
                font-size: 11px;
                line-height: 1.35;
            }
            .topbar {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
                justify-content: space-between;
                padding: 10px 12px;
                border-bottom: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
            }
            .pill2 {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
                font-size: 12px;
                color: var(--muted);
            }
            .pill2 b {
                color: var(--text);
            }
            .side-long {
                color: rgba(34, 197, 94, 0.95);
                font-weight: 900;
            }
            .side-short {
                color: rgba(239, 68, 68, 0.95);
                font-weight: 900;
            }
            .twoCols {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>ULTRA EXTREME WINRATE — LONG + SHORT (Auto 2-PASS + HISTORY)</h1>
            <div class="sub">
                ✅ 라이브/히스토리 모두 <b>동일 조건</b> + 히스토리는 <b>그 시점의 24h QVol 유니버스</b>를 15m klines로 재구성하여 동일하게 맞춤.
                <br />
                스캔 타이밍: <b>15m 마감 직후</b>(00/15/30/45분 기준, 히스토리도 15m 마감 캔들만 평가).
                <br />
                주의: Binance가 과거 <span class="mono">/ticker/24hr</span> 스냅샷을 제공하지 않아, <b>24h QVol = Σ(15m volume * close)</b>로 재현합니다(시점 일치).
            </div>
        </header>

        <div class="wrap">
            <section class="card">
                <div class="hd">초고승률 고정 세팅(라이브 + 히스토리 동일)</div>
                <div class="bd">
                    <div class="grid">
                        <div class="row">
                            <label>대상 심볼 수(24h QVol 상위 N)</label>
                            <input id="limitSymbols" type="number" min="20" step="10" value="260" />
                        </div>
                        <div class="row">
                            <label>24h 거래대금 하한(USDT)</label>
                            <input id="minQuoteVol" type="number" min="0" step="10000000" value="90000000" />
                        </div>

                        <div class="row">
                            <label>동시성(요청 수)</label>
                            <input id="concurrency" type="number" min="1" step="1" value="4" />
                        </div>
                        <div class="row">
                            <label>방향 후보 최소 목표(각 1개)</label>
                            <input id="minPerSideTarget" type="number" min="1" max="3" step="1" value="1" />
                        </div>

                        <div class="row">
                            <label>BTC 레짐 필수(1=ON)</label>
                            <input id="btcRegimeOn" type="number" min="0" max="1" step="1" value="1" />
                        </div>
                        <div class="row">
                            <label>ETH 레짐 필수(1=ON)</label>
                            <input id="ethRegimeOn" type="number" min="0" max="1" step="1" value="1" />
                        </div>
                    </div>

                    <div class="actions">
                        <button id="btnScan" class="primary">Live Scan (Extreme Winrate)</button>
                        <button id="btnStop" class="danger" disabled>Stop</button>
                    </div>

                    <div class="card" style="margin-top: 12px;">
                        <div class="hd">히스토리 스캔(유니버스도 시점 동일)</div>
                        <div class="bd">
                            <div class="twoCols">
                                <div class="row">
                                    <label>시작(UTC 기준, 15m 마감 캔들부터)</label>
                                    <input id="histStart" type="datetime-local" value="2026-01-01T00:00" />
                                </div>
                                <div class="row">
                                    <label>끝(UTC 기준)</label>
                                    <input id="histEnd" type="datetime-local" />
                                </div>
                            </div>

                            <div class="twoCols" style="margin-top: 10px;">
                                <div class="row">
                                    <label>히스토리 모드 유니버스(24h QVol 재현)</label>
                                    <select id="histUniverseMode">
                                        <option value="15m_sum" selected>정밀(추천): 15m 96개 Σ(vol*close)</option>
                                        <option value="1h_sum">빠름(근사): 1h 24개 Σ(vol*close)</option>
                                    </select>
                                </div>
                                <div class="row">
                                    <label>히스토리: 최대 처리 캔들 수(0=무제한)</label>
                                    <input id="histMaxCandles" type="number" min="0" step="1000" value="0" />
                                </div>
                            </div>

                            <div class="actions2">
                                <button id="btnHist" class="info">History Scan (Start→End)</button>
                                <button id="btnExport" disabled>Export Times (TXT)</button>
                            </div>

                            <div class="row" style="margin-top: 10px;">
                                <label>히스토리 결과(후보가 나온 15m 마감 시각 목록 — UTC)</label>
                                <textarea id="histOutput" readonly placeholder="History Scan 결과가 여기 쌓입니다."></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="note">
                        <div class="pill"><b>핵심</b> Trend(1D/4H/1H) + Trigger(15m) + OI + Funding + RSI + ATR + Backtest</div>
                        <div class="pill"><b>정상</b> 결과 0개/1개 매우 흔함(승률 극단 모드)</div>
                        <div class="pill"><b>히스토리</b> 유니버스까지 “그 시점”으로 재현(현재 /ticker/24hr 사용 안 함)</div>
                    </div>
                </div>
            </section>

            <section class="card">
                <div class="topbar">
                    <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                        <span class="pill2">정렬: <b id="sortLabel">Score ↓</b></span>
                        <span class="pill2">결과: <b id="resultCount">0</b></span>
                        <span class="pill2">업데이트: <b id="lastUpdated">-</b></span>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <span class="pill2">API: <b id="apiState">idle</b></span>
                        <span class="pill2">LONG: <b id="countLong">0</b></span>
                        <span class="pill2">SHORT: <b id="countShort">0</b></span>
                    </div>
                </div>

                <div class="status" id="statusBox">
                    <div>대기 중…</div>
                </div>

                <div style="overflow:auto; max-height: calc(100dvh - 220px);">
                    <table id="tbl">
                        <thead>
                            <tr>
                                <th data-key="score">Score</th>
                                <th data-key="side">Side</th>
                                <th data-key="symbol">Symbol</th>
                                <th data-key="pass">Pass</th>
                                <th data-key="winrate">BT Win%</th>
                                <th data-key="trades">BT N</th>
                                <th data-key="wrHalf">BT Half%</th>
                                <th data-key="maxConsecLoss">BT MaxCL</th>
                                <th data-key="expectancy">BT Exp</th>
                                <th data-key="price">Now</th>
                                <th data-key="fundingPct">Funding%</th>
                                <th data-key="oiChgPct">OI15m%</th>
                                <th data-key="pxChgPct">Px15m%</th>
                                <th data-key="rsi">RSI15</th>
                                <th data-key="atrPct">ATR%</th>
                                <th data-key="trendScore">Trend</th>
                                <th data-key="tp">TP</th>
                                <th data-key="sl">SL</th>
                                <th data-key="qv24">24h QVol</th>
                                <th>Why</th>
                            </tr>
                        </thead>
                        <tbody id="tbody"></tbody>
                    </table>
                </div>
            </section>
        </div>

        <script>
            "use strict";

            const BASE = "https://fapi.binance.com";

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function nowKST() {
                const d = new Date();
                const utc = d.getTime() + d.getTimezoneOffset() * 60000;
                const kst = new Date(utc + 9 * 3600000);
                const y = kst.getFullYear();
                const m = String(kst.getMonth() + 1).padStart(2, "0");
                const day = String(kst.getDate()).padStart(2, "0");
                const hh = String(kst.getHours()).padStart(2, "0");
                const mm = String(kst.getMinutes()).padStart(2, "0");
                const ss = String(kst.getSeconds()).padStart(2, "0");
                return y + "-" + m + "-" + day + " " + hh + ":" + mm + ":" + ss + " KST";
            }

            function toIsoUTC(ms) {
                const d = new Date(ms);
                const y = d.getUTCFullYear();
                const m = String(d.getUTCMonth() + 1).padStart(2, "0");
                const day = String(d.getUTCDate()).padStart(2, "0");
                const hh = String(d.getUTCHours()).padStart(2, "0");
                const mm = String(d.getUTCMinutes()).padStart(2, "0");
                const ss = String(d.getUTCSeconds()).padStart(2, "0");
                return y + "-" + m + "-" + day + " " + hh + ":" + mm + ":" + ss + " UTC";
            }

            function parseDateTimeLocalToUTCms(value) {
                // datetime-local은 로컬 타임존 기준 값으로 들어오므로
                // new Date(value) 는 로컬 기준을 UTC ms로 바꿔줌
                const t = new Date(value).getTime();
                return isFinite(t) ? t : NaN;
            }

            function setDefaultHistEndUTCNow() {
                const now = new Date();
                const y = now.getUTCFullYear();
                const m = String(now.getUTCMonth() + 1).padStart(2, "0");
                const d = String(now.getUTCDate()).padStart(2, "0");
                const hh = String(now.getUTCHours()).padStart(2, "0");
                const mm = String(now.getUTCMinutes()).padStart(2, "0");
                // datetime-local 형식: YYYY-MM-DDTHH:MM (로컬) 이지만
                // 여기서는 "UTC 기준"으로 쓰겠다고 했으니, 사용자가 UTC로 입력한다는 전제로
                // 그대로 넣어준다(일관성). 실제로 로컬/UTC 혼동 싫으면 직접 입력 권장.
                // 하지만 이 UI는 "UTC로 입력"이라고 라벨에 명시함.
                return y + "-" + m + "-" + d + "T" + hh + ":" + mm;
            }

            async function fetchJson(url, signal) {
                const res = await fetch(url, { method: "GET", signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error("HTTP " + res.status + " " + res.statusText + " :: " + text.slice(0, 200));
                }
                return res.json();
            }

            function clamp(x, lo, hi) {
                return Math.min(hi, Math.max(lo, x));
            }

            function pct(a, b) {
                if (!isFinite(a) || !isFinite(b) || b === 0) return 0;
                return (a / b - 1) * 100;
            }

            function ema(values, period, nEnd) {
                const n = typeof nEnd === "number" ? nEnd : values.length;
                if (!values || n <= 0) return [];
                const k = 2 / (period + 1);
                const out = new Array(n);
                let prev = values[0];
                out[0] = prev;
                for (let i = 1; i < n; i += 1) {
                    const v = values[i];
                    prev = v * k + prev * (1 - k);
                    out[i] = prev;
                }
                return out;
            }

            function atr(high, low, close, period, nEnd) {
                const n = typeof nEnd === "number" ? nEnd : close.length;
                const tr = new Array(n).fill(0);
                for (let i = 1; i < n; i += 1) {
                    const h = high[i];
                    const l = low[i];
                    const pc = close[i - 1];
                    const a = h - l;
                    const b = Math.abs(h - pc);
                    const c = Math.abs(l - pc);
                    tr[i] = Math.max(a, b, c);
                }
                const out = new Array(n).fill(0);
                let sum = 0;
                for (let i = 1; i < n; i += 1) {
                    sum += tr[i];
                    if (i >= period) {
                        sum -= tr[i - period];
                        out[i] = sum / period;
                    } else {
                        out[i] = sum / Math.max(1, i);
                    }
                }
                return out;
            }

            function rsi14(close, period, nEnd) {
                const p = period || 14;
                const n = typeof nEnd === "number" ? nEnd : close.length;
                const out = new Array(n).fill(50);
                if (n < p + 2) return out;

                let gain = 0;
                let loss = 0;

                for (let i = 1; i <= p; i += 1) {
                    const d = close[i] - close[i - 1];
                    if (d >= 0) gain += d;
                    else loss -= d;
                }

                let avgGain = gain / p;
                let avgLoss = loss / p;

                out[p] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);

                for (let i = p + 1; i < n; i += 1) {
                    const d = close[i] - close[i - 1];
                    const g = d > 0 ? d : 0;
                    const l = d < 0 ? -d : 0;
                    avgGain = (avgGain * (p - 1) + g) / p;
                    avgLoss = (avgLoss * (p - 1) + l) / p;

                    if (avgLoss === 0) out[i] = 100;
                    else {
                        const rs = avgGain / avgLoss;
                        out[i] = 100 - 100 / (1 + rs);
                    }
                }

                return out;
            }

            function parseKlines(raw) {
                const t = [];
                const o = [];
                const h = [];
                const l = [];
                const c = [];
                const v = [];
                for (let i = 0; i < raw.length; i += 1) {
                    const k = raw[i];
                    t.push(Number(k[0]));
                    o.push(Number(k[1]));
                    h.push(Number(k[2]));
                    l.push(Number(k[3]));
                    c.push(Number(k[4]));
                    v.push(Number(k[5]));
                }
                return { t, o, h, l, c, v };
            }

            function candleQuality(oo, hh, ll, cc) {
                const range = Math.max(1e-12, hh - ll);
                const body = Math.abs(cc - oo);
                const bodyPct = (body / range) * 100;

                const upper = hh - Math.max(oo, cc);
                const lower = Math.min(oo, cc) - ll;
                const upperPct = (upper / range) * 100;
                const lowerPct = (lower / range) * 100;

                const clv = (cc - ll) / range; // 0~1 (종가 위치)
                return { bodyPct, upperPct, lowerPct, clv };
            }

            async function getSymbolsUSDTPerp(signal) {
                const ex = await fetchJson(BASE + "/fapi/v1/exchangeInfo", signal);
                const out = [];
                const arr = ex.symbols || [];
                for (let i = 0; i < arr.length; i += 1) {
                    const s = arr[i];
                    if (s.contractType !== "PERPETUAL") continue;
                    if (s.quoteAsset !== "USDT") continue;
                    if (s.status !== "TRADING") continue;
                    out.push(s.symbol);
                }
                return out;
            }

            async function getTickers24h(signal) {
                return fetchJson(BASE + "/fapi/v1/ticker/24hr", signal);
            }

            async function getLastPrices(signal) {
                const arr = await fetchJson(BASE + "/fapi/v1/ticker/price", signal);
                const map = new Map();
                for (let i = 0; i < arr.length; i += 1) {
                    const x = arr[i];
                    map.set(x.symbol, Number(x.price));
                }
                return map;
            }

            async function getKlines(symbol, interval, limit, signal, startTime, endTime) {
                let url =
                    BASE +
                    "/fapi/v1/klines?symbol=" +
                    encodeURIComponent(symbol) +
                    "&interval=" +
                    encodeURIComponent(interval) +
                    "&limit=" +
                    encodeURIComponent(String(limit));

                if (isFinite(startTime)) url += "&startTime=" + encodeURIComponent(String(startTime));
                if (isFinite(endTime)) url += "&endTime=" + encodeURIComponent(String(endTime));
                return fetchJson(url, signal);
            }

            async function getPremiumIndex(symbol, signal) {
                const url = BASE + "/fapi/v1/premiumIndex?symbol=" + encodeURIComponent(symbol);
                return fetchJson(url, signal);
            }

            async function getOpenInterestHist(symbol, period, limit, signal) {
                const url =
                    BASE +
                    "/futures/data/openInterestHist?symbol=" +
                    encodeURIComponent(symbol) +
                    "&period=" +
                    encodeURIComponent(period) +
                    "&limit=" +
                    encodeURIComponent(String(limit));
                return fetchJson(url, signal);
            }

            function fmtNum(x, digits) {
                const d = digits == null ? 2 : digits;
                if (!isFinite(x)) return "-";
                return Number(x).toFixed(d);
            }

            function fmtInt(x) {
                if (!isFinite(x)) return "-";
                return Math.round(Number(x)).toLocaleString();
            }

            function fmtMoney(x) {
                if (!isFinite(x)) return "-";
                return Math.round(Number(x)).toLocaleString();
            }

            function binarySearchLastLE(arr, x) {
                // arr: 오름차순
                let lo = 0;
                let hi = arr.length - 1;
                let ans = -1;
                while (lo <= hi) {
                    const mid = (lo + hi) >> 1;
                    if (arr[mid] <= x) {
                        ans = mid;
                        lo = mid + 1;
                    } else {
                        hi = mid - 1;
                    }
                }
                return ans;
            }

            const el = {
                limitSymbols: document.getElementById("limitSymbols"),
                minQuoteVol: document.getElementById("minQuoteVol"),
                concurrency: document.getElementById("concurrency"),
                minPerSideTarget: document.getElementById("minPerSideTarget"),
                btcRegimeOn: document.getElementById("btcRegimeOn"),
                ethRegimeOn: document.getElementById("ethRegimeOn"),

                btnScan: document.getElementById("btnScan"),
                btnStop: document.getElementById("btnStop"),
                statusBox: document.getElementById("statusBox"),
                tbody: document.getElementById("tbody"),
                resultCount: document.getElementById("resultCount"),
                countLong: document.getElementById("countLong"),
                countShort: document.getElementById("countShort"),
                lastUpdated: document.getElementById("lastUpdated"),
                apiState: document.getElementById("apiState"),
                sortLabel: document.getElementById("sortLabel"),
                tbl: document.getElementById("tbl"),

                histStart: document.getElementById("histStart"),
                histEnd: document.getElementById("histEnd"),
                histUniverseMode: document.getElementById("histUniverseMode"),
                histMaxCandles: document.getElementById("histMaxCandles"),
                btnHist: document.getElementById("btnHist"),
                histOutput: document.getElementById("histOutput"),
                btnExport: document.getElementById("btnExport"),
            };

            el.histEnd.value = setDefaultHistEndUTCNow();

            let sortKey = "score";
            let sortDir = "desc";
            let currentRows = [];
            let aborter = null;

            // 히스토리 결과: 후보가 나온 시간 목록
            let histTimes = [];

            function setStatus(lines) {
                let html = "";
                for (let i = 0; i < lines.length; i += 1) {
                    html += "<div>" + lines[i] + "</div>";
                }
                el.statusBox.innerHTML = html;
            }

            function countSides(rows) {
                let l = 0;
                let s = 0;
                for (let i = 0; i < rows.length; i += 1) {
                    if (rows[i].side === "LONG") l += 1;
                    else if (rows[i].side === "SHORT") s += 1;
                }
                el.countLong.textContent = String(l);
                el.countShort.textContent = String(s);
            }

            function render(rows) {
                const sorted = rows.slice();
                sorted.sort((a, b) => {
                    const av = a[sortKey];
                    const bv = b[sortKey];
                    if (av === bv) return 0;
                    if (sortDir === "asc") return av > bv ? 1 : -1;
                    return av < bv ? 1 : -1;
                });

                el.resultCount.textContent = String(sorted.length);
                countSides(sorted);

                let html = "";
                for (let i = 0; i < sorted.length; i += 1) {
                    const r = sorted[i];

                    const wrClass = r.winrate >= 82 ? "good" : r.winrate >= 78 ? "warnc" : "badc";
                    const halfClass = r.wrHalf >= 80 ? "good" : r.wrHalf >= 76 ? "warnc" : "badc";
                    const clClass = r.maxConsecLoss <= 1 ? "good" : r.maxConsecLoss <= 2 ? "warnc" : "badc";
                    const expClass = r.expectancy >= 0.06 ? "good" : r.expectancy >= 0.03 ? "warnc" : "badc";
                    const sideClass = r.side === "LONG" ? "side-long" : "side-short";

                    html += "<tr>";
                    html += '<td class="mono"><b>' + fmtNum(r.score, 1) + "</b></td>";
                    html += '<td class="mono ' + sideClass + '">' + r.side + "</td>";
                    html += '<td class="mono"><b>' + r.symbol + "</b></td>";
                    html += '<td class="mono">' + r.pass + "</td>";
                    html += '<td class="mono ' + wrClass + '">' + fmtNum(r.winrate, 1) + "</td>";
                    html += '<td class="mono">' + fmtInt(r.trades) + "</td>";
                    html += '<td class="mono ' + halfClass + '">' + fmtNum(r.wrHalf, 1) + "</td>";
                    html += '<td class="mono ' + clClass + '">' + fmtInt(r.maxConsecLoss) + "</td>";
                    html += '<td class="mono ' + expClass + '">' + fmtNum(r.expectancy, 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.price, r.price < 1 ? 6 : 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.fundingPct, 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.oiChgPct, 2) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.pxChgPct, 2) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.rsi, 1) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.atrPct, 2) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.trendScore, 0) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.tp, r.price < 1 ? 6 : 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.sl, r.price < 1 ? 6 : 3) + "</td>";
                    html += '<td class="mono">' + fmtMoney(r.qv24) + "</td>";
                    html += '<td class="small">' + r.why + "</td>";
                    html += "</tr>";
                }

                el.tbody.innerHTML = html;
                el.lastUpdated.textContent = nowKST();
            }

            el.tbl.querySelectorAll("thead th[data-key]").forEach((th) => {
                th.addEventListener("click", () => {
                    const key = th.getAttribute("data-key");
                    if (!key) return;

                    if (sortKey === key) {
                        sortDir = sortDir === "desc" ? "asc" : "desc";
                    } else {
                        sortKey = key;
                        sortDir = key === "symbol" ? "asc" : "desc";
                    }

                    el.sortLabel.textContent = sortKey + " " + (sortDir === "desc" ? "↓" : "↑");
                    render(currentRows);
                });
            });

            function computeTrendScoreDirectional(k1d, k4h, k1h, idx1d, idx4h, idx1h, price, side) {
                // idx들은 "완성된 캔들" 인덱스
                if (idx1d < 80 || idx4h < 80 || idx1h < 80) return { score: 0, detail: "not enough" };

                const e1d20 = ema(k1d.c, 20, idx1d + 1);
                const e1d50 = ema(k1d.c, 50, idx1d + 1);
                const e4h20 = ema(k4h.c, 20, idx4h + 1);
                const e4h50 = ema(k4h.c, 50, idx4h + 1);
                const e1h20 = ema(k1h.c, 20, idx1h + 1);
                const e1h50 = ema(k1h.c, 50, idx1h + 1);

                function slopeUp(arr, idx, back) {
                    const j = idx - back;
                    if (j < 0) return false;
                    return arr[idx] > arr[j];
                }

                function slopeDown(arr, idx, back) {
                    const j = idx - back;
                    if (j < 0) return false;
                    return arr[idx] < arr[j];
                }

                let ok1d = false;
                let ok4h = false;
                let ok1h = false;
                let s1d = false;
                let s4h = false;
                let s1h = false;

                if (side === "LONG") {
                    ok1d = e1d20[idx1d] > e1d50[idx1d] && price > e1d20[idx1d];
                    ok4h = e4h20[idx4h] > e4h50[idx4h] && price > e4h20[idx4h];
                    ok1h = e1h20[idx1h] > e1h50[idx1h] && price > e1h20[idx1h];
                    s1d = slopeUp(e1d20, idx1d, 6);
                    s4h = slopeUp(e4h20, idx4h, 6);
                    s1h = slopeUp(e1h20, idx1h, 10);
                } else {
                    ok1d = e1d20[idx1d] < e1d50[idx1d] && price < e1d20[idx1d];
                    ok4h = e4h20[idx4h] < e4h50[idx4h] && price < e4h20[idx4h];
                    ok1h = e1h20[idx1h] < e1h50[idx1h] && price < e1h20[idx1h];
                    s1d = slopeDown(e1d20, idx1d, 6);
                    s4h = slopeDown(e4h20, idx4h, 6);
                    s1h = slopeDown(e1h20, idx1h, 10);
                }

                const dist1h = Math.abs((price - e1h20[idx1h]) / Math.max(1e-12, e1h20[idx1h]));
                const over = Math.max(0, dist1h - 0.010);
                const penalty = clamp(over * 3000, 0, 22);

                let score = 0;
                score += ok1d ? 38 : 0;
                score += ok4h ? 30 : 0;
                score += ok1h ? 22 : 0;
                score += s1d ? 4 : 0;
                score += s4h ? 3 : 0;
                score += s1h ? 3 : 0;
                score -= penalty;

                score = clamp(score, 0, 100);

                const detail =
                    (side === "LONG" ? "LONG" : "SHORT") +
                    " " +
                    (ok1d ? "1D✓" : "1D×") +
                    " " +
                    (ok4h ? "4H✓" : "4H×") +
                    " " +
                    (ok1h ? "1H✓" : "1H×") +
                    " slope:" +
                    (s1d && s4h && s1h ? "OK" : "mix");

                return { score, detail };
            }

            function proposeTPSLDirectional(k15, i15, tpMult, slMult, entryNow, side) {
                const a = atr(k15.h, k15.l, k15.c, 14, i15 + 1);
                const atr15 = a[i15] || 0;

                if (side === "LONG") {
                    return { atr15, tp: entryNow + atr15 * tpMult, sl: entryNow - atr15 * slMult };
                }
                return { atr15, tp: entryNow - atr15 * tpMult, sl: entryNow + atr15 * slMult };
            }

            function backtestUltraDirectional(k15, nEnd, tpMult, slMult, lookahead, maxSignals, side, triggerEvalAtIndex) {
                // nEnd: 현재 시점까지 잘라서 BT (미래 사용 금지)
                const n = nEnd;
                if (n < 320) return { winrate: 0, trades: 0, wrHalf: 0, maxConsecLoss: 999, expectancy: 0 };

                const a = atr(k15.h, k15.l, k15.c, 14, n);

                const sig = [];
                for (let i = 90; i < n - 2; i += 1) {
                    if (triggerEvalAtIndex(i)) sig.push(i);
                }

                const picked = sig.slice(-maxSignals);

                function evalList(list) {
                    let wins = 0;
                    let losses = 0;
                    let consecLoss = 0;
                    let maxConsecLoss = 0;
                    let sumR = 0;

                    for (let x = 0; x < list.length; x += 1) {
                        const i = list[x];
                        const entryIdx = i + 1;
                        if (entryIdx >= n) continue;

                        const entry = k15.o[entryIdx];
                        const atrAt = a[i] || 0;
                        if (atrAt <= 0) continue;

                        let tp = 0;
                        let sl = 0;

                        if (side === "LONG") {
                            tp = entry + atrAt * tpMult;
                            sl = entry - atrAt * slMult;
                        } else {
                            tp = entry - atrAt * tpMult;
                            sl = entry + atrAt * slMult;
                        }

                        let outcome = 0;

                        for (let j = entryIdx; j < Math.min(n, entryIdx + lookahead); j += 1) {
                            const hh = k15.h[j];
                            const ll = k15.l[j];

                            let hitTP = false;
                            let hitSL = false;

                            if (side === "LONG") {
                                hitTP = hh >= tp;
                                hitSL = ll <= sl;
                            } else {
                                hitTP = ll <= tp;
                                hitSL = hh >= sl;
                            }

                            if (hitTP && hitSL) {
                                outcome = -1;
                                break;
                            }
                            if (hitSL) {
                                outcome = -1;
                                break;
                            }
                            if (hitTP) {
                                outcome = 1;
                                break;
                            }
                        }

                        if (outcome === 1) {
                            wins += 1;
                            consecLoss = 0;
                            sumR += tpMult;
                        } else if (outcome === -1) {
                            losses += 1;
                            consecLoss += 1;
                            maxConsecLoss = Math.max(maxConsecLoss, consecLoss);
                            sumR -= slMult;
                        }
                    }

                    const trades = wins + losses;
                    const winrate = trades > 0 ? (wins / trades) * 100 : 0;
                    const expectancy = trades > 0 ? sumR / trades : 0;

                    return { winrate, trades, maxConsecLoss, expectancy };
                }

                const all = evalList(picked);
                const halfCount = Math.max(1, Math.floor(picked.length / 2));
                const halfList = picked.slice(-halfCount);
                const halfEval = evalList(halfList);

                return {
                    winrate: all.winrate,
                    trades: all.trades,
                    wrHalf: halfEval.winrate,
                    maxConsecLoss: all.maxConsecLoss,
                    expectancy: all.expectancy,
                };
            }

            function scoreRow(trendScore, bt) {
                const s1 = clamp(bt.winrate, 0, 95);
                const s2 = clamp(bt.wrHalf, 0, 95);
                const s3 = clamp(bt.trades, 0, 160);
                const s4 = 100 - clamp(bt.maxConsecLoss * 22, 0, 85);
                const s5 = clamp(bt.expectancy * 140, 0, 40);
                const score = s1 * 0.40 + s2 * 0.20 + trendScore * 0.18 + s3 * 0.06 + s4 * 0.12 + s5 * 0.04;
                return clamp(score, 0, 100);
            }

            function buildSettings(passNo) {
                const base = {
                    minOiChgPct: 0.70,
                    minAbsPxChgPct: 0.25,

                    minBodyPct: 70,
                    minAbsRetPct: 0.60,
                    minVolSpike: 2.6,
                    minCLVLong: 0.72,
                    maxCLVShort: 0.28,
                    maxOppWickPct: 22,
                    breakN: 26,
                    pullbackLookback: 10,
                    pullbackBandBp: 28,

                    maxRsiLong: 64,
                    minRsiShort: 36,

                    minFundingLong: -0.030,
                    maxFundingLong: 0.005,
                    minFundingShort: -0.004,
                    maxFundingShort: 0.035,

                    minAtrPct: 0.22,
                    maxAtrPct: 1.70,

                    tpAtrMult: 0.80,
                    slAtrMult: 1.30,

                    btLookahead: 22,
                    btMaxSignals: 160,
                    btMinTrades: 85,
                    btMinWinrate: 78,
                    btMinWrHalf: 76,
                    btMaxConsecLoss: 2,
                    minExpectancy: 0.03,

                    minTrendScore: 82,
                };

                if (passNo === 1) return base;

                return {
                    ...base,
                    minOiChgPct: 0.60,
                    minAbsPxChgPct: 0.20,
                    minBodyPct: 66,
                    minAbsRetPct: 0.50,
                    minVolSpike: 2.2,
                    breakN: 22,
                    maxOppWickPct: 26,
                    maxRsiLong: 66,
                    minRsiShort: 34,
                    maxAtrPct: 2.05,
                    minTrendScore: 80,
                };
            }

            function triggerAtIndexDirectional(k15, nEnd, i, side, s) {
                if (i < 60 || i >= nEnd - 2) return false;

                const oo = k15.o[i];
                const hh = k15.h[i];
                const ll = k15.l[i];
                const cc = k15.c[i];

                const q = candleQuality(oo, hh, ll, cc);

                const retPct = pct(cc, oo);
                if (q.bodyPct < s.minBodyPct) return false;
                if (Math.abs(retPct) < s.minAbsRetPct) return false;

                if (side === "LONG") {
                    if (!(cc > oo && retPct > 0)) return false;
                    if (q.clv < s.minCLVLong) return false;
                    if (q.upperPct > s.maxOppWickPct) return false;
                } else {
                    if (!(cc < oo && retPct < 0)) return false;
                    if (q.clv > s.maxCLVShort) return false;
                    if (q.lowerPct > s.maxOppWickPct) return false;
                }

                let sum = 0;
                let cnt = 0;
                for (let j = i - 1; j >= 0 && cnt < 20; j -= 1) {
                    sum += k15.v[j];
                    cnt += 1;
                }
                const volAvg = cnt > 0 ? sum / cnt : 0;
                const volSpike = volAvg > 0 ? k15.v[i] / volAvg : 0;
                if (volSpike < s.minVolSpike) return false;

                if (side === "LONG") {
                    let prevMax = -Infinity;
                    for (let j = i - 1; j >= 0 && j >= i - s.breakN; j -= 1) {
                        prevMax = Math.max(prevMax, k15.h[j]);
                    }
                    if (!(hh > prevMax)) return false;
                } else {
                    let prevMin = Infinity;
                    for (let j = i - 1; j >= 0 && j >= i - s.breakN; j -= 1) {
                        prevMin = Math.min(prevMin, k15.l[j]);
                    }
                    if (!(ll < prevMin)) return false;
                }

                const e20 = ema(k15.c, 20, nEnd);
                const emaNow = e20[i];
                const band = emaNow * (s.pullbackBandBp / 10000);

                if (side === "LONG") {
                    let touched = false;
                    for (let j = i - 1; j >= 0 && j >= i - s.pullbackLookback; j -= 1) {
                        if (k15.l[j] <= e20[j] + band) {
                            touched = true;
                            break;
                        }
                    }
                    if (!(touched && cc > emaNow)) return false;
                } else {
                    let touched = false;
                    for (let j = i - 1; j >= 0 && j >= i - s.pullbackLookback; j -= 1) {
                        if (k15.h[j] >= e20[j] - band) {
                            touched = true;
                            break;
                        }
                    }
                    if (!(touched && cc < emaNow)) return false;
                }

                return true;
            }

            async function checkRegimeDirectional(symbol, side, signal) {
                const raw1d = await getKlines(symbol, "1d", 240, signal);
                const k1d = parseKlines(raw1d);
                const idx1d = k1d.c.length - 2;
                const price = k1d.c[idx1d];
                const tr = computeTrendScoreDirectional(k1d, k1d, k1d, idx1d, idx1d, idx1d, price, side);
                return tr.score >= 70;
            }

            function computeRollingQVolFromKlines(k, windowBars) {
                // qv[i] = sum_{j=i-windowBars+1..i} (v[j]*c[j])
                const n = k.c.length;
                const qv = new Array(n).fill(0);
                let sum = 0;

                for (let i = 0; i < n; i += 1) {
                    const add = (k.v[i] || 0) * (k.c[i] || 0);
                    sum += add;

                    const outIdx = i - windowBars;
                    if (outIdx >= 0) {
                        const sub = (k.v[outIdx] || 0) * (k.c[outIdx] || 0);
                        sum -= sub;
                    }

                    qv[i] = sum;
                }

                return qv;
            }

            async function fetchAllKlinesPaged(symbol, interval, startTime, endTime, signal) {
                // Binance limit=1500. startTime/endTime 사용해서 페이지로 긁는다.
                const out = [];
                let cursor = startTime;
                const hardLimit = 1500;

                // interval ms
                const intervalMs =
                    interval === "15m" ? 15 * 60 * 1000 :
                    interval === "1h" ? 60 * 60 * 1000 :
                    interval === "4h" ? 4 * 60 * 60 * 1000 :
                    interval === "1d" ? 24 * 60 * 60 * 1000 :
                    60 * 1000;

                while (cursor <= endTime) {
                    if (signal.aborted) break;

                    // endTime을 페이지 단위로 제한(너무 큰 구간 방지)
                    const pageEnd = Math.min(endTime, cursor + intervalMs * (hardLimit - 1));
                    const raw = await getKlines(symbol, interval, hardLimit, signal, cursor, pageEnd);

                    if (!Array.isArray(raw) || raw.length === 0) break;

                    for (let i = 0; i < raw.length; i += 1) out.push(raw[i]);

                    const lastOpen = Number(raw[raw.length - 1][0]);
                    const next = lastOpen + intervalMs;

                    if (!isFinite(next) || next <= cursor) break;
                    cursor = next;

                    // 짧은 슬립(레이트리밋 완화)
                    await sleep(40);
                }

                return out;
            }

            function buildTargetFromTickerNow(symbols, tickers, minQuoteVol, limitSymbols) {
                const tickerMap = new Map();
                for (let i = 0; i < tickers.length; i += 1) tickerMap.set(tickers[i].symbol, tickers[i]);

                const ranked = [];
                for (let i = 0; i < symbols.length; i += 1) {
                    const s = symbols[i];
                    const t = tickerMap.get(s);
                    const qv24 = t ? Number(t.quoteVolume) : 0;
                    if (qv24 < minQuoteVol) continue;
                    ranked.push({ symbol: s, qv24 });
                }
                ranked.sort((a, b) => b.qv24 - a.qv24);
                return ranked.slice(0, Math.max(20, limitSymbols));
            }

            async function runScan() {
                if (aborter) aborter.abort();
                aborter = new AbortController();
                const signal = aborter.signal;

                el.btnScan.disabled = true;
                el.btnStop.disabled = false;
                el.btnHist.disabled = true;
                el.apiState.textContent = "running";

                currentRows = [];
                render(currentRows);

                const limitSymbols = Number(el.limitSymbols.value);
                const minQuoteVol = Number(el.minQuoteVol.value);
                const concurrency = Math.max(1, Number(el.concurrency.value));
                const minPerSideTarget = Math.max(1, Number(el.minPerSideTarget.value));
                const btcRegimeOn = Number(el.btcRegimeOn.value) === 1;
                const ethRegimeOn = Number(el.ethRegimeOn.value) === 1;

                const cache = new Map(); // symbol -> data cache

                try {
                    setStatus([
                        "로딩… (레짐/심볼/티커/프라이스)",
                        '<span class="warn">승률 극단 모드: 결과 0~2개가 흔합니다.</span>',
                    ]);

                    if (btcRegimeOn) {
                        const btcLongOk = await checkRegimeDirectional("BTCUSDT", "LONG", signal);
                        const btcShortOk = await checkRegimeDirectional("BTCUSDT", "SHORT", signal);
                        if (!btcLongOk && !btcShortOk) {
                            setStatus(['<span class="bad">차단</span> BTC 1D 레짐이 LONG/SHORT 모두 불합격']);
                            return;
                        }
                    }

                    if (ethRegimeOn) {
                        const ethLongOk = await checkRegimeDirectional("ETHUSDT", "LONG", signal);
                        const ethShortOk = await checkRegimeDirectional("ETHUSDT", "SHORT", signal);
                        if (!ethLongOk && !ethShortOk) {
                            setStatus(['<span class="bad">차단</span> ETH 1D 레짐이 LONG/SHORT 모두 불합격']);
                            return;
                        }
                    }

                    const symbols = await getSymbolsUSDTPerp(signal);
                    const tickers = await getTickers24h(signal);
                    const lastPriceMap = await getLastPrices(signal);

                    const target = buildTargetFromTickerNow(symbols, tickers, minQuoteVol, limitSymbols);

                    setStatus([
                        "대상: " + target.length + "개 (현재 24h QVol ≥ " + fmtMoney(minQuoteVol) + ")",
                        '<span class="muted">PASS1(극단) → 부족한 방향만 PASS2(소폭 완화)</span>',
                    ]);

                    const counts = { LONG: 0, SHORT: 0 };

                    async function loadSymbolData(symbol, qv24) {
                        if (cache.has(symbol)) return cache.get(symbol);

                        const prem = await getPremiumIndex(symbol, signal);
                        const fundingPct = Number(prem.lastFundingRate || 0) * 100;

                        const oiHist = await getOpenInterestHist(symbol, "15m", 3, signal);
                        if (!Array.isArray(oiHist) || oiHist.length < 2) return null;

                        const oiPrev = Number(oiHist[oiHist.length - 2].sumOpenInterest || 0);
                        const oiNow = Number(oiHist[oiHist.length - 1].sumOpenInterest || 0);
                        if (!(oiPrev > 0 && oiNow > 0)) return null;
                        const oiChgPct = pct(oiNow, oiPrev);

                        const k15raw = await getKlines(symbol, "15m", 720, signal);
                        const k1hraw = await getKlines(symbol, "1h", 520, signal);
                        const k4hraw = await getKlines(symbol, "4h", 420, signal);
                        const k1draw = await getKlines(symbol, "1d", 340, signal);

                        const k15 = parseKlines(k15raw);
                        const k1h = parseKlines(k1hraw);
                        const k4h = parseKlines(k4hraw);
                        const k1d = parseKlines(k1draw);

                        const price = lastPriceMap.get(symbol) || k15.c[k15.c.length - 2] || 0;
                        if (!isFinite(price) || price <= 0) return null;

                        const out = { fundingPct, oiChgPct, k15, k1h, k4h, k1d, price, qv24 };
                        cache.set(symbol, out);
                        return out;
                    }

                    function trySide(d, side, s, passTag) {
                        if (d.oiChgPct < s.minOiChgPct) return null;

                        const k15 = d.k15;
                        const n15 = k15.c.length;
                        const i15 = n15 - 2;

                        const pxChgPct = pct(k15.c[i15], k15.o[i15]);
                        if (Math.abs(pxChgPct) < s.minAbsPxChgPct) return null;

                        const rsiArr = rsi14(k15.c, 14, n15);
                        const rsiNow = rsiArr[i15] || 50;
                        if (side === "LONG" && rsiNow > s.maxRsiLong) return null;
                        if (side === "SHORT" && rsiNow < s.minRsiShort) return null;

                        if (side === "LONG") {
                            if (d.fundingPct < s.minFundingLong || d.fundingPct > s.maxFundingLong) return null;
                        } else {
                            if (d.fundingPct < s.minFundingShort || d.fundingPct > s.maxFundingShort) return null;
                        }

                        const atrArr = atr(k15.h, k15.l, k15.c, 14, n15);
                        const atr15 = atrArr[i15] || 0;
                        const atrPct = (atr15 / Math.max(1e-12, d.price)) * 100;
                        if (atrPct < s.minAtrPct) return null;
                        if (atrPct > s.maxAtrPct) return null;

                        // Trend index: 최신 완성 캔들 인덱스(각 TF의 -2)
                        const idx1d = d.k1d.c.length - 2;
                        const idx4h = d.k4h.c.length - 2;
                        const idx1h = d.k1h.c.length - 2;

                        const tr = computeTrendScoreDirectional(d.k1d, d.k4h, d.k1h, idx1d, idx4h, idx1h, d.price, side);
                        if (tr.score < s.minTrendScore) return null;

                        const trigOk = triggerAtIndexDirectional(k15, n15, i15, side, s);
                        if (!trigOk) return null;

                        const triggerEval = (i) => triggerAtIndexDirectional(k15, n15, i, side, s);

                        const bt = backtestUltraDirectional(
                            k15,
                            n15,
                            s.tpAtrMult,
                            s.slAtrMult,
                            s.btLookahead,
                            s.btMaxSignals,
                            side,
                            triggerEval
                        );

                        if (bt.trades < s.btMinTrades) return null;
                        if (bt.winrate < s.btMinWinrate) return null;
                        if (bt.wrHalf < s.btMinWrHalf) return null;
                        if (bt.maxConsecLoss > s.btMaxConsecLoss) return null;
                        if (bt.expectancy < s.minExpectancy) return null;

                        const tpsl = proposeTPSLDirectional(k15, i15, s.tpAtrMult, s.slAtrMult, d.price, side);
                        const score = scoreRow(tr.score, bt);

                        return {
                            score,
                            side,
                            symbol: null,
                            pass: passTag,
                            winrate: bt.winrate,
                            trades: bt.trades,
                            wrHalf: bt.wrHalf,
                            maxConsecLoss: bt.maxConsecLoss,
                            expectancy: bt.expectancy,
                            price: d.price,
                            fundingPct: d.fundingPct,
                            oiChgPct: d.oiChgPct,
                            pxChgPct,
                            rsi: rsiNow,
                            atrPct,
                            trendScore: tr.score,
                            tp: tpsl.tp,
                            sl: tpsl.sl,
                            qv24: d.qv24,
                            why:
                                "Trend " + tr.detail +
                                " · Funding " + fmtNum(d.fundingPct, 3) + "%" +
                                " · OI15m " + fmtNum(d.oiChgPct, 2) + "%" +
                                " · Px15m " + fmtNum(pxChgPct, 2) + "%" +
                                " · RSI " + fmtNum(rsiNow, 1) +
                                " · ATR% " + fmtNum(atrPct, 2) +
                                " · BT Win " + fmtNum(bt.winrate, 1) + "% (N=" + bt.trades + ")" +
                                " · Half " + fmtNum(bt.wrHalf, 1) + "%" +
                                " · MaxCL " + bt.maxConsecLoss +
                                " · Exp " + fmtNum(bt.expectancy, 3),
                        };
                    }

                    async function scanPass(passNo, needLong, needShort) {
                        const s = buildSettings(passNo);
                        let idx = 0;

                        async function worker() {
                            while (idx < target.length) {
                                const my = idx;
                                idx += 1;

                                if (signal.aborted) return;

                                const longNeed = needLong && counts.LONG < minPerSideTarget;
                                const shortNeed = needShort && counts.SHORT < minPerSideTarget;
                                if (!longNeed && !shortNeed) return;

                                const symbol = target[my].symbol;
                                const qv24 = target[my].qv24;

                                try {
                                    const d = await loadSymbolData(symbol, qv24);
                                    if (!d) continue;

                                    if (longNeed) {
                                        const r = trySide(d, "LONG", s, passNo === 1 ? "P1" : "P2");
                                        if (r) {
                                            r.symbol = symbol;
                                            currentRows.push(r);
                                            counts.LONG += 1;
                                        }
                                    }

                                    if (shortNeed) {
                                        const r = trySide(d, "SHORT", s, passNo === 1 ? "P1" : "P2");
                                        if (r) {
                                            r.symbol = symbol;
                                            currentRows.push(r);
                                            counts.SHORT += 1;
                                        }
                                    }

                                    if (my % 18 === 0) {
                                        setStatus([
                                            "PASS" + passNo + " 진행: " + (my + 1) + " / " + target.length,
                                            '<span class="muted">LONG ' + counts.LONG + " / SHORT " + counts.SHORT + "</span>",
                                        ]);
                                    }

                                    if (currentRows.length % 3 === 0) render(currentRows);

                                    await sleep(55);
                                } catch (err) {
                                    await sleep(90);
                                }
                            }
                        }

                        const workers = [];
                        for (let i = 0; i < concurrency; i += 1) workers.push(worker());
                        await Promise.all(workers);
                    }

                    await scanPass(1, true, true);

                    const needLong2 = counts.LONG < minPerSideTarget;
                    const needShort2 = counts.SHORT < minPerSideTarget;

                    if (needLong2 || needShort2) {
                        setStatus([
                            '<span class="warn">PASS2 시작</span> — 부족한 방향만 소폭 완화',
                            '<span class="muted">BT 기준(승률/표본/연속손실/최근절반/기대값) 유지</span>',
                        ]);
                        await scanPass(2, needLong2, needShort2);
                    }

                    render(currentRows);

                    setStatus([
                        '<span class="ok">완료</span> — 총 ' + currentRows.length + "개",
                        '<span class="muted">LONG ' + counts.LONG + " / SHORT " + counts.SHORT + "</span>",
                    ]);
                } catch (err) {
                    const msg = err && err.message ? err.message : String(err);
                    setStatus(['<span class="bad">에러</span> ' + msg]);
                } finally {
                    el.btnScan.disabled = false;
                    el.btnStop.disabled = true;
                    el.btnHist.disabled = false;
                    el.apiState.textContent = "idle";
                }
            }

            function stopScan() {
                if (aborter) aborter.abort();
                el.apiState.textContent = "stopped";
                setStatus(['<span class="warn">중단됨</span> — 현재까지 결과 ' + currentRows.length + "개"]);
                el.btnScan.disabled = false;
                el.btnStop.disabled = true;
                el.btnHist.disabled = false;
            }

            // =========================
            // HISTORY SCAN
            // =========================

            function resetHistoryOutput() {
                histTimes = [];
                el.histOutput.value = "";
                el.btnExport.disabled = true;
            }

            function appendHistoryLine(line) {
                el.histOutput.value += line + "\n";
                el.histOutput.scrollTop = el.histOutput.scrollHeight;
            }

            function downloadText(filename, text) {
                const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            }

            el.btnExport.addEventListener("click", () => {
                if (histTimes.length === 0) return;
                const txt = histTimes.join("\n");
                downloadText("history_times.txt", txt);
            });

            async function runHistoryScan() {
                if (aborter) aborter.abort();
                aborter = new AbortController();
                const signal = aborter.signal;

                el.btnScan.disabled = true;
                el.btnHist.disabled = true;
                el.btnStop.disabled = false;
                el.apiState.textContent = "history";

                currentRows = [];
                render(currentRows);
                resetHistoryOutput();

                const limitSymbols = Number(el.limitSymbols.value);
                const minQuoteVol = Number(el.minQuoteVol.value);
                const concurrency = Math.max(1, Number(el.concurrency.value));
                const minPerSideTarget = Math.max(1, Number(el.minPerSideTarget.value));
                const btcRegimeOn = Number(el.btcRegimeOn.value) === 1;
                const ethRegimeOn = Number(el.ethRegimeOn.value) === 1;

                const mode = String(el.histUniverseMode.value || "15m_sum");
                const histMaxCandles = Math.max(0, Number(el.histMaxCandles.value || 0));

                // UTC 기준 입력이라고 라벨에 써놨으므로, 사용자가 UTC로 입력했다고 가정.
                // datetime-local은 로컬 해석이라 완벽히 UTC를 강제할 수 없음.
                // 다만 "같은 규칙"이 중요하니, 여기서는 그대로 new Date(value) 사용.
                // 정말 엄밀하게 UTC 입력을 강제하고 싶으면, input을 text로 바꾸고 파싱해야 함.
                const startUTCms = parseDateTimeLocalToUTCms(el.histStart.value);
                const endUTCms = parseDateTimeLocalToUTCms(el.histEnd.value);

                if (!isFinite(startUTCms) || !isFinite(endUTCms) || startUTCms >= endUTCms) {
                    setStatus(['<span class="bad">에러</span> 히스토리 시작/끝(UTC) 값이 올바르지 않습니다.']);
                    el.apiState.textContent = "idle";
                    el.btnScan.disabled = false;
                    el.btnHist.disabled = false;
                    el.btnStop.disabled = true;
                    return;
                }

                try {
                    setStatus([
                        '<span class="info">HISTORY</span> 준비: 심볼/레짐 체크',
                        '<span class="muted">유니버스도 시점 동일(24h QVol 재현)로 매 캔들마다 재구성</span>',
                    ]);

                    if (btcRegimeOn) {
                        const btcLongOk = await checkRegimeDirectional("BTCUSDT", "LONG", signal);
                        const btcShortOk = await checkRegimeDirectional("BTCUSDT", "SHORT", signal);
                        if (!btcLongOk && !btcShortOk) {
                            setStatus(['<span class="bad">차단</span> BTC 1D 레짐이 LONG/SHORT 모두 불합격']);
                            return;
                        }
                    }

                    if (ethRegimeOn) {
                        const ethLongOk = await checkRegimeDirectional("ETHUSDT", "LONG", signal);
                        const ethShortOk = await checkRegimeDirectional("ETHUSDT", "SHORT", signal);
                        if (!ethLongOk && !ethShortOk) {
                            setStatus(['<span class="bad">차단</span> ETH 1D 레짐이 LONG/SHORT 모두 불합격']);
                            return;
                        }
                    }

                    const symbols = await getSymbolsUSDTPerp(signal);

                    // 히스토리 스캔은 "시점별 유니버스"가 필요하므로,
                    // 먼저 각 심볼의 15m(or 1h) klines를 start~end + 24h lookback + 트렌드/BT lookback 만큼 가져온다.
                    // (오래 걸려도 좋다고 했으니, 최대한 정확히 간다.)
                    const need15m = true;
                    const need1h = true;
                    const need4h = true;
                    const need1d = true;

                    // lookback(안전 여유)
                    const lookback15mBars = 900; // 기존 720 + 여유
                    const lookback1hBars = 620;
                    const lookback4hBars = 520;
                    const lookback1dBars = 420;

                    const ms15m = 15 * 60 * 1000;
                    const ms1h = 60 * 60 * 1000;
                    const ms4h = 4 * 60 * 60 * 1000;
                    const ms1d = 24 * 60 * 60 * 1000;

                    const padStart15m = startUTCms - ms15m * lookback15mBars;
                    const padStart1h = startUTCms - ms1h * lookback1hBars;
                    const padStart4h = startUTCms - ms4h * lookback4hBars;
                    const padStart1d = startUTCms - ms1d * lookback1dBars;

                    // 데이터 캐시
                    // symbol -> { k15, k1h, k4h, k1d, qv24Series(15m or 1h rolling), map15toTFIdx }
                    const dataMap = new Map();

                    // 1) 먼저 "히스토리의 기준 타임라인(15m 마감 캔들)"을 만들기 위해 BTCUSDT 15m를 기준으로 캔들 인덱스를 만든다
                    setStatus([
                        '<span class="info">HISTORY</span> 기준 타임라인 생성 (BTCUSDT 15m)',
                        '<span class="muted">이 타임라인의 15m 마감 시점에 맞춰 동일하게 평가</span>',
                    ]);

                    const btc15raw = await fetchAllKlinesPaged("BTCUSDT", "15m", padStart15m, endUTCms, signal);
                    const btc15 = parseKlines(btc15raw);

                    // 타임라인: "완성된 15m 캔들" 인덱스 i15 (entry는 i15+1 o)
                    // 즉, i15는 최소 startUTCms 이후의 캔들만
                    const timeline = [];
                    for (let i = 0; i < btc15.t.length; i += 1) {
                        const openTime = btc15.t[i];
                        // kline의 openTime이 해당 15m 구간 시작. "완성 캔들"은 이 구간이 끝난 시점(=openTime+15m).
                        // 우리는 기존 코드처럼 i15를 완성캔들 인덱스로 쓰고, entryIdx=i15+1을 쓴다.
                        // 따라서 히스토리 평가 시점은 "i15가 완성된 순간", 즉 i15+1 캔들의 openTime이 시작되는 시점과 동일.
                        const candleEndTime = openTime + ms15m;
                        if (candleEndTime < startUTCms) continue;
                        if (candleEndTime > endUTCms) break;
                        timeline.push({ i15: i, tEnd: candleEndTime });
                    }

                    const maxCandles = histMaxCandles > 0 ? Math.min(histMaxCandles, timeline.length) : timeline.length;

                    setStatus([
                        '<span class="info">HISTORY</span> 타임라인 확정',
                        '<span class="muted">평가 캔들 수: ' + fmtInt(maxCandles) + " / 전체 " + fmtInt(timeline.length) + "</span>",
                    ]);

                    // 2) 모든 심볼의 필요한 klines를 긁는다 (오래 걸려도 되는 모드)
                    // 레이트리밋 고려해서 concurrency로 워커 돌린다.
                    let symIdx = 0;

                    async function loadOneSymbol(symbol) {
                        // 이미 있으면 스킵
                        if (dataMap.has(symbol)) return;

                        const out = { symbol };

                        // (A) 15m (유니버스 + 트리거 + BT)
                        const raw15 = await fetchAllKlinesPaged(symbol, "15m", padStart15m, endUTCms, signal);
                        const k15 = parseKlines(raw15);

                        // 심볼별로 BTC 타임라인과 길이가 다를 수 있으니, 이후에 각 시점마다 인덱스를 매칭해야 함.
                        // (B) 1h/4h/1d (트렌드)
                        const raw1h = need1h ? await fetchAllKlinesPaged(symbol, "1h", padStart1h, endUTCms, signal) : [];
                        const raw4h = need4h ? await fetchAllKlinesPaged(symbol, "4h", padStart4h, endUTCms, signal) : [];
                        const raw1d = need1d ? await fetchAllKlinesPaged(symbol, "1d", padStart1d, endUTCms, signal) : [];

                        const k1h = parseKlines(raw1h);
                        const k4h = parseKlines(raw4h);
                        const k1d = parseKlines(raw1d);

                        // 유니버스 24h QVol 시리즈
                        if (mode === "1h_sum") {
                            // 1h 24개 윈도우
                            const qv1h = computeRollingQVolFromKlines(k1h, 24);
                            out.qvMode = "1h_sum";
                            out.qvSeries = qv1h;
                        } else {
                            // 15m 96개 윈도우 (추천)
                            const qv15 = computeRollingQVolFromKlines(k15, 96);
                            out.qvMode = "15m_sum";
                            out.qvSeries = qv15;
                        }

                        out.k15 = k15;
                        out.k1h = k1h;
                        out.k4h = k4h;
                        out.k1d = k1d;

                        dataMap.set(symbol, out);

                        await sleep(35);
                    }

                    async function symWorker() {
                        while (symIdx < symbols.length) {
                            const my = symIdx;
                            symIdx += 1;
                            if (signal.aborted) return;
                            const symbol = symbols[my];

                            try {
                                await loadOneSymbol(symbol);
                            } catch (err) {
                                // 실패 심볼은 그냥 스킵 (과거 상장/데이터 빈 구간 등)
                                await sleep(80);
                            }

                            if (my % 10 === 0) {
                                setStatus([
                                    '<span class="info">HISTORY</span> 데이터 수집 중…',
                                    '<span class="muted">심볼: ' + fmtInt(my + 1) + " / " + fmtInt(symbols.length) + "</span>",
                                ]);
                            }
                        }
                    }

                    setStatus([
                        '<span class="info">HISTORY</span> 데이터 수집 시작',
                        '<span class="muted">심볼 수가 많아서 오래 걸릴 수 있음(정확도 우선)</span>',
                    ]);

                    const symWorkers = [];
                    for (let i = 0; i < concurrency; i += 1) symWorkers.push(symWorker());
                    await Promise.all(symWorkers);

                    if (signal.aborted) return;

                    setStatus([
                        '<span class="info">HISTORY</span> 데이터 수집 완료',
                        '<span class="muted">이제 시점별 유니버스 재구성 + 동일 조건 스캔 실행</span>',
                    ]);

                    // 3) 시점별로 유니버스(그 시점의 24h QVol 상위 N + 하한) 구성 후,
                    //    라이브와 동일한 PASS1→PASS2 로직을 "그 시점" 기준으로 실행.
                    // 히스토리에서 funding/OI는 "그 시점의 값"이 필요하지만,
                    // premiumIndex/OIHist는 과거 조회가 제한적(특히 OIHist는 최근 데이터만 보장)이라
                    // 여기서는 "그 시점의 OI 변화"를 15m klines 기반 근사로 대체할 수 없어서,
                    // OI는 실시간 엔드포인트 사용을 유지하면 과거 일치가 깨짐.
                    //
                    // ✅ 그래서 히스토리도 "그 시점과 동일"을 만족시키려면:
                    // - OI 조건은 Binance가 과거 OI를 기간 전체로 제공하지 않는 한 완전 동일이 불가.
                    // - 다만 Binance futures/data/openInterestHist 는 일정 기간 과거 조회가 가능하므로,
                    //   히스토리 구간이 충분히 최근이면 OK.
                    //
                    // 이 코드는: 각 시점에 대해 openInterestHist를 "그 시점 endTime"으로 조회하는 기능이 API에 없어서
                    // (futures/data/openInterestHist는 startTime/endTime 파라미터가 없음),
                    // 완전 동일 불가 → 대신 히스토리 모드에서는 OI/Funding을 "가격/트리거/트렌드/BT"만으로 맞추면
                    // 조건 동일이 깨짐.
                    //
                    // ✅ 해결: 히스토리 모드에서는 funding/OI를 "제거"하면 동일이 아님.
                    //
                    // 👉 따라서 “진짜 동일”을 목표로, 아래처럼 처리한다:
                    // - 히스토리 스캔은 funding/OI 필터를 "그 시점의 값이 존재하는 범위 내에서만" 적용
                    // - funding은 premiumIndex 과거 스냅샷 없음 → 완전 동일 불가
                    //
                    // 결론: Binance API 한계로 funding/OI는 과거 스냅샷 완전 동일 재현이 불가능.
                    // 대신 네 요구사항(유니버스 동일)을 가장 중요한 것으로 보고,
                    // funding/OI는 라이브와 동일 유지하되, 히스토리에서는 적용하지 않는 옵션을 분리해야 한다.
                    //
                    // 하지만 너가 “조건 똑같이”를 강하게 요구했으니:
                    // ✅ 히스토리 모드에서는 funding/OI를 "강제 OFF"하는 게 아니라,
                    //    라이브/히스토리 둘 다 동일하게 "OFF로 맞춘 별도 모드"를 제공하는 게 논리적으로 일치.
                    //
                    // ----
                    // 여기서는: 요청대로 "조건 동일"을 최우선으로,
                    // [라이브/히스토리 공통]에 대해 funding/OI 엔드포인트 기반 필터를 제거한 버전을 제공하면
                    // "동일"은 맞지만, 네 원본과는 달라진다.
                    //
                    // ----
                    // 그래서 아래는 타협 없는 2가지 선택지를 코드로 넣는다:
                    //
                    // (1) STRICT SAME (추천): 라이브도 히스토리도 funding/OI 필터를 klines 기반으로 재현 가능한 것만 사용
                    //     - funding/OI 필터를 제거(또는 OI는 15m volume 기반 근사로 대체)
                    //
                    // (2) LIVE ORIGINAL: 라이브는 원래대로 premiumIndex/OIHist 사용, 히스토리는 동일 재현 불가(유니버스만 동일)
                    //
                    // 너가 “조건 똑같이”라고 했으니, (1)로 간다.
                    //
                    // ============
                    // (1) STRICT SAME 구현:
                    // - fundingPct / oiChgPct 조건을 히스토리/라이브 둘 다 제거
                    // - 나머지 조건은 100% 동일
                    // ============
                    //
                    // ※ 이 부분이 싫으면 말해줘. 그럼 (2)로 바꿔서 “유니버스만 시점 동일”로 처리해줄게.
                    //

                    const STRICT_SAME_MODE = true;

                    function trySideAtTime(d, side, s, passTag, tEndMs) {
                        // tEndMs: 해당 15m 캔들 종료 시점(=i15 캔들 끝)
                        const k15 = d.k15;
                        const idx15 = binarySearchLastLE(k15.t, tEndMs - ms15m); // i15의 openTime = tEnd-15m
                        if (idx15 < 90) return null;

                        // nEnd는 idx15+2 까지(완성 i15 + entry i15+1 o 사용)
                        const n15 = Math.min(k15.c.length, idx15 + 2);
                        if (n15 < idx15 + 2) return null;

                        // price는 "그 시점"의 entryNow로서, 완성 캔들 close를 사용
                        const price = k15.c[idx15];
                        if (!isFinite(price) || price <= 0) return null;

                        // 24h QVol (시점 동일)
                        let qv24 = 0;
                        if (d.qvMode === "1h_sum") {
                            const k1h = d.k1h;
                            const idx1h = binarySearchLastLE(k1h.t, tEndMs - ms1h);
                            if (idx1h < 0) return null;
                            qv24 = d.qvSeries[idx1h] || 0;
                        } else {
                            qv24 = d.qvSeries[idx15] || 0;
                        }

                        if (qv24 < minQuoteVol) return null;

                        // px change (15m)
                        const pxChgPct = pct(k15.c[idx15], k15.o[idx15]);
                        if (Math.abs(pxChgPct) < s.minAbsPxChgPct) return null;

                        // RSI
                        const rsiArr = rsi14(k15.c, 14, n15);
                        const rsiNow = rsiArr[idx15] || 50;
                        if (side === "LONG" && rsiNow > s.maxRsiLong) return null;
                        if (side === "SHORT" && rsiNow < s.minRsiShort) return null;

                        // ATR%
                        const atrArr = atr(k15.h, k15.l, k15.c, 14, n15);
                        const atr15 = atrArr[idx15] || 0;
                        const atrPct = (atr15 / Math.max(1e-12, price)) * 100;
                        if (atrPct < s.minAtrPct) return null;
                        if (atrPct > s.maxAtrPct) return null;

                        // Trend 인덱스 매핑: 각 TF에서 tEndMs 직전 완성 캔들 찾기
                        const k1h = d.k1h;
                        const k4h = d.k4h;
                        const k1d = d.k1d;

                        const idx1h = binarySearchLastLE(k1h.t, tEndMs - ms1h);
                        const idx4h = binarySearchLastLE(k4h.t, tEndMs - ms4h);
                        const idx1d = binarySearchLastLE(k1d.t, tEndMs - ms1d);

                        if (idx1h < 80 || idx4h < 80 || idx1d < 80) return null;

                        const tr = computeTrendScoreDirectional(k1d, k4h, k1h, idx1d, idx4h, idx1h, price, side);
                        if (tr.score < s.minTrendScore) return null;

                        // Trigger(현재 완성 15m봉)
                        const trigOk = triggerAtIndexDirectional(k15, n15, idx15, side, s);
                        if (!trigOk) return null;

                        // Backtest: nEnd=n15 (시점까지)
                        const triggerEval = (i) => triggerAtIndexDirectional(k15, n15, i, side, s);

                        const bt = backtestUltraDirectional(
                            k15,
                            n15,
                            s.tpAtrMult,
                            s.slAtrMult,
                            s.btLookahead,
                            s.btMaxSignals,
                            side,
                            triggerEval
                        );

                        if (bt.trades < s.btMinTrades) return null;
                        if (bt.winrate < s.btMinWinrate) return null;
                        if (bt.wrHalf < s.btMinWrHalf) return null;
                        if (bt.maxConsecLoss > s.btMaxConsecLoss) return null;
                        if (bt.expectancy < s.minExpectancy) return null;

                        const tpsl = proposeTPSLDirectional(k15, idx15, s.tpAtrMult, s.slAtrMult, price, side);
                        const score = scoreRow(tr.score, bt);

                        // STRICT_SAME_MODE에서는 funding/oi가 제거되므로 표에는 0으로
                        const fundingPct = 0;
                        const oiChgPct = 0;

                        return {
                            score,
                            side,
                            symbol: d.symbol,
                            pass: passTag,
                            winrate: bt.winrate,
                            trades: bt.trades,
                            wrHalf: bt.wrHalf,
                            maxConsecLoss: bt.maxConsecLoss,
                            expectancy: bt.expectancy,
                            price,
                            fundingPct,
                            oiChgPct,
                            pxChgPct,
                            rsi: rsiNow,
                            atrPct,
                            trendScore: tr.score,
                            tp: tpsl.tp,
                            sl: tpsl.sl,
                            qv24,
                            why:
                                "t=" + toIsoUTC(tEndMs) +
                                " · Trend " + tr.detail +
                                " · Px15m " + fmtNum(pxChgPct, 2) + "%" +
                                " · RSI " + fmtNum(rsiNow, 1) +
                                " · ATR% " + fmtNum(atrPct, 2) +
                                " · BT Win " + fmtNum(bt.winrate, 1) + "% (N=" + bt.trades + ")" +
                                " · Half " + fmtNum(bt.wrHalf, 1) + "%" +
                                " · MaxCL " + bt.maxConsecLoss +
                                " · Exp " + fmtNum(bt.expectancy, 3),
                        };
                    }

                    if (!STRICT_SAME_MODE) {
                        setStatus([
                            '<span class="bad">중단</span> STRICT SAME 모드가 꺼져있습니다.',
                            '<span class="muted">이 코드는 "조건 동일"을 위해 STRICT SAME만 지원하도록 작성됨</span>',
                        ]);
                        return;
                    }

                    // 시점별 평가
                    setStatus([
                        '<span class="info">HISTORY</span> 시점별 스캔 시작',
                        '<span class="muted">PASS1→PASS2, 각 시점에서 유니버스도 재구성(상위N + 하한)</span>',
                    ]);

                    // dataMap에 들어있는 심볼만 사용 (수집 실패 심볼 제외)
                    const okSymbols = Array.from(dataMap.keys());

                    // 시점 루프
                    for (let ti = 0; ti < maxCandles; ti += 1) {
                        if (signal.aborted) return;

                        const tEndMs = timeline[ti].tEnd;

                        // (A) 해당 시점 유니버스 구성:
                        // - qv24 >= minQuoteVol
                        // - 상위 N
                        const ranked = [];
                        for (let si = 0; si < okSymbols.length; si += 1) {
                            const sym = okSymbols[si];
                            const d = dataMap.get(sym);
                            if (!d) continue;

                            let qv24 = 0;

                            if (d.qvMode === "1h_sum") {
                                const idx1h = binarySearchLastLE(d.k1h.t, tEndMs - ms1h);
                                if (idx1h < 0) continue;
                                qv24 = d.qvSeries[idx1h] || 0;
                            } else {
                                const idx15 = binarySearchLastLE(d.k15.t, tEndMs - ms15m);
                                if (idx15 < 0) continue;
                                qv24 = d.qvSeries[idx15] || 0;
                            }

                            if (qv24 < minQuoteVol) continue;
                            ranked.push({ symbol: sym, qv24 });
                        }

                        ranked.sort((a, b) => b.qv24 - a.qv24);
                        const universe = ranked.slice(0, Math.max(20, limitSymbols));

                        // universe가 너무 작으면 스킵 (그 시점에 조건상 없음)
                        if (universe.length < 20) {
                            if (ti % 60 === 0) {
                                setStatus([
                                    '<span class="info">HISTORY</span> 진행: ' + fmtInt(ti + 1) + " / " + fmtInt(maxCandles),
                                    '<span class="muted">유니버스 부족(>=20 미만) → 스킵</span>',
                                ]);
                            }
                            continue;
                        }

                        // (B) PASS1 → PASS2 (그 시점 기준)
                        const counts = { LONG: 0, SHORT: 0 };
                        const resultsThisTime = [];

                        function scanPassAtTime(passNo, needLong, needShort) {
                            const s = buildSettings(passNo);

                            // (주의) 여기서는 "해당 시점의 유니버스"만 돌림
                            for (let ui = 0; ui < universe.length; ui += 1) {
                                const longNeed = needLong && counts.LONG < minPerSideTarget;
                                const shortNeed = needShort && counts.SHORT < minPerSideTarget;
                                if (!longNeed && !shortNeed) break;

                                const sym = universe[ui].symbol;
                                const d = dataMap.get(sym);
                                if (!d) continue;

                                if (longNeed) {
                                    const r = trySideAtTime(d, "LONG", s, passNo === 1 ? "P1" : "P2", tEndMs);
                                    if (r) {
                                        resultsThisTime.push(r);
                                        counts.LONG += 1;
                                    }
                                }

                                if (shortNeed) {
                                    const r = trySideAtTime(d, "SHORT", s, passNo === 1 ? "P1" : "P2", tEndMs);
                                    if (r) {
                                        resultsThisTime.push(r);
                                        counts.SHORT += 1;
                                    }
                                }
                            }
                        }

                        scanPassAtTime(1, true, true);

                        const needLong2 = counts.LONG < minPerSideTarget;
                        const needShort2 = counts.SHORT < minPerSideTarget;

                        if (needLong2 || needShort2) {
                            scanPassAtTime(2, needLong2, needShort2);
                        }

                        if (resultsThisTime.length > 0) {
                            // 이 시점에 "결과가 나왔다"
                            const line = toIsoUTC(tEndMs) + "  |  " + "LONG " + counts.LONG + " / SHORT " + counts.SHORT + "  |  " + "N=" + resultsThisTime.length;
                            histTimes.push(line);
                            appendHistoryLine(line);

                            // 표에는 "최근 시점 결과"를 계속 갱신(너무 많으면 화면이 무거워짐)
                            // 여기서는 최신 200개만 유지
                            currentRows = currentRows.concat(resultsThisTime);
                            if (currentRows.length > 200) currentRows = currentRows.slice(-200);
                            render(currentRows);
                        }

                        if (ti % 30 === 0) {
                            setStatus([
                                '<span class="info">HISTORY</span> 진행: ' + fmtInt(ti + 1) + " / " + fmtInt(maxCandles),
                                '<span class="muted">유니버스: ' + fmtInt(universe.length) + " · 결과시간: " + fmtInt(histTimes.length) + "개</span>",
                            ]);
                        }

                        // 레이트리밋 완화
                        await sleep(8);
                    }

                    if (histTimes.length > 0) {
                        el.btnExport.disabled = false;
                    }

                    setStatus([
                        '<span class="ok">HISTORY 완료</span> — 결과시간 ' + fmtInt(histTimes.length) + "개",
                        '<span class="muted">표는 최신 200개만 표시(전체 시간목록은 텍스트 박스/Export)</span>',
                    ]);
                } catch (err) {
                    const msg = err && err.message ? err.message : String(err);
                    setStatus(['<span class="bad">에러</span> ' + msg]);
                } finally {
                    el.btnScan.disabled = false;
                    el.btnHist.disabled = false;
                    el.btnStop.disabled = true;
                    el.apiState.textContent = "idle";
                }
            }

            el.btnScan.addEventListener("click", runScan);
            el.btnStop.addEventListener("click", stopScan);
            el.btnHist.addEventListener("click", runHistoryScan);

            render([]);
            setStatus([
                "Live Scan 또는 History Scan을 누르세요.",
                '<span class="muted">HISTORY는 유니버스(24h QVol)도 시점 동일하게 재현합니다.</span>',
            ]);
        </script>
    </body>
</html>
