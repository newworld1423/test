<!doctype html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — ULTRA EXTREME WINRATE (LONG+SHORT, Auto 2-PASS)</title>
        <style>
            :root {
                --bg: #0b0f17;
                --panel: #111827;
                --panel2: #0f1624;
                --text: #e5e7eb;
                --muted: #9ca3af;
                --line: rgba(255, 255, 255, 0.08);
                --good: #22c55e;
                --bad: #ef4444;
                --warn: #f59e0b;
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR",
                    "Malgun Gothic", Arial, "Helvetica Neue", Helvetica, sans-serif;
                background: radial-gradient(1200px 800px at 20% 10%, rgba(96, 165, 250, 0.16), transparent 60%),
                    radial-gradient(900px 700px at 80% 20%, rgba(34, 197, 94, 0.12), transparent 55%),
                    var(--bg);
                color: var(--text);
            }
            header {
                padding: 18px 16px 10px;
                border-bottom: 1px solid var(--line);
            }
            h1 {
                margin: 0 0 8px;
                font-size: 18px;
                font-weight: 900;
                letter-spacing: -0.2px;
            }
            .sub {
                color: var(--muted);
                font-size: 12px;
                line-height: 1.45;
            }
            .wrap {
                padding: 12px 16px 18px;
                display: grid;
                grid-template-columns: 500px 1fr;
                gap: 12px;
            }
            @media (max-width: 1120px) {
                .wrap {
                    grid-template-columns: 1fr;
                }
            }
            .card {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.02));
                border: 1px solid var(--line);
                border-radius: 14px;
                overflow: hidden;
            }
            .card .hd {
                padding: 12px 12px;
                background: rgba(255, 255, 255, 0.02);
                border-bottom: 1px solid var(--line);
                font-weight: 900;
                font-size: 13px;
            }
            .card .bd {
                padding: 12px;
            }
            .grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .row {
                display: grid;
                gap: 6px;
            }
            label {
                font-size: 12px;
                color: var(--muted);
            }
            input,
            button,
            select {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: var(--panel2);
                color: var(--text);
                outline: none;
            }
            input:focus,
            select:focus {
                border-color: rgba(96, 165, 250, 0.45);
                box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.12);
            }
            button {
                cursor: pointer;
                font-weight: 900;
            }
            .actions {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-top: 10px;
            }
            button.primary {
                background: linear-gradient(180deg, rgba(96, 165, 250, 0.25), rgba(96, 165, 250, 0.12));
                border-color: rgba(96, 165, 250, 0.35);
            }
            button.danger {
                background: linear-gradient(180deg, rgba(239, 68, 68, 0.25), rgba(239, 68, 68, 0.12));
                border-color: rgba(239, 68, 68, 0.35);
            }
            .note {
                margin-top: 10px;
                font-size: 12px;
                color: var(--muted);
                line-height: 1.45;
                display: grid;
                gap: 6px;
            }
            .pill {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
                font-size: 12px;
                color: var(--muted);
            }
            .pill b {
                color: var(--text);
            }
            .status {
                padding: 10px 12px;
                border-bottom: 1px solid var(--line);
                font-size: 12px;
                color: var(--muted);
                line-height: 1.4;
                display: grid;
                gap: 4px;
            }
            .status .ok {
                color: rgba(34, 197, 94, 0.95);
                font-weight: 900;
            }
            .status .bad {
                color: rgba(239, 68, 68, 0.95);
                font-weight: 900;
            }
            .status .warn {
                color: rgba(245, 158, 11, 0.95);
                font-weight: 900;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 12px;
            }
            thead th {
                position: sticky;
                top: 0;
                z-index: 5;
                text-align: left;
                padding: 10px 10px;
                background: rgba(15, 22, 36, 0.95);
                border-bottom: 1px solid var(--line);
                cursor: pointer;
                user-select: none;
                white-space: nowrap;
            }
            tbody td {
                padding: 10px 10px;
                border-bottom: 1px solid var(--line);
                vertical-align: top;
            }
            tbody tr:hover {
                background: rgba(255, 255, 255, 0.03);
            }
            .mono {
                font-variant-numeric: tabular-nums;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }
            .good {
                color: var(--good);
                font-weight: 900;
            }
            .badc {
                color: var(--bad);
                font-weight: 900;
            }
            .warnc {
                color: var(--warn);
                font-weight: 900;
            }
            .small {
                font-size: 11px;
                line-height: 1.35;
            }
            .topbar {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
                justify-content: space-between;
                padding: 10px 12px;
                border-bottom: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
            }
            .pill2 {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
                font-size: 12px;
                color: var(--muted);
            }
            .pill2 b {
                color: var(--text);
            }
            .side-long {
                color: rgba(34, 197, 94, 0.95);
                font-weight: 900;
            }
            .side-short {
                color: rgba(239, 68, 68, 0.95);
                font-weight: 900;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>ULTRA EXTREME WINRATE — LONG + SHORT (Auto 2-PASS)</h1>
            <div class="sub">
                승률 최우선(신호 극소). <b>롱/숏 둘 다</b> 후보 생성. 한쪽이 0개면 그 방향만 <b>아주 소폭</b> 완화해 2-PASS를 자동 수행.
                <br />
                스캔 타이밍: <b>15m 마감 직후</b>(00/15/30/45분 + 5~20초).
            </div>
        </header>

        <div class="wrap">
            <section class="card">
                <div class="hd">초고승률 고정 세팅(최종)</div>
                <div class="bd">
                    <div class="grid">
                        <div class="row">
                            <label>대상 심볼 수(24h QVol 상위 N)</label>
                            <input id="limitSymbols" type="number" min="20" step="10" value="260" />
                        </div>
                        <div class="row">
                            <label>24h 거래대금 하한(USDT)</label>
                            <input id="minQuoteVol" type="number" min="0" step="10000000" value="90000000" />
                        </div>

                        <div class="row">
                            <label>동시성(요청 수)</label>
                            <input id="concurrency" type="number" min="1" step="1" value="4" />
                        </div>
                        <div class="row">
                            <label>방향 후보 최소 목표(각 1개)</label>
                            <input id="minPerSideTarget" type="number" min="1" max="3" step="1" value="1" />
                        </div>

                        <div class="row">
                            <label>BTC 레짐 필수(1=ON)</label>
                            <input id="btcRegimeOn" type="number" min="0" max="1" step="1" value="1" />
                        </div>
                        <div class="row">
                            <label>ETH 레짐 필수(1=ON)</label>
                            <input id="ethRegimeOn" type="number" min="0" max="1" step="1" value="1" />
                        </div>
                    </div>

                    <div class="actions">
                        <button id="btnScan" class="primary">Scan (Extreme Winrate)</button>
                        <button id="btnStop" class="danger" disabled>Stop</button>
                    </div>

                    <div class="note">
                        <div class="pill"><b>핵심</b> Trend(1D/4H/1H) + Trigger(15m) + OI + Funding + RSI + ATR + Backtest</div>
                        <div class="pill"><b>정상</b> 결과 0개/1개 매우 흔함(승률 극단 모드)</div>
                    </div>
                </div>
            </section>

            <section class="card">
                <div class="topbar">
                    <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                        <span class="pill2">정렬: <b id="sortLabel">Score ↓</b></span>
                        <span class="pill2">결과: <b id="resultCount">0</b></span>
                        <span class="pill2">업데이트: <b id="lastUpdated">-</b></span>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <span class="pill2">API: <b id="apiState">idle</b></span>
                        <span class="pill2">LONG: <b id="countLong">0</b></span>
                        <span class="pill2">SHORT: <b id="countShort">0</b></span>
                    </div>
                </div>

                <div class="status" id="statusBox">
                    <div>대기 중…</div>
                </div>

                <div style="overflow:auto; max-height: calc(100dvh - 220px);">
                    <table id="tbl">
                        <thead>
                            <tr>
                                <th data-key="score">Score</th>
                                <th data-key="side">Side</th>
                                <th data-key="symbol">Symbol</th>
                                <th data-key="pass">Pass</th>
                                <th data-key="winrate">BT Win%</th>
                                <th data-key="trades">BT N</th>
                                <th data-key="wrHalf">BT Half%</th>
                                <th data-key="maxConsecLoss">BT MaxCL</th>
                                <th data-key="expectancy">BT Exp</th>
                                <th data-key="price">Now</th>
                                <th data-key="fundingPct">Funding%</th>
                                <th data-key="oiChgPct">OI15m%</th>
                                <th data-key="pxChgPct">Px15m%</th>
                                <th data-key="rsi">RSI15</th>
                                <th data-key="atrPct">ATR%</th>
                                <th data-key="trendScore">Trend</th>
                                <th data-key="tp">TP</th>
                                <th data-key="sl">SL</th>
                                <th data-key="qv24">24h QVol</th>
                                <th>Why</th>
                            </tr>
                        </thead>
                        <tbody id="tbody"></tbody>
                    </table>
                </div>
            </section>
        </div>

        <script>
            "use strict";

            const BASE = "https://fapi.binance.com";

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function nowKST() {
                const d = new Date();
                const utc = d.getTime() + d.getTimezoneOffset() * 60000;
                const kst = new Date(utc + 9 * 3600000);
                const y = kst.getFullYear();
                const m = String(kst.getMonth() + 1).padStart(2, "0");
                const day = String(kst.getDate()).padStart(2, "0");
                const hh = String(kst.getHours()).padStart(2, "0");
                const mm = String(kst.getMinutes()).padStart(2, "0");
                const ss = String(kst.getSeconds()).padStart(2, "0");
                return y + "-" + m + "-" + day + " " + hh + ":" + mm + ":" + ss + " KST";
            }

            async function fetchJson(url, signal) {
                const res = await fetch(url, { method: "GET", signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error("HTTP " + res.status + " " + res.statusText + " :: " + text.slice(0, 200));
                }
                return res.json();
            }

            function clamp(x, lo, hi) {
                return Math.min(hi, Math.max(lo, x));
            }

            function pct(a, b) {
                if (!isFinite(a) || !isFinite(b) || b === 0) return 0;
                return (a / b - 1) * 100;
            }

            function ema(values, period) {
                if (!values || values.length === 0) return [];
                const k = 2 / (period + 1);
                const out = new Array(values.length);
                let prev = values[0];
                out[0] = prev;
                for (let i = 1; i < values.length; i += 1) {
                    const v = values[i];
                    prev = v * k + prev * (1 - k);
                    out[i] = prev;
                }
                return out;
            }

            function atr(high, low, close, period) {
                const n = close.length;
                const tr = new Array(n).fill(0);
                for (let i = 1; i < n; i += 1) {
                    const h = high[i];
                    const l = low[i];
                    const pc = close[i - 1];
                    const a = h - l;
                    const b = Math.abs(h - pc);
                    const c = Math.abs(l - pc);
                    tr[i] = Math.max(a, b, c);
                }
                const out = new Array(n).fill(0);
                let sum = 0;
                for (let i = 1; i < n; i += 1) {
                    sum += tr[i];
                    if (i >= period) {
                        sum -= tr[i - period];
                        out[i] = sum / period;
                    } else {
                        out[i] = sum / Math.max(1, i);
                    }
                }
                return out;
            }

            function rsi14(close, period) {
                const p = period || 14;
                const n = close.length;
                const out = new Array(n).fill(50);
                if (n < p + 2) return out;

                let gain = 0;
                let loss = 0;

                for (let i = 1; i <= p; i += 1) {
                    const d = close[i] - close[i - 1];
                    if (d >= 0) gain += d;
                    else loss -= d;
                }

                let avgGain = gain / p;
                let avgLoss = loss / p;

                out[p] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);

                for (let i = p + 1; i < n; i += 1) {
                    const d = close[i] - close[i - 1];
                    const g = d > 0 ? d : 0;
                    const l = d < 0 ? -d : 0;
                    avgGain = (avgGain * (p - 1) + g) / p;
                    avgLoss = (avgLoss * (p - 1) + l) / p;

                    if (avgLoss === 0) out[i] = 100;
                    else {
                        const rs = avgGain / avgLoss;
                        out[i] = 100 - 100 / (1 + rs);
                    }
                }

                return out;
            }

            function parseKlines(raw) {
                const t = [];
                const o = [];
                const h = [];
                const l = [];
                const c = [];
                const v = [];
                for (let i = 0; i < raw.length; i += 1) {
                    const k = raw[i];
                    t.push(Number(k[0]));
                    o.push(Number(k[1]));
                    h.push(Number(k[2]));
                    l.push(Number(k[3]));
                    c.push(Number(k[4]));
                    v.push(Number(k[5]));
                }
                return { t, o, h, l, c, v };
            }

            function candleQuality(oo, hh, ll, cc) {
                const range = Math.max(1e-12, hh - ll);
                const body = Math.abs(cc - oo);
                const bodyPct = (body / range) * 100;

                const upper = hh - Math.max(oo, cc);
                const lower = Math.min(oo, cc) - ll;
                const upperPct = (upper / range) * 100;
                const lowerPct = (lower / range) * 100;

                const clv = (cc - ll) / range; // 0~1 (종가 위치)
                return { bodyPct, upperPct, lowerPct, clv };
            }

            async function getSymbolsUSDTPerp(signal) {
                const ex = await fetchJson(BASE + "/fapi/v1/exchangeInfo", signal);
                const out = [];
                const arr = ex.symbols || [];
                for (let i = 0; i < arr.length; i += 1) {
                    const s = arr[i];
                    if (s.contractType !== "PERPETUAL") continue;
                    if (s.quoteAsset !== "USDT") continue;
                    if (s.status !== "TRADING") continue;
                    out.push(s.symbol);
                }
                return out;
            }

            async function getTickers24h(signal) {
                return fetchJson(BASE + "/fapi/v1/ticker/24hr", signal);
            }

            async function getLastPrices(signal) {
                const arr = await fetchJson(BASE + "/fapi/v1/ticker/price", signal);
                const map = new Map();
                for (let i = 0; i < arr.length; i += 1) {
                    const x = arr[i];
                    map.set(x.symbol, Number(x.price));
                }
                return map;
            }

            async function getKlines(symbol, interval, limit, signal) {
                const url =
                    BASE +
                    "/fapi/v1/klines?symbol=" +
                    encodeURIComponent(symbol) +
                    "&interval=" +
                    encodeURIComponent(interval) +
                    "&limit=" +
                    encodeURIComponent(String(limit));
                return fetchJson(url, signal);
            }

            async function getPremiumIndex(symbol, signal) {
                const url = BASE + "/fapi/v1/premiumIndex?symbol=" + encodeURIComponent(symbol);
                return fetchJson(url, signal);
            }

            async function getOpenInterestHist(symbol, period, limit, signal) {
                const url =
                    BASE +
                    "/futures/data/openInterestHist?symbol=" +
                    encodeURIComponent(symbol) +
                    "&period=" +
                    encodeURIComponent(period) +
                    "&limit=" +
                    encodeURIComponent(String(limit));
                return fetchJson(url, signal);
            }

            function fmtNum(x, digits) {
                const d = digits == null ? 2 : digits;
                if (!isFinite(x)) return "-";
                return Number(x).toFixed(d);
            }

            function fmtInt(x) {
                if (!isFinite(x)) return "-";
                return Math.round(Number(x)).toLocaleString();
            }

            function fmtMoney(x) {
                if (!isFinite(x)) return "-";
                return Math.round(Number(x)).toLocaleString();
            }

            const el = {
                limitSymbols: document.getElementById("limitSymbols"),
                minQuoteVol: document.getElementById("minQuoteVol"),
                concurrency: document.getElementById("concurrency"),
                minPerSideTarget: document.getElementById("minPerSideTarget"),
                btcRegimeOn: document.getElementById("btcRegimeOn"),
                ethRegimeOn: document.getElementById("ethRegimeOn"),

                btnScan: document.getElementById("btnScan"),
                btnStop: document.getElementById("btnStop"),
                statusBox: document.getElementById("statusBox"),
                tbody: document.getElementById("tbody"),
                resultCount: document.getElementById("resultCount"),
                countLong: document.getElementById("countLong"),
                countShort: document.getElementById("countShort"),
                lastUpdated: document.getElementById("lastUpdated"),
                apiState: document.getElementById("apiState"),
                sortLabel: document.getElementById("sortLabel"),
                tbl: document.getElementById("tbl"),
            };

            let sortKey = "score";
            let sortDir = "desc";
            let currentRows = [];
            let aborter = null;

            function setStatus(lines) {
                let html = "";
                for (let i = 0; i < lines.length; i += 1) {
                    html += "<div>" + lines[i] + "</div>";
                }
                el.statusBox.innerHTML = html;
            }

            function countSides(rows) {
                let l = 0;
                let s = 0;
                for (let i = 0; i < rows.length; i += 1) {
                    if (rows[i].side === "LONG") l += 1;
                    else if (rows[i].side === "SHORT") s += 1;
                }
                el.countLong.textContent = String(l);
                el.countShort.textContent = String(s);
            }

            function render(rows) {
                const sorted = rows.slice();
                sorted.sort((a, b) => {
                    const av = a[sortKey];
                    const bv = b[sortKey];
                    if (av === bv) return 0;
                    if (sortDir === "asc") return av > bv ? 1 : -1;
                    return av < bv ? 1 : -1;
                });

                el.resultCount.textContent = String(sorted.length);
                countSides(sorted);

                let html = "";
                for (let i = 0; i < sorted.length; i += 1) {
                    const r = sorted[i];

                    const wrClass = r.winrate >= 82 ? "good" : r.winrate >= 78 ? "warnc" : "badc";
                    const halfClass = r.wrHalf >= 80 ? "good" : r.wrHalf >= 76 ? "warnc" : "badc";
                    const clClass = r.maxConsecLoss <= 1 ? "good" : r.maxConsecLoss <= 2 ? "warnc" : "badc";
                    const expClass = r.expectancy >= 0.06 ? "good" : r.expectancy >= 0.03 ? "warnc" : "badc";
                    const sideClass = r.side === "LONG" ? "side-long" : "side-short";

                    html += "<tr>";
                    html += '<td class="mono"><b>' + fmtNum(r.score, 1) + "</b></td>";
                    html += '<td class="mono ' + sideClass + '">' + r.side + "</td>";
                    html += '<td class="mono"><b>' + r.symbol + "</b></td>";
                    html += '<td class="mono">' + r.pass + "</td>";
                    html += '<td class="mono ' + wrClass + '">' + fmtNum(r.winrate, 1) + "</td>";
                    html += '<td class="mono">' + fmtInt(r.trades) + "</td>";
                    html += '<td class="mono ' + halfClass + '">' + fmtNum(r.wrHalf, 1) + "</td>";
                    html += '<td class="mono ' + clClass + '">' + fmtInt(r.maxConsecLoss) + "</td>";
                    html += '<td class="mono ' + expClass + '">' + fmtNum(r.expectancy, 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.price, r.price < 1 ? 6 : 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.fundingPct, 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.oiChgPct, 2) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.pxChgPct, 2) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.rsi, 1) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.atrPct, 2) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.trendScore, 0) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.tp, r.price < 1 ? 6 : 3) + "</td>";
                    html += '<td class="mono">' + fmtNum(r.sl, r.price < 1 ? 6 : 3) + "</td>";
                    html += '<td class="mono">' + fmtMoney(r.qv24) + "</td>";
                    html += '<td class="small">' + r.why + "</td>";
                    html += "</tr>";
                }

                el.tbody.innerHTML = html;
                el.lastUpdated.textContent = nowKST();
            }

            el.tbl.querySelectorAll("thead th[data-key]").forEach((th) => {
                th.addEventListener("click", () => {
                    const key = th.getAttribute("data-key");
                    if (!key) return;

                    if (sortKey === key) {
                        sortDir = sortDir === "desc" ? "asc" : "desc";
                    } else {
                        sortKey = key;
                        sortDir = key === "symbol" ? "asc" : "desc";
                    }

                    el.sortLabel.textContent = sortKey + " " + (sortDir === "desc" ? "↓" : "↑");
                    render(currentRows);
                });
            });

            function computeTrendScoreDirectional(k1d, k4h, k1h, price, side) {
                const e1d20 = ema(k1d.c, 20);
                const e1d50 = ema(k1d.c, 50);
                const e4h20 = ema(k4h.c, 20);
                const e4h50 = ema(k4h.c, 50);
                const e1h20 = ema(k1h.c, 20);
                const e1h50 = ema(k1h.c, 50);

                const i1d = k1d.c.length - 2;
                const i4h = k4h.c.length - 2;
                const i1h = k1h.c.length - 2;

                if (i1d < 80 || i4h < 80 || i1h < 80) return { score: 0, detail: "not enough" };

                function slopeUp(arr, idx, back) {
                    const j = idx - back;
                    if (j < 0) return false;
                    return arr[idx] > arr[j];
                }

                function slopeDown(arr, idx, back) {
                    const j = idx - back;
                    if (j < 0) return false;
                    return arr[idx] < arr[j];
                }

                let ok1d = false;
                let ok4h = false;
                let ok1h = false;
                let s1d = false;
                let s4h = false;
                let s1h = false;

                if (side === "LONG") {
                    ok1d = e1d20[i1d] > e1d50[i1d] && price > e1d20[i1d];
                    ok4h = e4h20[i4h] > e4h50[i4h] && price > e4h20[i4h];
                    ok1h = e1h20[i1h] > e1h50[i1h] && price > e1h20[i1h];
                    s1d = slopeUp(e1d20, i1d, 6);
                    s4h = slopeUp(e4h20, i4h, 6);
                    s1h = slopeUp(e1h20, i1h, 10);
                } else {
                    ok1d = e1d20[i1d] < e1d50[i1d] && price < e1d20[i1d];
                    ok4h = e4h20[i4h] < e4h50[i4h] && price < e4h20[i4h];
                    ok1h = e1h20[i1h] < e1h50[i1h] && price < e1h20[i1h];
                    s1d = slopeDown(e1d20, i1d, 6);
                    s4h = slopeDown(e4h20, i4h, 6);
                    s1h = slopeDown(e1h20, i1h, 10);
                }

                const dist1h = Math.abs((price - e1h20[i1h]) / Math.max(1e-12, e1h20[i1h]));
                const over = Math.max(0, dist1h - 0.010);
                const penalty = clamp(over * 3000, 0, 22);

                let score = 0;
                score += ok1d ? 38 : 0;
                score += ok4h ? 30 : 0;
                score += ok1h ? 22 : 0;
                score += s1d ? 4 : 0;
                score += s4h ? 3 : 0;
                score += s1h ? 3 : 0;
                score -= penalty;

                score = clamp(score, 0, 100);

                const detail =
                    (side === "LONG" ? "LONG" : "SHORT") +
                    " " +
                    (ok1d ? "1D✓" : "1D×") +
                    " " +
                    (ok4h ? "4H✓" : "4H×") +
                    " " +
                    (ok1h ? "1H✓" : "1H×") +
                    " slope:" +
                    (s1d && s4h && s1h ? "OK" : "mix");

                return { score, detail };
            }

            function proposeTPSLDirectional(k15, tpMult, slMult, entryNow, side) {
                const a = atr(k15.h, k15.l, k15.c, 14);
                const i = k15.c.length - 2;
                const atr15 = a[i] || 0;

                if (side === "LONG") {
                    return { atr15, tp: entryNow + atr15 * tpMult, sl: entryNow - atr15 * slMult };
                }
                return { atr15, tp: entryNow - atr15 * tpMult, sl: entryNow + atr15 * slMult };
            }

            function backtestUltraDirectional(k15, tpMult, slMult, lookahead, maxSignals, side, triggerEvalAtIndex) {
                const n = k15.c.length;
                if (n < 320) return { winrate: 0, trades: 0, wrHalf: 0, maxConsecLoss: 999, expectancy: 0 };

                const a = atr(k15.h, k15.l, k15.c, 14);

                const sig = [];
                for (let i = 90; i < n - 2; i += 1) {
                    if (triggerEvalAtIndex(i)) sig.push(i);
                }

                const picked = sig.slice(-maxSignals);

                function evalList(list) {
                    let wins = 0;
                    let losses = 0;
                    let consecLoss = 0;
                    let maxConsecLoss = 0;
                    let sumR = 0;

                    for (let x = 0; x < list.length; x += 1) {
                        const i = list[x];
                        const entryIdx = i + 1;
                        if (entryIdx >= n) continue;

                        const entry = k15.o[entryIdx];
                        const atrAt = a[i] || 0;
                        if (atrAt <= 0) continue;

                        let tp = 0;
                        let sl = 0;

                        if (side === "LONG") {
                            tp = entry + atrAt * tpMult;
                            sl = entry - atrAt * slMult;
                        } else {
                            tp = entry - atrAt * tpMult;
                            sl = entry + atrAt * slMult;
                        }

                        let outcome = 0;

                        for (let j = entryIdx; j < Math.min(n, entryIdx + lookahead); j += 1) {
                            const hh = k15.h[j];
                            const ll = k15.l[j];

                            let hitTP = false;
                            let hitSL = false;

                            if (side === "LONG") {
                                hitTP = hh >= tp;
                                hitSL = ll <= sl;
                            } else {
                                hitTP = ll <= tp;
                                hitSL = hh >= sl;
                            }

                            if (hitTP && hitSL) {
                                outcome = -1;
                                break;
                            }
                            if (hitSL) {
                                outcome = -1;
                                break;
                            }
                            if (hitTP) {
                                outcome = 1;
                                break;
                            }
                        }

                        if (outcome === 1) {
                            wins += 1;
                            consecLoss = 0;
                            sumR += tpMult;
                        } else if (outcome === -1) {
                            losses += 1;
                            consecLoss += 1;
                            maxConsecLoss = Math.max(maxConsecLoss, consecLoss);
                            sumR -= slMult;
                        }
                    }

                    const trades = wins + losses;
                    const winrate = trades > 0 ? (wins / trades) * 100 : 0;
                    const expectancy = trades > 0 ? sumR / trades : 0;

                    return { winrate, trades, maxConsecLoss, expectancy };
                }

                const all = evalList(picked);
                const halfCount = Math.max(1, Math.floor(picked.length / 2));
                const halfList = picked.slice(-halfCount);
                const halfEval = evalList(halfList);

                return {
                    winrate: all.winrate,
                    trades: all.trades,
                    wrHalf: halfEval.winrate,
                    maxConsecLoss: all.maxConsecLoss,
                    expectancy: all.expectancy,
                };
            }

            function scoreRow(trendScore, bt) {
                const s1 = clamp(bt.winrate, 0, 95);
                const s2 = clamp(bt.wrHalf, 0, 95);
                const s3 = clamp(bt.trades, 0, 160);
                const s4 = 100 - clamp(bt.maxConsecLoss * 22, 0, 85);
                const s5 = clamp(bt.expectancy * 140, 0, 40);
                const score = s1 * 0.40 + s2 * 0.20 + trendScore * 0.18 + s3 * 0.06 + s4 * 0.12 + s5 * 0.04;
                return clamp(score, 0, 100);
            }

            function buildSettings(passNo) {
                // PASS1: 극단
                // PASS2: 한쪽 0개일 때만 “아주 소폭” 완화 (BT 기준은 유지)

                const base = {
                    // Universe
                    minOiChgPct: 0.70,
                    minAbsPxChgPct: 0.25,

                    // Trigger quality (15m)
                    minBodyPct: 70,
                    minAbsRetPct: 0.60,
                    minVolSpike: 2.6,
                    minCLVLong: 0.72,   // 종가가 캔들 상단에 가까움
                    maxCLVShort: 0.28,  // 종가가 캔들 하단에 가까움
                    maxOppWickPct: 22,  // 반대꼬리 너무 길면 제외
                    breakN: 26,
                    pullbackLookback: 10,
                    pullbackBandBp: 28, // EMA20 band (bp)

                    // RSI
                    maxRsiLong: 64,
                    minRsiShort: 36,

                    // Funding (방향별 과밀 회피)
                    minFundingLong: -0.030,
                    maxFundingLong: 0.005,
                    minFundingShort: -0.004,
                    maxFundingShort: 0.035,

                    // ATR filter
                    minAtrPct: 0.22,
                    maxAtrPct: 1.70,

                    // TP/SL (승률 우선: TP 작게, SL 보수)
                    tpAtrMult: 0.80,
                    slAtrMult: 1.30,

                    // Backtest (승률 극단)
                    btLookahead: 22,
                    btMaxSignals: 160,
                    btMinTrades: 85,
                    btMinWinrate: 78,
                    btMinWrHalf: 76,
                    btMaxConsecLoss: 2,
                    minExpectancy: 0.03,

                    // Trend
                    minTrendScore: 82,
                };

                if (passNo === 1) return base;

                return {
                    ...base,
                    // 아주 소폭 완화 (품질은 유지, 신호만 살짝 늘림)
                    minOiChgPct: 0.60,
                    minAbsPxChgPct: 0.20,
                    minBodyPct: 66,
                    minAbsRetPct: 0.50,
                    minVolSpike: 2.2,
                    breakN: 22,
                    maxOppWickPct: 26,
                    maxRsiLong: 66,
                    minRsiShort: 34,
                    maxAtrPct: 2.05,
                    minTrendScore: 80,
                };
            }

            function triggerAtIndexDirectional(k15, i, side, s) {
                // i는 "완성된 캔들" 인덱스
                if (i < 60 || i >= k15.c.length - 2) return false;

                const oo = k15.o[i];
                const hh = k15.h[i];
                const ll = k15.l[i];
                const cc = k15.c[i];

                const q = candleQuality(oo, hh, ll, cc);

                // 방향성 + 몸통 + 변화율
                const retPct = pct(cc, oo);
                if (q.bodyPct < s.minBodyPct) return false;
                if (Math.abs(retPct) < s.minAbsRetPct) return false;

                if (side === "LONG") {
                    if (!(cc > oo && retPct > 0)) return false;
                    if (q.clv < s.minCLVLong) return false;
                    if (q.upperPct > s.maxOppWickPct) return false; // 위꼬리 과다(롱에 불리)
                } else {
                    if (!(cc < oo && retPct < 0)) return false;
                    if (q.clv > s.maxCLVShort) return false;
                    if (q.lowerPct > s.maxOppWickPct) return false; // 아래꼬리 과다(숏에 불리)
                }

                // 볼륨 스파이크
                let sum = 0;
                let cnt = 0;
                for (let j = i - 1; j >= 0 && cnt < 20; j -= 1) {
                    sum += k15.v[j];
                    cnt += 1;
                }
                const volAvg = cnt > 0 ? sum / cnt : 0;
                const volSpike = volAvg > 0 ? k15.v[i] / volAvg : 0;
                if (volSpike < s.minVolSpike) return false;

                // 브레이크아웃/브레이크다운
                if (side === "LONG") {
                    let prevMax = -Infinity;
                    for (let j = i - 1; j >= 0 && j >= i - s.breakN; j -= 1) {
                        prevMax = Math.max(prevMax, k15.h[j]);
                    }
                    if (!(hh > prevMax)) return false;
                } else {
                    let prevMin = Infinity;
                    for (let j = i - 1; j >= 0 && j >= i - s.breakN; j -= 1) {
                        prevMin = Math.min(prevMin, k15.l[j]);
                    }
                    if (!(ll < prevMin)) return false;
                }

                // EMA20 눌림 후 재개(휩쏘 감소)
                const e20 = ema(k15.c, 20);
                const emaNow = e20[i];
                const band = emaNow * (s.pullbackBandBp / 10000);

                if (side === "LONG") {
                    let touched = false;
                    for (let j = i - 1; j >= 0 && j >= i - s.pullbackLookback; j -= 1) {
                        if (k15.l[j] <= e20[j] + band) {
                            touched = true;
                            break;
                        }
                    }
                    if (!(touched && cc > emaNow)) return false;
                } else {
                    let touched = false;
                    for (let j = i - 1; j >= 0 && j >= i - s.pullbackLookback; j -= 1) {
                        if (k15.h[j] >= e20[j] - band) {
                            touched = true;
                            break;
                        }
                    }
                    if (!(touched && cc < emaNow)) return false;
                }

                return true;
            }

            async function checkRegimeDirectional(symbol, side, signal) {
                const raw1d = await getKlines(symbol, "1d", 240, signal);
                const k1d = parseKlines(raw1d);
                const price = k1d.c[k1d.c.length - 2];
                const tr = computeTrendScoreDirectional(k1d, k1d, k1d, price, side);
                return tr.score >= 70;
            }

            async function runScan() {
                if (aborter) aborter.abort();
                aborter = new AbortController();
                const signal = aborter.signal;

                el.btnScan.disabled = true;
                el.btnStop.disabled = false;
                el.apiState.textContent = "running";

                currentRows = [];
                render(currentRows);

                const limitSymbols = Number(el.limitSymbols.value);
                const minQuoteVol = Number(el.minQuoteVol.value);
                const concurrency = Math.max(1, Number(el.concurrency.value));
                const minPerSideTarget = Math.max(1, Number(el.minPerSideTarget.value));
                const btcRegimeOn = Number(el.btcRegimeOn.value) === 1;
                const ethRegimeOn = Number(el.ethRegimeOn.value) === 1;

                const cache = new Map(); // symbol -> data cache

                try {
                    setStatus([
                        "로딩… (레짐/심볼/티커)",
                        '<span class="warn">승률 극단 모드: 결과 0~2개가 흔합니다.</span>',
                    ]);

                    // 레짐: BTC/ETH가 LONG/SHORT 둘 다에 대해 “일방향”을 강제하지는 않음.
                    // 대신 각 후보는 자기 방향(롱/숏)에 대해 TrendScore로 필터됨.
                    // BTC/ETH 레짐 ON일 때는 “양쪽 다 완전 역행 레짐”이면 전체 후보 자체가 줄어듦.
                    if (btcRegimeOn) {
                        const btcLongOk = await checkRegimeDirectional("BTCUSDT", "LONG", signal);
                        const btcShortOk = await checkRegimeDirectional("BTCUSDT", "SHORT", signal);
                        if (!btcLongOk && !btcShortOk) {
                            setStatus(['<span class="bad">차단</span> BTC 1D 레짐이 LONG/SHORT 모두 불합격(데이터 이상/극단 역행)']);
                            return;
                        }
                    }

                    if (ethRegimeOn) {
                        const ethLongOk = await checkRegimeDirectional("ETHUSDT", "LONG", signal);
                        const ethShortOk = await checkRegimeDirectional("ETHUSDT", "SHORT", signal);
                        if (!ethLongOk && !ethShortOk) {
                            setStatus(['<span class="bad">차단</span> ETH 1D 레짐이 LONG/SHORT 모두 불합격(데이터 이상/극단 역행)']);
                            return;
                        }
                    }

                    const symbols = await getSymbolsUSDTPerp(signal);
                    const tickers = await getTickers24h(signal);
                    const lastPriceMap = await getLastPrices(signal);

                    const tickerMap = new Map();
                    for (let i = 0; i < tickers.length; i += 1) tickerMap.set(tickers[i].symbol, tickers[i]);

                    const ranked = [];
                    for (let i = 0; i < symbols.length; i += 1) {
                        const s = symbols[i];
                        const t = tickerMap.get(s);
                        const qv24 = t ? Number(t.quoteVolume) : 0;
                        if (qv24 < minQuoteVol) continue;
                        ranked.push({ symbol: s, qv24 });
                    }
                    ranked.sort((a, b) => b.qv24 - a.qv24);

                    const target = ranked.slice(0, Math.max(20, limitSymbols));

                    setStatus([
                        "대상: " + target.length + "개 (24h QVol ≥ " + fmtMoney(minQuoteVol) + ")",
                        '<span class="muted">PASS1(극단) → 부족한 방향만 PASS2(소폭 완화)</span>',
                    ]);

                    const counts = { LONG: 0, SHORT: 0 };

                    async function loadSymbolData(symbol, qv24) {
                        if (cache.has(symbol)) return cache.get(symbol);

                        const prem = await getPremiumIndex(symbol, signal);
                        const fundingPct = Number(prem.lastFundingRate || 0) * 100;

                        const oiHist = await getOpenInterestHist(symbol, "15m", 3, signal);
                        if (!Array.isArray(oiHist) || oiHist.length < 2) return null;

                        const oiPrev = Number(oiHist[oiHist.length - 2].sumOpenInterest || 0);
                        const oiNow = Number(oiHist[oiHist.length - 1].sumOpenInterest || 0);
                        if (!(oiPrev > 0 && oiNow > 0)) return null;
                        const oiChgPct = pct(oiNow, oiPrev);

                        const k15raw = await getKlines(symbol, "15m", 720, signal);
                        const k1hraw = await getKlines(symbol, "1h", 520, signal);
                        const k4hraw = await getKlines(symbol, "4h", 420, signal);
                        const k1draw = await getKlines(symbol, "1d", 340, signal);

                        const k15 = parseKlines(k15raw);
                        const k1h = parseKlines(k1hraw);
                        const k4h = parseKlines(k4hraw);
                        const k1d = parseKlines(k1draw);

                        const price = lastPriceMap.get(symbol) || k15.c[k15.c.length - 2] || 0;
                        if (!isFinite(price) || price <= 0) return null;

                        const out = { fundingPct, oiChgPct, k15, k1h, k4h, k1d, price, qv24 };
                        cache.set(symbol, out);
                        return out;
                    }

                    function trySide(d, side, s, passTag) {
                        // OI + 가격변화 최소
                        if (d.oiChgPct < s.minOiChgPct) return null;

                        const k15 = d.k15;
                        const i15 = k15.c.length - 2;

                        const pxChgPct = pct(k15.c[i15], k15.o[i15]);
                        if (Math.abs(pxChgPct) < s.minAbsPxChgPct) return null;

                        // RSI
                        const rsiArr = rsi14(k15.c, 14);
                        const rsiNow = rsiArr[i15] || 50;
                        if (side === "LONG" && rsiNow > s.maxRsiLong) return null;
                        if (side === "SHORT" && rsiNow < s.minRsiShort) return null;

                        // Funding (과밀 회피)
                        if (side === "LONG") {
                            if (d.fundingPct < s.minFundingLong || d.fundingPct > s.maxFundingLong) return null;
                        } else {
                            if (d.fundingPct < s.minFundingShort || d.fundingPct > s.maxFundingShort) return null;
                        }

                        // ATR%
                        const atrArr = atr(k15.h, k15.l, k15.c, 14);
                        const atr15 = atrArr[i15] || 0;
                        const atrPct = (atr15 / Math.max(1e-12, d.price)) * 100;
                        if (atrPct < s.minAtrPct) return null;
                        if (atrPct > s.maxAtrPct) return null;

                        // Trend (1D/4H/1H)
                        const tr = computeTrendScoreDirectional(d.k1d, d.k4h, d.k1h, d.price, side);
                        if (tr.score < s.minTrendScore) return null;

                        // Trigger(현재 완성 15m봉)
                        const trigOk = triggerAtIndexDirectional(k15, i15, side, s);
                        if (!trigOk) return null;

                        // Backtest trigger eval
                        const triggerEval = (i) => triggerAtIndexDirectional(k15, i, side, s);

                        const bt = backtestUltraDirectional(
                            k15,
                            s.tpAtrMult,
                            s.slAtrMult,
                            s.btLookahead,
                            s.btMaxSignals,
                            side,
                            triggerEval
                        );

                        if (bt.trades < s.btMinTrades) return null;
                        if (bt.winrate < s.btMinWinrate) return null;
                        if (bt.wrHalf < s.btMinWrHalf) return null;
                        if (bt.maxConsecLoss > s.btMaxConsecLoss) return null;
                        if (bt.expectancy < s.minExpectancy) return null;

                        const tpsl = proposeTPSLDirectional(k15, s.tpAtrMult, s.slAtrMult, d.price, side);
                        const score = scoreRow(tr.score, bt);

                        return {
                            score,
                            side,
                            symbol: null,
                            pass: passTag,
                            winrate: bt.winrate,
                            trades: bt.trades,
                            wrHalf: bt.wrHalf,
                            maxConsecLoss: bt.maxConsecLoss,
                            expectancy: bt.expectancy,
                            price: d.price,
                            fundingPct: d.fundingPct,
                            oiChgPct: d.oiChgPct,
                            pxChgPct,
                            rsi: rsiNow,
                            atrPct,
                            trendScore: tr.score,
                            tp: tpsl.tp,
                            sl: tpsl.sl,
                            qv24: d.qv24,
                            why:
                                "Trend " + tr.detail +
                                " · Funding " + fmtNum(d.fundingPct, 3) + "%" +
                                " · OI15m " + fmtNum(d.oiChgPct, 2) + "%" +
                                " · Px15m " + fmtNum(pxChgPct, 2) + "%" +
                                " · RSI " + fmtNum(rsiNow, 1) +
                                " · ATR% " + fmtNum(atrPct, 2) +
                                " · BT Win " + fmtNum(bt.winrate, 1) + "% (N=" + bt.trades + ")" +
                                " · Half " + fmtNum(bt.wrHalf, 1) + "%" +
                                " · MaxCL " + bt.maxConsecLoss +
                                " · Exp " + fmtNum(bt.expectancy, 3),
                        };
                    }

                    async function scanPass(passNo, needLong, needShort) {
                        const s = buildSettings(passNo);
                        let idx = 0;

                        async function worker() {
                            while (idx < target.length) {
                                const my = idx;
                                idx += 1;

                                if (signal.aborted) return;

                                const longNeed = needLong && counts.LONG < minPerSideTarget;
                                const shortNeed = needShort && counts.SHORT < minPerSideTarget;
                                if (!longNeed && !shortNeed) return;

                                const symbol = target[my].symbol;
                                const qv24 = target[my].qv24;

                                try {
                                    const d = await loadSymbolData(symbol, qv24);
                                    if (!d) continue;

                                    if (longNeed) {
                                        const r = trySide(d, "LONG", s, passNo === 1 ? "P1" : "P2");
                                        if (r) {
                                            r.symbol = symbol;
                                            currentRows.push(r);
                                            counts.LONG += 1;
                                        }
                                    }

                                    if (shortNeed) {
                                        const r = trySide(d, "SHORT", s, passNo === 1 ? "P1" : "P2");
                                        if (r) {
                                            r.symbol = symbol;
                                            currentRows.push(r);
                                            counts.SHORT += 1;
                                        }
                                    }

                                    if (my % 18 === 0) {
                                        setStatus([
                                            "PASS" + passNo + " 진행: " + (my + 1) + " / " + target.length,
                                            '<span class="muted">LONG ' + counts.LONG + " / SHORT " + counts.SHORT + "</span>",
                                        ]);
                                    }

                                    if (currentRows.length % 3 === 0) render(currentRows);

                                    await sleep(55);
                                } catch (err) {
                                    await sleep(90);
                                }
                            }
                        }

                        const workers = [];
                        for (let i = 0; i < concurrency; i += 1) workers.push(worker());
                        await Promise.all(workers);
                    }

                    // PASS1: 극단
                    await scanPass(1, true, true);

                    // PASS2: 부족한 방향만 (소폭 완화)
                    const needLong2 = counts.LONG < minPerSideTarget;
                    const needShort2 = counts.SHORT < minPerSideTarget;

                    if (needLong2 || needShort2) {
                        setStatus([
                            '<span class="warn">PASS2 시작</span> — 부족한 방향만 소폭 완화',
                            '<span class="muted">BT 기준(승률/표본/연속손실/최근절반/기대값) 유지</span>',
                        ]);
                        await scanPass(2, needLong2, needShort2);
                    }

                    render(currentRows);

                    setStatus([
                        '<span class="ok">완료</span> — 총 ' + currentRows.length + "개",
                        '<span class="muted">LONG ' + counts.LONG + " / SHORT " + counts.SHORT + "</span>",
                    ]);
                } catch (err) {
                    const msg = err && err.message ? err.message : String(err);
                    setStatus(['<span class="bad">에러</span> ' + msg]);
                } finally {
                    el.btnScan.disabled = false;
                    el.btnStop.disabled = true;
                    el.apiState.textContent = "idle";
                }
            }

            function stopScan() {
                if (aborter) aborter.abort();
                el.apiState.textContent = "stopped";
                setStatus(['<span class="warn">중단됨</span> — 현재까지 결과 ' + currentRows.length + "개"]);
                el.btnScan.disabled = false;
                el.btnStop.disabled = true;
            }

            el.btnScan.addEventListener("click", runScan);
            el.btnStop.addEventListener("click", stopScan);

            render([]);
            setStatus([
                "Scan을 누르세요.",
                '<span class="muted">PASS1(극단) → 부족한 방향만 PASS2(소폭 완화)</span>',
            ]);
        </script>
    </body>
</html>