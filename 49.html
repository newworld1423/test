<!doctype html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — ULTRA EXTREME Winrate LONG Scanner</title>
        <style>
            :root {
                --bg: #0b0f17;
                --panel: #111827;
                --panel2: #0f1624;
                --text: #e5e7eb;
                --muted: #9ca3af;
                --line: rgba(255, 255, 255, 0.08);
                --good: #22c55e;
                --bad: #ef4444;
                --warn: #f59e0b;
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR",
                    "Malgun Gothic", Arial, "Helvetica Neue", Helvetica, sans-serif;
                background: radial-gradient(1200px 800px at 20% 10%, rgba(96, 165, 250, 0.16), transparent 60%),
                    radial-gradient(900px 700px at 80% 20%, rgba(34, 197, 94, 0.12), transparent 55%),
                    var(--bg);
                color: var(--text);
            }
            header {
                padding: 18px 16px 10px;
                border-bottom: 1px solid var(--line);
            }
            h1 {
                margin: 0 0 8px;
                font-size: 18px;
                font-weight: 900;
                letter-spacing: -0.2px;
            }
            .sub {
                color: var(--muted);
                font-size: 12px;
                line-height: 1.45;
            }
            .wrap {
                padding: 12px 16px 18px;
                display: grid;
                grid-template-columns: 450px 1fr;
                gap: 12px;
            }
            @media (max-width: 1120px) {
                .wrap {
                    grid-template-columns: 1fr;
                }
            }
            .card {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.02));
                border: 1px solid var(--line);
                border-radius: 14px;
                overflow: hidden;
            }
            .card .hd {
                padding: 12px 12px;
                background: rgba(255, 255, 255, 0.02);
                border-bottom: 1px solid var(--line);
                font-weight: 900;
                font-size: 13px;
            }
            .card .bd {
                padding: 12px;
            }
            .grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .row {
                display: grid;
                gap: 6px;
            }
            label {
                font-size: 12px;
                color: var(--muted);
            }
            input,
            button {
                width: 100%;
                padding: 10px 10px;
                border-radius: 10px;
                border: 1px solid var(--line);
                background: var(--panel2);
                color: var(--text);
                outline: none;
            }
            input:focus {
                border-color: rgba(96, 165, 250, 0.45);
                box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.12);
            }
            button {
                cursor: pointer;
                font-weight: 900;
            }
            .actions {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-top: 10px;
            }
            button.primary {
                background: linear-gradient(180deg, rgba(96, 165, 250, 0.25), rgba(96, 165, 250, 0.12));
                border-color: rgba(96, 165, 250, 0.35);
            }
            button.danger {
                background: linear-gradient(180deg, rgba(239, 68, 68, 0.25), rgba(239, 68, 68, 0.12));
                border-color: rgba(239, 68, 68, 0.35);
            }
            .note {
                margin-top: 10px;
                font-size: 12px;
                color: var(--muted);
                line-height: 1.45;
                display: grid;
                gap: 6px;
            }
            .pill {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
                font-size: 12px;
                color: var(--muted);
            }
            .pill b {
                color: var(--text);
            }
            .status {
                padding: 10px 12px;
                border-bottom: 1px solid var(--line);
                font-size: 12px;
                color: var(--muted);
                line-height: 1.4;
                display: grid;
                gap: 4px;
            }
            .status .ok {
                color: rgba(34, 197, 94, 0.95);
                font-weight: 900;
            }
            .status .bad {
                color: rgba(239, 68, 68, 0.95);
                font-weight: 900;
            }
            .status .warn {
                color: rgba(245, 158, 11, 0.95);
                font-weight: 900;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 12px;
            }
            thead th {
                position: sticky;
                top: 0;
                z-index: 5;
                text-align: left;
                padding: 10px 10px;
                background: rgba(15, 22, 36, 0.95);
                border-bottom: 1px solid var(--line);
                cursor: pointer;
                user-select: none;
                white-space: nowrap;
            }
            tbody td {
                padding: 10px 10px;
                border-bottom: 1px solid var(--line);
                vertical-align: top;
            }
            tbody tr:hover {
                background: rgba(255, 255, 255, 0.03);
            }
            .mono {
                font-variant-numeric: tabular-nums;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            }
            .good {
                color: var(--good);
                font-weight: 900;
            }
            .badc {
                color: var(--bad);
                font-weight: 900;
            }
            .warnc {
                color: var(--warn);
                font-weight: 900;
            }
            .small {
                font-size: 11px;
                line-height: 1.35;
            }
            .topbar {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
                justify-content: space-between;
                padding: 10px 12px;
                border-bottom: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
            }
            .pill2 {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                padding: 4px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.02);
                font-size: 12px;
                color: var(--muted);
            }
            .pill2 b {
                color: var(--text);
            }
        </style>
    </head>
    <body>
        <header>
            <h1>ULTRA EXTREME Winrate LONG Scanner</h1>
            <div class="sub">
                <b>목표:</b> 신호가 거의 사라져도 상관없다는 전제로 “승률/안정성”만 최대한 챙긴 후보만 남깁니다.
                <br />
                <b>중요:</b> 이 도구는 “후보 선별” 도구이고, <b>무조건/확실/절대손실 없음은 불가능</b>합니다.
            </div>
        </header>

        <div class="wrap">
            <section class="card">
                <div class="hd">극단 세팅</div>
                <div class="bd">
                    <div class="grid">
                        <div class="row">
                            <label>대상 심볼 수(24h QVol 상위 N)</label>
                            <input id="limitSymbols" type="number" min="20" step="10" value="200" />
                        </div>
                        <div class="row">
                            <label>24h 거래대금 하한(USDT)</label>
                            <input id="minQuoteVol" type="number" min="0" step="10000000" value="80000000" />
                        </div>

                        <div class="row">
                            <label>레짐 필터: BTC 1D 추세 통과 필요(1=ON, 0=OFF)</label>
                            <input id="btcRegimeOn" type="number" min="0" max="1" step="1" value="1" />
                        </div>
                        <div class="row">
                            <label>레짐 필터: ETH 1D 추세 통과 필요(1=ON, 0=OFF)</label>
                            <input id="ethRegimeOn" type="number" min="0" max="1" step="1" value="1" />
                        </div>

                        <div class="row">
                            <label>펀딩 상한(과열 차단): funding% ≤</label>
                            <input id="maxFundingPct" type="number" min="-5" step="0.001" value="0.006" />
                        </div>
                        <div class="row">
                            <label>펀딩 하한(너무 약세 차단): funding% ≥</label>
                            <input id="minFundingPct" type="number" min="-5" step="0.001" value="-0.020" />
                        </div>

                        <div class="row">
                            <label>OI 동행(15m): OI% ≥</label>
                            <input id="minOiChgPct" type="number" min="-50" step="0.1" value="0.50" />
                        </div>
                        <div class="row">
                            <label>OI 동행(15m): 가격% ≥</label>
                            <input id="minPxChgPct" type="number" min="-50" step="0.1" value="0.20" />
                        </div>

                        <div class="row">
                            <label>15m: 바디 비중% ≥</label>
                            <input id="minBodyPct" type="number" min="0" step="1" value="65" />
                        </div>
                        <div class="row">
                            <label>15m: 직전봉 상승% ≥</label>
                            <input id="minRetPct" type="number" min="0" step="0.05" value="0.50" />
                        </div>

                        <div class="row">
                            <label>15m: 볼륨 스파이크 ≥</label>
                            <input id="minVolSpike" type="number" min="1" step="0.1" value="2.2" />
                        </div>
                        <div class="row">
                            <label>15m: “눌림 후 재돌파” 강제(1=ON, 0=OFF)</label>
                            <input id="requirePullbackReclaim" type="number" min="0" max="1" step="1" value="1" />
                        </div>

                        <div class="row">
                            <label>RSI 과열 차단: RSI(15m) ≤</label>
                            <input id="maxRsi" type="number" min="40" step="1" value="68" />
                        </div>
                        <div class="row">
                            <label>브레이크아웃 N(직전 고가 > 이전 N고가)</label>
                            <input id="breakN" type="number" min="8" step="1" value="20" />
                        </div>

                        <div class="row">
                            <label>ATR% 최소(너무 잔변동 차단) ≥</label>
                            <input id="minAtrPct" type="number" min="0.01" step="0.01" value="0.18" />
                        </div>
                        <div class="row">
                            <label>ATR% 최대(너무 난폭 차단) ≤</label>
                            <input id="maxAtrPct" type="number" min="0.1" step="0.1" value="2.0" />
                        </div>

                        <div class="row">
                            <label>TP = ATR * (승률↑ 보통 작게)</label>
                            <input id="tpAtrMult" type="number" min="0.2" step="0.1" value="0.9" />
                        </div>
                        <div class="row">
                            <label>SL = ATR * (손실폭 제한 목적)</label>
                            <input id="slAtrMult" type="number" min="0.3" step="0.1" value="1.3" />
                        </div>

                        <div class="row">
                            <label>BT: lookahead(신호 후 캔들 수)</label>
                            <input id="btLookahead" type="number" min="8" step="1" value="20" />
                        </div>
                        <div class="row">
                            <label>BT: 심볼당 최대 신호 수</label>
                            <input id="btMaxSignals" type="number" min="10" step="10" value="120" />
                        </div>

                        <div class="row">
                            <label>BT: 최소 표본 N ≥</label>
                            <input id="btMinTrades" type="number" min="10" step="5" value="60" />
                        </div>
                        <div class="row">
                            <label>BT: 최소 승률% ≥</label>
                            <input id="btMinWinrate" type="number" min="40" step="0.5" value="74" />
                        </div>

                        <div class="row">
                            <label>BT: 최근 절반 승률% ≥</label>
                            <input id="btMinWrHalf" type="number" min="40" step="0.5" value="72" />
                        </div>
                        <div class="row">
                            <label>BT: 최대 연속손실(MaxConsecLoss) ≤</label>
                            <input id="btMaxConsecLoss" type="number" min="0" step="1" value="2" />
                        </div>

                        <div class="row">
                            <label>추세 최소점수(1D+4H+1H) ≥</label>
                            <input id="minTrendScore" type="number" min="0" step="1" value="78" />
                        </div>
                        <div class="row">
                            <label>BT 기대값(간이) ≥ (0이면 비활성)</label>
                            <input id="minExpectancy" type="number" min="0" step="0.01" value="0.02" />
                        </div>
                    </div>

                    <div class="actions">
                        <button id="btnScan" class="primary">Scan (Ultra Extreme)</button>
                        <button id="btnStop" class="danger" disabled>Stop</button>
                    </div>

                    <div class="note">
                        <div class="pill"><b>레짐필터</b> BTC/ETH 1D가 약세면 전체 신호를 막음</div>
                        <div class="pill"><b>승률 착시 방지</b> 최근 절반 승률 + 연속손실 제한 + 기대값 기준</div>
                        <div class="pill"><b>실전</b> 결과가 떠도 “즉시”가 아니라 <b>체크리스트</b> 통과 후</div>
                    </div>
                </div>
            </section>

            <section class="card">
                <div class="topbar">
                    <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                        <span class="pill2">정렬: <b id="sortLabel">Score ↓</b></span>
                        <span class="pill2">결과: <b id="resultCount">0</b></span>
                        <span class="pill2">업데이트: <b id="lastUpdated">-</b></span>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <span class="pill2">API: <b id="apiState">idle</b></span>
                    </div>
                </div>

                <div class="status" id="statusBox">
                    <div>대기 중…</div>
                </div>

                <div style="overflow:auto; max-height: calc(100dvh - 210px);">
                    <table id="tbl">
                        <thead>
                            <tr>
                                <th data-key="score">Score</th>
                                <th data-key="symbol">Symbol</th>
                                <th data-key="winrate">BT Win%</th>
                                <th data-key="trades">BT N</th>
                                <th data-key="wrHalf">BT Half%</th>
                                <th data-key="maxConsecLoss">BT MaxCL</th>
                                <th data-key="expectancy">BT Exp</th>
                                <th data-key="price">Now</th>
                                <th data-key="fundingPct">Funding%</th>
                                <th data-key="oiChgPct">OI15m%</th>
                                <th data-key="pxChgPct">Px15m%</th>
                                <th data-key="rsi">RSI15</th>
                                <th data-key="atrPct">ATR%</th>
                                <th data-key="trendScore">Trend</th>
                                <th data-key="tp">TP</th>
                                <th data-key="sl">SL</th>
                                <th data-key="qv24">24h QVol</th>
                                <th>Why</th>
                            </tr>
                        </thead>
                        <tbody id="tbody"></tbody>
                    </table>
                </div>
            </section>
        </div>

        <script>
            "use strict";

            const BASE = "https://fapi.binance.com";

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function nowKST() {
                const d = new Date();
                const utc = d.getTime() + d.getTimezoneOffset() * 60000;
                const kst = new Date(utc + 9 * 3600000);
                const y = kst.getFullYear();
                const m = String(kst.getMonth() + 1).padStart(2, "0");
                const day = String(kst.getDate()).padStart(2, "0");
                const hh = String(kst.getHours()).padStart(2, "0");
                const mm = String(kst.getMinutes()).padStart(2, "0");
                const ss = String(kst.getSeconds()).padStart(2, "0");
                return `${y}-${m}-${day} ${hh}:${mm}:${ss} KST`;
            }

            async function fetchJson(url, signal) {
                const res = await fetch(url, { method: "GET", signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 200)}`);
                }
                return res.json();
            }

            function clamp(x, lo, hi) {
                return Math.min(hi, Math.max(lo, x));
            }

            function pct(a, b) {
                if (!isFinite(a) || !isFinite(b) || b === 0) return 0;
                return (a / b - 1) * 100;
            }

            function ema(values, period) {
                if (!values || values.length === 0) return [];
                const k = 2 / (period + 1);
                const out = new Array(values.length);
                let prev = values[0];
                out[0] = prev;
                for (let i = 1; i < values.length; i += 1) {
                    const v = values[i];
                    prev = v * k + prev * (1 - k);
                    out[i] = prev;
                }
                return out;
            }

            function atr(high, low, close, period) {
                const n = close.length;
                const tr = new Array(n).fill(0);
                for (let i = 1; i < n; i += 1) {
                    const h = high[i];
                    const l = low[i];
                    const pc = close[i - 1];
                    const a = h - l;
                    const b = Math.abs(h - pc);
                    const c = Math.abs(l - pc);
                    tr[i] = Math.max(a, b, c);
                }
                const out = new Array(n).fill(0);
                let sum = 0;
                for (let i = 1; i < n; i += 1) {
                    sum += tr[i];
                    if (i >= period) {
                        sum -= tr[i - period];
                        out[i] = sum / period;
                    } else {
                        out[i] = sum / Math.max(1, i);
                    }
                }
                return out;
            }

            function rsi14(close, period = 14) {
                const n = close.length;
                if (n < period + 2) return new Array(n).fill(50);
                const out = new Array(n).fill(50);
                let gain = 0;
                let loss = 0;

                for (let i = 1; i <= period; i += 1) {
                    const d = close[i] - close[i - 1];
                    if (d >= 0) gain += d;
                    else loss -= d;
                }

                let avgGain = gain / period;
                let avgLoss = loss / period;
                out[period] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);

                for (let i = period + 1; i < n; i += 1) {
                    const d = close[i] - close[i - 1];
                    const g = d > 0 ? d : 0;
                    const l = d < 0 ? -d : 0;
                    avgGain = (avgGain * (period - 1) + g) / period;
                    avgLoss = (avgLoss * (period - 1) + l) / period;

                    if (avgLoss === 0) out[i] = 100;
                    else {
                        const rs = avgGain / avgLoss;
                        out[i] = 100 - 100 / (1 + rs);
                    }
                }

                return out;
            }

            function parseKlines(raw) {
                const t = [];
                const o = [];
                const h = [];
                const l = [];
                const c = [];
                const v = [];
                for (const k of raw) {
                    t.push(Number(k[0]));
                    o.push(Number(k[1]));
                    h.push(Number(k[2]));
                    l.push(Number(k[3]));
                    c.push(Number(k[4]));
                    v.push(Number(k[5]));
                }
                return { t, o, h, l, c, v };
            }

            async function getSymbolsUSDTPerp(signal) {
                const ex = await fetchJson(`${BASE}/fapi/v1/exchangeInfo`, signal);
                return (ex.symbols || [])
                    .filter((s) => s.contractType === "PERPETUAL")
                    .filter((s) => s.quoteAsset === "USDT")
                    .filter((s) => s.status === "TRADING")
                    .map((s) => s.symbol);
            }

            async function getTickers24h(signal) {
                return fetchJson(`${BASE}/fapi/v1/ticker/24hr`, signal);
            }

            async function getLastPrices(signal) {
                const arr = await fetchJson(`${BASE}/fapi/v1/ticker/price`, signal);
                const map = new Map();
                for (const x of arr) map.set(x.symbol, Number(x.price));
                return map;
            }

            async function getKlines(symbol, interval, limit, signal) {
                const url = `${BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${interval}&limit=${limit}`;
                return fetchJson(url, signal);
            }

            async function getPremiumIndex(symbol, signal) {
                const url = `${BASE}/fapi/v1/premiumIndex?symbol=${encodeURIComponent(symbol)}`;
                return fetchJson(url, signal);
            }

            async function getOpenInterestHist(symbol, period, limit, signal) {
                const url =
                    `${BASE}/futures/data/openInterestHist?symbol=${encodeURIComponent(symbol)}` +
                    `&period=${encodeURIComponent(period)}&limit=${encodeURIComponent(String(limit))}`;
                return fetchJson(url, signal);
            }

            function fmtNum(x, digits = 2) {
                if (!isFinite(x)) return "-";
                return Number(x).toFixed(digits);
            }

            function fmtInt(x) {
                if (!isFinite(x)) return "-";
                return Math.round(Number(x)).toLocaleString();
            }

            function fmtMoney(x) {
                if (!isFinite(x)) return "-";
                return Math.round(Number(x)).toLocaleString();
            }

            const el = {
                limitSymbols: document.getElementById("limitSymbols"),
                minQuoteVol: document.getElementById("minQuoteVol"),
                btcRegimeOn: document.getElementById("btcRegimeOn"),
                ethRegimeOn: document.getElementById("ethRegimeOn"),
                maxFundingPct: document.getElementById("maxFundingPct"),
                minFundingPct: document.getElementById("minFundingPct"),
                minOiChgPct: document.getElementById("minOiChgPct"),
                minPxChgPct: document.getElementById("minPxChgPct"),
                minBodyPct: document.getElementById("minBodyPct"),
                minRetPct: document.getElementById("minRetPct"),
                minVolSpike: document.getElementById("minVolSpike"),
                requirePullbackReclaim: document.getElementById("requirePullbackReclaim"),
                maxRsi: document.getElementById("maxRsi"),
                breakN: document.getElementById("breakN"),
                minAtrPct: document.getElementById("minAtrPct"),
                maxAtrPct: document.getElementById("maxAtrPct"),
                tpAtrMult: document.getElementById("tpAtrMult"),
                slAtrMult: document.getElementById("slAtrMult"),
                btLookahead: document.getElementById("btLookahead"),
                btMaxSignals: document.getElementById("btMaxSignals"),
                btMinTrades: document.getElementById("btMinTrades"),
                btMinWinrate: document.getElementById("btMinWinrate"),
                btMinWrHalf: document.getElementById("btMinWrHalf"),
                btMaxConsecLoss: document.getElementById("btMaxConsecLoss"),
                minTrendScore: document.getElementById("minTrendScore"),
                minExpectancy: document.getElementById("minExpectancy"),
                btnScan: document.getElementById("btnScan"),
                btnStop: document.getElementById("btnStop"),
                statusBox: document.getElementById("statusBox"),
                tbody: document.getElementById("tbody"),
                resultCount: document.getElementById("resultCount"),
                lastUpdated: document.getElementById("lastUpdated"),
                apiState: document.getElementById("apiState"),
                sortLabel: document.getElementById("sortLabel"),
                tbl: document.getElementById("tbl"),
            };

            let sortKey = "score";
            let sortDir = "desc";
            let currentRows = [];
            let aborter = null;

            function setStatus(lines) {
                el.statusBox.innerHTML = lines.map((x) => `<div>${x}</div>`).join("");
            }

            function render(rows) {
                const sorted = [...rows].sort((a, b) => {
                    const av = a[sortKey];
                    const bv = b[sortKey];
                    if (av === bv) return 0;
                    if (sortDir === "asc") return av > bv ? 1 : -1;
                    return av < bv ? 1 : -1;
                });

                el.resultCount.textContent = String(sorted.length);

                const html = sorted
                    .map((r) => {
                        const wrClass = r.winrate >= 80 ? "good" : r.winrate >= 74 ? "warnc" : "badc";
                        const halfClass = r.wrHalf >= 80 ? "good" : r.wrHalf >= 72 ? "warnc" : "badc";
                        const clClass = r.maxConsecLoss <= 1 ? "good" : r.maxConsecLoss <= 2 ? "warnc" : "badc";
                        const expClass = r.expectancy >= 0.06 ? "good" : r.expectancy >= 0.02 ? "warnc" : "badc";

                        return `
                        <tr>
                            <td class="mono"><b>${fmtNum(r.score, 1)}</b></td>
                            <td class="mono"><b>${r.symbol}</b></td>
                            <td class="mono ${wrClass}">${fmtNum(r.winrate, 1)}</td>
                            <td class="mono">${fmtInt(r.trades)}</td>
                            <td class="mono ${halfClass}">${fmtNum(r.wrHalf, 1)}</td>
                            <td class="mono ${clClass}">${fmtInt(r.maxConsecLoss)}</td>
                            <td class="mono ${expClass}">${fmtNum(r.expectancy, 3)}</td>
                            <td class="mono">${fmtNum(r.price, r.price < 1 ? 6 : 3)}</td>
                            <td class="mono">${fmtNum(r.fundingPct, 3)}</td>
                            <td class="mono">${fmtNum(r.oiChgPct, 2)}</td>
                            <td class="mono">${fmtNum(r.pxChgPct, 2)}</td>
                            <td class="mono">${fmtNum(r.rsi, 1)}</td>
                            <td class="mono">${fmtNum(r.atrPct, 2)}</td>
                            <td class="mono">${fmtNum(r.trendScore, 0)}</td>
                            <td class="mono">${fmtNum(r.tp, r.price < 1 ? 6 : 3)}</td>
                            <td class="mono">${fmtNum(r.sl, r.price < 1 ? 6 : 3)}</td>
                            <td class="mono">${fmtMoney(r.qv24)}</td>
                            <td class="small">${r.why}</td>
                        </tr>
                        `;
                    })
                    .join("");

                el.tbody.innerHTML = html;
                el.lastUpdated.textContent = nowKST();
            }

            el.tbl.querySelectorAll("thead th[data-key]").forEach((th) => {
                th.addEventListener("click", () => {
                    const key = th.getAttribute("data-key");
                    if (!key) return;
                    if (sortKey === key) sortDir = sortDir === "desc" ? "asc" : "desc";
                    else {
                        sortKey = key;
                        sortDir = key === "symbol" ? "asc" : "desc";
                    }
                    el.sortLabel.textContent = `${sortKey} ${sortDir === "desc" ? "↓" : "↑"}`;
                    render(currentRows);
                });
            });

            function computeTrendScore(k1d, k4h, k1h, price) {
                const e1d20 = ema(k1d.c, 20);
                const e1d50 = ema(k1d.c, 50);
                const e4h20 = ema(k4h.c, 20);
                const e4h50 = ema(k4h.c, 50);
                const e1h20 = ema(k1h.c, 20);
                const e1h50 = ema(k1h.c, 50);

                const i1d = k1d.c.length - 2;
                const i4h = k4h.c.length - 2;
                const i1h = k1h.c.length - 2;
                if (i1d < 80 || i4h < 80 || i1h < 80) return { score: 0, detail: "not enough" };

                const ok1d = e1d20[i1d] > e1d50[i1d] && price > e1d20[i1d];
                const ok4h = e4h20[i4h] > e4h50[i4h] && price > e4h20[i4h];
                const ok1h = e1h20[i1h] > e1h50[i1h] && price > e1h20[i1h];

                function slopeUp(arr, idx, back) {
                    const j = idx - back;
                    if (j < 0) return false;
                    return arr[idx] > arr[j];
                }

                const s1d = slopeUp(e1d20, i1d, 5);
                const s4h = slopeUp(e4h20, i4h, 6);
                const s1h = slopeUp(e1h20, i1h, 8);

                const dist1h = (price - e1h20[i1h]) / Math.max(1e-12, e1h20[i1h]);
                const over = Math.max(0, dist1h - 0.012);
                const penaltyOver = clamp(over * 2500, 0, 18);

                let score = 0;
                score += ok1d ? 36 : 0;
                score += ok4h ? 30 : 0;
                score += ok1h ? 22 : 0;
                score += s1d ? 5 : 0;
                score += s4h ? 4 : 0;
                score += s1h ? 4 : 0;
                score -= penaltyOver;

                score = clamp(score, 0, 100);

                const detail = `${ok1d ? "1D↑" : "1D×"} ${ok4h ? "4H↑" : "4H×"} ${ok1h ? "1H↑" : "1H×"} slope:${
                    s1d && s4h && s1h ? "OK" : "mix"
                }`;

                return { score, detail };
            }

            function computeTrigger15m(k15, minBodyPct, minRetPct, minVolSpike, breakN, requirePullbackReclaim) {
                const n = k15.c.length;
                if (n < 120) return null;

                const i = n - 2;
                const open = k15.o[i];
                const high = k15.h[i];
                const low = k15.l[i];
                const close = k15.c[i];

                const range = Math.max(1e-12, high - low);
                const bodyPct = (Math.abs(close - open) / range) * 100;
                const retPct = pct(close, open);
                const isGreen = close > open;

                let sum = 0;
                let cnt = 0;
                for (let j = i - 1; j >= 0 && cnt < 20; j -= 1) {
                    sum += k15.v[j];
                    cnt += 1;
                }
                const volAvg = cnt > 0 ? sum / cnt : 0;
                const volSpike = volAvg > 0 ? k15.v[i] / volAvg : 0;

                let prevMax = -Infinity;
                for (let j = i - 1; j >= 0 && j >= i - breakN; j -= 1) {
                    prevMax = Math.max(prevMax, k15.h[j]);
                }
                const isBreakout = high > prevMax;

                // “눌림 후 재돌파” 강제: 최근 8봉 중 최소 1봉이 EMA20 아래/근처 터치 후, 현재는 EMA20 위로 마감
                let pullbackOk = true;
                const e20 = ema(k15.c, 20);
                if (requirePullbackReclaim === 1) {
                    const emaNow = e20[i];
                    const touchBand = emaNow * 0.0025; // 0.25% 밴드
                    let touched = false;
                    for (let j = i - 1; j >= 0 && j >= i - 8; j -= 1) {
                        if (k15.l[j] <= e20[j] + touchBand) {
                            touched = true;
                            break;
                        }
                    }
                    pullbackOk = touched && close > emaNow;
                }

                const pass =
                    isGreen &&
                    bodyPct >= minBodyPct &&
                    retPct >= minRetPct &&
                    volSpike >= minVolSpike &&
                    isBreakout &&
                    pullbackOk;

                return { pass, bodyPct, retPct, volSpike, isBreakout, pullbackOk };
            }

            function proposeTPSL(k15, tpMult, slMult, entryNow) {
                const a = atr(k15.h, k15.l, k15.c, 14);
                const i = k15.c.length - 2;
                const atr15 = a[i] || 0;
                return {
                    atr15,
                    tp: entryNow + atr15 * tpMult,
                    sl: entryNow - atr15 * slMult,
                };
            }

            function backtestUltra(k15, tpMult, slMult, lookahead, maxSignals, triggerFn) {
                // 보수적 판정:
                // - entry = 다음 캔들 시가
                // - TP/SL 동봉 히트 => 손실 처리
                // - outcome 없는 건 제외
                // + max consecutive loss 계산
                const n = k15.c.length;
                if (n < 300) return { winrate: 0, trades: 0, wrHalf: 0, maxConsecLoss: 999, expectancy: 0 };

                const a = atr(k15.h, k15.l, k15.c, 14);

                const sig = [];
                for (let i = 80; i < n - 2; i += 1) {
                    const ok = triggerFn(i);
                    if (ok) sig.push(i);
                }

                const picked = sig.slice(-maxSignals);

                function evalList(list) {
                    let wins = 0;
                    let losses = 0;
                    let consecLoss = 0;
                    let maxConsecLoss = 0;

                    // expectancy(간이): win = +tpMult, loss = -slMult 로 가중 (ATR 단위)
                    let sumR = 0;

                    for (const i of list) {
                        const entryIdx = i + 1;
                        if (entryIdx >= n) continue;

                        const entry = k15.o[entryIdx];
                        const atrAt = a[i] || 0;
                        if (atrAt <= 0) continue;

                        const tp = entry + atrAt * tpMult;
                        const sl = entry - atrAt * slMult;

                        let outcome = 0;
                        for (let j = entryIdx; j < Math.min(n, entryIdx + lookahead); j += 1) {
                            const hh = k15.h[j];
                            const ll = k15.l[j];

                            const hitTP = hh >= tp;
                            const hitSL = ll <= sl;

                            if (hitTP && hitSL) {
                                outcome = -1;
                                break;
                            }
                            if (hitSL) {
                                outcome = -1;
                                break;
                            }
                            if (hitTP) {
                                outcome = 1;
                                break;
                            }
                        }

                        if (outcome === 1) {
                            wins += 1;
                            consecLoss = 0;
                            sumR += tpMult;
                        } else if (outcome === -1) {
                            losses += 1;
                            consecLoss += 1;
                            maxConsecLoss = Math.max(maxConsecLoss, consecLoss);
                            sumR -= slMult;
                        }
                    }

                    const trades = wins + losses;
                    const winrate = trades > 0 ? (wins / trades) * 100 : 0;
                    const expectancy = trades > 0 ? sumR / trades : 0;

                    return { winrate, trades, maxConsecLoss, expectancy };
                }

                const all = evalList(picked);
                const half = Math.max(1, Math.floor(picked.length / 2));
                const halfList = picked.slice(-half);
                const halfEval = evalList(halfList);

                return {
                    winrate: all.winrate,
                    trades: all.trades,
                    wrHalf: halfEval.winrate,
                    maxConsecLoss: all.maxConsecLoss,
                    expectancy: all.expectancy,
                };
            }

            function scoreRow(trendScore, bt) {
                const s1 = clamp(bt.winrate, 0, 95);
                const s2 = clamp(bt.wrHalf, 0, 95);
                const s3 = clamp(bt.trades, 0, 120);
                const s4 = 100 - clamp(bt.maxConsecLoss * 18, 0, 80);
                const s5 = clamp(bt.expectancy * 120, 0, 30);

                const score = s1 * 0.38 + s2 * 0.20 + trendScore * 0.18 + s3 * 0.08 + s4 * 0.12 + s5 * 0.04;
                return clamp(score, 0, 100);
            }

            async function checkRegime(symbol, signal) {
                const raw1d = await getKlines(symbol, "1d", 200, signal);
                const k1d = parseKlines(raw1d);
                const last = k1d.c[k1d.c.length - 2];
                const tr = computeTrendScore(k1d, k1d, k1d, last); // same series ok for regime
                // 여기서는 간단히: EMA20>EMA50 & price>EMA20 조건이 점수에 반영됨
                return tr.score >= 70;
            }

            async function runScan() {
                if (aborter) aborter.abort();
                aborter = new AbortController();
                const { signal } = aborter;

                el.btnScan.disabled = true;
                el.btnStop.disabled = false;
                el.apiState.textContent = "running";

                currentRows = [];
                render(currentRows);

                const limitSymbols = Number(el.limitSymbols.value);
                const minQuoteVol = Number(el.minQuoteVol.value);

                const btcRegimeOn = Number(el.btcRegimeOn.value);
                const ethRegimeOn = Number(el.ethRegimeOn.value);

                const maxFundingPct = Number(el.maxFundingPct.value);
                const minFundingPct = Number(el.minFundingPct.value);

                const minOiChgPct = Number(el.minOiChgPct.value);
                const minPxChgPct = Number(el.minPxChgPct.value);

                const minBodyPct = Number(el.minBodyPct.value);
                const minRetPct = Number(el.minRetPct.value);
                const minVolSpike = Number(el.minVolSpike.value);
                const requirePullbackReclaim = Number(el.requirePullbackReclaim.value);

                const maxRsi = Number(el.maxRsi.value);
                const breakN = Number(el.breakN.value);

                const minAtrPct = Number(el.minAtrPct.value);
                const maxAtrPct = Number(el.maxAtrPct.value);

                const tpAtrMult = Number(el.tpAtrMult.value);
                const slAtrMult = Number(el.slAtrMult.value);

                const btLookahead = Number(el.btLookahead.value);
                const btMaxSignals = Number(el.btMaxSignals.value);
                const btMinTrades = Number(el.btMinTrades.value);
                const btMinWinrate = Number(el.btMinWinrate.value);
                const btMinWrHalf = Number(el.btMinWrHalf.value);
                const btMaxConsecLoss = Number(el.btMaxConsecLoss.value);

                const minTrendScore = Number(el.minTrendScore.value);
                const minExpectancy = Number(el.minExpectancy.value);

                try {
                    setStatus([`로딩… (exchangeInfo + ticker)`, `<span class="warn">※ 결과가 0개여도 정상입니다(극단 필터).</span>`]);

                    if (btcRegimeOn === 1) {
                        setStatus([`레짐 체크: BTCUSDT 1D…`, `<span class="muted">약세면 전체 신호 차단</span>`]);
                        const ok = await checkRegime("BTCUSDT", signal);
                        if (!ok) {
                            setStatus([`<span class="bad">차단</span> BTC 1D 레짐 불합격 → 오늘은 “롱 후보 스캔 자체를 중단”`]);
                            return;
                        }
                    }
                    if (ethRegimeOn === 1) {
                        setStatus([`레짐 체크: ETHUSDT 1D…`, `<span class="muted">약세면 전체 신호 차단</span>`]);
                        const ok = await checkRegime("ETHUSDT", signal);
                        if (!ok) {
                            setStatus([`<span class="bad">차단</span> ETH 1D 레짐 불합격 → 오늘은 “롱 후보 스캔 자체를 중단”`]);
                            return;
                        }
                    }

                    const [symbols, tickers, lastPriceMap] = await Promise.all([
                        getSymbolsUSDTPerp(signal),
                        getTickers24h(signal),
                        getLastPrices(signal),
                    ]);

                    const tickerMap = new Map();
                    for (const t of tickers) tickerMap.set(t.symbol, t);

                    const ranked = symbols
                        .map((s) => {
                            const t = tickerMap.get(s);
                            const qv24 = t ? Number(t.quoteVolume) : 0;
                            return { symbol: s, qv24 };
                        })
                        .filter((x) => x.qv24 >= minQuoteVol)
                        .sort((a, b) => b.qv24 - a.qv24)
                        .slice(0, Math.max(20, limitSymbols));

                    setStatus([
                        `대상: ${ranked.length}개 (24h QVol ≥ ${fmtMoney(minQuoteVol)})`,
                        `<span class="muted">펀딩→OI→캔들→RSI/ATR→BT 순으로 극단 필터</span>`,
                    ]);

                    const concurrency = 4;
                    let idx = 0;

                    async function worker() {
                        while (idx < ranked.length) {
                            const my = idx;
                            idx += 1;

                            const { symbol, qv24 } = ranked[my];
                            if (signal.aborted) return;

                            try {
                                // 1) funding filter
                                const prem = await getPremiumIndex(symbol, signal);
                                const fundingPct = Number(prem.lastFundingRate || 0) * 100;
                                if (fundingPct > maxFundingPct) continue;
                                if (fundingPct < minFundingPct) continue;

                                // 2) OI confirm
                                const oiHist = await getOpenInterestHist(symbol, "15m", 3, signal);
                                if (!Array.isArray(oiHist) || oiHist.length < 2) continue;

                                const oiPrev = Number(oiHist[oiHist.length - 2].sumOpenInterest || 0);
                                const oiNow = Number(oiHist[oiHist.length - 1].sumOpenInterest || 0);
                                if (!(oiPrev > 0 && oiNow > 0)) continue;

                                const oiChgPct = pct(oiNow, oiPrev);
                                if (oiChgPct < minOiChgPct) continue;

                                // 3) candles
                                const [k15raw, k1hraw, k4hraw, k1draw] = await Promise.all([
                                    getKlines(symbol, "15m", 700, signal),
                                    getKlines(symbol, "1h", 520, signal),
                                    getKlines(symbol, "4h", 420, signal),
                                    getKlines(symbol, "1d", 320, signal),
                                ]);

                                const k15 = parseKlines(k15raw);
                                const k1h = parseKlines(k1hraw);
                                const k4h = parseKlines(k4hraw);
                                const k1d = parseKlines(k1draw);

                                const price = lastPriceMap.get(symbol) || k15.c[k15.c.length - 2] || 0;
                                if (!isFinite(price) || price <= 0) continue;

                                // 4) trend strict
                                const tr = computeTrendScore(k1d, k4h, k1h, price);
                                if (tr.score < minTrendScore) continue;

                                // 5) 15m price change min
                                const i15 = k15.c.length - 2;
                                const pxChgPct = pct(k15.c[i15], k15.o[i15]);
                                if (pxChgPct < minPxChgPct) continue;

                                // 6) RSI anti-overheat
                                const rsiArr = rsi14(k15.c, 14);
                                const rsiNow = rsiArr[i15] || 50;
                                if (rsiNow > maxRsi) continue;

                                // 7) ATR% band
                                const atrArr = atr(k15.h, k15.l, k15.c, 14);
                                const atr15 = atrArr[i15] || 0;
                                const atrPct = (atr15 / Math.max(1e-12, price)) * 100;
                                if (atrPct < minAtrPct) continue;
                                if (atrPct > maxAtrPct) continue;

                                // 8) trigger ultra strict
                                const trig = computeTrigger15m(
                                    k15,
                                    minBodyPct,
                                    minRetPct,
                                    minVolSpike,
                                    breakN,
                                    requirePullbackReclaim
                                );
                                if (!trig || !trig.pass) continue;

                                // 9) backtest ultra strict
                                const triggerFn = (i) => {
                                    // evaluate trigger at candle i using same rules (approx)
                                    const tmp = {
                                        o: k15.o,
                                        h: k15.h,
                                        l: k15.l,
                                        c: k15.c,
                                        v: k15.v,
                                    };

                                    // reuse logic without re-ema for speed: keep pullback off in historical BT to avoid false negatives?
                                    // 여기서는 동일 조건 유지(극단).
                                    const slice = tmp; // full arrays
                                    const n = slice.c.length;
                                    if (i < 30 || i >= n - 2) return false;

                                    const open = slice.o[i];
                                    const high = slice.h[i];
                                    const low = slice.l[i];
                                    const close = slice.c[i];

                                    const range = Math.max(1e-12, high - low);
                                    const bodyPct2 = (Math.abs(close - open) / range) * 100;
                                    const retPct2 = pct(close, open);
                                    const isGreen2 = close > open;

                                    let sum = 0;
                                    let cnt = 0;
                                    for (let j = i - 1; j >= 0 && cnt < 20; j -= 1) {
                                        sum += slice.v[j];
                                        cnt += 1;
                                    }
                                    const volAvg = cnt > 0 ? sum / cnt : 0;
                                    const volSpike2 = volAvg > 0 ? slice.v[i] / volAvg : 0;

                                    let prevMax = -Infinity;
                                    for (let j = i - 1; j >= 0 && j >= i - breakN; j -= 1) {
                                        prevMax = Math.max(prevMax, slice.h[j]);
                                    }
                                    const isBreakout2 = high > prevMax;

                                    let pullbackOk2 = true;
                                    if (requirePullbackReclaim === 1) {
                                        const e20 = ema(slice.c, 20);
                                        const emaNow = e20[i];
                                        const touchBand = emaNow * 0.0025;
                                        let touched = false;
                                        for (let j = i - 1; j >= 0 && j >= i - 8; j -= 1) {
                                            if (slice.l[j] <= e20[j] + touchBand) {
                                                touched = true;
                                                break;
                                            }
                                        }
                                        pullbackOk2 = touched && close > emaNow;
                                    }

                                    return (
                                        isGreen2 &&
                                        bodyPct2 >= minBodyPct &&
                                        retPct2 >= minRetPct &&
                                        volSpike2 >= minVolSpike &&
                                        isBreakout2 &&
                                        pullbackOk2
                                    );
                                };

                                const bt = backtestUltra(k15, tpAtrMult, slAtrMult, btLookahead, btMaxSignals, triggerFn);

                                if (bt.trades < btMinTrades) continue;
                                if (bt.winrate < btMinWinrate) continue;
                                if (bt.wrHalf < btMinWrHalf) continue;
                                if (bt.maxConsecLoss > btMaxConsecLoss) continue;
                                if (minExpectancy > 0 && bt.expectancy < minExpectancy) continue;

                                const tpsl = proposeTPSL(k15, tpAtrMult, slAtrMult, price);
                                const score = scoreRow(tr.score, bt);

                                currentRows.push({
                                    score,
                                    symbol,
                                    winrate: bt.winrate,
                                    trades: bt.trades,
                                    wrHalf: bt.wrHalf,
                                    maxConsecLoss: bt.maxConsecLoss,
                                    expectancy: bt.expectancy,
                                    price,
                                    fundingPct,
                                    oiChgPct,
                                    pxChgPct,
                                    rsi: rsiNow,
                                    atrPct,
                                    trendScore: tr.score,
                                    tp: tpsl.tp,
                                    sl: tpsl.sl,
                                    qv24,
                                    why: [
                                        `Trend ${tr.detail} (${fmtNum(tr.score, 0)})`,
                                        `Funding ${fmtNum(fundingPct, 3)}%`,
                                        `OI15m ${fmtNum(oiChgPct, 2)}% / Px15m ${fmtNum(pxChgPct, 2)}%`,
                                        `Trigger OK(눌림후재돌파:${trig.pullbackOk ? "Y" : "N"})`,
                                        `RSI ${fmtNum(rsiNow, 1)} / ATR% ${fmtNum(atrPct, 2)}`,
                                        `BT Win ${fmtNum(bt.winrate, 1)}% (N=${bt.trades}) / Half ${fmtNum(bt.wrHalf, 1)}% / MaxCL ${bt.maxConsecLoss} / Exp ${fmtNum(
                                            bt.expectancy,
                                            3
                                        )}`,
                                    ].join(" · "),
                                });

                                if (currentRows.length % 3 === 0) render(currentRows);

                                await sleep(70);
                            } catch (err) {
                                await sleep(90);
                            } finally {
                                if (my % 12 === 0) {
                                    setStatus([
                                        `진행: ${my + 1} / ${ranked.length}`,
                                        `<span class="muted">통과: ${currentRows.length} (극단 필터)</span>`,
                                        `<span class="warn">결과 0개면 정상입니다. (승률 최우선)</span>`,
                                    ]);
                                }
                            }
                        }
                    }

                    const workers = [];
                    for (let i = 0; i < concurrency; i += 1) workers.push(worker());
                    await Promise.all(workers);

                    render(currentRows);
                    setStatus([
                        `<span class="ok">완료</span> — 결과 ${currentRows.length}개`,
                        `<span class="muted">헤더 클릭 정렬 가능</span>`,
                        `<span class="warn">중요: “후보”일 뿐, 무조건 수익 보장은 없습니다. 특히 뉴스/급락장에서는 신호가 무력화됩니다.</span>`,
                    ]);
                } catch (err) {
                    const msg = err && err.message ? err.message : String(err);
                    setStatus([`<span class="bad">에러</span> ${msg}`]);
                } finally {
                    el.btnScan.disabled = false;
                    el.btnStop.disabled = true;
                    el.apiState.textContent = "idle";
                }
            }

            function stopScan() {
                if (aborter) aborter.abort();
                el.apiState.textContent = "stopped";
                setStatus([`<span class="warn">중단됨</span> — 현재까지 결과 ${currentRows.length}개`]);
                el.btnScan.disabled = false;
                el.btnStop.disabled = true;
            }

            el.btnScan.addEventListener("click", runScan);
            el.btnStop.addEventListener("click", stopScan);

            render([]);
            setStatus([
                `설정 후 Scan을 누르세요.`,
                `<span class="muted">극단 승률 모드라 결과 0개가 흔합니다. 그게 정상이에요.</span>`,
            ]);
        </script>
    </body>
</html>