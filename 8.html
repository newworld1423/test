<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <title>4H 추세 + 15m 눌림 전략 백테스트 (Binance Perp)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body style="background:#111;color:#eee;font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Apple SD Gothic Neo', sans-serif;">
    <h1 style="font-size:18px;">4H 추세 + 15m 눌림 전략 백테스트</h1>
    <p>브라우저 콘솔(F12)을 열어 결과를 확인하세요.</p>
    <label>
        심볼:
        <input id="symbolInput" type="text" value="BTCUSDT" style="padding:4px 6px;">
    </label>
    <button id="runBtn" style="margin-left:8px;padding:4px 10px;">백테스트 실행</button>

    <pre id="output" style="margin-top:16px;font-size:12px;white-space:pre-wrap;"></pre>

    <script>
        // 숫자 변환 유틸
        function toNum(v) {
            return Number(v);
        }

        // 단순 EMA 계산 (초기 구간은 null로 채움)
        function calcEMA(values, period) {
            const ema = new Array(values.length).fill(null);
            const k = 2 / (period + 1);
            let sum = 0;

            for (let i = 0; i < values.length; i++) {
                const price = values[i];
                if (i < period) {
                    sum += price;
                    if (i === period - 1) {
                        const sma = sum / period;
                        ema[i] = sma;
                    }
                } else {
                    ema[i] = price * k + ema[i - 1] * (1 - k);
                }
            }
            return ema;
        }

        // 바이낸스 선물 K라인 가져오기
        async function fetchKlines(symbol, interval, limit) {
            const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
            const res = await fetch(url);
            if (!res.ok) {
                throw new Error(`Klines fetch error: ${res.status} ${res.statusText}`);
            }
            const raw = await res.json();
            // [ openTime, open, high, low, close, volume, closeTime, ... ]
            return raw.map(k => ({
                openTime: k[0],
                open: toNum(k[1]),
                high: toNum(k[2]),
                low: toNum(k[3]),
                close: toNum(k[4]),
                volume: toNum(k[5]),
                closeTime: k[6]
            }));
        }

        // 4H 추세 + 15m 눌림 전략 백테스트
        async function backtestTrendPullback(symbol, logEl) {
            logEl.textContent = `[${symbol}] 데이터 로딩 중...\n(조금 걸릴 수 있습니다)\n`;
            try {
                // 4H / 15m 데이터 넉넉하게
                const [klines4h, klines15m] = await Promise.all([
                    fetchKlines(symbol, '4h', 500),
                    fetchKlines(symbol, '15m', 1500)
                ]);

                const close4h = klines4h.map(k => k.close);
                const close15 = klines15m.map(k => k.close);

                const ema50_4h = calcEMA(close4h, 50);
                const ema200_4h = calcEMA(close4h, 200);
                const ema20_15 = calcEMA(close15, 20);

                let idx4 = 0;
                let wins = 0;
                let losses = 0;
                let unresolved = 0;
                let total = 0;

                const trades = [];

                // 15m 기준으로 루프
                for (let i = 1; i < klines15m.length - 1; i++) {
                    const c15_prev = klines15m[i - 1];
                    const c15_curr = klines15m[i];

                    // 4H 인덱스 맞추기 (현재 15m 캔들 오픈 이전에 시작한 마지막 4H 캔들)
                    const t15 = c15_curr.openTime;
                    while (idx4 + 1 < klines4h.length && klines4h[idx4 + 1].openTime < t15) {
                        idx4++;
                    }
                    if (idx4 < 200) {
                        continue; // 아직 200EMA 계산 안 된 구간은 스킵
                    }

                    // --- 4H 추세 필터 (상승 추세) ---
                    const c4 = klines4h[idx4];
                    const ema50 = ema50_4h[idx4];
                    const ema200 = ema200_4h[idx4];
                    if (ema50 === null || ema200 === null) {
                        continue;
                    }
                    // 조건: 종가가 200EMA 위, 50EMA > 200EMA
                    if (!(c4.close > ema200 && ema50 > ema200)) {
                        continue;
                    }

                    // --- 15m 눌림 후 재돌파 패턴 ---
                    const emaPrev = ema20_15[i - 1];
                    const emaCurr = ema20_15[i];
                    if (emaPrev === null || emaCurr === null) {
                        continue;
                    }

                    const prevClose = c15_prev.close;
                    const currOpen = c15_curr.open;
                    const currClose = c15_curr.close;

                    // 조건:
                    // 1) 이전 봉 종가 < 20EMA
                    // 2) 현재 봉 종가 > 20EMA
                    // 3) 현재 봉은 양봉 (종가 > 시가)
                    if (!(prevClose < emaPrev && currClose > emaCurr && currClose > currOpen)) {
                        continue;
                    }

                    // --- 진입 / TP / SL ---
                    const entryPrice = currClose;
                    const tp = entryPrice * (1 + 0.01);   // +1%
                    const sl = entryPrice * (1 - 0.006);  // -0.6%

                    let result = null;
                    let exitPrice = null;
                    let exitIndex = null;

                    // 진입 이후 캔들에서 TP/SL 먼저 맞는 쪽 판정
                    for (let j = i + 1; j < klines15m.length; j++) {
                        const bar = klines15m[j];
                        const high = bar.high;
                        const low = bar.low;

                        // 같은 캔들에서 둘 다 닿으면 보수적으로 SL 우선 (가장 보수적인 가정)
                        if (low <= sl && high >= tp) {
                            result = 'LOSS_BOTH_HIT';
                            exitPrice = sl;
                            exitIndex = j;
                            break;
                        }
                        if (low <= sl) {
                            result = 'LOSS';
                            exitPrice = sl;
                            exitIndex = j;
                            break;
                        }
                        if (high >= tp) {
                            result = 'WIN';
                            exitPrice = tp;
                            exitIndex = j;
                            break;
                        }
                    }

                    if (!result) {
                        unresolved++;
                        continue;
                    }

                    total++;
                    if (result.startsWith('WIN')) {
                        wins++;
                    } else {
                        losses++;
                    }

                    trades.push({
                        index15: i,
                        time: new Date(c15_curr.openTime).toISOString(),
                        entry: entryPrice,
                        tp,
                        sl,
                        result,
                        exitPrice,
                        exitTime: exitIndex ? new Date(klines15m[exitIndex].openTime).toISOString() : null
                    });
                }

                const winRate = total > 0 ? (wins / total * 100) : 0;

                let txt = '';
                txt += `심볼: ${symbol}\n`;
                txt += `4H 추세 + 15m 눌림 전략 (상승 추세만, 롱만)\n`;
                txt += `조건 요약:\n`;
                txt += `  - 4H: 50EMA > 200EMA, 종가 > 200EMA\n`;
                txt += `  - 15m: 이전 봉 종가 < 20EMA, 현재 봉 종가 > 20EMA, 현재 봉 양봉\n`;
                txt += `  - 진입: 현재 15m 봉 종가\n`;
                txt += `  - TP: +1%  /  SL: -0.6%\n\n`;
                txt += `총 트레이드 수(결과 확정된 것만): ${total}\n`;
                txt += `승: ${wins}  패: ${losses}\n`;
                txt += `승률: ${winRate.toFixed(2)}%\n`;
                txt += `TP/SL 둘 다 닿았지만 SL 우선 처리된 케이스 포함 (보수적 가정)\n`;
                txt += `해당 데이터 안에서 TP/SL에 도달하지 못한 미해결 시그널 수: ${unresolved}\n\n`;
                txt += `최근 일부 트레이드 예시 (최대 10개):\n`;

                const recent = trades.slice(-10);
                for (const t of recent) {
                    txt += `- time=${t.time}, entry=${t.entry.toFixed(4)}, tp=${t.tp.toFixed(4)}, sl=${t.sl.toFixed(4)}, result=${t.result}\n`;
                }

                logEl.textContent = txt;
                console.log('[백테스트 결과]', { symbol, wins, losses, total, winRate, unresolved, trades });
            } catch (err) {
                logEl.textContent += `\n에러 발생: ${err.message}`;
                console.error(err);
            }
        }

        document.getElementById('runBtn').addEventListener('click', () => {
            const symbol = document.getElementById('symbolInput').value.trim().toUpperCase() || 'BTCUSDT';
            const out = document.getElementById('output');
            backtestTrendPullback(symbol, out);
        });
    </script>
</body>
</html>
