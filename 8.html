<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <title>Binance Perp USDT — 4H 추세 + 15m 눌림 롱/숏 시그널 스캐너 (Safe)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --bg: #0b0c10;
            --card: #121318;
            --muted: #9aa0a6;
            --text: #e8eaed;
            --accent: #3ea6ff;
            --good: #00c853;
            --bad: #ff5252;
            --warn: #ffd54f;
            --border: #2a2e36;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at top, #151821 0, #050609 55%, #020308 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                         Roboto, "Helvetica Neue", Arial, "Apple SD Gothic Neo",
                         "Noto Sans KR", sans-serif;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px;
        }

        .header {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }

        .title {
            font-size: 20px;
            font-weight: 600;
        }

        .desc {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.6;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-top: 4px;
        }

        .btn {
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #1b1c22;
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn.primary {
            background: linear-gradient(135deg, #3ea6ff, #00c9ff);
            border-color: transparent;
            color: #020308;
            font-weight: 600;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: default;
        }

        .tag {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            color: var(--muted);
        }

        .tag.long {
            border-color: var(--good);
            color: var(--good);
        }

        .tag.short {
            border-color: var(--bad);
            color: var(--bad);
        }

        .status-bar {
            margin-top: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            background: #111217;
            border: 1px solid var(--border);
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .progress-wrap {
            width: 100%;
            height: 6px;
            background: #20232a;
            border-radius: 999px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3ea6ff, #00c853);
            transition: width .2s ease-out;
        }

        .status-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .status-text {
            font-size: 11px;
            color: var(--muted);
        }

        .card {
            margin-top: 16px;
            padding: 10px;
            border-radius: 14px;
            background: #111217;
            border: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        thead {
            position: sticky;
            top: 0;
            background: #111217;
            z-index: 2;
        }

        th, td {
            padding: 6px 8px;
            border-bottom: 1px solid #1e212a;
            text-align: right;
            white-space: nowrap;
        }

        th:first-child,
        td:first-child {
            text-align: left;
        }

        th {
            font-weight: 500;
            color: var(--muted);
            cursor: pointer;
            user-select: none;
        }

        th.sortable:hover {
            color: var(--accent);
        }

        tr:nth-child(even) td {
            background: #101118;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                         "Liberation Mono", "Courier New", monospace;
        }

        .dir-long {
            color: var(--good);
        }

        .dir-short {
            color: var(--bad);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            font-size: 10px;
            color: var(--muted);
        }

        .pill.none {
            border-style: dashed;
        }

        .pill.error {
            border-color: var(--bad);
            color: var(--bad);
        }

        .footer-note {
            margin-top: 8px;
            font-size: 11px;
            color: var(--muted);
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 17px;
            }

            table {
                font-size: 10px;
            }

            th, td {
                padding: 4px 6px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="title">Binance Perp USDT — 4H 추세 + 15m 눌림 롱/숏 시그널 스캐너 (Safe)</div>
            <div class="desc">
                · 모든 <span class="mono">PERPETUAL / USDT</span> 페어에 대해<br>
                · <strong>4시간봉 추세 필터(50EMA vs 200EMA)</strong> + <strong>15분봉 20EMA 눌림</strong> 조건을 검사해서<br>
                · 조건에 맞는 심볼에 대해 <strong>롱/숏 포지션 시그널 (진입/손절/익절)</strong>을 한 번에 보여줍니다.<br>
                · 스캔 버튼 클릭 시 즉시 1회 스캔 후, 매시 <strong>00 / 15 / 30 / 45분</strong>마다 자동으로 다시 스캔합니다.<br>
                · 바이낸스 레이트리밋을 고려해서, 한 번 스캔할 때 <strong>일부 심볼(chunk)</strong>만 돌리고 다음 스캔에서 이어서 검사합니다.
            </div>

            <div class="controls">
                <button id="scanBtn" class="btn primary">USDT 페어 스캔 시작</button>
                <span class="tag long">롱: 4H 상승 추세 + 15m 20EMA 재돌파 양봉</span>
                <span class="tag short">숏: 4H 하락 추세 + 15m 20EMA 재이탈 음봉</span>
            </div>

            <div class="status-bar">
                <div class="progress-wrap">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
                <div class="status-line">
                    <div id="statusText" class="status-text">대기 중입니다. 버튼을 눌러 시작하세요.</div>
                    <div id="summaryText" class="status-text"></div>
                </div>
            </div>
        </header>

        <section class="card">
            <table>
                <thead>
                    <tr>
                        <th class="sortable" data-sort="symbol">심볼</th>
                        <th class="sortable" data-sort="direction">방향</th>
                        <th>시그널 시간 (15m 기준)</th>
                        <th class="sortable" data-sort="trend">4H 추세</th>
                        <th>진입가</th>
                        <th>손절(SL)</th>
                        <th>익절(TP)</th>
                        <th class="sortable" data-sort="risk">손절폭(%)</th>
                        <th class="sortable" data-sort="reward">익절폭(%)</th>
                        <th>상태</th>
                    </tr>
                </thead>
                <tbody id="resultBody">
                </tbody>
            </table>

            <div class="footer-note">
                · 이 스캐너는 참고용 시그널만 제공하며, <strong>실제 매매 판단·리스크 관리는 본인 책임</strong>입니다.<br>
                · 시그널은 항상 <strong>마지막에서 두 번째 15분봉(완전히 마감된 봉)</strong> 기준으로만 생성됩니다.<br>
                · 수수료, 슬리피지, 펀딩, 서버/네트워크 지연 등은 반영되지 않았습니다.<br>
                · 레이트리밋을 위해 한 번 스캔당 최대 <span class="mono">CHUNK_SIZE</span>개 심볼만 검사합니다.
            </div>
        </section>
    </div>

    <script>
        // ===== 설정 (레이트리밋 관련) =====
        const CONFIG = {
            // 한 번 스캔할 때 최대 몇 개 심볼만 돌릴지
            // 이 정도면: 60심볼 × (4h+15m) = 120 요청 / 15분
            // 같은 구조 스캐너 2개 돌려도 240 요청 / 15분 → 매우 여유
            CHUNK_SIZE: 60,
            // 동시에 몇 개 심볼까지 병렬로 요청할지 (너무 올리면 순간 폭발)
            MAX_CONCURRENT: 2
        };

        // ===== 유틸 함수 =====
        function toNum(v) {
            return Number(v);
        }

        function calcEMA(values, period) {
            const ema = new Array(values.length).fill(null);
            const k = 2 / (period + 1);
            let sum = 0;

            for (let i = 0; i < values.length; i++) {
                const price = values[i];
                if (i < period) {
                    sum += price;
                    if (i === period - 1) {
                        const sma = sum / period;
                        ema[i] = sma;
                    }
                } else {
                    ema[i] = price * k + ema[i - 1] * (1 - k);
                }
            }
            return ema;
        }

        async function fetchKlines(symbol, interval, limit) {
            const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
            const res = await fetch(url);
            if (!res.ok) {
                throw new Error(`klines error ${symbol} ${interval}: ${res.status}`);
            }
            const raw = await res.json();
            return raw.map(k => ({
                openTime: k[0],
                open: toNum(k[1]),
                high: toNum(k[2]),
                low: toNum(k[3]),
                close: toNum(k[4]),
                volume: toNum(k[5]),
                closeTime: k[6]
            }));
        }

        async function fetchPerpUsdtSymbols() {
            const url = "https://fapi.binance.com/fapi/v1/exchangeInfo";
            const res = await fetch(url);
            if (!res.ok) {
                throw new Error(`exchangeInfo error: ${res.status}`);
            }
            const data = await res.json();
            const list = data.symbols
                .filter(s =>
                    s.contractType === "PERPETUAL" &&
                    s.quoteAsset === "USDT" &&
                    s.status === "TRADING"
                )
                .map(s => s.symbol)
                .sort();
            return list;
        }

        function formatLocalTime(ms) {
            try {
                const d = new Date(ms);
                return d.toLocaleString("ko-KR", {
                    year: "2-digit",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit"
                });
            } catch {
                return "-";
            }
        }

        // ===== 전략: 4H 추세 + 15m 눌림 롱/숏 시그널 =====
        function findTrendPullbackSignal(klines4h, klines15m) {
            if (klines4h.length < 200 || klines15m.length < 30) {
                return null;
            }

            const close4h = klines4h.map(k => k.close);
            const close15 = klines15m.map(k => k.close);

            const ema50_4h = calcEMA(close4h, 50);
            const ema200_4h = calcEMA(close4h, 200);
            const ema20_15 = calcEMA(close15, 20);

            // 현재 시그널은 "마지막에서 두 번째 15m 봉" 기준 (완전히 마감된 봉)
            const currIndex = klines15m.length - 2;
            const prevIndex = currIndex - 1;
            if (prevIndex < 0) return null;

            const curr15 = klines15m[currIndex];
            const prev15 = klines15m[prevIndex];

            const emaPrev = ema20_15[prevIndex];
            const emaCurr = ema20_15[currIndex];
            if (emaPrev === null || emaCurr === null) return null;

            // 4H 인덱스 매칭: curr15.openTime 이전에 시작한 마지막 4H 봉
            let idx4 = 0;
            const t15 = curr15.openTime;
            while (idx4 + 1 < klines4h.length && klines4h[idx4 + 1].openTime < t15) {
                idx4++;
            }
            if (idx4 < 200) return null;

            const c4 = klines4h[idx4];
            const ema50 = ema50_4h[idx4];
            const ema200 = ema200_4h[idx4];
            if (ema50 === null || ema200 === null) return null;

            const prevClose = prev15.close;
            const currOpen = curr15.open;
            const currClose = curr15.close;

            // 4H 추세 방향 체크
            const upTrend = (c4.close > ema200 && ema50 > ema200);
            const downTrend = (c4.close < ema200 && ema50 < ema200);

            // ----- 롱 조건 -----
            if (upTrend &&
                prevClose < emaPrev &&
                currClose > emaCurr &&
                currClose > currOpen) {

                const direction = "LONG";
                const entry = currClose;
                const tp = entry * 1.01;    // +1%
                const sl = entry * 0.994;   // -0.6%

                const riskPct = (sl / entry - 1) * 100;
                const rewardPct = (tp / entry - 1) * 100;

                return {
                    direction,
                    trend: "UP",
                    entry,
                    tp,
                    sl,
                    riskPct,
                    rewardPct,
                    signalTime: curr15.openTime
                };
            }

            // ----- 숏 조건 -----
            if (downTrend &&
                prevClose > emaPrev &&
                currClose < emaCurr &&
                currClose < currOpen) {

                const direction = "SHORT";
                const entry = currClose;
                const tp = entry * 0.99;    // -1%
                const sl = entry * 1.006;   // +0.6%

                const riskPct = (sl / entry - 1) * 100;
                const rewardPct = (tp / entry - 1) * 100;

                return {
                    direction,
                    trend: "DOWN",
                    entry,
                    tp,
                    sl,
                    riskPct,
                    rewardPct,
                    signalTime: curr15.openTime
                };
            }

            return null;
        }

        // ===== 상태 & 렌더링 =====
        const state = {
            running: false,
            symbols: [],        // 전체 USDT PERP 심볼 리스트
            symbolOffset: 0,    // 다음 스캔에서 시작할 인덱스
            totalSymbols: 0,    // 이번 스캔 대상 심볼 수 (chunk 기준)
            doneSymbols: 0,
            signals: [],
            sortKey: "symbol",
            sortDir: "asc"
        };

        let autoScanTimer = null;
        let autoScanInterval = null;

        const scanBtn = document.getElementById("scanBtn");
        const progressBar = document.getElementById("progressBar");
        const statusText = document.getElementById("statusText");
        const summaryText = document.getElementById("summaryText");
        const resultBody = document.getElementById("resultBody");

        function renderProgress() {
            const totalAll = state.symbols.length;
            if (!state.running && state.totalSymbols === 0 && totalAll === 0) {
                progressBar.style.width = "0%";
                statusText.textContent = "대기 중입니다. 버튼을 눌러 시작하세요.";
                summaryText.textContent = "";
                return;
            }

            if (state.totalSymbols === 0) {
                progressBar.style.width = "0%";
                if (totalAll > 0) {
                    statusText.textContent = `심볼 목록 로딩 완료. 전체 심볼 수: ${totalAll}개`;
                } else {
                    statusText.textContent = "심볼 목록 로딩 중...";
                }
                summaryText.textContent = "";
                return;
            }

            const pct = Math.min(100, Math.round(state.doneSymbols / state.totalSymbols * 100));
            progressBar.style.width = pct + "%";

            const baseInfo = `이번 스캔 대상: ${state.doneSymbols} / ${state.totalSymbols}개 심볼 (전체: ${totalAll}개 중 일부)`;
            statusText.textContent = baseInfo;

            if (state.signals.length > 0) {
                const longCnt = state.signals.filter(s => s.direction === "LONG").length;
                const shortCnt = state.signals.filter(s => s.direction === "SHORT").length;
                summaryText.textContent = `시그널 수: 롱 ${longCnt}개 / 숏 ${shortCnt}개 (총 ${state.signals.length}개)`;
            } else {
                summaryText.textContent = "이번 스캔에서는 조건에 맞는 시그널이 아직 없습니다.";
            }
        }

        function renderTable() {
            const rows = [...state.signals];

            rows.sort((a, b) => {
                const key = state.sortKey;
                const dir = state.sortDir;
                let va = a[key];
                let vb = b[key];

                if (key === "direction" || key === "trend" || key === "symbol") {
                    va = String(va);
                    vb = String(vb);
                }

                if (va < vb) return dir === "asc" ? -1 : 1;
                if (va > vb) return dir === "asc" ? 1 : -1;
                return 0;
            });

            resultBody.innerHTML = "";

            if (rows.length === 0) {
                const tr = document.createElement("tr");
                const td = document.createElement("td");
                td.colSpan = 10;
                td.style.textAlign = "center";
                td.textContent = "조건에 맞는 시그널이 없습니다.";
                tr.appendChild(td);
                resultBody.appendChild(tr);
                return;
            }

            for (const s of rows) {
                const tr = document.createElement("tr");

                const tdSymbol = document.createElement("td");
                tdSymbol.textContent = s.symbol;
                tr.appendChild(tdSymbol);

                const tdDir = document.createElement("td");
                const spanDir = document.createElement("span");
                spanDir.textContent = s.direction;
                spanDir.className = s.direction === "LONG" ? "dir-long" : "dir-short";
                tdDir.appendChild(spanDir);
                tr.appendChild(tdDir);

                const tdTime = document.createElement("td");
                tdTime.textContent = formatLocalTime(s.signalTime);
                tr.appendChild(tdTime);

                const tdTrend = document.createElement("td");
                tdTrend.textContent = s.trend === "UP" ? "상승(UP)" : "하락(DOWN)";
                tr.appendChild(tdTrend);

                const tdEntry = document.createElement("td");
                tdEntry.textContent = s.entry.toFixed(4);
                tr.appendChild(tdEntry);

                const tdSL = document.createElement("td");
                tdSL.textContent = s.sl.toFixed(4);
                tr.appendChild(tdSL);

                const tdTP = document.createElement("td");
                tdTP.textContent = s.tp.toFixed(4);
                tr.appendChild(tdTP);

                const tdRisk = document.createElement("td");
                tdRisk.textContent = s.riskPct.toFixed(2);
                tr.appendChild(tdRisk);

                const tdReward = document.createElement("td");
                tdReward.textContent = s.rewardPct.toFixed(2);
                tr.appendChild(tdReward);

                const tdStatus = document.createElement("td");
                const pill = document.createElement("span");
                pill.className = "pill";
                pill.textContent = "시그널";
                tdStatus.appendChild(pill);
                tr.appendChild(tdStatus);

                resultBody.appendChild(tr);
            }
        }

        // ===== 심볼별 처리 =====
        async function processSymbol(symbol) {
            try {
                // 레이트리밋을 위해 캔들 수는 최소한만 (limit 값은 weight에 영향 거의 없음 / 어차피 1요청)
                const [kl4h, kl15m] = await Promise.all([
                    fetchKlines(symbol, "4h", 220),
                    fetchKlines(symbol, "15m", 220)
                ]);

                const sig = findTrendPullbackSignal(kl4h, kl15m);
                if (sig) {
                    state.signals.push({
                        symbol,
                        ...sig,
                        risk: sig.riskPct,
                        reward: sig.rewardPct
                    });
                }
            } catch (err) {
                console.error("processSymbol error:", symbol, err);
            } finally {
                state.doneSymbols++;
                renderProgress();
                renderTable();
            }
        }

        async function runScan() {
            if (state.running) {
                console.log("[INFO] scan skipped: already running");
                return;
            }

            state.running = true;
            state.doneSymbols = 0;
            state.totalSymbols = 0;
            state.signals = [];
            renderProgress();
            renderTable();
            scanBtn.disabled = true;

            try {
                // 심볼 리스트가 없으면 한 번만 가져와서 캐싱
                if (!state.symbols || state.symbols.length === 0) {
                    statusText.textContent = "심볼 목록 로딩 중...";
                    const symbols = await fetchPerpUsdtSymbols();
                    state.symbols = symbols;
                    state.symbolOffset = 0;
                }

                const all = state.symbols;
                const totalAll = all.length;
                if (totalAll === 0) {
                    throw new Error("USDT PERP 심볼을 찾지 못했습니다.");
                }

                // 이번 스캔에서 사용할 chunk 결정 (라운드 로빈)
                const chunkSize = CONFIG.CHUNK_SIZE;
                const start = state.symbolOffset;
                let end = start + chunkSize;
                let subset = [];

                if (end <= totalAll) {
                    subset = all.slice(start, end);
                } else {
                    // 끝까지 갔다가 앞에서 이어붙이기
                    const first = all.slice(start, totalAll);
                    const rest = all.slice(0, end - totalAll);
                    subset = first.concat(rest);
                }

                // 다음 스캔에서 이어갈 오프셋
                state.symbolOffset = (start + subset.length) % totalAll;
                state.totalSymbols = subset.length;
                state.doneSymbols = 0;

                statusText.textContent = `이번 스캔: 전체 ${totalAll}개 중 ${subset.length}개 심볼 검사 (offset=${start})`;
                renderProgress();

                const queue = [...subset];
                const workers = [];

                async function worker() {
                    while (queue.length > 0) {
                        const sym = queue.shift();
                        if (!sym) break;
                        await processSymbol(sym);
                    }
                }

                const maxWorkers = Math.max(1, CONFIG.MAX_CONCURRENT);
                for (let i = 0; i < maxWorkers; i++) {
                    workers.push(worker());
                }

                await Promise.all(workers);

                statusText.textContent = `스캔 완료: 이번 스캔 ${state.doneSymbols}개 / 전체 ${state.totalSymbols}개 검사 (다음 offset=${state.symbolOffset})`;
            } catch (err) {
                console.error(err);
                statusText.textContent = `에러: ${err.message || String(err)}`;
            } finally {
                state.running = false;
                scanBtn.disabled = false;
            }
        }

        // ===== 자동 스케줄링 (매시 00/15/30/45) =====
        function getMsToNextQuarter() {
            const now = new Date();
            const m = now.getMinutes();
            const currentQuarter = Math.floor(m / 15) * 15;
            let nextQuarter = currentQuarter + 15;
            if (nextQuarter >= 60) {
                nextQuarter -= 60;
                now.setHours(now.getHours() + 1);
            }

            const next = new Date(now);
            next.setMinutes(nextQuarter);
            next.setSeconds(0);
            next.setMilliseconds(0);

            const diff = next.getTime() - (new Date().getTime());
            return diff > 0 ? diff : 0;
        }

        function scheduleAutoScan() {
            if (autoScanTimer) {
                clearTimeout(autoScanTimer);
                autoScanTimer = null;
            }
            if (autoScanInterval) {
                clearInterval(autoScanInterval);
                autoScanInterval = null;
            }

            const delay = getMsToNextQuarter();
            const now = new Date();
            const nextTime = new Date(now.getTime() + delay);

            summaryText.textContent =
                `자동 스캔 예약됨: 다음 스캔 ${nextTime.toLocaleTimeString("ko-KR", { hour: "2-digit", minute: "2-digit" })} 이후 15분마다 (chunk=${CONFIG.CHUNK_SIZE})`;

            autoScanTimer = setTimeout(() => {
                runScan();
                autoScanInterval = setInterval(() => {
                    runScan();
                }, 15 * 60 * 1000);
            }, delay);
        }

        // ===== 이벤트 =====
        scanBtn.addEventListener("click", () => {
            // 1) 즉시 1회 스캔
            runScan();
            // 2) 이후 정각/15/30/45 자동 스캔
            scheduleAutoScan();
        });

        document.querySelectorAll("th.sortable").forEach(th => {
            th.addEventListener("click", () => {
                const key = th.dataset.sort;
                if (!key) return;
                if (state.sortKey === key) {
                    state.sortDir = state.sortDir === "asc" ? "desc" : "asc";
                } else {
                    state.sortKey = key;
                    state.sortDir = key === "symbol" ? "asc" : "desc";
                }
                renderTable();
            });
        });

        // 초기 렌더
        renderProgress();
        renderTable();
    </script>
</body>
</html>
