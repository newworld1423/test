<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT Perp 15m Wick + MA Scanner (Near 96 High/Low Sort, Auto 00/15/30/45)</title>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Pretendard, Apple SD Gothic Neo, sans-serif;
            margin: 16px;
            background: #0b0f19;
            color: #e7eaf0;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }
        .card {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 12px;
            padding: 12px;
            margin: 12px 0;
        }
        input, button {
            background: rgba(255,255,255,0.08);
            color: #e7eaf0;
            border: 1px solid rgba(255,255,255,0.14);
            border-radius: 10px;
            padding: 10px 12px;
            outline: none;
        }
        button { cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .muted { color: rgba(231,234,240,0.70); font-size: 13px; }
        .ok { color: #8ef0a6; }
        .warn { color: #ffce6a; }
        .bad { color: #ff7a7a; }

        table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            border-radius: 12px;
        }
        th, td {
            text-align: left;
            padding: 10px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            font-size: 13px;
            vertical-align: middle;
        }
        th {
            position: sticky;
            top: 0;
            background: #0f1629;
            z-index: 1;
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        @media (min-width: 1100px) {
            .grid2 { grid-template-columns: 1fr 1fr; }
        }

        a { color: #9bd1ff; text-decoration: none; }
        a:hover { text-decoration: underline; }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.06);
            font-size: 12px;
        }
        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .progress {
            width: 260px;
            height: 10px;
            background: rgba(255,255,255,0.08);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.10);
        }
        .bar {
            height: 100%;
            width: 0%;
            background: rgba(155, 209, 255, 0.85);
        }

        .top-pick {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .top-pick .title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        .top-pick .big {
            font-size: 16px;
            font-weight: 700;
        }
        .top-pick .meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 12px;
        }
        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.06);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h2 style="margin: 0 0 8px;">Binance USDT-M Perp 15m “이전봉” 꼬리/몸통 + MA 스캐너 (최근 96봉 극값 ‘가까움’ 정렬)</h2>

    <div class="muted">
        - 코인별 15m <span class="mono">200개</span> 조회 / 기준봉: <span class="mono">이전봉(마감된 마지막 봉)</span><br/>
        - 결과 1 조건: 밑꼬리&gt;몸통 AND 7MA&lt;25MA&lt;99MA AND C&lt;MA7<br/>
        - 결과 2 조건: 윗꼬리&gt;몸통 AND 7MA&gt;25MA&gt;99MA AND C&gt;MA7<br/>
        - 정렬(핵심): “이전봉 제외 최근 96봉” 기준 극값에 <b>가까운 순</b><br/>
        &nbsp;&nbsp;• 결과 1: <span class="mono">|maxHigh96 - prev.h| / maxHigh96</span> (작을수록 상단)<br/>
        &nbsp;&nbsp;• 결과 2: <span class="mono">|prev.l - minLow96| / minLow96</span> (작을수록 상단)<br/>
        - TOP PICK: 결과1 1등 vs 결과2 1등 중 <b>거리% 더 작은 것(더 가까운 것)</b> 1개 표시<br/>
        - 자동 스캔: 매시 <span class="mono">00/15/30/45</span>분 (스캔 중이면 스킵)
    </div>

    <div class="card">
        <div class="row">
            <button id="btnScan">스캔 시작</button>
            <button id="btnStop" disabled>중지</button>

            <span class="pill">Interval: <span class="mono">15m</span></span>
            <span class="pill">Klines: <span class="mono">200</span></span>
            <span class="pill">Compare Window: <span class="mono">96 (exclude prev)</span></span>
            <span class="pill">MA: <span class="mono">7 / 25 / 99</span></span>

            <label class="row" style="margin: 0;">
                <span class="muted">동시요청</span>
                <input id="inpConc" type="number" min="1" max="20" step="1" value="6" style="width: 90px;" />
            </label>

            <label class="row" style="margin: 0;">
                <span class="muted">요청 딜레이(ms)</span>
                <input id="inpDelay" type="number" min="0" max="2000" step="10" value="120" style="width: 110px;" />
            </label>

            <label class="row" style="margin: 0;">
                <input id="chkTopN" type="checkbox" />
                <span class="muted">거래대금 상위 N개만</span>
                <input id="inpTopN" type="number" min="10" max="800" step="10" value="250" style="width: 110px;" />
            </label>
        </div>

        <div class="row" style="justify-content: space-between;">
            <div class="row" style="margin: 0;">
                <div class="progress"><div id="progBar" class="bar"></div></div>
                <span id="txtProg" class="muted">대기중</span>
            </div>
            <div class="row" style="margin: 0;">
                <span class="muted">업데이트:</span>
                <span id="txtTime" class="mono">-</span>
                <span class="pill">다음 자동: <span id="txtNextAuto" class="mono">-</span></span>
            </div>
        </div>

        <div id="txtStatus" class="muted" style="margin-top: 8px;"></div>
    </div>

    <div id="topPickCard" class="card" style="display:none;">
        <div class="top-pick">
            <div class="title">
                <div class="big">TOP PICK — 결과1 1등 vs 결과2 1등 (가까움 비교)</div>
                <div class="muted" id="topPickWhen"></div>
            </div>
            <div id="topPickBody"></div>
        </div>
    </div>

    <div class="grid2">
        <div class="card">
            <h3 style="margin: 0 0 8px;">결과 1 — “최근 96봉 최고점”에 가까운 순</h3>
            <div class="muted" style="margin-bottom: 8px;">
                정렬: <span class="mono">NearHigh%</span> 오름차순 (작을수록 위)
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Symbol</th>
                        <th class="mono">NearHigh%</th>
                        <th class="mono">maxHigh96</th>
                        <th class="mono">Prev H</th>
                        <th class="mono">Range%</th>
                        <th class="mono">Lower/Body</th>
                        <th class="mono">MA7/25/99</th>
                        <th class="mono">Prev O/H/L/C</th>
                    </tr>
                </thead>
                <tbody id="tb1"></tbody>
            </table>
        </div>

        <div class="card">
            <h3 style="margin: 0 0 8px;">결과 2 — “최근 96봉 최저점”에 가까운 순</h3>
            <div class="muted" style="margin-bottom: 8px;">
                정렬: <span class="mono">NearLow%</span> 오름차순 (작을수록 위)
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Symbol</th>
                        <th class="mono">NearLow%</th>
                        <th class="mono">minLow96</th>
                        <th class="mono">Prev L</th>
                        <th class="mono">Range%</th>
                        <th class="mono">Upper/Body</th>
                        <th class="mono">MA7/25/99</th>
                        <th class="mono">Prev O/H/L/C</th>
                    </tr>
                </thead>
                <tbody id="tb2"></tbody>
            </table>
        </div>
    </div>

    <script>
        const API_BASE = "https://fapi.binance.com";
        const KLINES_LIMIT = 200;

        const EXTREME_WINDOW = 96;          // 이전봉 제외하고 최근 96봉
        const EPS_DENOM = 1e-12;

        const $ = (sel) => document.querySelector(sel);

        const btnScan = $("#btnScan");
        const btnStop = $("#btnStop");
        const inpConc = $("#inpConc");
        const inpDelay = $("#inpDelay");
        const chkTopN = $("#chkTopN");
        const inpTopN = $("#inpTopN");

        const tb1 = $("#tb1");
        const tb2 = $("#tb2");

        const txtStatus = $("#txtStatus");
        const txtProg = $("#txtProg");
        const txtTime = $("#txtTime");
        const progBar = $("#progBar");

        const topPickCard = $("#topPickCard");
        const topPickBody = $("#topPickBody");
        const topPickWhen = $("#topPickWhen");
        const txtNextAuto = $("#txtNextAuto");

        let stopFlag = false;
        let isScanning = false;

        function sleep(ms) {
            return new Promise((r) => setTimeout(r, ms));
        }

        function safeNum(x, fallback) {
            return (typeof x === "number" && isFinite(x)) ? x : fallback;
        }

        function fmt(n, d = 6) {
            if (!isFinite(n)) return "-";
            const abs = Math.abs(n);
            if (abs >= 1000) return n.toFixed(2);
            if (abs >= 1) return n.toFixed(4);
            return n.toFixed(d);
        }

        function fmtFixed(n, digits = 10) {
            if (!isFinite(n)) return "-";
            return Number(n).toFixed(digits);
        }

        function fmtPct(n, digits = 4) {
            if (!isFinite(n)) return "-";
            return `${Number(n).toFixed(digits)}%`;
        }

        function setProgress(done, total) {
            const p = total > 0 ? (done / total) * 100 : 0;
            progBar.style.width = `${Math.max(0, Math.min(100, p))}%`;
            txtProg.textContent = `${done}/${total}`;
        }

        function setTimeNow() {
            const d = new Date();
            txtTime.textContent = d.toLocaleString();
            topPickWhen.textContent = `업데이트: ${d.toLocaleString()}`;
        }

        function setNextAutoLabel(nextDate) {
            txtNextAuto.textContent = nextDate ? nextDate.toLocaleTimeString() : "-";
        }

        async function safeFetch(url, options = {}) {
            const res = await fetch(url, options);

            if (res.status === 429 || res.status === 418) {
                const retryAfter = Number(res.headers.get("retry-after") || "0");
                const waitMs = retryAfter > 0 ? retryAfter * 1000 : 30000;
                throw new Error(`RATE_LIMIT:${res.status}:${waitMs}`);
            }

            if (!res.ok) {
                const t = await res.text().catch(() => "");
                throw new Error(`HTTP_${res.status}:${t.slice(0, 200)}`);
            }

            return res;
        }

        async function getUsdtPerpSymbols() {
            const url = `${API_BASE}/fapi/v1/exchangeInfo`;
            const res = await safeFetch(url);
            const data = await res.json();

            return (data.symbols || [])
                .filter((s) =>
                    s &&
                    s.contractType === "PERPETUAL" &&
                    s.quoteAsset === "USDT" &&
                    s.status === "TRADING"
                )
                .map((s) => s.symbol);
        }

        async function getTopSymbolsByQuoteVolume(limit) {
            const url = `${API_BASE}/fapi/v1/ticker/24hr`;
            const res = await safeFetch(url);
            const data = await res.json();

            return (data || [])
                .filter((r) => r && String(r.symbol || "").endsWith("USDT"))
                .map((r) => ({
                    symbol: r.symbol,
                    quoteVolume: Number(r.quoteVolume || 0)
                }))
                .sort((a, b) => b.quoteVolume - a.quoteVolume)
                .slice(0, Math.max(1, limit | 0))
                .map((r) => r.symbol);
        }

        async function fetchKlines(symbol, interval = "15m", limit = KLINES_LIMIT) {
            const url = `${API_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${interval}&limit=${limit}`;
            const res = await safeFetch(url);
            return await res.json();
        }

        function sma(closes, endIndex, period) {
            const start = endIndex - period + 1;
            if (start < 0) return null;

            let sum = 0;
            for (let i = start; i <= endIndex; i++) {
                sum += closes[i];
            }
            return sum / period;
        }

        function buildRowLink(symbol) {
            const url = `https://www.binance.com/en/futures/${symbol}`;
            return `<a href="${url}" target="_blank" rel="noreferrer">${symbol}</a>`;
        }

        function parseCandle(k) {
            const o = Number(k[1]);
            const h = Number(k[2]);
            const l = Number(k[3]);
            const c = Number(k[4]);

            const body = Math.abs(c - o);
            const lowerWick = Math.min(o, c) - l;
            const upperWick = h - Math.max(o, c);
            const range = h - l;

            const rangePct = (h > 0) ? (range / h) * 100 : NaN;

            return { o, h, l, c, body, lowerWick, upperWick, range, rangePct };
        }

        function isFiniteNumber(x) {
            return typeof x === "number" && isFinite(x);
        }

        function computeExtremesPrev96ExPrev(klines, prevIdx) {
            // 비교 구간: [prevIdx-96 .. prevIdx-1] (총 96개, prev 제외)
            const endIdx = prevIdx - 1;
            const startIdx = Math.max(0, prevIdx - EXTREME_WINDOW);

            if (endIdx < startIdx) return null;

            let maxHigh96 = -Infinity;
            let minLow96 = Infinity;

            for (let i = startIdx; i <= endIdx; i++) {
                const h = Number(klines[i][2]);
                const l = Number(klines[i][3]);

                if (isFinite(h) && h > maxHigh96) maxHigh96 = h;
                if (isFinite(l) && l < minLow96) minLow96 = l;
            }

            if (!isFinite(maxHigh96) || !isFinite(minLow96)) return null;

            return { maxHigh96, minLow96 };
        }

        function computeSignal(symbol, klines) {
            if (!Array.isArray(klines) || klines.length < 120) return null;

            const prevIdx = klines.length - 2; // 이전봉
            const closes = klines.map((k) => Number(k[4]));

            const ma7 = sma(closes, prevIdx, 7);
            const ma25 = sma(closes, prevIdx, 25);
            const ma99 = sma(closes, prevIdx, 99);

            if (![ma7, ma25, ma99].every(isFiniteNumber)) return null;

            const prev = parseCandle(klines[prevIdx]);
            if (!isFinite(prev.rangePct)) return null;

            const ex = computeExtremesPrev96ExPrev(klines, prevIdx);
            if (!ex) return null;

            const maxHigh96 = ex.maxHigh96;
            const minLow96 = ex.minLow96;

            // ✅ “가까움” 거리% 계산 (작을수록 가까움)
            const nearHighPct = (Math.abs(maxHigh96 - prev.h) / Math.max(EPS_DENOM, Math.abs(maxHigh96))) * 100;
            const nearLowPct = (Math.abs(prev.l - minLow96) / Math.max(EPS_DENOM, Math.abs(minLow96))) * 100;

            const bodyEps = prev.body > 0 ? prev.body : 1e-12;
            const lowerRatio = prev.lowerWick / bodyEps;
            const upperRatio = prev.upperWick / bodyEps;

            return {
                symbol,
                prev,
                ma7,
                ma25,
                ma99,
                lowerRatio,
                upperRatio,
                maxHigh96,
                minLow96,
                nearHighPct,
                nearLowPct
            };
        }

        function renderTables(result1, result2) {
            tb1.innerHTML = "";
            tb2.innerHTML = "";

            const r1 = result1.map((x, i) => {
                const { symbol, prev, ma7, ma25, ma99, lowerRatio, maxHigh96, nearHighPct } = x;
                return `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${buildRowLink(symbol)}</td>
                        <td class="mono">${fmtPct(nearHighPct, 4)}</td>
                        <td class="mono">${fmt(maxHigh96)}</td>
                        <td class="mono">${fmt(prev.h)}</td>
                        <td class="mono">${fmtPct(prev.rangePct, 4)}</td>
                        <td class="mono">${fmt(lowerRatio, 3)}</td>
                        <td class="mono">${fmt(ma7)} / ${fmt(ma25)} / ${fmt(ma99)}</td>
                        <td class="mono">${fmt(prev.o)} / ${fmt(prev.h)} / ${fmt(prev.l)} / ${fmt(prev.c)}</td>
                    </tr>
                `;
            }).join("");

            const r2 = result2.map((x, i) => {
                const { symbol, prev, ma7, ma25, ma99, upperRatio, minLow96, nearLowPct } = x;
                return `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${buildRowLink(symbol)}</td>
                        <td class="mono">${fmtPct(nearLowPct, 4)}</td>
                        <td class="mono">${fmt(minLow96)}</td>
                        <td class="mono">${fmt(prev.l)}</td>
                        <td class="mono">${fmtPct(prev.rangePct, 4)}</td>
                        <td class="mono">${fmt(upperRatio, 3)}</td>
                        <td class="mono">${fmt(ma7)} / ${fmt(ma25)} / ${fmt(ma99)}</td>
                        <td class="mono">${fmt(prev.o)} / ${fmt(prev.h)} / ${fmt(prev.l)} / ${fmt(prev.c)}</td>
                    </tr>
                `;
            }).join("");

            tb1.innerHTML = r1 || `<tr><td colspan="9" class="muted">조건을 만족하는 코인이 없습니다.</td></tr>`;
            tb2.innerHTML = r2 || `<tr><td colspan="9" class="muted">조건을 만족하는 코인이 없습니다.</td></tr>`;
        }

        function pickTopPick(result1, result2) {
            const top1 = (result1 && result1.length) ? result1[0] : null;
            const top2 = (result2 && result2.length) ? result2[0] : null;

            if (!top1 && !top2) return null;
            if (top1 && !top2) return { which: 1, item: top1 };
            if (!top1 && top2) return { which: 2, item: top2 };

            // ✅ 거리% 더 작은(더 가까운) 쪽 선택
            const d1 = safeNum(top1.nearHighPct, Infinity);
            const d2 = safeNum(top2.nearLowPct, Infinity);

            if (d1 < d2) return { which: 1, item: top1 };
            if (d2 < d1) return { which: 2, item: top2 };

            // 동률이면 Range% 큰 쪽
            const r1 = safeNum(top1.prev.rangePct, -Infinity);
            const r2 = safeNum(top2.prev.rangePct, -Infinity);
            if (r1 >= r2) return { which: 1, item: top1 };
            return { which: 2, item: top2 };
        }

        function renderTopPickCard(result1, result2) {
            const pick = pickTopPick(result1, result2);

            if (!pick) {
                topPickCard.style.display = "none";
                topPickBody.innerHTML = "";
                return;
            }

            const { which, item } = pick;
            const prev = item.prev;

            const isResult1 = which === 1;
            const sideLabel = isResult1 ? "결과 1 (Near High)" : "결과 2 (Near Low)";
            const nearPct = isResult1 ? item.nearHighPct : item.nearLowPct;

            const refLabel = isResult1 ? "maxHigh96" : "minLow96";
            const refValue = isResult1 ? item.maxHigh96 : item.minLow96;

            const ratio = isResult1 ? item.lowerRatio : item.upperRatio;
            const wick = isResult1 ? prev.lowerWick : prev.upperWick;

            const badge = isResult1
                ? `<span class="tag"><span class="ok">●</span> ${sideLabel}</span>`
                : `<span class="tag"><span class="warn">●</span> ${sideLabel}</span>`;

            const url = `https://www.binance.com/en/futures/${item.symbol}`;

            topPickBody.innerHTML = `
                <div class="top-pick">
                    <div class="meta">
                        ${badge}
                        <span class="tag">Symbol: <a href="${url}" target="_blank" rel="noreferrer" class="mono">${item.symbol}</a></span>
                        <span class="tag">Near%: <span class="mono">${fmtPct(nearPct, 4)}</span></span>
                        <span class="tag">${refLabel}: <span class="mono">${fmt(refValue)}</span></span>
                        <span class="tag">Range%: <span class="mono">${fmtPct(prev.rangePct, 4)}</span></span>
                        <span class="tag">Wick/Body: <span class="mono">${fmt(ratio, 3)}</span></span>
                        <span class="tag">Wick: <span class="mono">${fmtFixed(wick, 10)}</span></span>
                        <span class="tag">Body: <span class="mono">${fmtFixed(prev.body, 10)}</span></span>
                    </div>
                    <div class="muted">
                        Prev O/H/L/C: <span class="mono">${fmt(prev.o)} / ${fmt(prev.h)} / ${fmt(prev.l)} / ${fmt(prev.c)}</span>
                        &nbsp; | &nbsp;
                        MA7/25/99: <span class="mono">${fmt(item.ma7)} / ${fmt(item.ma25)} / ${fmt(item.ma99)}</span>
                    </div>
                </div>
            `;

            topPickCard.style.display = "block";
        }

        async function runQueue(items, workerFn, concurrency, perItemDelayMs, onProgress) {
            let idx = 0;
            let done = 0;
            const total = items.length;

            async function worker() {
                while (true) {
                    if (stopFlag) return;

                    const myIdx = idx++;
                    if (myIdx >= total) return;

                    const item = items[myIdx];

                    try {
                        await workerFn(item, myIdx);
                    } catch (e) {
                        console.warn("worker error:", item, e);
                    } finally {
                        done++;
                        if (onProgress) onProgress(done, total);
                        if (perItemDelayMs > 0) await sleep(perItemDelayMs);
                    }
                }
            }

            const workers = [];
            for (let i = 0; i < concurrency; i++) {
                workers.push(worker());
            }
            await Promise.all(workers);
        }

        async function scan(reason = "manual") {
            if (isScanning) {
                txtStatus.innerHTML = `<span class="warn">이미 스캔 중</span> (트리거: ${reason})`;
                return;
            }

            stopFlag = false;
            isScanning = true;

            btnScan.disabled = true;
            btnStop.disabled = false;

            tb1.innerHTML = "";
            tb2.innerHTML = "";
            topPickCard.style.display = "none";

            txtStatus.textContent = `심볼 목록 가져오는 중... (트리거: ${reason})`;
            setProgress(0, 0);

            const conc = Math.max(1, Math.min(20, Number(inpConc.value || 6)));
            const delayMs = Math.max(0, Math.min(2000, Number(inpDelay.value || 120)));

            try {
                let symbols = await getUsdtPerpSymbols();

                if (chkTopN.checked) {
                    const topN = Math.max(10, Math.min(800, Number(inpTopN.value || 250)));
                    txtStatus.textContent = `거래대금 상위 ${topN}개 선별 중... (트리거: ${reason})`;
                    const topSyms = await getTopSymbolsByQuoteVolume(topN);

                    const symSet = new Set(symbols);
                    symbols = topSyms.filter((s) => symSet.has(s));
                }

                txtStatus.textContent = `스캔 대상: ${symbols.length}개 / 동시요청 ${conc} / 딜레이 ${delayMs}ms (트리거: ${reason})`;

                const result1 = [];
                const result2 = [];

                let rateLimitBackoffUntil = 0;

                async function workerFn(symbol) {
                    if (stopFlag) return;

                    const now = Date.now();
                    if (now < rateLimitBackoffUntil) {
                        await sleep(rateLimitBackoffUntil - now);
                    }

                    try {
                        const klines = await fetchKlines(symbol, "15m", KLINES_LIMIT);
                        const sig = computeSignal(symbol, klines);
                        if (!sig) return;

                        const { prev, ma7, ma25, ma99 } = sig;

                        // ✅ 결과 1 필터 (고점 비교 조건 제거)
                        if (
                            prev.lowerWick > prev.body &&
                            ma7 < ma25 && ma25 < ma99 &&
                            prev.c < ma7
                        ) {
                            result1.push(sig);
                        }

                        // ✅ 결과 2 필터 (저점 비교 조건 제거)
                        if (
                            prev.upperWick > prev.body &&
                            ma7 > ma25 && ma25 > ma99 &&
                            prev.c > ma7
                        ) {
                            result2.push(sig);
                        }
                    } catch (e) {
                        const msg = String(e && e.message ? e.message : e);

                        if (msg.startsWith("RATE_LIMIT:")) {
                            const parts = msg.split(":");
                            const status = parts[1];
                            const waitMs = Number(parts[2] || "30000");

                            rateLimitBackoffUntil = Date.now() + Math.max(10000, Math.min(180000, waitMs));
                            txtStatus.innerHTML = `<span class="warn">레이트리밋(${status}) 감지 → ${Math.round((rateLimitBackoffUntil - Date.now()) / 1000)}초 대기 후 재개</span>`;
                            await sleep(Math.max(1000, Math.min(180000, waitMs)));
                            return;
                        }

                        console.warn(symbol, e);
                    }
                }

                setProgress(0, symbols.length);

                await runQueue(
                    symbols,
                    workerFn,
                    conc,
                    delayMs,
                    (done, total) => {
                        setProgress(done, total);
                        txtStatus.innerHTML =
                            `진행중... <span class="mono">${done}/${total}</span> | ` +
                            `현재 결과: <span class="ok">결과1 ${result1.length}</span>, <span class="ok">결과2 ${result2.length}</span> ` +
                            `<span class="muted">(트리거: ${reason})</span>`;
                    }
                );

                // ✅ 정렬 변경:
                // 결과1: NearHigh% 오름차순(가까울수록 위), 동률이면 Range% 내림차순, 그 다음 lowerRatio 내림차순
                result1.sort((a, b) => {
                    const da = safeNum(a.nearHighPct, Infinity);
                    const db = safeNum(b.nearHighPct, Infinity);
                    if (da !== db) return da - db;

                    const ra = safeNum(a.prev.rangePct, -Infinity);
                    const rb = safeNum(b.prev.rangePct, -Infinity);
                    if (rb !== ra) return rb - ra;

                    return safeNum(b.lowerRatio, -Infinity) - safeNum(a.lowerRatio, -Infinity);
                });

                // 결과2: NearLow% 오름차순(가까울수록 위), 동률이면 Range% 내림차순, 그 다음 upperRatio 내림차순
                result2.sort((a, b) => {
                    const da = safeNum(a.nearLowPct, Infinity);
                    const db = safeNum(b.nearLowPct, Infinity);
                    if (da !== db) return da - db;

                    const ra = safeNum(a.prev.rangePct, -Infinity);
                    const rb = safeNum(b.prev.rangePct, -Infinity);
                    if (rb !== ra) return rb - ra;

                    return safeNum(b.upperRatio, -Infinity) - safeNum(a.upperRatio, -Infinity);
                });

                renderTopPickCard(result1, result2);
                renderTables(result1, result2);
                setTimeNow();

                if (stopFlag) {
                    txtStatus.innerHTML =
                        `<span class="warn">중지됨</span> | 결과: ` +
                        `<span class="ok">결과1 ${result1.length}</span>, <span class="ok">결과2 ${result2.length}</span> ` +
                        `<span class="muted">(트리거: ${reason})</span>`;
                } else {
                    txtStatus.innerHTML =
                        `<span class="ok">완료</span> | 결과: ` +
                        `<span class="ok">결과1 ${result1.length}</span>, <span class="ok">결과2 ${result2.length}</span> ` +
                        `<span class="muted">(트리거: ${reason})</span>`;
                }
            } catch (e) {
                console.error(e);
                txtStatus.innerHTML = `<span class="bad">오류:</span> <span class="mono">${String(e && e.message ? e.message : e)}</span>`;
            } finally {
                isScanning = false;
                btnScan.disabled = false;
                btnStop.disabled = true;
            }
        }

        btnScan.addEventListener("click", () => {
            scan("manual").catch(console.error);
        });

        btnStop.addEventListener("click", () => {
            stopFlag = true;
            btnStop.disabled = true;
            txtStatus.innerHTML = `<span class="warn">중지 요청됨...</span>`;
        });

        // ✅ 자동 스캔: 매시 00/15/30/45
        function getNextQuarterHour(now = new Date()) {
            const d = new Date(now);
            d.setSeconds(0, 0);

            const m = d.getMinutes();
            const nextM = m < 15 ? 15 : m < 30 ? 30 : m < 45 ? 45 : 60;

            if (nextM === 60) {
                d.setHours(d.getHours() + 1);
                d.setMinutes(0);
            } else {
                d.setMinutes(nextM);
            }
            return d;
        }

        let autoTimer = null;

        function scheduleAutoScan() {
            if (autoTimer) clearTimeout(autoTimer);

            const now = new Date();
            const next = getNextQuarterHour(now);
            setNextAutoLabel(next);

            const waitMs = Math.max(0, next.getTime() - now.getTime());

            autoTimer = setTimeout(async () => {
                if (!isScanning) {
                    await scan("auto@00/15/30/45");
                } else {
                    txtStatus.innerHTML = `<span class="warn">자동 스캔 스킵</span> (이미 스캔 중)`;
                }
                scheduleAutoScan();
            }, waitMs);
        }

        scheduleAutoScan();
        // scan("auto@initial").catch(console.error);
    </script>
</body>
</html>