<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance Futures 15m Scanner (Swing SL + Confirm + Score + Auto + NEW NOW + Partial TP)</title>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
            margin: 16px;
        }
        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 12px;
            margin-top: 12px;
        }
        label {
            font-size: 13px;
            color: #333;
        }
        input, select, button {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 10px;
        }
        button { cursor: pointer; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }
        th, td {
            border-bottom: 1px solid #eee;
            padding: 10px 8px;
            font-size: 13px;
            text-align: left;
        }
        th {
            position: sticky;
            top: 0;
            background: #fafafa;
            z-index: 1;
        }

        .muted { color: #777; font-size: 12px; }
        .right { text-align: right; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        .warn { color: #b45309; }
        .ok { color: #0f766e; }
        .err { color: #b91c1c; }
        .small { font-size: 12px; }
        .actions { display: flex; gap: 8px; flex-wrap: wrap; }
        a { color: inherit; }

        .pill {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid #ddd;
        }
        .pill.long { border-color: #3bb27366; }
        .pill.short { border-color: #ff5a5f66; }
        .pill.triggered { border-color: #111; }
        .pill.newnow {
            border-color: #16a34a;
            background: #ecfdf5;
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 11px;
            border: 1px solid #e5e5e5;
            background: #fff;
            margin-left: 6px;
        }

        /* NOW 강조 */
        .row-now {
            background: #fff7ed;
        }

        /* 새로 뜬 NOW 강조(변화 감지) */
        .row-newnow {
            background: #ecfdf5;
            outline: 1px solid #16a34a55;
        }
    </style>
</head>
<body>
    <h2>Binance USDT-M Futures 15m 스캐너 (NOW 고정 + NEW NOW 강조 + 분할익절 텍스트)</h2>
    <div class="muted">
        - 방향: <span class="mono">1H EMA200(기울기 포함)</span><br/>
        - 트리거: <span class="mono">15m EMA20/50 눌림 후 확인봉</span> + <span class="mono">직전봉 High/Low 돌파 진입</span><br/>
        - SL: <span class="mono">최근 스윙(lookback) 저/고점 ± 버퍼</span><br/>
        - TP: <span class="mono">TP1=1R(50%), TP2=2R(30%), 잔여 20% 트레일링</span><br/>
        <span class="warn">※ 선물은 고위험. 이 도구는 신호 생성용이며 자동매매/수익 보장 아님.</span>
    </div>

    <div class="card">
        <div class="row">
            <div>
                <label>스캔 코인 개수(거래대금 상위)</label><br/>
                <input id="maxSymbols" type="number" value="120" min="10" max="500" />
            </div>

            <div>
                <label>스윙/눌림 탐색 N (15m)</label><br/>
                <input id="lookbackN" type="number" value="12" min="6" max="80" />
            </div>

            <div>
                <label>SL 버퍼(%)</label><br/>
                <input id="slBufferPct" type="number" value="0.25" min="0.05" step="0.05" />
            </div>

            <div>
                <label>최소 SL 거리(%)</label><br/>
                <input id="minStopPct" type="number" value="0.6" min="0.1" step="0.1" />
            </div>

            <div>
                <label>최대 SL 거리(%)</label><br/>
                <input id="maxStopPct" type="number" value="5.0" min="0.5" step="0.5" />
            </div>

            <div>
                <label>확인봉 강도(0~2)</label><br/>
                <select id="confirmLevel">
                    <option value="0">0: 약함(필터 적음)</option>
                    <option value="1" selected>1: 보통(추천)</option>
                    <option value="2">2: 강함(신호 적지만 퀄↑)</option>
                </select>
            </div>

            <div>
                <label>표시 상위 N개(점수)</label><br/>
                <input id="topN" type="number" value="30" min="5" max="200" />
            </div>

            <div>
                <label>스캔 모드</label><br/>
                <select id="mode">
                    <option value="both" selected>롱+숏</option>
                    <option value="long">롱만</option>
                    <option value="short">숏만</option>
                </select>
            </div>

            <div>
                <label>1회 리스크(%)</label><br/>
                <input id="riskPct" type="number" value="0.5" min="0.1" step="0.1" />
            </div>

            <div>
                <label>계좌(USDT)</label><br/>
                <input id="balance" type="number" value="700" min="1" step="1" />
            </div>

            <div class="actions" style="margin-top: 18px;">
                <button id="scanBtn">수동 스캔</button>
                <button id="stopBtn" disabled>중지</button>
                <button id="toggleAutoBtn">자동스캔: OFF</button>
            </div>
        </div>

        <div style="margin-top: 10px;" class="small">
            <span class="mono">포지션(USDT) = (잔고 × 리스크%) ÷ (손절거리%)</span>
            <span class="muted">※ NOW는 항상 표 최상단 고정 / NEW NOW는 이전 스캔 대비 새로 뜬 NOW</span>
        </div>

        <div id="autoInfo" class="muted" style="margin-top: 6px;"></div>
        <div id="status" class="muted" style="margin-top: 10px;"></div>
    </div>

    <div class="card">
        <div class="row">
            <div>
                <label>정렬(각 그룹 내부 정렬)</label><br/>
                <select id="sortBy">
                    <option value="score" selected>점수 높은 순</option>
                    <option value="closest">진입가 근접 순</option>
                    <option value="stop">손절거리(짧은) 우선</option>
                    <option value="trend">추세 강도 순</option>
                </select>
            </div>
            <div>
                <label>표시</label><br/>
                <select id="showOnly">
                    <option value="all" selected>전체</option>
                    <option value="triggered">NOW만</option>
                    <option value="newnow">NEW NOW만</option>
                    <option value="near">진입가 0.2% 이내 근접</option>
                </select>
            </div>
        </div>

        <table>
            <thead>
                <tr>
                    <th>심볼</th>
                    <th>포지션</th>
                    <th>점수</th>
                    <th>현재가</th>
                    <th>진입가</th>
                    <th>SL</th>
                    <th class="right">SL거리%</th>
                    <th>TP1(1R)</th>
                    <th>TP2(2R)</th>
                    <th class="right">진입까지%</th>
                    <th class="right">권장 포지션(USDT)</th>
                    <th>액션</th>
                </tr>
            </thead>
            <tbody id="tbody"></tbody>
        </table>
    </div>

<script>
    "use strict";

    const API = "https://fapi.binance.com";

    // ✅ 자동 스캔: 매시간 HH:02:05 (KST 로컬시간 기준)
    const AUTO_MINUTE = 2;
    const AUTO_SECOND = 5;

    // ✅ 분할익절 규칙(고정)
    const PARTIAL_TP1_PCT = 50;  // 1R에서 50%
    const PARTIAL_TP2_PCT = 30;  // 2R에서 30%
    const PARTIAL_TRAIL_PCT = 20; // 나머지 20% 트레일링

    let STOP_FLAG = false;
    let IS_SCANNING = false;
    let AUTO_ENABLED = false;
    let AUTO_TIMER_ID = null;

    let LAST_RESULTS = [];
    let LAST_SETTINGS = null;

    // ✅ 변화 감지용: 이전 스캔 NOW 집합
    let HAS_PREV_SCAN = false;
    let PREV_NOW_SET = new Set(); // key: SYMBOL|SIDE

    function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }

    function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
    }

    function fmt(num, digits = 6) {
        if (!isFinite(num)) return "-";
        const abs = Math.abs(num);
        if (abs >= 1000) return num.toFixed(2);
        if (abs >= 1) return num.toFixed(4);
        return num.toFixed(digits);
    }

    function ema(values, period) {
        const k = 2 / (period + 1);
        let e = values[0];
        const out = [e];
        for (let i = 1; i < values.length; i += 1) {
            e = values[i] * k + e * (1 - k);
            out.push(e);
        }
        return out;
    }

    function roundToStep(value, step, mode) {
        if (!step || step <= 0) return value;
        const inv = 1 / step;
        if (mode === "ceil") return Math.ceil(value * inv) / inv;
        if (mode === "floor") return Math.floor(value * inv) / inv;
        return Math.round(value * inv) / inv;
    }

    async function fetchJson(url, retry = 4) {
        let attempt = 0;
        while (attempt <= retry) {
            try {
                const res = await fetch(url, { cache: "no-store" });
                if (!res.ok) {
                    if ((res.status === 429 || res.status === 418) && attempt < retry) {
                        const wait = 650 * Math.pow(2, attempt);
                        await sleep(wait);
                        attempt += 1;
                        continue;
                    }
                    throw new Error("HTTP " + res.status + " " + res.statusText);
                }
                return await res.json();
            } catch (e) {
                if (attempt >= retry) throw e;
                await sleep(380 * Math.pow(2, attempt));
                attempt += 1;
            }
        }
        throw new Error("fetchJson failed");
    }

    async function getExchangeInfo() {
        const data = await fetchJson(API + "/fapi/v1/exchangeInfo");
        const map = new Map();
        for (const s of data.symbols) {
            if (s.contractType !== "PERPETUAL") continue;
            if (s.quoteAsset !== "USDT") continue;
            if (s.status !== "TRADING") continue;

            let tickSize = null;
            for (const f of s.filters) {
                if (f.filterType === "PRICE_FILTER") tickSize = parseFloat(f.tickSize);
            }
            map.set(s.symbol, { tickSize });
        }
        return map;
    }

    async function getTopSymbolsByQuoteVolume(maxSymbols) {
        const tickers = await fetchJson(API + "/fapi/v1/ticker/24hr");
        return tickers
            .filter((t) => t.symbol.endsWith("USDT"))
            .map((t) => ({ symbol: t.symbol, quoteVolume: parseFloat(t.quoteVolume || "0") }))
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, maxSymbols)
            .map((x) => x.symbol);
    }

    async function getAllPricesMap() {
        const arr = await fetchJson(API + "/fapi/v1/ticker/price");
        const map = new Map();
        for (const it of arr) map.set(it.symbol, parseFloat(it.price));
        return map;
    }

    async function getKlines(symbol, interval, limit) {
        const url = API + "/fapi/v1/klines?symbol=" + encodeURIComponent(symbol) +
            "&interval=" + encodeURIComponent(interval) + "&limit=" + limit;
        return await fetchJson(url);
    }

    function calcStopDistancePct(entry, sl) {
        if (!isFinite(entry) || !isFinite(sl) || entry <= 0) return null;
        return (Math.abs(entry - sl) / entry) * 100;
    }

    function calcPositionSizeUSDT(balance, riskPct, stopDistancePct) {
        const risk = balance * (riskPct / 100);
        const stop = stopDistancePct / 100;
        if (stop <= 0) return 0;
        return risk / stop;
    }

    function makeTradeUrl(symbol) {
        return "https://www.binance.com/en/futures/" + encodeURIComponent(symbol);
    }

    function gaussianScore(x, mu, sigma) {
        if (!isFinite(x) || sigma <= 0) return 0;
        const z = (x - mu) / sigma;
        return Math.exp(-0.5 * z * z);
    }

    function scoreRow(row) {
        const distScore = row.triggered ? 1.0 : (1.0 - clamp((row.distPct ?? 999) / 1.0, 0, 1)); // 1% 이내 가점
        const trendScore = clamp(Math.abs(row.trendStrength) * 60, 0, 1);
        const emaGapScore = clamp((row.emaGapPct ?? 0) / 0.25, 0, 1);
        const stopScore = gaussianScore(row.stopDistancePct, 2.0, 0.9); // 2% 근처 선호(안정)
        const volScore = clamp((row.volRatio ?? 1) / 2.0, 0, 1);

        const score =
            distScore * 0.32 +
            trendScore * 0.24 +
            emaGapScore * 0.18 +
            stopScore * 0.16 +
            volScore * 0.10;

        return clamp(score, 0, 1);
    }

    function buildSwingSLAndTP(side, entry, lows15, highs15, lastIdx, lookbackN, slBufferPct, tickSize) {
        const start = Math.max(0, lastIdx - lookbackN + 1);
        const windowLows = lows15.slice(start, lastIdx + 1);
        const windowHighs = highs15.slice(start, lastIdx + 1);

        const swingLow = Math.min(...windowLows);
        const swingHigh = Math.max(...windowHighs);

        const buffer = slBufferPct / 100;

        let sl = null;
        let tp1 = null;
        let tp2 = null;

        if (side === "LONG") {
            sl = swingLow * (1 - buffer);
            tp1 = entry + (entry - sl) * 1.0;
            tp2 = entry + (entry - sl) * 2.0;
        } else {
            sl = swingHigh * (1 + buffer);
            tp1 = entry - (sl - entry) * 1.0;
            tp2 = entry - (sl - entry) * 2.0;
        }

        if (tickSize) {
            sl = roundToStep(sl, tickSize, "round");
            tp1 = roundToStep(tp1, tickSize, "round");
            tp2 = roundToStep(tp2, tickSize, "round");
        }

        return { sl, tp1, tp2 };
    }

    function checkConfirm(side, opens15, closes15, lows15, highs15, ema20, ema50, vols15, lastIdx, lookbackN, confirmLevel) {
        const start = Math.max(0, lastIdx - lookbackN + 1);
        const touchTol = 0.003; // 0.3%
        const lastOpen = opens15[lastIdx];
        const lastClose = closes15[lastIdx];
        const e20 = ema20[lastIdx];
        const e50 = ema50[lastIdx];

        let touched = false;
        for (let i = start; i <= lastIdx; i += 1) {
            const low = lows15[i];
            const high = highs15[i];
            if (side === "LONG") {
                if (low <= e50 * (1 + touchTol)) {
                    touched = true;
                    break;
                }
            } else {
                if (high >= e50 * (1 - touchTol)) {
                    touched = true;
                    break;
                }
            }
        }

        if (confirmLevel === 0) return true;
        if (!touched) return false;

        if (side === "LONG") {
            const bullish = lastClose > lastOpen;
            const aboveE20 = lastClose >= e20;
            if (!(bullish && aboveE20)) return false;
        } else {
            const bearish = lastClose < lastOpen;
            const belowE20 = lastClose <= e20;
            if (!(bearish && belowE20)) return false;
        }

        if (confirmLevel === 1) return true;

        const volNow = vols15[lastIdx];
        const avgStart = Math.max(0, lastIdx - 21);
        const avg = vols15.slice(avgStart, lastIdx).reduce((a, b) => a + b, 0) / Math.max(1, (lastIdx - avgStart));
        if (avg <= 0) return false;
        return (volNow / avg) >= 1.2;
    }

    function analyzeSymbol(symbol, priceNow, info, kl1h, kl15m, settings) {
        const {
            lookbackN, mode, slBufferPct, minStopPct, maxStopPct, confirmLevel
        } = settings;

        // 1H EMA200 방향 필터
        const closes1h = kl1h.map((k) => parseFloat(k[4]));
        if (closes1h.length < 220) return null;

        const ema200_1h = ema(closes1h, 200);
        const lastClose1h = closes1h[closes1h.length - 1];
        const eNow = ema200_1h[ema200_1h.length - 1];
        const ePrev = ema200_1h[ema200_1h.length - 11];

        const longAllowed = (lastClose1h > eNow) && (eNow > ePrev);
        const shortAllowed = (lastClose1h < eNow) && (eNow < ePrev);

        if (mode === "long" && !longAllowed) return null;
        if (mode === "short" && !shortAllowed) return null;
        if (mode === "both" && !longAllowed && !shortAllowed) return null;

        // 15m
        const opens15 = kl15m.map((k) => parseFloat(k[1]));
        const highs15 = kl15m.map((k) => parseFloat(k[2]));
        const lows15 = kl15m.map((k) => parseFloat(k[3]));
        const closes15 = kl15m.map((k) => parseFloat(k[4]));
        const vols15 = kl15m.map((k) => parseFloat(k[5]));
        if (closes15.length < 120) return null;

        const ema20 = ema(closes15, 20);
        const ema50 = ema(closes15, 50);

        const lastIdx = closes15.length - 1;
        const lastClose15 = closes15[lastIdx];
        const e20 = ema20[lastIdx];
        const e50 = ema50[lastIdx];

        const prevIdx = closes15.length - 2;
        if (prevIdx < 0) return null;

        const prevHigh = highs15[prevIdx];
        const prevLow = lows15[prevIdx];

        const longSetupBase = longAllowed && (e20 > e50) && (lastClose15 >= e20);
        const shortSetupBase = shortAllowed && (e20 < e50) && (lastClose15 <= e20);

        let side = null;
        if (mode === "both") {
            if (longSetupBase && !shortSetupBase) side = "LONG";
            else if (shortSetupBase && !longSetupBase) side = "SHORT";
            else return null;
        } else if (mode === "long") {
            if (!longSetupBase) return null;
            side = "LONG";
        } else {
            if (!shortSetupBase) return null;
            side = "SHORT";
        }

        // 확인봉 필터
        if (!checkConfirm(side, opens15, closes15, lows15, highs15, ema20, ema50, vols15, lastIdx, lookbackN, confirmLevel)) {
            return null;
        }

        const tickSize = info?.tickSize || null;

        let entry = (side === "LONG") ? prevHigh : prevLow;
        if (tickSize) entry = roundToStep(entry, tickSize, side === "LONG" ? "ceil" : "floor");

        const plan = buildSwingSLAndTP(side, entry, lows15, highs15, lastIdx, lookbackN, slBufferPct, tickSize);
        const stopDistancePct = calcStopDistancePct(entry, plan.sl);
        if (stopDistancePct === null) return null;

        if (stopDistancePct < minStopPct || stopDistancePct > maxStopPct) return null;

        const trendStrength = (lastClose1h - eNow) / eNow;

        let distPct = null;
        let triggered = false;
        if (priceNow && isFinite(priceNow)) {
            if (side === "LONG") {
                distPct = ((entry - priceNow) / priceNow) * 100;
                triggered = priceNow >= entry;
            } else {
                distPct = ((priceNow - entry) / priceNow) * 100;
                triggered = priceNow <= entry;
            }
        } else {
            distPct = 999;
        }

        const emaGapPct = priceNow && isFinite(priceNow) ? (Math.abs(e20 - e50) / priceNow) * 100 : 0;

        const volNow = vols15[lastIdx];
        const avgStart = Math.max(0, lastIdx - 21);
        const avg = vols15.slice(avgStart, lastIdx).reduce((a, b) => a + b, 0) / Math.max(1, (lastIdx - avgStart));
        const volRatio = (avg > 0) ? (volNow / avg) : 1;

        const row = {
            symbol,
            side,
            priceNow,
            entry,
            sl: plan.sl,
            tp1: plan.tp1,
            tp2: plan.tp2,
            stopDistancePct,
            trendStrength,
            distPct,
            triggered,
            emaGapPct,
            volRatio
        };

        row.score = scoreRow(row);
        return row;
    }

    function rowKey(symbol, side) {
        return symbol + "|" + side;
    }

    function applyNowPinAndSort(list, sortBy) {
        const now = list.filter((r) => r.triggered);
        const rest = list.filter((r) => !r.triggered);

        const sorter = {
            "score": (a, b) => (b.score ?? 0) - (a.score ?? 0),
            "closest": (a, b) => (a.distPct ?? 999) - (b.distPct ?? 999),
            "stop": (a, b) => (a.stopDistancePct ?? 999) - (b.stopDistancePct ?? 999),
            "trend": (a, b) => Math.abs(b.trendStrength ?? 0) - Math.abs(a.trendStrength ?? 0),
        }[sortBy] || ((a, b) => (b.score ?? 0) - (a.score ?? 0));

        now.sort(sorter);
        rest.sort(sorter);

        return { now, rest };
    }

    function buildPartialPlanText(side) {
        const trailRule = (side === "LONG")
            ? "잔여 20% 트레일링: 15m 종가가 EMA20 아래로 마감하면 전량 청산(또는 직전 스윙 저점 갱신 시 스탑 상향)."
            : "잔여 20% 트레일링: 15m 종가가 EMA20 위로 마감하면 전량 청산(또는 직전 스윙 고점 갱신 시 스탑 하향).";

        return [
            `분할익절:`,
            `- TP1(1R) ${PARTIAL_TP1_PCT}%`,
            `- TP2(2R) ${PARTIAL_TP2_PCT}%`,
            `- 잔여 ${PARTIAL_TRAIL_PCT}%: 트레일링`,
            `- 규칙: TP1 체결 후 SL을 Entry(본절)로 이동 권장.`,
            `- ${trailRule}`
        ].join("\n");
    }

    function applyViewAndRender() {
        if (!LAST_SETTINGS) return;

        const tbody = document.getElementById("tbody");
        tbody.innerHTML = "";

        const showOnly = document.getElementById("showOnly").value;
        const sortBy = document.getElementById("sortBy").value;
        const topN = clamp(parseInt(document.getElementById("topN").value, 10) || 30, 5, 500);

        let list = LAST_RESULTS.slice();

        if (showOnly === "triggered") {
            list = list.filter((r) => r.triggered);
        } else if (showOnly === "newnow") {
            list = list.filter((r) => r.triggered && r.isNewNow);
        } else if (showOnly === "near") {
            list = list.filter((r) => (r.distPct ?? 999) <= 0.2);
        }

        const { now, rest } = applyNowPinAndSort(list, sortBy);

        // ✅ NOW는 항상 전부 표시, rest만 topN에 맞춰 제한(전체가 너무 많아지는 것 방지)
        const remainingSlots = Math.max(0, topN - now.length);
        const finalList = now.concat(rest.slice(0, remainingSlots));

        for (const r of finalList) {
            const posUSDT = calcPositionSizeUSDT(LAST_SETTINGS.balance, LAST_SETTINGS.riskPct, r.stopDistancePct);

            const sidePill = `<span class="pill ${r.side === "LONG" ? "long" : "short"}">${r.side}</span>`;
            const nowPill = r.triggered ? ` <span class="pill triggered">NOW</span>` : "";
            const newPill = (r.triggered && r.isNewNow) ? ` <span class="pill newnow">NEW</span>` : "";

            const distTxt = (r.distPct === null) ? "-" : (r.distPct <= 0 ? "진입조건 충족" : (r.distPct.toFixed(3) + "%"));
            const scoreTxt = (r.score * 100).toFixed(1);

            const partialPlan = buildPartialPlanText(r.side);

            const copyText =
                `${r.symbol} ${r.side}\n` +
                `${r.triggered ? "NOW: 진입 가능\n" : ""}` +
                `${(r.triggered && r.isNewNow) ? "NEW NOW: 이전 스캔 대비 신규\n" : ""}` +
                `Score: ${scoreTxt}\n` +
                `Entry: ${r.entry}\n` +
                `SL: ${r.sl} (dist ${r.stopDistancePct.toFixed(2)}%)\n` +
                `TP1(1R): ${r.tp1}  -> ${PARTIAL_TP1_PCT}%\n` +
                `TP2(2R): ${r.tp2}  -> ${PARTIAL_TP2_PCT}%\n` +
                `Pos(USDT): ${fmt(posUSDT, 2)}\n` +
                `Risk: ${LAST_SETTINGS.riskPct}% / Balance: ${LAST_SETTINGS.balance}\n` +
                `EMA gap: ${fmt(r.emaGapPct, 4)}% / Vol x${fmt(r.volRatio, 2)}\n\n` +
                partialPlan;

            const tr = document.createElement("tr");

            if (r.triggered) tr.classList.add("row-now");
            if (r.triggered && r.isNewNow) tr.classList.add("row-newnow");

            tr.innerHTML = `
                <td class="mono">${r.symbol}
                    <div class="muted small">
                        1H trend: ${(r.trendStrength * 100).toFixed(2)}%
                        <span class="badge">vol x${fmt(r.volRatio, 2)}</span>
                        <span class="badge">gap ${fmt(r.emaGapPct, 3)}%</span>
                    </div>
                </td>
                <td>${sidePill}${nowPill}${newPill}</td>
                <td class="mono">${scoreTxt}</td>
                <td class="mono">${fmt(r.priceNow, 8)}</td>
                <td class="mono">${fmt(r.entry, 8)}</td>
                <td class="mono">${fmt(r.sl, 8)}</td>
                <td class="right mono">${r.stopDistancePct.toFixed(2)}%</td>
                <td class="mono">${fmt(r.tp1, 8)}</td>
                <td class="mono">${fmt(r.tp2, 8)}</td>
                <td class="right mono">${distTxt}</td>
                <td class="right mono">${fmt(posUSDT, 2)}</td>
                <td>
                    <div class="actions">
                        <button class="copyBtn">복사(분할익절 포함)</button>
                        <a class="mono" href="${makeTradeUrl(r.symbol)}" target="_blank" rel="noreferrer">Binance</a>
                    </div>
                </td>
            `;

            tr.querySelector(".copyBtn").addEventListener("click", async () => {
                try {
                    await navigator.clipboard.writeText(copyText);
                    alert("복사 완료!");
                } catch (e) {
                    alert("복사 실패(브라우저 권한).");
                }
            });

            tbody.appendChild(tr);
        }
    }

    function readSettingsFromUI() {
        const maxSymbols = clamp(parseInt(document.getElementById("maxSymbols").value, 10) || 120, 10, 500);
        const lookbackN = clamp(parseInt(document.getElementById("lookbackN").value, 10) || 12, 6, 80);
        const slBufferPct = clamp(parseFloat(document.getElementById("slBufferPct").value) || 0.25, 0.05, 2.0);
        const minStopPct = clamp(parseFloat(document.getElementById("minStopPct").value) || 0.6, 0.1, 50);
        const maxStopPct = clamp(parseFloat(document.getElementById("maxStopPct").value) || 5.0, 0.5, 50);
        const confirmLevel = clamp(parseInt(document.getElementById("confirmLevel").value, 10) || 1, 0, 2);
        const riskPct = clamp(parseFloat(document.getElementById("riskPct").value) || 0.5, 0.05, 5);
        const balance = Math.max(1, parseFloat(document.getElementById("balance").value) || 700);
        const mode = document.getElementById("mode").value;

        return { maxSymbols, lookbackN, slBufferPct, minStopPct, maxStopPct, confirmLevel, riskPct, balance, mode };
    }

    function computeNextAutoRun() {
        const now = new Date();
        const next = new Date(now);
        next.setMinutes(AUTO_MINUTE);
        next.setSeconds(AUTO_SECOND);
        next.setMilliseconds(0);

        if (next.getTime() <= now.getTime()) {
            next.setHours(next.getHours() + 1);
        }
        return next;
    }

    function updateAutoInfo() {
        const autoInfo = document.getElementById("autoInfo");
        if (!AUTO_ENABLED) {
            autoInfo.innerHTML = `자동 스캔 시간: <span class="mono">매시간 ${String(AUTO_MINUTE).padStart(2, "0")}:${String(AUTO_SECOND).padStart(2, "0")}</span> (KST 로컬시간 기준)`;
            return;
        }
        const next = computeNextAutoRun();
        autoInfo.innerHTML =
            `자동 스캔 ON · 다음 실행: <span class="mono">${next.toLocaleString()}</span> (매시간 ${String(AUTO_MINUTE).padStart(2, "0")}:${String(AUTO_SECOND).padStart(2, "0")})`;
    }

    function scheduleNextAutoScan(scanFn) {
        if (!AUTO_ENABLED) return;

        if (AUTO_TIMER_ID) {
            clearTimeout(AUTO_TIMER_ID);
            AUTO_TIMER_ID = null;
        }

        const next = computeNextAutoRun();
        const wait = Math.max(0, next.getTime() - Date.now());

        updateAutoInfo();

        AUTO_TIMER_ID = setTimeout(async () => {
            if (!AUTO_ENABLED) return;
            await scanFn("자동");
            scheduleNextAutoScan(scanFn);
        }, wait);
    }

    function toggleAuto(scanFn) {
        const btn = document.getElementById("toggleAutoBtn");
        AUTO_ENABLED = !AUTO_ENABLED;

        if (AUTO_ENABLED) {
            btn.textContent = "자동스캔: ON";
            scheduleNextAutoScan(scanFn);
        } else {
            btn.textContent = "자동스캔: OFF";
            if (AUTO_TIMER_ID) {
                clearTimeout(AUTO_TIMER_ID);
                AUTO_TIMER_ID = null;
            }
            updateAutoInfo();
        }
    }

    async function scanInternal(triggerLabel) {
        const status = document.getElementById("status");
        const scanBtn = document.getElementById("scanBtn");
        const stopBtn = document.getElementById("stopBtn");

        if (IS_SCANNING) return;

        STOP_FLAG = false;
        IS_SCANNING = true;

        scanBtn.disabled = true;
        stopBtn.disabled = false;

        const settings = readSettingsFromUI();
        LAST_SETTINGS = settings;

        try {
            status.innerHTML = `${triggerLabel} 스캔 준비중... <span class="muted">(exchangeInfo / ticker / prices)</span>`;

            const [exchangeInfoMap, pricesMap] = await Promise.all([
                getExchangeInfo(),
                getAllPricesMap()
            ]);

            const symbols = await getTopSymbolsByQuoteVolume(settings.maxSymbols);

            status.innerHTML = `${triggerLabel} 스캔 시작: ${symbols.length}개`;

            const results = [];
            const concurrency = 6;
            let idx = 0;

            async function worker() {
                while (idx < symbols.length && !STOP_FLAG) {
                    const myIdx = idx;
                    idx += 1;

                    const symbol = symbols[myIdx];
                    const info = exchangeInfoMap.get(symbol);
                    if (!info) continue;

                    try {
                        const [kl1h, kl15m] = await Promise.all([
                            getKlines(symbol, "1h", 260),
                            getKlines(symbol, "15m", 220)
                        ]);

                        const priceNow = pricesMap.get(symbol);
                        const row = analyzeSymbol(symbol, priceNow, info, kl1h, kl15m, settings);
                        if (row) results.push(row);
                    } catch (e) {
                        // 무시하고 계속
                    }

                    if (myIdx % 12 === 0) {
                        status.innerHTML = `${triggerLabel} 진행: ${myIdx + 1}/${symbols.length} | 시그널: ${results.length}개`;
                    }
                }
            }

            const workers = [];
            for (let i = 0; i < concurrency; i += 1) workers.push(worker());
            await Promise.all(workers);

            // ✅ 변화 감지(NEW NOW)
            const currNowSet = new Set();
            let newNowCount = 0;
            for (const r of results) {
                const k = rowKey(r.symbol, r.side);
                if (r.triggered) {
                    currNowSet.add(k);
                    if (HAS_PREV_SCAN && !PREV_NOW_SET.has(k)) {
                        r.isNewNow = true;
                        newNowCount += 1;
                    } else {
                        r.isNewNow = false;
                    }
                } else {
                    r.isNewNow = false;
                }
            }

            const nowCount = results.filter((r) => r.triggered).length;

            LAST_RESULTS = results;

            if (STOP_FLAG) {
                status.innerHTML = `<span class="warn">${triggerLabel} 중지됨</span> | 시그널: ${results.length}개`;
            } else {
                status.innerHTML =
                    `<span class="ok">${triggerLabel} 완료</span> | 시그널: ${results.length}개 | NOW: ${nowCount}개 | NEW NOW: ${newNowCount}개`;
            }

            applyViewAndRender();

            // ✅ 현재 NOW를 다음 스캔 비교 기준으로 저장
            PREV_NOW_SET = currNowSet;
            HAS_PREV_SCAN = true;

        } catch (e) {
            status.innerHTML = `<span class="err">오류:</span> ${String(e.message || e)}`;
        } finally {
            IS_SCANNING = false;
            scanBtn.disabled = false;
            stopBtn.disabled = true;
        }
    }

    function scanManual() {
        return scanInternal("수동");
    }

    // 이벤트 바인딩
    document.getElementById("scanBtn").addEventListener("click", scanManual);
    document.getElementById("stopBtn").addEventListener("click", () => { STOP_FLAG = true; });

    document.getElementById("toggleAutoBtn").addEventListener("click", () => {
        toggleAuto(scanInternal);
    });

    document.getElementById("sortBy").addEventListener("change", applyViewAndRender);
    document.getElementById("showOnly").addEventListener("change", applyViewAndRender);
    document.getElementById("topN").addEventListener("change", applyViewAndRender);

    // 초기 안내
    updateAutoInfo();
</script>
</body>
</html>
