<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT Perp 1m MA Streak Scanner (00/15/30/45 Auto)</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0b0f17;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --line: rgba(255, 255, 255, 0.08);
            --good: rgba(16, 185, 129, 0.18);
            --bad: rgba(239, 68, 68, 0.18);
            --chip: rgba(255, 255, 255, 0.06);
            --shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Pretendard, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
            background: radial-gradient(1200px 800px at 20% 10%, rgba(59, 130, 246, 0.18), transparent 60%),
                        radial-gradient(1200px 800px at 80% 20%, rgba(16, 185, 129, 0.14), transparent 60%),
                        var(--bg);
            color: var(--text);
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 18px;
        }

        .header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 14px;
            margin-bottom: 12px;
        }

        .title {
            font-size: 18px;
            font-weight: 800;
            letter-spacing: -0.2px;
            margin: 0;
        }

        .sub {
            margin: 6px 0 0;
            color: var(--muted);
            font-size: 12px;
            line-height: 1.4;
        }

        .panel {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border: 1px solid var(--line);
            border-radius: 16px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .controls {
            display: grid;
            grid-template-columns: 1.3fr 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.18);
            border-bottom: 1px solid var(--line);
        }

        .control {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }

        label {
            font-size: 11px;
            color: var(--muted);
        }

        input, select, button {
            border-radius: 12px;
            border: 1px solid var(--line);
            background: rgba(0, 0, 0, 0.25);
            color: var(--text);
            padding: 10px 10px;
            outline: none;
            font-size: 13px;
        }

        input::placeholder {
            color: rgba(156, 163, 175, 0.7);
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            cursor: pointer;
            font-weight: 700;
            background: rgba(59, 130, 246, 0.18);
        }

        button:hover {
            filter: brightness(1.08);
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .statusBar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--line);
        }

        .chips {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .chip {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: var(--chip);
            border: 1px solid var(--line);
            color: var(--text);
        }

        .chip b {
            color: #fff;
        }

        .log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            color: var(--muted);
            padding: 10px 12px;
            border-bottom: 1px solid var(--line);
            white-space: pre-wrap;
            line-height: 1.45;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead th {
            position: sticky;
            top: 0;
            background: rgba(15, 23, 42, 0.92);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--line);
            font-size: 12px;
            color: var(--muted);
            text-align: left;
            padding: 10px 12px;
            z-index: 1;
        }

        tbody td {
            border-bottom: 1px solid var(--line);
            padding: 10px 12px;
            font-size: 13px;
            vertical-align: middle;
        }

        tbody tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .right {
            text-align: right;
        }

        .muted {
            color: var(--muted);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: rgba(0, 0, 0, 0.2);
            font-size: 12px;
        }

        .badge.good {
            background: var(--good);
        }

        .badge.bad {
            background: var(--bad);
        }

        a {
            color: #93c5fd;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width: 980px) {
            .controls {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="header">
        <div>
            <h1 class="title">Binance USDT 무기한(Perp) 1분봉 MA 연속조건 스캐너</h1>
            <p class="sub">
                이전봉(마감봉)부터 역순으로
                <b>7MA &gt; 25MA &gt; 99MA</b> AND <b>종가 &gt; 7MA</b> 조건 연속개수(streak)를 계산합니다.<br/>
                ✅ 정렬: <b>정배열(7&gt;25&gt;99)을 깨는 FAIL 봉이 가까운 순</b> (FAIL 몇 봉 전 = maOrderStreak + 1), 동률이면 <b>24h quoteVolume</b>.
            </p>
        </div>
        <div class="row">
            <button id="btnScan">지금 스캔</button>
            <button id="btnStop" disabled>중지</button>
        </div>
    </div>

    <div class="panel">
        <div class="controls">
            <div class="control">
                <label>인터벌</label>
                <select id="interval">
                    <option value="1m" selected>1m</option>
                    <option value="3m">3m</option>
                    <option value="5m">5m</option>
                    <option value="15m">15m</option>
                </select>
            </div>
            <div class="control">
                <label>MA(단기/중기/장기)</label>
                <input id="maTriplet" type="text" value="7,25,99" />
            </div>
            <div class="control">
                <label>kline limit (최대 연속체크 길이 상한)</label>
                <input id="klineLimit" type="number" min="120" max="1500" step="10" value="300" />
            </div>
            <div class="control">
                <label>동시요청수(낮출수록 안정)</label>
                <input id="concurrency" type="number" min="1" max="12" step="1" value="6" />
            </div>
            <div class="control">
                <label>상위 N개만 스캔(0=전체)</label>
                <input id="topN" type="number" min="0" max="1000" step="10" value="0" />
            </div>
        </div>

        <div class="statusBar">
            <div class="chips">
                <div class="chip">자동스캔: <b>매시 00/15/30/45</b></div>
                <div class="chip">다음 스캔: <b id="nextRun">-</b></div>
                <div class="chip">상태: <b id="statusText">대기</b></div>
                <div class="chip">진행: <b id="progressText">0 / 0</b></div>
                <div class="chip">결과: <b id="resultCount">0</b></div>
            </div>
            <div class="chips">
                <div class="chip">마지막 스캔: <b id="lastRun">-</b></div>
            </div>
        </div>

        <div class="log" id="log"></div>

        <div style="overflow:auto; max-height: 70vh;">
            <table>
                <thead>
                <tr>
                    <th style="width:70px;">#</th>
                    <th>심볼</th>
                    <th class="right">streak<br/><span class="muted">(정배열+종가&gt;7MA)</span></th>
                    <th class="right">FAIL 몇 봉 전<br/><span class="muted">(정배열 깨짐)</span></th>
                    <th class="right">MA정배열 연속</th>
                    <th class="right">24h quoteVolume (USDT)</th>
                    <th class="right">마지막가격</th>
                    <th class="right">24h 변동률</th>
                    <th class="right">링크</th>
                </tr>
                </thead>
                <tbody id="tbody">
                <tr>
                    <td colspan="9" class="muted" style="padding:16px 12px;">스캔을 실행하면 결과가 표시됩니다.</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
(function () {
    "use strict";

    const API = "https://fapi.binance.com";

    const $ = (sel) => document.querySelector(sel);

    const elBtnScan = $("#btnScan");
    const elBtnStop = $("#btnStop");
    const elInterval = $("#interval");
    const elMaTriplet = $("#maTriplet");
    const elKlineLimit = $("#klineLimit");
    const elConcurrency = $("#concurrency");
    const elTopN = $("#topN");

    const elNextRun = $("#nextRun");
    const elLastRun = $("#lastRun");
    const elStatusText = $("#statusText");
    const elProgressText = $("#progressText");
    const elResultCount = $("#resultCount");
    const elLog = $("#log");
    const elTbody = $("#tbody");

    let cachedSymbols = null;
    let scanAbort = { aborted: false };
    let scanInProgress = false;
    let timerId = null;

    function logLine(s) {
        const t = new Date();
        const hh = String(t.getHours()).padStart(2, "0");
        const mm = String(t.getMinutes()).padStart(2, "0");
        const ss = String(t.getSeconds()).padStart(2, "0");
        elLog.textContent = `[${hh}:${mm}:${ss}] ${s}\n` + elLog.textContent;
    }

    function setStatus(s) {
        elStatusText.textContent = s;
    }

    function fmtNum(n, digits = 0) {
        if (!Number.isFinite(n)) return "-";
        return n.toLocaleString(undefined, {
            minimumFractionDigits: digits,
            maximumFractionDigits: digits
        });
    }

    function parseTriplet(text) {
        const parts = String(text || "")
            .split(",")
            .map((v) => parseInt(v.trim(), 10))
            .filter((v) => Number.isFinite(v) && v > 0);

        if (parts.length !== 3) return null;
        return parts;
    }

    async function fetchJson(url, { signal, retry = 4 } = {}) {
        let attempt = 0;
        let lastErr = null;

        while (attempt <= retry) {
            if (signal && signal.aborted) throw new Error("aborted");

            try {
                const res = await fetch(url, { method: "GET", cache: "no-store" });
                if (!res.ok) {
                    const code = res.status;

                    if (code === 418 || code === 429 || code === 503) {
                        const waitMs = Math.min(20000, 800 * Math.pow(2, attempt));
                        logLine(`⚠️ ${code} 응답 - ${waitMs}ms 후 재시도: ${url}`);
                        await new Promise((r) => setTimeout(r, waitMs));
                        attempt += 1;
                        continue;
                    }

                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${code}: ${text.slice(0, 180)}`);
                }

                return await res.json();
            } catch (e) {
                lastErr = e;
                const waitMs = Math.min(12000, 600 * Math.pow(2, attempt));
                logLine(`⚠️ 네트워크 오류 - ${waitMs}ms 후 재시도: ${String(e && e.message ? e.message : e)}`);
                await new Promise((r) => setTimeout(r, waitMs));
                attempt += 1;
            }
        }

        throw lastErr || new Error("fetchJson failed");
    }

    async function loadPerpUsdtSymbolsOnce() {
        if (cachedSymbols) return cachedSymbols;

        setStatus("심볼 목록 로드...");
        logLine("exchangeInfo 로드 중...");
        const info = await fetchJson(`${API}/fapi/v1/exchangeInfo`);

        const list = (info && info.symbols ? info.symbols : [])
            .filter((s) =>
                s &&
                s.quoteAsset === "USDT" &&
                s.contractType === "PERPETUAL" &&
                s.status === "TRADING"
            )
            .map((s) => s.symbol);

        cachedSymbols = list;
        logLine(`USDT PERP 심볼 ${list.length}개 로드 완료`);
        return list;
    }

    async function loadAllTickers24hMap() {
        logLine("24h ticker 로드 중...");
        const tickers = await fetchJson(`${API}/fapi/v1/ticker/24hr`);
        const map = new Map();

        for (const t of (tickers || [])) {
            if (!t || !t.symbol) continue;

            const quoteVolume = parseFloat(t.quoteVolume);
            const lastPrice = parseFloat(t.lastPrice);
            const priceChangePercent = parseFloat(t.priceChangePercent);

            map.set(t.symbol, {
                quoteVolume: Number.isFinite(quoteVolume) ? quoteVolume : 0,
                lastPrice: Number.isFinite(lastPrice) ? lastPrice : NaN,
                priceChangePercent: Number.isFinite(priceChangePercent) ? priceChangePercent : NaN
            });
        }

        return map;
    }

    function calcSMA(closes, period) {
        const n = closes.length;
        const out = new Array(n).fill(null);
        let sum = 0;

        for (let i = 0; i < n; i++) {
            sum += closes[i];

            if (i >= period) {
                sum -= closes[i - period];
            }

            if (i >= period - 1) {
                out[i] = sum / period;
            }
        }

        return out;
    }

    // streak: (7MA > 25MA > 99MA) AND (close > 7MA) 연속개수
    function calcSignalStreakFromPreviousClosedCandle(klines, ma7, ma25, ma99) {
        const n = klines.length;
        if (n < 120) return 0;

        let idx = n - 2;    // 이전봉(마감봉)
        let streak = 0;

        for (; idx >= 0; idx--) {
            const close = parseFloat(klines[idx][4]);
            const a = ma7[idx];
            const b = ma25[idx];
            const c = ma99[idx];

            if (a === null || b === null || c === null) break;

            if (a > b && b > c && close > a) {
                streak += 1;
            } else {
                break;
            }
        }

        return streak;
    }

    // MA 정배열 연속 + FAIL 봉이 몇 봉 전인지 계산
    // maOrderStreak: 이전봉부터 역순으로 (7MA > 25MA > 99MA) 연속개수
    // failBarsAgo: FAIL 봉이 "몇 봉 전인지" = maOrderStreak + 1 (FAIL 봉을 실제로 만난 경우에만)
    function calcMAOrderInfoFromPreviousClosedCandle(klines, ma7, ma25, ma99) {
        const n = klines.length;
        if (n < 120) {
            return { maOrderStreak: 0, failBarsAgo: null, failFound: false };
        }

        let idx = n - 2;
        let maOrderStreak = 0;
        let failFound = false;

        for (; idx >= 0; idx--) {
            const a = ma7[idx];
            const b = ma25[idx];
            const c = ma99[idx];

            if (a === null || b === null || c === null) {
                // MA 계산 불가 구간으로 종료 -> FAIL 봉을 못 찾았다고 처리
                failFound = false;
                break;
            }

            if (a > b && b > c) {
                maOrderStreak += 1;
            } else {
                // 여기서 FAIL 봉을 실제로 만남
                failFound = true;
                break;
            }
        }

        const failBarsAgo = failFound ? (maOrderStreak + 1) : null;

        return { maOrderStreak, failBarsAgo, failFound };
    }

    async function scanSymbol(symbol, interval, limit, triplet, signal) {
        const [p7, p25, p99] = triplet;

        const url = `${API}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`;
        const klines = await fetchJson(url, { signal });

        if (!Array.isArray(klines) || klines.length < p99 + 5) {
            return { symbol, streak: 0, maOrderStreak: 0, failBarsAgo: null };
        }

        const closes = klines.map((k) => parseFloat(k[4]));

        const maA = calcSMA(closes, p7);
        const maB = calcSMA(closes, p25);
        const maC = calcSMA(closes, p99);

        const streak = calcSignalStreakFromPreviousClosedCandle(klines, maA, maB, maC);
        const info = calcMAOrderInfoFromPreviousClosedCandle(klines, maA, maB, maC);

        return {
            symbol,
            streak,
            maOrderStreak: info.maOrderStreak,
            failBarsAgo: info.failBarsAgo
        };
    }

    async function runPool(items, workerFn, concurrency, onProgress, signal) {
        const results = [];
        let idx = 0;
        let done = 0;

        async function worker() {
            while (true) {
                if (signal && signal.aborted) return;

                const myIdx = idx;
                idx += 1;
                if (myIdx >= items.length) return;

                const item = items[myIdx];
                try {
                    const r = await workerFn(item);
                    results[myIdx] = r;
                } catch (e) {
                    results[myIdx] = { error: true, message: String(e && e.message ? e.message : e), item };
                } finally {
                    done += 1;
                    if (onProgress) onProgress(done, items.length);
                }
            }
        }

        const workers = [];
        const c = Math.max(1, Math.min(concurrency, 32));
        for (let i = 0; i < c; i++) {
            workers.push(worker());
        }

        await Promise.all(workers);
        return results;
    }

    function renderResults(rows) {
        elTbody.innerHTML = "";

        if (!rows.length) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td colspan="9" class="muted" style="padding:16px 12px;">조건(streak &gt;= 1)을 만족하는 심볼이 없습니다.</td>`;
            elTbody.appendChild(tr);
            return;
        }

        rows.forEach((r, i) => {
            const tr = document.createElement("tr");

            const badgeCls = r.streak >= 10 ? "good" : (r.streak >= 1 ? "good" : "bad");
            const link = `https://www.binance.com/en/futures/${encodeURIComponent(r.symbol)}`;

            const failText = Number.isFinite(r.failBarsAgo) ? fmtNum(r.failBarsAgo) : "N/A";

            tr.innerHTML = `
                <td class="muted">${i + 1}</td>
                <td>
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <span style="font-weight:800;">${r.symbol}</span>
                        <span class="badge ${badgeCls}">streak <b>${r.streak}</b></span>
                    </div>
                </td>
                <td class="right" style="font-weight:800;">${fmtNum(r.streak)}</td>
                <td class="right" style="font-weight:800;">${failText}</td>
                <td class="right">${fmtNum(r.maOrderStreak || 0)}</td>
                <td class="right">${fmtNum(r.quoteVolume, 0)}</td>
                <td class="right">${Number.isFinite(r.lastPrice) ? fmtNum(r.lastPrice, 6) : "-"}</td>
                <td class="right">${Number.isFinite(r.priceChangePercent) ? fmtNum(r.priceChangePercent, 2) + "%" : "-"}</td>
                <td class="right"><a href="${link}" target="_blank" rel="noreferrer">Futures</a></td>
            `;
            elTbody.appendChild(tr);
        });
    }

    function computeNextQuarterTime(now = new Date()) {
        const d = new Date(now.getTime());
        d.setMilliseconds(0);

        const minute = d.getMinutes();
        const second = d.getSeconds();

        const remainder = minute % 15;
        const addMin = (remainder === 0 && second === 0) ? 15 : (15 - remainder);

        d.setSeconds(0);
        d.setMinutes(minute + addMin);

        return d;
    }

    function scheduleNextAutoScan() {
        if (timerId) {
            clearTimeout(timerId);
            timerId = null;
        }

        const now = new Date();
        const next = computeNextQuarterTime(now);
        const diff = Math.max(0, next.getTime() - now.getTime());

        elNextRun.textContent = next.toLocaleString();

        timerId = setTimeout(async () => {
            if (!scanInProgress) {
                await startScan("auto");
            } else {
                logLine("자동스캔 시점이지만 현재 스캔 진행 중이라 건너뜀");
            }
            scheduleNextAutoScan();
        }, diff);
    }

    async function startScan(trigger = "manual") {
        if (scanInProgress) {
            logLine("이미 스캔 중입니다.");
            return;
        }

        const triplet = parseTriplet(elMaTriplet.value);
        if (!triplet) {
            alert("MA(단기/중기/장기)를 '7,25,99' 형식으로 입력해주세요.");
            return;
        }

        const interval = elInterval.value;
        const limit = Math.max(120, Math.min(1500, parseInt(elKlineLimit.value, 10) || 300));
        const concurrency = Math.max(1, Math.min(12, parseInt(elConcurrency.value, 10) || 6));
        const topN = Math.max(0, Math.min(2000, parseInt(elTopN.value, 10) || 0));

        scanAbort = { aborted: false };
        scanInProgress = true;

        elBtnScan.disabled = true;
        elBtnStop.disabled = false;

        setStatus(trigger === "auto" ? "자동 스캔 중..." : "스캔 중...");
        elProgressText.textContent = "0 / 0";
        elResultCount.textContent = "0";

        const startedAt = new Date();
        elLastRun.textContent = startedAt.toLocaleString();
        logLine(`===== 스캔 시작 (${trigger}) interval=${interval}, MA=${triplet.join("/")}, limit=${limit}, concurrency=${concurrency} =====`);

        try {
            const symbols = await loadPerpUsdtSymbolsOnce();
            const tickerMap = await loadAllTickers24hMap();

            // 심볼 + 24h volume 결합 (우선은 거래량 순으로 스캔 우선순위를 정해 둠)
            let merged = symbols
                .map((sym) => {
                    const t = tickerMap.get(sym) || { quoteVolume: 0, lastPrice: NaN, priceChangePercent: NaN };
                    return {
                        symbol: sym,
                        quoteVolume: t.quoteVolume,
                        lastPrice: t.lastPrice,
                        priceChangePercent: t.priceChangePercent
                    };
                })
                .sort((a, b) => (b.quoteVolume || 0) - (a.quoteVolume || 0));

            if (topN > 0) {
                merged = merged.slice(0, topN);
                logLine(`상위 ${topN}개만 스캔하도록 제한됨`);
            }

            const total = merged.length;
            elProgressText.textContent = `0 / ${total}`;

            const workerFn = async (item) => {
                if (scanAbort.aborted) throw new Error("aborted");

                const r = await scanSymbol(item.symbol, interval, limit, triplet, scanAbort);

                return {
                    symbol: item.symbol,
                    quoteVolume: item.quoteVolume,
                    lastPrice: item.lastPrice,
                    priceChangePercent: item.priceChangePercent,
                    streak: r.streak || 0,
                    maOrderStreak: r.maOrderStreak || 0,
                    failBarsAgo: Number.isFinite(r.failBarsAgo) ? r.failBarsAgo : null
                };
            };

            const results = await runPool(
                merged,
                workerFn,
                concurrency,
                (done, tot) => {
                    elProgressText.textContent = `${done} / ${tot}`;
                },
                scanAbort
            );

            if (scanAbort.aborted) {
                setStatus("중지됨");
                logLine("스캔이 중지되었습니다.");
                return;
            }

            // streak >= 1만 필터링
            const hits = results
                .filter((r) => r && !r.error && (r.streak || 0) >= 1)
                .sort((a, b) => {
                    // ✅ 1) FAIL 봉이 가까운 순 (failBarsAgo 오름차순)
                    // failBarsAgo가 null이면 뒤로 보냄
                    const fa = Number.isFinite(a.failBarsAgo) ? a.failBarsAgo : Number.POSITIVE_INFINITY;
                    const fb = Number.isFinite(b.failBarsAgo) ? b.failBarsAgo : Number.POSITIVE_INFINITY;

                    if (fa !== fb) return fa - fb;

                    // ✅ 2) 동률이면 거래량(24h quoteVolume) 내림차순
                    const va = a.quoteVolume || 0;
                    const vb = b.quoteVolume || 0;
                    if (va !== vb) return vb - va;

                    return String(a.symbol).localeCompare(String(b.symbol));
                });

            elResultCount.textContent = String(hits.length);
            renderResults(hits);

            const endedAt = new Date();
            const sec = Math.round((endedAt.getTime() - startedAt.getTime()) / 1000);
            setStatus("완료");
            logLine(`===== 스캔 완료: ${hits.length}개 발견 / 소요 ${sec}s =====`);
        } catch (e) {
            const msg = String(e && e.message ? e.message : e);
            if (msg === "aborted") {
                setStatus("중지됨");
                logLine("스캔이 중지되었습니다.");
            } else {
                setStatus("오류");
                logLine(`❌ 오류: ${msg}`);
                alert("스캔 중 오류가 발생했습니다.\n\n" + msg);
            }
        } finally {
            scanInProgress = false;
            elBtnScan.disabled = false;
            elBtnStop.disabled = true;
        }
    }

    function stopScan() {
        if (!scanInProgress) return;
        scanAbort.aborted = true;
        setStatus("중지 요청...");
        logLine("중지 요청됨");
    }

    elBtnScan.addEventListener("click", () => startScan("manual"));
    elBtnStop.addEventListener("click", stopScan);

    scheduleNextAutoScan();
    logLine("대기 중... (다음 자동스캔 시간은 상단에 표시됨)");
})();
</script>
</body>
</html>
