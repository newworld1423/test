<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binance USDT Perp 1m MA Streak Scanner (00/15/30/45 Auto)</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0b0f17;
            --panel: #111827;
            --panel2: #0f172a;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --line: rgba(255, 255, 255, 0.08);
            --good: rgba(16, 185, 129, 0.18);
            --bad: rgba(239, 68, 68, 0.18);
            --chip: rgba(255, 255, 255, 0.06);
            --shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Pretendard, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
            background: radial-gradient(1200px 800px at 20% 10%, rgba(59, 130, 246, 0.18), transparent 60%),
                        radial-gradient(1200px 800px at 80% 20%, rgba(16, 185, 129, 0.14), transparent 60%),
                        var(--bg);
            color: var(--text);
        }
        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 18px;
        }
        .header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 14px;
            margin-bottom: 12px;
        }
        .title {
            font-size: 18px;
            font-weight: 800;
            letter-spacing: -0.2px;
            margin: 0;
        }
        .sub {
            margin: 6px 0 0;
            color: var(--muted);
            font-size: 12px;
            line-height: 1.4;
        }
        .panel {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border: 1px solid var(--line);
            border-radius: 16px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        .controls {
            display: grid;
            grid-template-columns: 1.3fr 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.18);
            border-bottom: 1px solid var(--line);
        }
        .control {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }
        label {
            font-size: 11px;
            color: var(--muted);
        }
        input, select, button {
            border-radius: 12px;
            border: 1px solid var(--line);
            background: rgba(0, 0, 0, 0.25);
            color: var(--text);
            padding: 10px 10px;
            outline: none;
            font-size: 13px;
        }
        input::placeholder { color: rgba(156, 163, 175, 0.7); }
        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        button {
            cursor: pointer;
            font-weight: 700;
            background: rgba(59, 130, 246, 0.18);
        }
        button:hover { filter: brightness(1.08); }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .statusBar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--line);
        }
        .chips {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .chip {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: var(--chip);
            border: 1px solid var(--line);
            color: var(--text);
        }
        .chip b { color: #fff; }
        .log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            color: var(--muted);
            padding: 10px 12px;
            border-bottom: 1px solid var(--line);
            white-space: pre-wrap;
            line-height: 1.45;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        thead th {
            position: sticky;
            top: 0;
            background: rgba(15, 23, 42, 0.92);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--line);
            font-size: 12px;
            color: var(--muted);
            text-align: left;
            padding: 10px 12px;
            z-index: 1;
        }
        tbody td {
            border-bottom: 1px solid var(--line);
            padding: 10px 12px;
            font-size: 13px;
            vertical-align: middle;
        }
        tbody tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }
        .right { text-align: right; }
        .muted { color: var(--muted); }
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: rgba(0, 0, 0, 0.2);
            font-size: 12px;
        }
        .badge.good { background: var(--good); }
        .badge.bad { background: var(--bad); }
        a {
            color: #93c5fd;
            text-decoration: none;
        }
        a:hover { text-decoration: underline; }

        @media (max-width: 980px) {
            .controls {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="header">
        <div>
            <h1 class="title">Binance USDT 무기한(Perp) 1분봉 MA 연속조건 스캐너</h1>
            <p class="sub">
                이전봉부터 역순으로 <b>7MA &gt; 25MA &gt; 99MA</b> AND <b>종가 &gt; 7MA</b> 조건이
                끊기기 전까지 연속 개수(streak)를 계산합니다. 결과는 <b>최근 24h quoteVolume(USDT) 내림차순</b>.
            </p>
        </div>
        <div class="row">
            <button id="btnScan">지금 스캔</button>
            <button id="btnStop" disabled>중지</button>
        </div>
    </div>

    <div class="panel">
        <div class="controls">
            <div class="control">
                <label>인터벌</label>
                <select id="interval">
                    <option value="1m" selected>1m</option>
                    <option value="3m">3m</option>
                    <option value="5m">5m</option>
                    <option value="15m">15m</option>
                </select>
            </div>
            <div class="control">
                <label>MA(단기/중기/장기)</label>
                <input id="maTriplet" type="text" value="7,25,99" />
            </div>
            <div class="control">
                <label>kline limit (최대 연속체크 길이 상한)</label>
                <input id="klineLimit" type="number" min="120" max="1500" step="10" value="300" />
            </div>
            <div class="control">
                <label>동시요청수(낮출수록 안정)</label>
                <input id="concurrency" type="number" min="1" max="12" step="1" value="6" />
            </div>
            <div class="control">
                <label>상위 N개만 스캔(0=전체)</label>
                <input id="topN" type="number" min="0" max="1000" step="10" value="0" />
            </div>
        </div>

        <div class="statusBar">
            <div class="chips">
                <div class="chip">자동스캔: <b>매시 00/15/30/45</b></div>
                <div class="chip">다음 스캔: <b id="nextRun">-</b></div>
                <div class="chip">상태: <b id="statusText">대기</b></div>
                <div class="chip">진행: <b id="progressText">0 / 0</b></div>
                <div class="chip">결과: <b id="resultCount">0</b></div>
            </div>
            <div class="chips">
                <div class="chip">마지막 스캔: <b id="lastRun">-</b></div>
            </div>
        </div>

        <div class="log" id="log"></div>

        <div style="overflow:auto; max-height: 70vh;">
            <table>
                <thead>
                <tr>
                    <th style="width:70px;">#</th>
                    <th>심볼</th>
                    <th class="right">streak</th>
                    <th class="right">24h quoteVolume (USDT)</th>
                    <th class="right">마지막가격</th>
                    <th class="right">24h 변동률</th>
                    <th class="right">링크</th>
                </tr>
                </thead>
                <tbody id="tbody">
                <tr>
                    <td colspan="7" class="muted" style="padding:16px 12px;">스캔을 실행하면 결과가 표시됩니다.</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
(function () {
    "use strict";

    const API = "https://fapi.binance.com";

    const $ = (sel) => document.querySelector(sel);

    const elBtnScan = $("#btnScan");
    const elBtnStop = $("#btnStop");
    const elInterval = $("#interval");
    const elMaTriplet = $("#maTriplet");
    const elKlineLimit = $("#klineLimit");
    const elConcurrency = $("#concurrency");
    const elTopN = $("#topN");

    const elNextRun = $("#nextRun");
    const elLastRun = $("#lastRun");
    const elStatusText = $("#statusText");
    const elProgressText = $("#progressText");
    const elResultCount = $("#resultCount");
    const elLog = $("#log");
    const elTbody = $("#tbody");

    let cachedSymbols = null;      // USDT PERP symbol list
    let scanAbort = { aborted: false };
    let scanInProgress = false;
    let timerId = null;

    function logLine(s) {
        const t = new Date();
        const hh = String(t.getHours()).padStart(2, "0");
        const mm = String(t.getMinutes()).padStart(2, "0");
        const ss = String(t.getSeconds()).padStart(2, "0");
        elLog.textContent = `[${hh}:${mm}:${ss}] ${s}\n` + elLog.textContent;
    }

    function setStatus(s) {
        elStatusText.textContent = s;
    }

    function fmtNum(n, digits = 0) {
        if (!Number.isFinite(n)) return "-";
        return n.toLocaleString(undefined, {
            minimumFractionDigits: digits,
            maximumFractionDigits: digits
        });
    }

    function parseTriplet(text) {
        const parts = String(text || "")
            .split(",")
            .map((v) => parseInt(v.trim(), 10))
            .filter((v) => Number.isFinite(v) && v > 0);

        if (parts.length !== 3) return null;

        // short, mid, long
        return parts;
    }

    async function fetchJson(url, { signal, retry = 4 } = {}) {
        let attempt = 0;
        let lastErr = null;

        while (attempt <= retry) {
            if (signal && signal.aborted) throw new Error("aborted");

            try {
                const res = await fetch(url, { method: "GET", cache: "no-store" });
                if (!res.ok) {
                    const code = res.status;

                    // 418/429: backoff
                    if (code === 418 || code === 429 || code === 503) {
                        const waitMs = Math.min(20000, 800 * Math.pow(2, attempt));
                        logLine(`⚠️ ${code} 응답 - ${waitMs}ms 후 재시도: ${url}`);
                        await new Promise((r) => setTimeout(r, waitMs));
                        attempt += 1;
                        continue;
                    }

                    const text = await res.text().catch(() => "");
                    throw new Error(`HTTP ${code}: ${text.slice(0, 180)}`);
                }

                return await res.json();
            } catch (e) {
                lastErr = e;
                const waitMs = Math.min(12000, 600 * Math.pow(2, attempt));
                logLine(`⚠️ 네트워크 오류 - ${waitMs}ms 후 재시도: ${String(e && e.message ? e.message : e)}`);
                await new Promise((r) => setTimeout(r, waitMs));
                attempt += 1;
            }
        }

        throw lastErr || new Error("fetchJson failed");
    }

    async function loadPerpUsdtSymbolsOnce() {
        if (cachedSymbols) return cachedSymbols;

        setStatus("심볼 목록 로드...");
        logLine("exchangeInfo 로드 중...");
        const info = await fetchJson(`${API}/fapi/v1/exchangeInfo`);

        const list = (info && info.symbols ? info.symbols : [])
            .filter((s) =>
                s &&
                s.quoteAsset === "USDT" &&
                s.contractType === "PERPETUAL" &&
                s.status === "TRADING"
            )
            .map((s) => s.symbol);

        cachedSymbols = list;
        logLine(`USDT PERP 심볼 ${list.length}개 로드 완료`);
        return list;
    }

    async function loadAllTickers24hMap() {
        logLine("24h ticker 로드 중...");
        const tickers = await fetchJson(`${API}/fapi/v1/ticker/24hr`);
        const map = new Map();

        for (const t of (tickers || [])) {
            if (!t || !t.symbol) continue;
            const quoteVolume = parseFloat(t.quoteVolume);
            const lastPrice = parseFloat(t.lastPrice);
            const priceChangePercent = parseFloat(t.priceChangePercent);

            map.set(t.symbol, {
                quoteVolume: Number.isFinite(quoteVolume) ? quoteVolume : 0,
                lastPrice: Number.isFinite(lastPrice) ? lastPrice : NaN,
                priceChangePercent: Number.isFinite(priceChangePercent) ? priceChangePercent : NaN
            });
        }

        return map;
    }

    function calcSMA(closes, period) {
        const n = closes.length;
        const out = new Array(n).fill(null);
        let sum = 0;

        for (let i = 0; i < n; i++) {
            sum += closes[i];

            if (i >= period) {
                sum -= closes[i - period];
            }

            if (i >= period - 1) {
                out[i] = sum / period;
            }
        }

        return out;
    }

    function calcStreakFromPreviousClosedCandle(klines, ma7, ma25, ma99) {
        const n = klines.length;
        if (n < 120) return 0;

        // Binance 마지막 kline은 진행 중일 수 있으니 "이전봉" = n-2부터 검사
        let idx = n - 2;
        let streak = 0;

        for (; idx >= 0; idx--) {
            const close = parseFloat(klines[idx][4]);
            const a = ma7[idx];
            const b = ma25[idx];
            const c = ma99[idx];

            // MA가 계산 안 되는 구간(초반)이면 종료
            if (a === null || b === null || c === null) break;

            // 조건: 7MA > 25MA > 99MA && close > 7MA
            if (a > b && b > c && close > a) {
                streak += 1;
            } else {
                break;
            }
        }

        return streak;
    }

    async function scanSymbol(symbol, interval, limit, triplet, signal) {
        const [p7, p25, p99] = triplet;

        const url = `${API}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`;
        const klines = await fetchJson(url, { signal });

        if (!Array.isArray(klines) || klines.length < p99 + 5) {
            return { symbol, streak: 0 };
        }

        const closes = klines.map((k) => parseFloat(k[4]));

        const maA = calcSMA(closes, p7);
        const maB = calcSMA(closes, p25);
        const maC = calcSMA(closes, p99);

        const streak = calcStreakFromPreviousClosedCandle(klines, maA, maB, maC);

        return { symbol, streak };
    }

    async function runPool(items, workerFn, concurrency, onProgress, signal) {
        const results = [];
        let idx = 0;
        let done = 0;

        async function worker() {
            while (true) {
                if (signal && signal.aborted) return;

                const myIdx = idx;
                idx += 1;
                if (myIdx >= items.length) return;

                const item = items[myIdx];
                try {
                    const r = await workerFn(item);
                    results[myIdx] = r;
                } catch (e) {
                    results[myIdx] = { error: true, message: String(e && e.message ? e.message : e), item };
                } finally {
                    done += 1;
                    if (onProgress) onProgress(done, items.length);
                }
            }
        }

        const workers = [];
        const c = Math.max(1, Math.min(concurrency, 32));
        for (let i = 0; i < c; i++) {
            workers.push(worker());
        }
        await Promise.all(workers);

        return results;
    }

    function renderResults(rows) {
        elTbody.innerHTML = "";

        if (!rows.length) {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td colspan="7" class="muted" style="padding:16px 12px;">조건(streak &gt;= 1)을 만족하는 심볼이 없습니다.</td>`;
            elTbody.appendChild(tr);
            return;
        }

        rows.forEach((r, i) => {
            const tr = document.createElement("tr");

            const badgeCls = r.streak >= 10 ? "good" : (r.streak >= 1 ? "good" : "bad");
            const link = `https://www.binance.com/en/futures/${encodeURIComponent(r.symbol)}`;

            tr.innerHTML = `
                <td class="muted">${i + 1}</td>
                <td>
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <span style="font-weight:800;">${r.symbol}</span>
                        <span class="badge ${badgeCls}">streak <b>${r.streak}</b></span>
                    </div>
                </td>
                <td class="right" style="font-weight:800;">${fmtNum(r.streak)}</td>
                <td class="right">${fmtNum(r.quoteVolume, 0)}</td>
                <td class="right">${Number.isFinite(r.lastPrice) ? fmtNum(r.lastPrice, 6) : "-"}</td>
                <td class="right">${Number.isFinite(r.priceChangePercent) ? fmtNum(r.priceChangePercent, 2) + "%" : "-"}</td>
                <td class="right"><a href="${link}" target="_blank" rel="noreferrer">Futures</a></td>
            `;
            elTbody.appendChild(tr);
        });
    }

    function computeNextQuarterTime(now = new Date()) {
        // 다음 00/15/30/45 "정각" 시점(+0초 기준). 이미 정각이면 다음 구간으로.
        const d = new Date(now.getTime());
        d.setMilliseconds(0);

        const minute = d.getMinutes();
        const second = d.getSeconds();

        const remainder = minute % 15;
        let addMin = (remainder === 0 && second === 0) ? 15 : (15 - remainder);

        // 예: 12:00:10이면 addMin=15, 하지만 초는 0으로 맞추기 위해 분 올리고 초 0으로
        d.setSeconds(0);
        d.setMinutes(minute + addMin);

        return d;
    }

    function scheduleNextAutoScan() {
        if (timerId) {
            clearTimeout(timerId);
            timerId = null;
        }

        const now = new Date();
        const next = computeNextQuarterTime(now);
        const diff = Math.max(0, next.getTime() - now.getTime());

        elNextRun.textContent = next.toLocaleString();

        timerId = setTimeout(async () => {
            // 스캔 중이면 다음으로 넘김
            if (!scanInProgress) {
                await startScan("auto");
            } else {
                logLine("자동스캔 시점이지만 현재 스캔 진행 중이라 건너뜀");
            }
            scheduleNextAutoScan();
        }, diff);
    }

    async function startScan(trigger = "manual") {
        if (scanInProgress) {
            logLine("이미 스캔 중입니다.");
            return;
        }

        const triplet = parseTriplet(elMaTriplet.value);
        if (!triplet) {
            alert("MA(단기/중기/장기)를 '7,25,99' 형식으로 입력해주세요.");
            return;
        }

        const interval = elInterval.value;
        const limit = Math.max(120, Math.min(1500, parseInt(elKlineLimit.value, 10) || 300));
        const concurrency = Math.max(1, Math.min(12, parseInt(elConcurrency.value, 10) || 6));
        const topN = Math.max(0, Math.min(2000, parseInt(elTopN.value, 10) || 0));

        scanAbort = { aborted: false };
        scanInProgress = true;

        elBtnScan.disabled = true;
        elBtnStop.disabled = false;

        setStatus(trigger === "auto" ? "자동 스캔 중..." : "스캔 중...");
        elProgressText.textContent = "0 / 0";
        elResultCount.textContent = "0";

        const startedAt = new Date();
        elLastRun.textContent = startedAt.toLocaleString();
        logLine(`===== 스캔 시작 (${trigger}) interval=${interval}, MA=${triplet.join("/")}, limit=${limit}, concurrency=${concurrency} =====`);

        try {
            const symbols = await loadPerpUsdtSymbolsOnce();
            const tickerMap = await loadAllTickers24hMap();

            // 심볼 + 24h volume 결합
            let merged = symbols
                .map((sym) => {
                    const t = tickerMap.get(sym) || { quoteVolume: 0, lastPrice: NaN, priceChangePercent: NaN };
                    return {
                        symbol: sym,
                        quoteVolume: t.quoteVolume,
                        lastPrice: t.lastPrice,
                        priceChangePercent: t.priceChangePercent
                    };
                })
                .sort((a, b) => (b.quoteVolume || 0) - (a.quoteVolume || 0));

            if (topN > 0) {
                merged = merged.slice(0, topN);
                logLine(`상위 ${topN}개만 스캔하도록 제한됨`);
            }

            const total = merged.length;
            elProgressText.textContent = `0 / ${total}`;

            const workerFn = async (item) => {
                if (scanAbort.aborted) throw new Error("aborted");
                const r = await scanSymbol(item.symbol, interval, limit, triplet, scanAbort);
                return {
                    symbol: item.symbol,
                    quoteVolume: item.quoteVolume,
                    lastPrice: item.lastPrice,
                    priceChangePercent: item.priceChangePercent,
                    streak: r.streak || 0
                };
            };

            const results = await runPool(
                merged,
                workerFn,
                concurrency,
                (done, tot) => {
                    elProgressText.textContent = `${done} / ${tot}`;
                },
                scanAbort
            );

            if (scanAbort.aborted) {
                setStatus("중지됨");
                logLine("스캔이 중지되었습니다.");
                return;
            }

            // 조건 만족(streak >= 1)만 필터
            const hits = results
                .filter((r) => r && !r.error && (r.streak || 0) >= 1)
                .sort((a, b) => (b.quoteVolume || 0) - (a.quoteVolume || 0));

            elResultCount.textContent = String(hits.length);
            renderResults(hits);

            const endedAt = new Date();
            const sec = Math.round((endedAt.getTime() - startedAt.getTime()) / 1000);
            setStatus("완료");
            logLine(`===== 스캔 완료: ${hits.length}개 발견 / 소요 ${sec}s =====`);
        } catch (e) {
            const msg = String(e && e.message ? e.message : e);
            if (msg === "aborted") {
                setStatus("중지됨");
                logLine("스캔이 중지되었습니다.");
            } else {
                setStatus("오류");
                logLine(`❌ 오류: ${msg}`);
                alert("스캔 중 오류가 발생했습니다.\n\n" + msg);
            }
        } finally {
            scanInProgress = false;
            elBtnScan.disabled = false;
            elBtnStop.disabled = true;
        }
    }

    function stopScan() {
        if (!scanInProgress) return;
        scanAbort.aborted = true;
        setStatus("중지 요청...");
        logLine("중지 요청됨");
    }

    elBtnScan.addEventListener("click", () => startScan("manual"));
    elBtnStop.addEventListener("click", stopScan);

    // 시작 시 자동 스케줄 설정 + 즉시 1회 실행은 원하면 주석 해제
    scheduleNextAutoScan();
    logLine("대기 중... (다음 자동스캔 시간은 상단에 표시됨)");

    // 원하면 페이지 로드 후 바로 1회 스캔:
    // startScan("manual");
})();
</script>
</body>
</html>
