<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ USDT â€” ê±°ë˜ëŸ‰ ê¸‰ì¦ ìŠ¤ìºë„ˆ (Pro / MTF / RSI / ADX)</title>
    <style>
        :root {
            --bg: #0b0c0f; --card:#161a23; --muted:#8b92a6; --text:#e8ebf1;
            --pos:#1db954; --neg:#ff4d4f; --accent:#6ea8fe; --warn:#ffb020;
        }
        * { box-sizing: border-box; }
        body { margin: 0; background: var(--bg); color: var(--text); font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Arial; }
        header { padding: 22px 18px 10px; max-width: 1280px; margin: 0 auto; }
        h1 { margin: 0 0 8px; font-size: 20px; }
        .muted { color: var(--muted); }
        .wrap { max-width: 1280px; margin: 0 auto; padding: 12px 18px 28px; }

        .panel { background: var(--card); border: 1px solid #1f2430; border-radius: 16px; padding: 14px; }
        .grid { display: grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap: 10px; }
        .grid .item { display: flex; flex-direction: column; gap: 6px; }
        label { font-size: 12px; color: var(--muted); }
        select, input, button {
            width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #2a3140;
            background: #0f1218; color: var(--text);
        }
        button.primary { background: var(--accent); border-color: var(--accent); color: #0b0c0f; font-weight: 600; }
        button.ghost { background: transparent; border-color: #2a3140; }

        .toolbar { display: flex; gap: 10px; margin-top: 12px; align-items: center; }
        .status { margin-left: auto; font-size: 12px; color: var(--muted); display: flex; align-items: center; gap: 8px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--warn); display: inline-block; }

        table { width: 100%; border-collapse: collapse; margin-top: 14px; }
        thead th {
            position: sticky; top: 0; background: #121621; z-index: 1;
            text-align: left; font-weight: 600; font-size: 12px; color: var(--muted);
            padding: 10px 8px; border-bottom: 1px solid #232a3a; cursor: pointer;
        }
        tbody td { padding: 10px 8px; border-bottom: 1px solid #1f2430; font-variant-numeric: tabular-nums; }
        tbody tr:hover { background: #121621; }
        .pill { font-size: 12px; padding: 3px 8px; border-radius: 999px; background: #0f1218; border: 1px solid #2a3140; }
        .good { color: var(--pos); }
        .bad  { color: var(--neg); }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
        .note { margin-top: 10px; color: var(--muted); font-size: 12px; }

        @media (max-width: 1100px) {
            .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .toolbar { flex-direction: column; align-items: stretch; }
            .status { margin: 0; }
        }
    </style>
</head>
<body>
<header>
    <h1>ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ USDT â€” ê±°ë˜ëŸ‰ ê¸‰ì¦ ìŠ¤ìºë„ˆ (Pro)</h1>
    <div class="muted">100% ê¸‰ë“±í˜• ì”¨ì•— íƒìƒ‰ ê¸°ë³¸ + ì—°ì† ìŠ¤íŒŒì´í¬ ê°€ì¤‘ì¹˜ + RSI/ADX + MTF í•©ì„± ì ìˆ˜. (quoteVolume=USD)</div>
</header>

<div class="wrap">
    <div class="panel">
        <div class="grid" style="margin-bottom:10px">
            <div class="item" style="grid-column: span 3;">
                <label>í”„ë¦¬ì…‹ (Profiles)</label>
                <select id="preset">
                    <option value="seed100" selected>ğŸ”¥ 100% ê¸‰ë“±í˜• ì”¨ì•— (5m / N20 / Ã—8 / â‰¥$100k / Top150 / 20s)</option>
                    <option value="scalp">âš¡ ì´ˆë‹¨íƒ€ ìŠ¤ìº˜í•‘ (1m / N40 / Ã—6 / â‰¥$80k / Top80 / 12s)</option>
                    <option value="day15">âœ… 15m ë‹¨íƒ€ (15m / N30 / Ã—4 / â‰¥$300k / Top100 / 45s)</option>
                    <option value="intraday1h">ğŸ• ì¸íŠ¸ë¼ë°ì´ (1h / N24 / Ã—3 / â‰¥$1.5M / Top60 / 180s)</option>
                </select>
            </div>
            <div class="item">
                <label>&nbsp;</label>
                <label style="display:flex;align-items:center;gap:8px;">
                    <input id="autoScanOnPreset" type="checkbox" checked />
                    ì ìš© ì¦‰ì‹œ ìŠ¤ìº”
                </label>
            </div>
            <div class="item">
                <label>&nbsp;</label>
                <button id="applyPresetBtn" class="ghost">í”„ë¦¬ì…‹ ì ìš©</button>
            </div>
        </div>

        <div class="grid">
            <div class="item">
                <label>ê¸°ë³¸ ê°„ê²© (Base Interval)</label>
                <select id="interval">
                    <option value="1m">1m</option>
                    <option value="5m" selected>5m</option>
                    <option value="15m">15m</option>
                    <option value="1h">1h</option>
                </select>
            </div>
            <div class="item">
                <label>ê¸°ì¤€ êµ¬ê°„ N (ì§ì „ Në´‰ í‰ê· )</label>
                <input id="lookback" type="number" min="5" max="200" step="1" value="20" />
            </div>
            <div class="item">
                <label>ìŠ¤íŒŒì´í¬ ë°°ìˆ˜ (í˜„ì¬ë´‰ Ã· í‰ê·  â‰¥)</label>
                <input id="threshold" type="number" min="1" max="50" step="0.1" value="8" />
            </div>
            <div class="item">
                <label>ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ USD (í˜„ì¬ë´‰ quoteVolume)</label>
                <input id="minQuoteUSD" type="number" min="0" step="1000" value="100000" />
            </div>
            <div class="item">
                <label>ìƒìœ„ ë…¸ì¶œ ê°œìˆ˜ (Top N)</label>
                <input id="topN" type="number" min="5" max="300" step="1" value="150" />
            </div>
            <div class="item">
                <label>ìë™ ê°±ì‹  (ì´ˆ)</label>
                <input id="refreshSec" type="number" min="0" step="1" value="20" />
            </div>
        </div>

        <div class="grid" style="margin-top:8px">
            <div class="item">
                <label>MTF ì‚¬ìš© (5m/15m/1h)</label>
                <select id="mtfMode">
                    <option value="on" selected>ì‚¬ìš©</option>
                    <option value="off">ì‚¬ìš© ì•ˆ í•¨</option>
                </select>
            </div>
            <div class="item">
                <label>ì§€í‘œ ê¸°ê°„ (RSI/ADX)</label>
                <input id="indPeriod" type="number" min="7" max="30" step="1" value="14" />
            </div>
            <div class="item">
                <label>ì—°ì† ìŠ¤íŒŒì´í¬ ê°€ì¤‘ì¹˜</label>
                <select id="streakWeighting">
                    <option value="std" selected>í‘œì¤€(ìµœê·¼ 3ë´‰)</option>
                    <option value="off">ì‚¬ìš© ì•ˆ í•¨</option>
                </select>
            </div>
            <div class="item">
                <label>ì ìˆ˜ ê°€ì¤‘ (ìŠ¤íŒŒì´í¬/MTF/ì§€í‘œ)</label>
                <input id="weights" type="text" value="0.6,0.25,0.15" />
                <small class="muted">ì˜ˆ: 0.6,0.25,0.15 (í•© 1)</small>
            </div>
            <div class="item">
                <label>&nbsp;</label>
                <label style="display:flex;align-items:center;gap:8px;">
                    <input id="strictFilter" type="checkbox" />
                    ì—„ê²© í•„í„°(ë¹„ì •ìƒ ê³ ì €í­ ì»·)
                </label>
            </div>
            <div class="item">
                <label>&nbsp;</label>
                <button id="scanBtn" class="primary">ìŠ¤ìº”</button>
            </div>
        </div>

        <div class="toolbar">
            <button id="stopBtn" class="ghost">ìë™ ê°±ì‹  ì¤‘ì§€</button>
            <div class="status">
                <span class="dot" id="dot"></span>
                <span id="status">ëŒ€ê¸°</span>
            </div>
        </div>

        <div class="note">
            â€¢ ìŠ¤íŒŒì´í¬ ë¹„ìœ¨ = <span class="mono">í˜„ì¬ë´‰ quoteVolume(USD) / ì§ì „ Në´‰ í‰ê·  quoteVolume</span>  
            â€¢ ì—°ì† ìŠ¤íŒŒì´í¬: ìµœê·¼ 3ë´‰ ì¤‘ ì„ê³„ì¹˜ í†µê³¼ ê°œìˆ˜(0~3)ì— ë”°ë¼ ê°€ì .  
            â€¢ RSI/ADXëŠ” ê¸°ë³¸ ê°„ê²©ì—ì„œ ê³„ì‚° (ì§€í‘œ ê¸°ê°„ ê¸°ë³¸ 14).  
            â€¢ MTF í•©ì„±: ê¸°ë³¸(5m) + 15m + 1hì—ì„œ ì¶”ì„¸/ìŠ¤íŒŒì´í¬ ì‹ í˜¸ë¥¼ ìŠ¤ì½”ì–´ë§.  
            â€¢ â€œì ìˆ˜ ê°€ì¤‘â€ì€ [ìŠ¤íŒŒì´í¬, MTF, ì§€í‘œ] ìˆœì…ë‹ˆë‹¤.
        </div>
    </div>

    <table id="result">
        <thead>
            <tr>
                <th data-sort="symbol">ì‹¬ë³¼</th>
                <th data-sort="score">ìµœì¢…ì ìˆ˜</th>
                <th data-sort="ratio">ìŠ¤íŒŒì´í¬Ã—</th>
                <th data-sort="streak">ì—°ì†</th>
                <th data-sort="nowQ">í˜„ì¬ë´‰ USD</th>
                <th data-sort="avgQ">í‰ê·  USD</th>
                <th data-sort="rsi">RSI</th>
                <th data-sort="adx">ADX</th>
                <th data-sort="mtf">MTFì ìˆ˜</th>
                <th data-sort="chg">í˜„ì¬ë´‰ %</th>
                <th data-sort="price">í˜„ì¬ê°€</th>
                <th data-sort="time">ì¢…ê°€ì‹œê°„</th>
                <th>ë§í¬</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<script>
    // ====================== ê¸°ë³¸ ì„¤ì • ======================
    const FAPI = 'https://fapi.binance.com';
    const EXCHANGE_INFO_URL = FAPI + '/fapi/v1/exchangeInfo';
    const KLINES_URL = FAPI + '/fapi/v1/klines';
    const CONCURRENCY = 6;              // Pro: MTFê¹Œì§€ ì¡°íšŒí•˜ë¯€ë¡œ ë™ì‹œì„± ì•½ê°„ ë‚®ì¶¤
    const RETRY = 2;
    const TIMEOUT_MS = 12000;

    const PRESETS = {
        seed100: { label: '100% ê¸‰ë“±í˜•', interval: '5m', lookback: 20, threshold: 8, minQuoteUSD: 100000, topN: 150, refreshSec: 20 },
        scalp:   { label: 'ì´ˆë‹¨íƒ€ ìŠ¤ìº˜í•‘', interval: '1m', lookback: 40, threshold: 6, minQuoteUSD: 80000,  topN: 80,  refreshSec: 12 },
        day15:   { label: '15m ë‹¨íƒ€',    interval: '15m', lookback: 30, threshold: 4, minQuoteUSD: 300000, topN: 100, refreshSec: 45 },
        intraday1h: { label: '1h ì¸íŠ¸ë¼ë°ì´', interval: '1h', lookback: 24, threshold: 3, minQuoteUSD: 1500000, topN: 60, refreshSec: 180 }
    };

    // ====================== DOM ======================
    const $preset = document.getElementById('preset');
    const $autoScanOnPreset = document.getElementById('autoScanOnPreset');
    const $applyPresetBtn = document.getElementById('applyPresetBtn');

    const $interval = document.getElementById('interval');
    const $lookback = document.getElementById('lookback');
    const $threshold = document.getElementById('threshold');
    const $minQuoteUSD = document.getElementById('minQuoteUSD');
    const $topN = document.getElementById('topN');
    const $refreshSec = document.getElementById('refreshSec');

    const $mtfMode = document.getElementById('mtfMode');
    const $indPeriod = document.getElementById('indPeriod');
    const $streakWeighting = document.getElementById('streakWeighting');
    const $weights = document.getElementById('weights');
    const $strictFilter = document.getElementById('strictFilter');

    const $scanBtn = document.getElementById('scanBtn');
    const $stopBtn = document.getElementById('stopBtn');
    const $tbody = document.querySelector('#result tbody');
    const $status = document.getElementById('status');
    const $dot = document.getElementById('dot');

    let autoTimer = null;
    let abortAll = null;

    // ====================== ìœ í‹¸ ======================
    function setStatus(text, busy = false) {
        $status.textContent = text;
        $dot.style.background = busy ? '#5fd4fb' : '#ffb020';
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function withTimeout(promise, ms, label = 'timeout') {
        let timer;
        const t = new Promise((_, rej) => { timer = setTimeout(() => rej(new Error(label)), ms); });
        return Promise.race([promise, t]).finally(() => clearTimeout(timer));
    }
    async function safeFetch(url, opts = {}, tries = RETRY) {
        for (let i = 0; i <= tries; i++) {
            try {
                return await withTimeout(fetch(url, opts), TIMEOUT_MS, 'request-timeout');
            } catch (e) {
                if (i === tries) throw e;
                await sleep(200 + i * 400);
            }
        }
    }
    function sum(arr) { return arr.reduce((a,b)=>a+b,0); }
    function ema(values, period) {
        if (values.length < period) return [];
        const k = 2 / (period + 1);
        const out = [];
        let emaPrev = values.slice(0, period).reduce((a,b)=>a+b,0) / period;
        out[period - 1] = emaPrev;
        for (let i = period; i < values.length; i++) {
            emaPrev = values[i] * k + emaPrev * (1 - k);
            out[i] = emaPrev;
        }
        return out;
    }
    function rsiFromCloses(closes, period = 14) {
        if (closes.length < period + 1) return null;
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const diff = closes[i] - closes[i-1];
            if (diff >= 0) gains += diff; else losses -= diff;
        }
        let avgGain = gains / period, avgLoss = losses / period;
        for (let i = period + 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i-1];
            avgGain = (avgGain * (period - 1) + Math.max(diff,0)) / period;
            avgLoss = (avgLoss * (period - 1) + Math.max(-diff,0)) / period;
        }
        const rs = avgLoss === 0 ? 100 : avgGain / (avgLoss || 1e-9);
        const rsi = 100 - (100 / (1 + rs));
        return rsi;
    }
    function adxFromOHLC(ohlc, period = 14) {
        // ohlc: [{high, low, close}, ...] ìµœì‹  ìˆœì´ ì•„ë‹ˆë¼ ì˜¤ë¦„ì°¨ìˆœì´ì–´ì•¼ í•¨ (ìš°ë¦¬ëŠ” ë°°ì—´ì´ ì˜¤ë˜ëœ->ìµœì‹  ìˆœ)
        if (ohlc.length < period + 1) return null;
        const tr = [], plusDM = [], minusDM = [];
        for (let i = 1; i < ohlc.length; i++) {
            const h = ohlc[i].high, l = ohlc[i].low, cPrev = ohlc[i-1].close;
            const upMove = h - ohlc[i-1].high;
            const downMove = ohlc[i-1].low - l;
            tr.push(Math.max(h - l, Math.abs(h - cPrev), Math.abs(l - cPrev)));
            plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        // Wilder smoothing
        function wilderSMA(arr, p) {
            const out = [];
            let s = sum(arr.slice(0, p));
            out[p-1] = s;
            for (let i = p; i < arr.length; i++) {
                s = out[i-1] - (out[i-1] / p) + arr[i];
                out[i] = s;
            }
            return out;
        }
        const trN = wilderSMA(tr, period);
        const pDMN = wilderSMA(plusDM, period);
        const mDMN = wilderSMA(minusDM, period);
        const adxArr = [];
        for (let i = period - 1; i < trN.length; i++) {
            const pDI = 100 * (pDMN[i] / trN[i]);
            const mDI = 100 * (mDMN[i] / trN[i]);
            const dx = 100 * (Math.abs(pDI - mDI) / Math.max(pDI + mDI, 1e-9));
            adxArr.push(dx);
        }
        if (adxArr.length < period) return null;
        // Smooth DX to ADX
        let adx = sum(adxArr.slice(0, period)) / period;
        for (let i = period; i < adxArr.length; i++) {
            adx = (adx * (period - 1) + adxArr[i]) / period;
        }
        return adx;
    }

    // ====================== ë°ì´í„° ì¡°íšŒ ======================
    async function fetchFuturesUSDTPerpSymbols() {
        const res = await safeFetch(EXCHANGE_INFO_URL);
        const json = await res.json();
        return json.symbols
            .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT' && s.status === 'TRADING')
            .map(s => s.symbol);
    }
    async function fetchKlines(symbol, interval, limit) {
        const url = `${KLINES_URL}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await safeFetch(url);
        const arr = await res.json();
        return Array.isArray(arr) ? arr : null;
    }

    // ====================== ìŠ¤íŒŒì´í¬/ì§€í‘œ/MTF ê³„ì‚° ======================
    function calcSpikeMetrics(klines, lookback, threshold, strictFilter) {
        if (!klines || klines.length < lookback + 3) return null;
        const last = klines[klines.length - 1];
        const prevSlice = klines.slice(klines.length - 1 - lookback, klines.length - 1);

        // í’ˆì§ˆ: í‰ê·  êµ¬ê°„ ì¤‘ 0 USD ìº”ë“¤ ê³¼ë‹¤ ì‹œ ì»·
        const nonZeroPrev = prevSlice.filter(c => parseFloat(c[7]) > 0);
        if (nonZeroPrev.length < Math.max(5, Math.floor(lookback * 0.6))) return null;

        const nowQ = parseFloat(last[7]);
        const avgQ = prevSlice.reduce((a, c) => a + parseFloat(c[7]), 0) / prevSlice.length;
        const ratio = avgQ > 0 ? nowQ / avgQ : 0;

        const open = parseFloat(last[1]);
        const close = parseFloat(last[4]);
        const chgPct = open > 0 ? ((close - open) / open) * 100 : 0;

        if (strictFilter) {
            const high = parseFloat(last[2]), low = parseFloat(last[3]);
            if (open > 0 && (high - low) / open > 0.25) return null; // ê³¼ê²©í•œ ìŠ¤í”„ë ˆë“œ ì»·
        }

        // ì—°ì† ìŠ¤íŒŒì´í¬(ìµœê·¼ 3ë´‰)
        let streak = 0;
        const back = klines.slice(-4, -1); // ë§ˆì§€ë§‰ ì§ì „ 3ë´‰
        for (const c of back) {
            const q = parseFloat(c[7]);
            const win = klines.slice(klines.indexOf(c) - lookback, klines.indexOf(c));
            if (win.length === lookback) {
                const avg = win.reduce((a, x) => a + parseFloat(x[7]), 0) / lookback;
                if (avg > 0 && q / avg >= threshold) streak++;
            }
        }

        return { nowQ, avgQ, ratio, chgPct, open, close, streak };
    }

    function calcRSIADX(klines, period) {
        if (!klines || klines.length < period + 2) return { rsi: null, adx: null };
        const closes = klines.map(k => parseFloat(k[4]));
        const ohlc = klines.map(k => ({ high: parseFloat(k[2]), low: parseFloat(k[3]), close: parseFloat(k[4]) }));
        const rsi = rsiFromCloses(closes, period);
        const adx = adxFromOHLC(ohlc, period);
        return { rsi, adx };
    }

    async function calcMTF(symbol, baseInterval, lookback, threshold, strictFilter) {
        // ê¸°ë³¸ + 15m + 1h ìŠ¤ì½”ì–´ (ê°„ë‹¨ ê°€ì¤‘ í‰ê· )
        const intervals = ['15m', '1h'];
        const out = [];
        for (const itv of intervals) {
            const kl = await fetchKlines(symbol, itv, Math.max(lookback + 6, 40));
            const spike = calcSpikeMetrics(kl, Math.min(lookback, 30), Math.max(2, threshold - 2), strictFilter);
            if (!spike) { out.push(0); continue; }
            // ê°„ë‹¨í•œ ìƒíƒœ ì ìˆ˜: ratio ì •ê·œí™” + chgPct/5 ì œí•œ + streak(0~3) * 0.2
            const r = Math.min(spike.ratio / (threshold - 2), 2.5);
            const m = Math.max(-1, Math.min(1, (spike.chgPct / 5)));
            const s = (spike.streak || 0) * 0.2;
            out.push(Math.max(0, r * 0.7 + m * 0.2 + s * 0.1));
        }
        // í‰ê·  (0~ì•½ 2.5 ì‚¬ì´)
        const mtfScore = out.length ? out.reduce((a,b)=>a+b,0) / out.length : 0;
        return mtfScore;
    }

    // ìµœì¢… ì ìˆ˜ ì‚°ì‹
    function finalScore(spikeRatio, streak, rsi, adx, mtfScore, weights) {
        // ìŠ¤íŒŒì´í¬ ì ìˆ˜: ratioë¥¼ threshold ëŒ€ë¹„ë¡œ ì •ê·œí™”, ì—°ì† ê°€ì¤‘
        const spikeBase = Math.max(0, Math.min(3, spikeRatio)); // 0~3 ìº¡
        const streakBonus = (streak || 0) * 0.25;              // 0~0.75
        const spikeScore = spikeBase + streakBonus;            // ~0~3.75

        // ì§€í‘œ ì ìˆ˜: RSI 55~70 ìš°ëŒ€, 80â†‘ í˜ë„í‹°; ADX 20~35 ìš°ëŒ€, 50â†‘ ê³¼ì—´ í˜ë„í‹°
        let rsiScore = 0;
        if (rsi != null) {
            if (rsi >= 50 && rsi <= 75) rsiScore = (rsi - 50) / 25; // 0~1
            else if (rsi > 80) rsiScore = 0.2;                      // ê³¼ì—´
            else if (rsi < 35) rsiScore = 0.1;                      // ì•½í•¨
            else rsiScore = 0.4;
        }
        let adxScore = 0;
        if (adx != null) {
            if (adx >= 18 && adx <= 40) adxScore = (adx - 18) / 22; // 0~1
            else if (adx > 55) adxScore = 0.3;                      // ê³¼ì—´
            else if (adx < 15) adxScore = 0.1;                      // ì•½í•¨
            else adxScore = 0.5;
        }
        const indiScore = (rsiScore * 0.5) + (adxScore * 0.5);      // 0~1

        // MTF ì ìˆ˜(0~ì•½ 2.5)ë¥¼ 0~1ë¡œ ì••ì¶•
        const mtfNorm = Math.min(1, mtfScore / 2.0);

        const [wSpike, wMTF, wInd] = weights; // í•© 1 ê°€ì •
        return wSpike * spikeScore + wMTF * mtfNorm + wInd * indiScore;
    }

    // ====================== ë™ì‹œì„± ì²˜ë¦¬ ======================
    async function mapLimit(items, limit, worker) {
        const ret = [];
        let i = 0;
        const exec = async () => {
            while (true) {
                const idx = i++;
                if (idx >= items.length) return;
                try {
                    const v = await worker(items[idx], idx);
                    ret[idx] = v;
                } catch (e) {
                    ret[idx] = null;
                }
            }
        };
        const tasks = Array.from({ length: limit }, exec);
        await Promise.all(tasks);
        return ret;
    }

    // ====================== ìŠ¤ìº” ë£¨í‹´ ======================
    async function scan() {
        if (abortAll) { try { abortAll.abort(); } catch(e){} }
        abortAll = new AbortController();

        const interval = $interval.value;
        const lookback = Math.max(5, parseInt($lookback.value || '20', 10));
        const threshold = parseFloat($threshold.value || '8');
        const minQuoteUSD = parseFloat($minQuoteUSD.value || '100000');
        const topN = Math.max(1, parseInt($topN.value || '150', 10));
        const refreshSec = Math.max(0, parseInt($refreshSec.value || '20', 10));
        const mtfOn = $mtfMode.value === 'on';
        const indPeriod = Math.max(7, parseInt($indPeriod.value || '14', 10));
        const streakMode = $streakWeighting.value;
        const strictFilter = $strictFilter.checked;

        // ê°€ì¤‘ì¹˜ íŒŒì‹±
        let w = [0.6, 0.25, 0.15];
        try {
            const parts = ($weights.value || '0.6,0.25,0.15').split(',').map(x => parseFloat(x.trim()));
            if (parts.length === 3 && parts.every(x => Number.isFinite(x))) {
                const s = parts[0] + parts[1] + parts[2];
                if (s > 0) w = parts.map(x => x / s);
            }
        } catch {}

        setStatus('ì‹¬ë³¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦', true);
        let symbols = [];
        try {
            symbols = await fetchFuturesUSDTPerpSymbols();
        } catch (e) {
            setStatus('ì‹¬ë³¼ ì¡°íšŒ ì‹¤íŒ¨: ' + e.message, false);
            return;
        }

        setStatus(`ì´ ${symbols.length}ê°œ ì‹¬ë³¼ ìŠ¤ìº” ì¤‘â€¦ (${interval}, N=${lookback})`, true);

        const results = await mapLimit(symbols, CONCURRENCY, async (sym) => {
            try {
                // ê¸°ë³¸ ê°„ê²© Kë¼ì¸
                const baseK = await fetchKlines(sym, interval, Math.max(lookback + 20, 60));
                const spike = calcSpikeMetrics(baseK, lookback, threshold, strictFilter);
                if (!spike) return null;
                if (spike.nowQ < minQuoteUSD) return null;
                if (spike.ratio < threshold) return null;

                // ì—°ì† ìŠ¤íŒŒì´í¬ ê°€ì¤‘ì¹˜
                const streak = (streakMode === 'std') ? (spike.streak || 0) : 0;

                // ì§€í‘œ
                const { rsi, adx } = calcRSIADX(baseK, indPeriod);

                // MTF
                let mtfScore = 0;
                if (mtfOn) {
                    mtfScore = await calcMTF(sym, interval, lookback, threshold, strictFilter);
                }

                // ìµœì¢… ì ìˆ˜
                const ratioNorm = Math.min(3, spike.ratio / threshold); // threshold ëŒ€ë¹„ 3ë°° ìº¡
                const score = finalScore(ratioNorm, streak, rsi, adx, mtfScore, w);

                const last = baseK[baseK.length - 1];
                const price = parseFloat(last[4]);
                const closeTime = last[6];

                return {
                    symbol: sym,
                    score,
                    ratio: spike.ratio,
                    streak,
                    nowQ: spike.nowQ,
                    avgQ: spike.avgQ,
                    rsi,
                    adx,
                    mtfScore,
                    chgPct: spike.chgPct,
                    price,
                    closeTime
                };
            } catch (e) {
                return null;
            }
        });

        const list = results.filter(Boolean)
            .sort((a, b) => b.score - a.score)
            .slice(0, topN);

        render(list);
        setStatus(`ì™„ë£Œ: ${list.length}ê°œ ê°ì§€`, false);

        // ìë™ ê°±ì‹ 
        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        if (refreshSec > 0) {
            autoTimer = setInterval(scan, Math.max(5, refreshSec) * 1000);
            setStatus(`ìë™ ê°±ì‹  ${Math.max(5, refreshSec)}ì´ˆ`, true);
        }
    }

    // ====================== ë Œë” & ì •ë ¬ ======================
    function render(rows) {
        const fmt0 = new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 });
        const fmt2 = new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 });
        const fmt6 = new Intl.NumberFormat('en-US', { maximumFractionDigits: 6 });
        const toTime = (t) => new Date(t).toLocaleString();

        $tbody.innerHTML = rows.map(r => {
            const cls = r.chgPct >= 0 ? 'good' : 'bad';
            const tv = `https://www.tradingview.com/chart/?symbol=BINANCE:${r.symbol}`;
            const bi = `https://www.binance.com/en/futures/${r.symbol}`;
            return `
                <tr>
                    <td class="mono">${r.symbol}</td>
                    <td><span class="pill">${fmt2.format(r.score)}</span></td>
                    <td class="mono">${fmt2.format(r.ratio)}Ã—</td>
                    <td class="mono">${r.streak}</td>
                    <td class="mono">$${fmt0.format(r.nowQ)}</td>
                    <td class="mono">$${fmt0.format(r.avgQ)}</td>
                    <td class="mono">${r.rsi == null ? '-' : fmt2.format(r.rsi)}</td>
                    <td class="mono">${r.adx == null ? '-' : fmt2.format(r.adx)}</td>
                    <td class="mono">${fmt2.format(r.mtfScore)}</td>
                    <td class="${cls} mono">${fmt2.format(r.chgPct)}%</td>
                    <td class="mono">${fmt6.format(r.price)}</td>
                    <td class="mono">${toTime(r.closeTime)}</td>
                    <td>
                        <a href="${tv}" target="_blank" rel="noopener">TV</a> Â·
                        <a href="${bi}" target="_blank" rel="noopener">Binance</a>
                    </td>
                </tr>
            `;
        }).join('');
    }

    let sortKey = 'score';
    let sortDir = 'desc';
    document.querySelectorAll('thead th[data-sort]').forEach(th => {
        th.addEventListener('click', () => {
            const key = th.getAttribute('data-sort');
            if (sortKey === key) sortDir = (sortDir === 'asc') ? 'desc' : 'asc';
            else { sortKey = key; sortDir = 'desc'; }

            const rows = Array.from($tbody.querySelectorAll('tr')).map(tr => {
                const tds = tr.querySelectorAll('td');
                const money = (s) => parseFloat(s.replace(/[$,]/g, '')) || 0;
                return {
                    symbol: tds[0].textContent.trim(),
                    score: parseFloat(tds[1].innerText) || 0,
                    ratio: parseFloat(tds[2].innerText) || 0,
                    streak: parseFloat(tds[3].innerText) || 0,
                    nowQ: money(tds[4].innerText),
                    avgQ: money(tds[5].innerText),
                    rsi: tds[6].innerText === '-' ? null : parseFloat(tds[6].innerText),
                    adx: tds[7].innerText === '-' ? null : parseFloat(tds[7].innerText),
                    mtf: parseFloat(tds[8].innerText) || 0,
                    chgPct: parseFloat(tds[9].innerText) || 0,
                    price: parseFloat(tds[10].innerText.replace(/,/g,'')) || 0,
                    time: tds[11].textContent.trim(),
                    links: tds[12].innerHTML
                };
            });
            rows.sort((a,b) => {
                if (a[sortKey] < b[sortKey]) return sortDir === 'asc' ? -1 : 1;
                if (a[sortKey] > b[sortKey]) return sortDir === 'asc' ? 1 : -1;
                return 0;
            });
            $tbody.innerHTML = rows.map(r => {
                return `
                    <tr>
                        <td class="mono">${r.symbol}</td>
                        <td><span class="pill">${r.score.toFixed(2)}</span></td>
                        <td class="mono">${r.ratio.toFixed(2)}Ã—</td>
                        <td class="mono">${r.streak}</td>
                        <td class="mono">$${r.nowQ.toLocaleString()}</td>
                        <td class="mono">$${r.avgQ.toLocaleString()}</td>
                        <td class="mono">${r.rsi == null ? '-' : r.rsi.toFixed(2)}</td>
                        <td class="mono">${r.adx == null ? '-' : r.adx.toFixed(2)}</td>
                        <td class="mono">${r.mtf.toFixed(2)}</td>
                        <td class="mono">${r.chgPct.toFixed(2)}%</td>
                        <td class="mono">${r.price.toLocaleString()}</td>
                        <td class="mono">${r.time}</td>
                        <td>${r.links}</td>
                    </tr>
                `;
            }).join('');
        });
    });

    // ====================== í”„ë¦¬ì…‹ ì ìš© & ìë™ ======================
    function applyPreset(key, andScan = false) {
        const p = PRESETS[key] || PRESETS.seed100;
        $interval.value = p.interval;
        $lookback.value = p.lookback;
        $threshold.value = p.threshold;
        $minQuoteUSD.value = p.minQuoteUSD;
        $topN.value = p.topN;
        $refreshSec.value = p.refreshSec;

        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        if (andScan) {
            scan();
            const sec = parseInt($refreshSec.value || '0', 10);
            if (sec > 0) {
                autoTimer = setInterval(scan, Math.max(5, sec) * 1000);
                setStatus(`ìë™ ê°±ì‹  ${Math.max(5, sec)}ì´ˆ`, true);
            }
        }
    }
    document.getElementById('applyPresetBtn').addEventListener('click', () => {
        applyPreset($preset.value, $autoScanOnPreset.checked);
    });
    $preset.addEventListener('change', () => {
        applyPreset($preset.value, $autoScanOnPreset.checked);
    });

    $scanBtn.addEventListener('click', () => {
        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        scan();
        const sec = parseInt($refreshSec.value || '0', 10);
        if (sec > 0) {
            autoTimer = setInterval(scan, Math.max(5, sec) * 1000);
            setStatus(`ìë™ ê°±ì‹  ${Math.max(5, sec)}ì´ˆ`, true);
        }
    });
    $stopBtn.addEventListener('click', () => {
        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        setStatus('ìë™ ê°±ì‹  ì¤‘ì§€', false);
    });

    // ì´ˆê¸° ì‹¤í–‰
    applyPreset('seed100', true);
    setStatus('ëŒ€ê¸°', false);
</script>
</body>
</html>
