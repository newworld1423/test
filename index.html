<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Binance USDT 무기한 선물 스캐너</title>

  <!-- technicalindicators 라이브러리(지표 계산) -->
  <script src="https://cdn.jsdelivr.net/npm/technicalindicators@3.0.5/dist/browser.js"></script>

  <style>
    body {
      font-family: "Noto Sans KR", sans-serif;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    #scanButton {
      padding: 8px 16px;
      font-size: 16px;
      background-color: #0072e3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #scanButton:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    #status {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      font-size: 14px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: center;
    }
    th {
      background-color: #f2f2f2;
    }
    <style>
      tr:nth-child(even) {
        background-color: #fafafa;
      }
      tr:hover {
        background-color: #f1f7ff;
      }
    </style>
  </style>
</head>

<body>
  <h1>Binance USDT 무기한 선물 스캐너</h1>
  <p>
    <button id="scanButton">지금 스캔하기</button>
    <span id="status">대기 중...</span>
  </p>

  <table id="resultTable">
    <thead>
      <tr>
        <th>순번</th>
        <th>심볼</th>
        <th>시장 타입</th>
        <th>신호</th>
        <th>EMA9</th>
        <th>EMA21</th>
        <th>ADX</th>
        <th>RSI</th>
        <th>BB 상단</th>
        <th>BB 하단</th>
        <th>Stoch %K</th>
        <th>Stoch %D</th>
      </tr>
    </thead>
    <tbody>
      <!-- 결과가 이곳에 삽입됩니다 -->
    </tbody>
  </table>

  <script>
    (function () {
      // 1) 전역 변수 및 유틸 함수 정의
      const scanButton = document.getElementById("scanButton");
      const statusSpan = document.getElementById("status");
      const tbody = document.querySelector("#resultTable tbody");

      let lastScanDate = null; // 자동 실행 일자 체크용

      // sleep: async/await로 딜레이를 줄 때 사용
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      // 현재 KST 시각 문자열 (YYYY-MM-DD) 리턴
      function getCurrentKSTDateString() {
        // JS Date는 브라우저 로케일 기준이므로, 한국(Asia/Seoul)에 맞춰 timeZone 옵션을 줍니다
        const now = new Date();
        const kstString = now.toLocaleString("ko-KR", { timeZone: "Asia/Seoul" });
        const [datePart] = kstString.split(" ");
        // "YYYY.MM.DD. 오후/오전 hh:mm:ss" 형태 → Date 객체에서 직접 YYYY-MM-DD 파싱하기보다
        // toISOString을 활용하는 편이 안전하지만, 여긴 로컬타임을 기준으로 함
        // 간단히 ISOString 후 KST 오프셋 보정 없이 날짜만 쓰겠습니다.
        const kstNow = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
        return kstNow.toISOString().slice(0, 10); // "2025-06-05" 형태
      }

      // 현재 KST 시각의 시,분 가져오기
      function getCurrentKSTHourMinute() {
        const now = new Date();
        const kstNow = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
        return { hour: kstNow.getHours(), minute: kstNow.getMinutes() };
      }

      // 2) 메인 스캔 로직
      async function scanAllSymbols() {
        // 버튼 비활성화, 상태 메시지 변경
        scanButton.disabled = true;
        statusSpan.textContent = "스캔 중...";

        // 테이블 초기화
        tbody.innerHTML = "";

        try {
          // 2-1) 바이낸스 USDT 무기한 선물 심볼 리스트 가져오기
          const exchangeInfoRes = await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo");
          if (!exchangeInfoRes.ok) {
            throw new Error("exchangeInfo 요청 실패");
          }
          const exchangeInfo = await exchangeInfoRes.json();
          // symbols 객체 중 contractType이 PERPETUAL이고, 심볼 문자열 끝이 "USDT"인 것만 필터
          const allSymbols = exchangeInfo.symbols
            .filter((s) => s.contractType === "PERPETUAL" && s.symbol.endsWith("USDT") && s.status === "TRADING")
            .map((s) => s.symbol);

          // 2-2) 심볼별로 데이터 조회 → 지표 계산 → 테이블에 추가
          for (let i = 0; i < allSymbols.length; i++) {
            const symbol = allSymbols[i];
            try {
              const info = await analyzeSymbol(symbol, 30);
              // 테이블 row 삽입
              if (info) {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                  <td>${i + 1}</td>
                  <td>${info.symbol}</td>
                  <td>${info.marketType}</td>
                  <td>${info.signal}</td>
                  <td>${info.EMA9 ?? "-"}</td>
                  <td>${info.EMA21 ?? "-"}</td>
                  <td>${info.ADX ?? "-"}</td>
                  <td>${info.RSI ?? "-"}</td>
                  <td>${info.BB_UPPER ?? "-"}</td>
                  <td>${info.BB_LOWER ?? "-"}</td>
                  <td>${info.STOCH_K ?? "-"}</td>
                  <td>${info.STOCH_D ?? "-"}</td>
                `;
                tbody.appendChild(tr);
              }
            } catch (err) {
              console.error(symbol, err);
              // 오류가 난 심볼은 건너뜀
            }
            // 레이트 리밋 회피용 짧은 딜레이 (200ms)
            await sleep(200);
          }

          statusSpan.textContent = `스캔 완료 (${allSymbols.length}개 심볼 처리)`;
        } catch (err) {
          console.error(err);
          statusSpan.textContent = "에러 발생: " + err.message;
        } finally {
          scanButton.disabled = false;
        }
      }

      // 3) 심볼 단위 분석 함수 (지표 계산 및 신호 생성)
      async function analyzeSymbol(symbol, lookback) {
        // 3-1) 일봉 K선 가져오기 (limit = lookback + 여유분)
        const limit = lookback + 10;
        const klinesRes = await fetch(
          `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=${limit}`
        );
        if (!klinesRes.ok) {
          throw new Error(`Klines 요청 실패 (${symbol})`);
        }
        const klines = await klinesRes.json();
        if (!Array.isArray(klines) || klines.length < lookback) {
          throw new Error(`${symbol} 일봉 데이터 부족`);
        }

        // 3-2) 데이터 파싱 → 배열 생성
        // klines 배열: [ [ openTime, open, high, low, close, volume, closeTime, ... ], ... ]
        const N = klines.length;
        const closes = klines.map((c) => parseFloat(c[4]));
        const highs = klines.map((c) => parseFloat(c[2]));
        const lows = klines.map((c) => parseFloat(c[3]));
        // 직전(전날) 값 인덱스
        const prevIdx = N - 2;
        const lastIdx = N - 1;

        // 3-3) 지표 계산 (technicalindicators)
        // EMA(9), EMA(21)
        const ema9Arr = technicalindicators.EMA.calculate({ period: 9, values: closes });
        const ema21Arr = technicalindicators.EMA.calculate({ period: 21, values: closes });
        if (ema9Arr.length < 2 || ema21Arr.length < 2) {
          // 계산 불충분하면 패스
          return null;
        }
        const lastEma9 = round(ema9Arr[ema9Arr.length - 1], 3);
        const prevEma9 = round(ema9Arr[ema9Arr.length - 2], 3);
        const lastEma21 = round(ema21Arr[ema21Arr.length - 1], 3);
        const prevEma21 = round(ema21Arr[ema21Arr.length - 2], 3);

        // ADX(14) → 입력: high, low, close
        const adxArr = technicalindicators.ADX.calculate({
          period: 14,
          high: highs,
          low: lows,
          close: closes,
        });
        if (adxArr.length < 2) {
          return null;
        }
        const lastAdx = round(adxArr[adxArr.length - 1].adx, 3);
        const prevAdx = round(adxArr[adxArr.length - 2].adx, 3);

        // RSI(14)
        const rsiArr = technicalindicators.RSI.calculate({ period: 14, values: closes });
        if (rsiArr.length < 1) {
          return null;
        }
        const lastRsi = round(rsiArr[rsiArr.length - 1], 3);

        // Bollinger Bands (BB) (period: 20, stdDev: 2)
        const bbArr = technicalindicators.BollingerBands.calculate({
          period: 20,
          values: closes,
          stdDev: 2,
        });
        if (bbArr.length < 2) {
          return null;
        }
        // BB 배열 객체: { lower: ..., middle: ..., upper: ... }
        const lastBb = bbArr[bbArr.length - 1];
        const prevBb = bbArr[bbArr.length - 2];
        const lastBbUpper = round(lastBb.upper, 3);
        const lastBbLower = round(lastBb.lower, 3);
        const prevBbUpper = round(prevBb.upper, 3);
        const prevBbLower = round(prevBb.lower, 3);

        // Stochastic (period:14, signalPeriod:3)
        const stochArr = technicalindicators.Stochastic.calculate({
          period: 14,
          signalPeriod: 3,
          high: highs,
          low: lows,
          close: closes,
        });
        if (stochArr.length < 2) {
          return null;
        }
        // stochArr 요소: { k: ..., d: ... }
        const lastStochK = round(stochArr[stochArr.length - 1].k, 3);
        const lastStochD = round(stochArr[stochArr.length - 1].d, 3);
        const prevStochK = round(stochArr[stochArr.length - 2].k, 3);
        const prevStochD = round(stochArr[stochArr.length - 2].d, 3);

        // 3-4) 시장 타입 판단 및 진입 신호 생성
        const prevClose = closes[prevIdx];
        const lastClose = closes[lastIdx];
        const prevHigh = highs[prevIdx];
        const prevLow = lows[prevIdx];
        const lastHigh = highs[lastIdx];
        const lastLow = lows[lastIdx];

        let marketType = "";
        let signal = "WAIT";

        if (lastAdx >= 25) {
          // --- (1) 강한 추세장 ---
          if (lastEma9 > lastEma21) {
            // 상승 추세장 (Uptrend)
            marketType = "Uptrend";
            // 롱 진입 조건: 전일 종가 < 전일 EMA9 && 당일 종가 > 당일 EMA9
            if (prevClose < prevEma9 && lastClose > lastEma9) {
              signal = "LONG";
            }
          } else if (lastEma9 < lastEma21) {
            // 하락 추세장 (Downtrend)
            marketType = "Downtrend";
            // 숏 진입 조건: 전일 종가 > 전일 EMA9 && 당일 종가 < 당일 EMA9
            if (prevClose > prevEma9 && lastClose < lastEma9) {
              signal = "SHORT";
            }
          } else {
            marketType = "Trend(NoDir)";
            signal = "WAIT";
          }
        } else {
          // --- (2) 횡보장 (ADX < 25) ---
          marketType = "Ranging";
          // 횡보장 롱 진입 조건: BB 하단 터치 + RSI<30 + Stoch 과매도 골든 크로스
          const longCond =
            prevLow <= prevBbLower &&
            lastLow <= lastBbLower &&
            lastRsi < 30 &&
            lastStochK < 20 &&
            lastStochK > lastStochD;
          // 횡보장 숏 진입 조건: BB 상단 터치 + RSI>70 + Stoch 과매수 데드 크로스
          const shortCond =
            prevHigh >= prevBbUpper &&
            lastHigh >= lastBbUpper &&
            lastRsi > 70 &&
            lastStochK > 80 &&
            lastStochK < lastStochD;

          if (longCond) {
            signal = "LONG";
          } else if (shortCond) {
            signal = "SHORT";
          } else {
            signal = "WAIT";
          }
        }

        return {
          symbol,
          marketType,
          signal,
          EMA9: lastEma9,
          EMA21: lastEma21,
          ADX: lastAdx,
          RSI: lastRsi,
          BB_UPPER: lastBbUpper,
          BB_LOWER: lastBbLower,
          STOCH_K: lastStochK,
          STOCH_D: lastStochD,
        };
      }

      // 반올림 유틸 함수
      function round(num, digits) {
        return Math.round((num + Number.EPSILON) * Math.pow(10, digits)) / Math.pow(10, digits);
      }

      // 4) 버튼 클릭 이벤트 바인딩
      scanButton.addEventListener("click", scanAllSymbols);

      // 5) 자동 스케줄러: 매 분 확인하여 KST 09:00에 스캔 실행
      setInterval(() => {
        const { hour, minute } = getCurrentKSTHourMinute();
        const today = getCurrentKSTDateString();
        // 오전 9시 정각에, 아직 오늘 스캔을 한 번도 하지 않았다면 실행
        if (hour === 9 && minute === 0 && lastScanDate !== today) {
          lastScanDate = today;
          scanAllSymbols();
        }
        // 다음 날 자정(00:00) 지나면 lastScanDate 초기화 (다음 스캔을 위해)
        if (hour === 0 && minute === 0) {
          lastScanDate = null;
        }
      }, 60 * 1000); // 매 1분마다 체크
    })();
  </script>
</body>
</html>
