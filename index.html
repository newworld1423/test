<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT-PERP 스캐너 (1분/15분 선택)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif; }
        body { margin: 20px; }
        .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
        label { font-size: 14px; }
        input, select, button { padding: 8px 10px; font-size: 14px; }
        button { cursor: pointer; }
        .muted { color: #666; font-size: 13px; }
        .log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; border: 1px solid #ddd; padding: 10px; border-radius: 8px; max-height: 180px; overflow: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 12px; }
        th, td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: right; }
        th:nth-child(1), td:nth-child(1) { text-align: left; position: sticky; left: 0; background: #fff; }
        tr:hover { background: #fafafa; }
        .badge { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #f1f5f9; font-size: 12px; }
        .controls { display: grid; grid-template-columns: repeat(8, minmax(120px, 1fr)); gap: 10px; margin-top: 12px; }
        @media (max-width: 900px) { .controls { grid-template-columns: 1fr 1fr; } }
    </style>
</head>
<body>
    <h1>USDT-PERP — EMA50 연속성 스캐너</h1>
    <div class="muted">타임프레임은 <strong>1분봉 / 15분봉</strong> 중 선택 가능합니다. 현재봉은 자동 제외하고 직전 200봉을 분석합니다.</div>

    <div class="controls">
        <label>타임프레임
            <select id="timeframe">
                <option value="1m">1분봉</option>
                <option value="15m" selected>15분봉</option>
            </select>
        </label>
        <label>EMA 기간
            <input id="emaPeriod" type="number" value="50" min="2">
        </label>
        <label>분석 봉 수
            <input id="lookback" type="number" value="200" min="50" max="1000">
        </label>
        <label>최소 ‘상단 연속’(A)
            <input id="minAbove" type="number" value="1" min="1" max="500">
        </label>
        <label>최소 ‘하단 연속’(B)
            <input id="minBelow" type="number" value="1" min="1" max="500">
        </label>
        <label>동시 요청(Throttle)
            <input id="concurrency" type="number" value="6" min="1" max="20">
        </label>
        <label>정렬
            <select id="sortBy">
                <option value="aboveDesc">상단 연속 ↓</option>
                <option value="belowDesc">하단 연속 ↓</option>
                <option value="recentCrossDesc">최근 교차시간 ↓</option>
                <option value="volDesc">24h 거래량(USDT) ↓</option>
                <option value="symbolAsc">심볼 ↑</option>
            </select>
        </label>
        <label>거래량 최소(USDT)
            <input id="minQuoteVol" type="number" value="0" min="0" step="1000000">
        </label>
    </div>

    <div class="row" style="margin-top:10px;">
        <button id="scanBtn">스캔 시작</button>
        <button id="stopBtn">중지</button>
        <button id="exportBtn">CSV 저장</button>
        <span id="status" class="badge">대기</span>
    </div>

    <div class="log" id="log" style="margin-top:10px;"></div>

    <table id="resultTable">
        <thead>
            <tr>
                <th>심볼</th>
                <th>상단 연속(A)</th>
                <th>하단 연속(B)</th>
                <th>교차시각(KST)</th>
                <th>최근 종가</th>
                <th>최근 EMA</th>
                <th>괴리(%)</th>
                <th>24h 거래량(USDT)</th>
                <th>데이터(봉)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

<script>
    const FAPI = 'https://fapi.binance.com';
    const logEl = document.getElementById('log');
    const tableBody = document.querySelector('#resultTable tbody');
    const statusEl = document.getElementById('status');
    let abortFlag = false;
    let lastResults = [];
    let volMap = new Map();

    function log(msg, type = 'info') {
        const prefix = type === 'error' ? '[ERR] ' : type === 'warn' ? '[WARN] ' : '';
        logEl.textContent += prefix + msg + '\n';
        logEl.scrollTop = logEl.scrollHeight;
    }

    function fmtNum(n, d = 4) {
        if (!isFinite(n)) return '-';
        return Number(n).toLocaleString(undefined, { maximumFractionDigits: d });
    }

    function humanUSDT(n) {
        if (!isFinite(n) || n == null) return '-';
        const abs = Math.abs(n);
        if (abs >= 1e9) return (n / 1e9).toFixed(2).replace(/\.00$/, '') + 'B';
        if (abs >= 1e6) return (n / 1e6).toFixed(2).replace(/\.00$/, '') + 'M';
        if (abs >= 1e3) return (n / 1e3).toFixed(2).replace(/\.00$/, '') + 'K';
        return Math.round(n).toString();
    }

    function toKST(ts) {
        const date = new Date(ts + (9 * 60 * 60 * 1000));
        return date.toISOString().replace('T', ' ').replace('.000Z', '');
    }

    async function fetchUSDTPerpSymbols() {
        const url = `${FAPI}/fapi/v1/exchangeInfo`;
        const res = await fetch(url);
        const json = await res.json();
        return json.symbols
            .filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING')
            .map(s => s.symbol).sort();
    }

    async function fetch24hAll() {
        const url = `${FAPI}/fapi/v1/ticker/24hr`;
        const res = await fetch(url);
        const arr = await res.json();
        const m = new Map();
        for (const t of arr) {
            if (t.symbol && t.quoteVolume) m.set(t.symbol, Number(t.quoteVolume));
        }
        return m;
    }

    async function fetchKlines(symbol, interval, limit) {
        const url = `${FAPI}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        return res.json();
    }

    function computeEMA(closes, period) {
        const ema = new Array(closes.length).fill(null);
        if (closes.length < period) return ema;
        let sum = 0;
        for (let i = 0; i < period; i++) sum += closes[i];
        let prev = sum / period;
        ema[period - 1] = prev;
        const k = 2 / (period + 1);
        for (let i = period; i < closes.length; i++) {
            const cur = closes[i] * k + prev * (1 - k);
            ema[i] = cur; prev = cur;
        }
        return ema;
    }

    function analyzeRuns(times, closes, ema, minAbove = 1, minBelow = 1) {
        const n = closes.length;
        if (n < 5) return null;
        const state = (i) => ema[i] == null ? 0 : closes[i] > ema[i] ? 1 : closes[i] < ema[i] ? -1 : 0;
        let i = n - 1;
        while (i >= 0 && state(i) === 0) i--;
        if (i < 0 || state(i) !== 1) return null;
        let aboveLen = 0, endAboveIdx = i;
        while (i >= 0 && state(i) === 1) { aboveLen++; i--; }
        while (i >= 0 && state(i) === 0) i--;
        let belowLen = 0, startBelowIdx = i;
        while (i >= 0 && state(i) === -1) { belowLen++; i--; }
        if (aboveLen >= minAbove && belowLen >= minBelow) {
            const crossIdx = startBelowIdx + 1;
            return {
                aboveLen, belowLen,
                crossTime: times[crossIdx] ?? times[0],
                lastClose: closes[endAboveIdx],
                lastEma: ema[endAboveIdx],
                gapPct: ((closes[endAboveIdx] - ema[endAboveIdx]) / ema[endAboveIdx]) * 100,
                dataPoints: n
            };
        }
        return null;
    }

    async function runWithConcurrency(items, limit, worker) {
        const results = [];
        let idx = 0, active = 0;
        return new Promise((resolve) => {
            const launchNext = () => {
                if (abortFlag) return resolve(results);
                while (active < limit && idx < items.length) {
                    const curIndex = idx++;
                    active++;
                    (async () => {
                        try { results[curIndex] = await worker(items[curIndex]); }
                        catch (e) { results[curIndex] = { error: e.message }; }
                        finally {
                            active--;
                            if (idx >= items.length && active === 0) resolve(results);
                            else launchNext();
                        }
                    })();
                }
            };
            launchNext();
        });
    }

    function render(results) {
        lastResults = results.filter(Boolean);
        const sortBy = document.getElementById('sortBy').value;
        const arr = [...lastResults];
        if (sortBy === 'aboveDesc') arr.sort((a,b)=>b.aboveLen-a.aboveLen||b.belowLen-a.belowLen);
        else if (sortBy === 'belowDesc') arr.sort((a,b)=>b.belowLen-a.belowLen||b.aboveLen-a.aboveLen);
        else if (sortBy === 'recentCrossDesc') arr.sort((a,b)=>b.crossTime-a.crossTime);
        else if (sortBy === 'volDesc') arr.sort((a,b)=>(b.quoteVolume??0)-(a.quoteVolume??0));
        else if (sortBy === 'symbolAsc') arr.sort((a,b)=>a.symbol.localeCompare(b.symbol));
        tableBody.innerHTML = '';
        for (const r of arr) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td><strong>${r.symbol}</strong></td>
                <td>${r.aboveLen}</td>
                <td>${r.belowLen}</td>
                <td>${toKST(r.crossTime)}</td>
                <td>${fmtNum(r.lastClose, 6)}</td>
                <td>${fmtNum(r.lastEma, 6)}</td>
                <td>${fmtNum(r.gapPct, 3)}</td>
                <td>${humanUSDT(r.quoteVolume)}</td>
                <td>${r.dataPoints}</td>
            `;
            tableBody.appendChild(tr);
        }
        statusEl.textContent = `결과: ${arr.length}개`;
    }

    async function scan() {
        abortFlag = false;
        tableBody.innerHTML = '';
        logEl.textContent = '';
        statusEl.textContent = '심볼/거래량 수집 중...';
        const interval = document.getElementById('timeframe').value; // ✅ 선택된 타임프레임
        const emaPeriod = parseInt(document.getElementById('emaPeriod').value, 10);
        const lookback = parseInt(document.getElementById('lookback').value, 10);
        const minAbove = parseInt(document.getElementById('minAbove').value, 10);
        const minBelow = parseInt(document.getElementById('minBelow').value, 10);
        const concurrency = parseInt(document.getElementById('concurrency').value, 10);
        const minQuoteVol = parseFloat(document.getElementById('minQuoteVol').value || '0');

        try {
            const symbols = await fetchUSDTPerpSymbols();
            volMap = await fetch24hAll();
            const filtered = symbols.filter(sym => (volMap.get(sym) ?? 0) >= minQuoteVol);
            statusEl.textContent = `${interval} 클라인 로딩 중... (${filtered.length}개)`;
            const limit = Math.max(lookback + 20, emaPeriod + 60);

            const worker = async (symbol) => {
                if (abortFlag) return null;
                const raw = await fetchKlines(symbol, interval, Math.min(1000, limit));
                if (!Array.isArray(raw) || raw.length < lookback + 1) return null;
                const sliced = raw.slice(0, -1);
                const tail = sliced.slice(-lookback);
                const times = tail.map(k => k[0]);
                const closes = tail.map(k => Number(k[4]));
                const ema = computeEMA(closes, emaPeriod);
                const hit = analyzeRuns(times, closes, ema, minAbove, minBelow);
                if (hit) return { symbol, quoteVolume: volMap.get(symbol) ?? 0, ...hit };
                return null;
            };

            const results = await runWithConcurrency(filtered, concurrency, worker);
            render(results.filter(r => r && !r.error));
        } catch (e) {
            log(e.message, 'error');
            statusEl.textContent = '오류';
        }
    }

    document.getElementById('scanBtn').addEventListener('click', scan);
    document.getElementById('stopBtn').addEventListener('click', () => { abortFlag = true; statusEl.textContent = '중지 요청'; });
    document.getElementById('exportBtn').addEventListener('click', () => { /* CSV 저장 로직 동일하게 넣을 수 있음 */ });
</script>
</body>
</html>