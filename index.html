<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT Perp Scanner (EMA50/200 + BB + Volume Spike)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; padding: 16px; }
        h1 { margin-top: 0; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap: 12px; margin-bottom: 16px; }
        label { display: block; font-weight: 600; margin-bottom: 4px; }
        input, select, button { width: 100%; padding: 8px 10px; box-sizing: border-box; }
        button { cursor: pointer; }
        .small { font-size: 12px; color: #666; }
        .row { display: flex; gap: 8px; align-items: center; }
        .badge { padding: 2px 6px; border-radius: 6px; font-size: 12px; display: inline-block; }
        .up { background:#e6f7ed; color:#0b8a49; border:1px solid #bce7cf; }
        .down { background:#fdeaea; color:#b60e0e; border:1px solid #f3c1c1; }
        .neutral { background:#eef1f6; color:#364152; border:1px solid #d7dce6; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: left; vertical-align: top; }
        th { position: sticky; top: 0; background: #fff; z-index: 1; }
        .muted { color:#6b7280; }
        .right { text-align: right; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
        .warn { color:#b45309; background:#fffbeb; border:1px solid #fde68a; padding:10px; border-radius:8px; margin:10px 0; }
        .ok { color:#065f46; background:#ecfdf5; border:1px solid #a7f3d0; padding:10px; border-radius:8px; margin:10px 0; }
        .grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
        .footer { margin-top: 16px; font-size: 12px; color:#6b7280; }
    </style>
</head>
<body>
    <h1>Binance USDT 무기한 선물 스캐너</h1>
    <p class="small">전략: 1시간봉 EMA50·200로 <b>추세 방향 단일</b> 거래 → 15분봉에서 <b>볼린저밴드 & 거래량 스파이크</b>로 진입 신호 탐지 (손절·리스크는 별도 관리)</p>

    <div class="controls">
        <div>
            <label>기본 타임프레임 (추세)</label>
            <select id="tfTrend">
                <option value="1h" selected>1h (권장)</option>
                <option value="4h">4h</option>
                <option value="2h">2h</option>
            </select>
            <div class="small">EMA50 vs EMA200로 추세 판단</div>
        </div>

        <div>
            <label>세부 타임프레임 (진입)</label>
            <select id="tfEntry">
                <option value="15m" selected>15m (권장)</option>
                <option value="5m">5m</option>
                <option value="30m">30m</option>
            </select>
            <div class="small">볼린저밴드·거래량 스파이크 신호</div>
        </div>

        <div>
            <label>볼린저밴드 기간</label>
            <input id="bbPeriod" type="number" min="10" value="20" />
            <div class="small">표준: 20 (표준편차 2)</div>
        </div>

        <div>
            <label>볼린저 표준편차</label>
            <input id="bbStd" type="number" step="0.1" value="2" />
        </div>

        <div>
            <label>거래량 스파이크 배수</label>
            <input id="volMult" type="number" step="0.1" value="2.0" />
            <div class="small">최근봉 거래량 ≥ 과거평균×배수</div>
        </div>

        <div>
            <label>최소 24h 거래대금(USDT)</label>
            <input id="minNotional24h" type="number" step="100000" value="5000000" />
            <div class="small">유동성 필터 (예: 5,000,000)</div>
        </div>

        <div>
            <label>스캔 범위</label>
            <select id="scanUniverse">
                <option value="all" selected>USDT Perp 전체</option>
                <option value="top">상위 유동성(상위 50)</option>
            </select>
        </div>

        <div class="row">
            <button id="run">스캔 실행</button>
            <button id="stop">정지</button>
        </div>
    </div>

    <div id="status" class="neutral badge">대기</div>
    <div id="note" class="warn">주의: 본 스캐너는 교육/연구용입니다. 신호=수익 보장 X. 반드시 손절·포지션 크기(1~2% 리스크)를 엄수하세요.</div>

    <table id="result">
        <thead>
            <tr>
                <th>심볼</th>
                <th>추세(1h)</th>
                <th>신호(15m)</th>
                <th class="right">최근봉 가격</th>
                <th class="right">24h 거래대금(USDT)</th>
                <th>근거</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div class="footer">
        데이터: Binance Futures API (공용). 과거 성과는 미래 수익을 보장하지 않습니다.
    </div>

<script>
    // ======== 유틸 ========
    async function sleep(ms) {
        return new Promise(res => setTimeout(res, ms));
    }
    function ema(values, period) {
        if (values.length < period) return [];
        const k = 2 / (period + 1);
        const out = [];
        // 초기값: SMA로 시드
        let sum = 0;
        for (let i = 0; i < period; i++) sum += values[i];
        let prev = sum / period;
        out.push(prev);
        for (let i = period; i < values.length; i++) {
            const cur = values[i] * k + prev * (1 - k);
            out.push(cur);
            prev = cur;
        }
        return out; // 길이: values.length - period + 1
    }
    function sma(values, period) {
        if (values.length < period) return [];
        const out = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
            sum += values[i];
            if (i >= period) sum -= values[i - period];
            if (i >= period - 1) out.push(sum / period);
        }
        return out;
    }
    function stdev(values, period) {
        const m = sma(values, period);
        const out = [];
        for (let i = 0; i < m.length; i++) {
            const start = i;
            const end = i + period;
            let s2 = 0;
            for (let j = start; j < end; j++) {
                const d = values[j] - m[i];
                s2 += d * d;
            }
            out.push(Math.sqrt(s2 / period));
        }
        return out;
    }
    function bollinger(values, period = 20, stdK = 2) {
        // values: 종가 배열
        const basis = sma(values, period);
        const sd = stdev(values, period);
        const upper = basis.map((b, i) => b + stdK * sd[i]);
        const lower = basis.map((b, i) => b - stdK * sd[i]);
        return { basis, upper, lower }; // 각 길이: values.length - period + 1
    }
    function avg(arr) {
        if (!arr.length) return 0;
        return arr.reduce((a,b)=>a+b,0) / arr.length;
    }
    function last(arr, n=1) {
        return arr.slice(-n)[0];
    }
    function toFixed(n, d=4) {
        return (n ?? 0).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: d });
    }

    // ======== Binance Futures REST ========
    const BASE = "https://fapi.binance.com";
    async function fetchJSON(url) {
        const r = await fetch(url);
        if (!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
        return r.json();
    }
    async function getPerpUSDTUniverse() {
        const info = await fetchJSON(`${BASE}/fapi/v1/exchangeInfo`);
        const symbols = info.symbols
            .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
            .map(s => s.symbol);
        return symbols;
    }
    async function get24hStats(symbols) {
        // /fapi/v1/ticker/24hr supports single or all; we'll use all then filter.
        const all = await fetchJSON(`${BASE}/fapi/v1/ticker/24hr`);
        const map = new Map();
        for (const t of all) {
            if (symbols.includes(t.symbol)) {
                map.set(t.symbol, t);
            }
        }
        return map;
    }
    async function getKlines(symbol, interval, limit=500) {
        // returns array of klines
        // [ openTime, open, high, low, close, volume, closeTime, quoteAssetVolume, trades, takerBuyBase, takerBuyQuote, ignore ]
        const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        return fetchJSON(url);
    }

    // ======== 시그널 로직 ========
    function trendByEMA(closes, periodFast=50, periodSlow=200) {
        if (closes.length < periodSlow + 5) return { trend: "neutral" };
        const ema50 = ema(closes, periodFast);
        const ema200 = ema(closes, periodSlow);
        // 길이 맞추기: 뒤쪽 기준으로 비교
        const shift = ema50.length - ema200.length;
        if (shift < 0) return { trend: "neutral" };
        const e50 = ema50.slice(shift);
        const e200 = ema200;
        const now50 = last(e50);
        const now200 = last(e200);
        if (now50 > now200) return { trend: "up", now50, now200 };
        if (now50 < now200) return { trend: "down", now50, now200 };
        return { trend: "neutral", now50, now200 };
    }

    function entrySignalBBVolume(closes, volumes, bbPeriod=20, bbStd=2, volMult=2.0) {
        // 최근 봉 기준: 볼린저 하단/상단 이탈 후 "복귀" + 거래량 스파이크
        if (closes.length < Math.max(bbPeriod+2, 30)) return { signal: "none" };
        const bb = bollinger(closes, bbPeriod, bbStd);
        const k = bb.basis.length; // 유효 인덱스 수
        // bb 시계열은 closes의 (closes.length - bbPeriod + 1) 길이
        // 이에 맞춰 최근 두 봉을 본다
        const cNow = last(closes);
        const cPrev = closes[closes.length - 2];
        const uNow = last(bb.upper);
        const lNow = last(bb.lower);
        const uPrev = bb.upper[bb.upper.length - 2];
        const lPrev = bb.lower[bb.lower.length - 2];

        // 거래량 스파이크: 최근봉 vs 과거 n개 평균 (n=20)
        const volWindow = 20;
        const recentVols = volumes.slice(-volWindow-1, -1); // 최근봉 직전 20개
        const vAvg = avg(recentVols);
        const vNow = last(volumes);
        const isVolSpike = vNow >= vAvg * volMult;

        // 복귀 패턴: 이전봉이 하단 이하이고 현재봉이 하단 위로 회복 → 롱
        const longBB = (cPrev < lPrev) && (cNow > lNow);
        // 반대로 상단 이상 → 현재 상단 아래 복귀 → 숏
        const shortBB = (cPrev > uPrev) && (cNow < uNow);

        if (longBB && isVolSpike) return { signal: "long", reason: "BB 하단 복귀 + 거래량 스파이크", vNow, vAvg };
        if (shortBB && isVolSpike) return { signal: "short", reason: "BB 상단 복귀 + 거래량 스파이크", vNow, vAvg };

        // 보조: 중단선(basis) 반등/저항 + 스파이크
        const basisNow = last(bb.basis);
        const basisPrev = bb.basis[bb.basis.length - 2];
        // 간단한 방향 체크
        const longBasis = (cPrev <= basisPrev) && (cNow > basisNow) && isVolSpike;
        const shortBasis = (cPrev >= basisPrev) && (cNow < basisNow) && isVolSpike;

        if (longBasis) return { signal: "long", reason: "BB 중단선 상회 + 거래량 스파이크", vNow, vAvg };
        if (shortBasis) return { signal: "short", reason: "BB 중단선 하회 + 거래량 스파이크", vNow, vAvg };

        return { signal: "none" };
    }

    function combineTrendAndEntry(trend, entry) {
        // 추세 추종만 허용
        if (trend === "up" && entry.signal === "long") return "LONG";
        if (trend === "down" && entry.signal === "short") return "SHORT";
        return "NONE";
    }

    // ======== 앱 로직 ========
    const el = {
        tfTrend: document.getElementById("tfTrend"),
        tfEntry: document.getElementById("tfEntry"),
        bbPeriod: document.getElementById("bbPeriod"),
        bbStd: document.getElementById("bbStd"),
        volMult: document.getElementById("volMult"),
        minNotional24h: document.getElementById("minNotional24h"),
        scanUniverse: document.getElementById("scanUniverse"),
        run: document.getElementById("run"),
        stop: document.getElementById("stop"),
        status: document.getElementById("status"),
        tableBody: document.querySelector("#result tbody"),
        note: document.getElementById("note"),
    };

    let abort = false;

    el.run.addEventListener("click", async () => {
        abort = false;
        el.status.textContent = "심볼 목록 로딩중…";
        el.status.className = "badge neutral";

        try {
            // 1) 심볼 목록
            let symbols = await getPerpUSDTUniverse();

            // 2) 24h 통계로 유동성 필터 및 상위 50 선택
            const statsMap = await get24hStats(symbols);
            const rows = [];
            for (const s of symbols) {
                const t = statsMap.get(s);
                if (!t) continue;
                const quoteVol = parseFloat(t.quoteVolume); // 24h 거래대금(USDT)
                rows.push({ symbol: s, quoteVol });
            }
            rows.sort((a,b)=>b.quoteVol - a.quoteVol);

            const universeType = el.scanUniverse.value;
            if (universeType === "top") {
                symbols = rows.slice(0, 50).map(r => r.symbol);
            } else {
                // 최소 24h 거래대금 필터
                const minNotional = Number(el.minNotional24h.value || 0);
                if (minNotional > 0) {
                    symbols = rows.filter(r => r.quoteVol >= minNotional).map(r => r.symbol);
                }
            }

            el.status.textContent = `스캔 시작: ${symbols.length} 종목`;
            el.status.className = "badge up";

            el.tableBody.innerHTML = "";
            const batchSize = 10; // API 과호출 방지용 배치
            for (let i = 0; i < symbols.length; i += batchSize) {
                if (abort) throw new Error("중지됨");
                const batch = symbols.slice(i, i + batchSize);
                await Promise.all(batch.map(s => scanSymbol(s, statsMap)));
                await sleep(400); // 레이트리밋 완화
            }

            el.status.textContent = `완료: ${symbols.length} 종목 스캔`;
            el.status.className = "badge up";
        } catch (e) {
            el.status.textContent = `오류: ${e.message}`;
            el.status.className = "badge down";
        }
    });

    el.stop.addEventListener("click", () => {
        abort = true;
        el.status.textContent = "정지 요청됨";
        el.status.className = "badge down";
    });

    async function scanSymbol(symbol, statsMap) {
        try {
            const tfTrend = el.tfTrend.value;   // 1h
            const tfEntry = el.tfEntry.value;   // 15m
            const bbPeriod = Number(el.bbPeriod.value || 20);
            const bbStd = Number(el.bbStd.value || 2);
            const volMult = Number(el.volMult.value || 2);

            // 1) 1시간봉 데이터 (추세 판단)
            const klTrend = await getKlines(symbol, tfTrend, 500);
            const closes1h = klTrend.map(k => parseFloat(k[4]));
            const trend = trendByEMA(closes1h);

            // 2) 24h 거래대금
            const stat = statsMap.get(symbol);
            const quoteVolUSDT = stat ? parseFloat(stat.quoteVolume) : 0;

            // 3) 15분봉 데이터 (진입 신호)
            const klEntry = await getKlines(symbol, tfEntry, 300);
            const closes15 = klEntry.map(k => parseFloat(k[4]));
            const vols15 = klEntry.map(k => parseFloat(k[5]));
            const entry = entrySignalBBVolume(closes15, vols15, bbPeriod, bbStd, volMult);

            const merged = combineTrendAndEntry(trend.trend, entry);
            const priceNow = last(closes15);

            // 표에 표시 (신호 없더라도 스캔 결과는 보여줌)
            appendRow({
                symbol,
                trend: trend.trend,
                signal: merged,
                price: priceNow,
                quoteVol: quoteVolUSDT,
                reason: entry.reason || "-"
            });
        } catch (e) {
            // 심볼별 에러는 무시하고 진행
            console.warn(symbol, e.message);
        }
    }

    function appendRow({ symbol, trend, signal, price, quoteVol, reason }) {
        const tr = document.createElement("tr");

        const tdSym = document.createElement("td");
        tdSym.innerHTML = `<span class="mono">${symbol}</span>`;
        tr.appendChild(tdSym);

        const tdTrend = document.createElement("td");
        tdTrend.innerHTML = trend === "up"
            ? `<span class="badge up">상승(EMA50&gt;200)</span>`
            : trend === "down"
            ? `<span class="badge down">하락(EMA50&lt;200)</span>`
            : `<span class="badge neutral">중립</span>`;
        tr.appendChild(tdTrend);

        const tdSig = document.createElement("td");
        tdSig.innerHTML = signal === "LONG"
            ? `<span class="badge up">LONG</span>`
            : signal === "SHORT"
            ? `<span class="badge down">SHORT</span>`
            : `<span class="badge neutral">NONE</span>`;
        tr.appendChild(tdSig);

        const tdPrice = document.createElement("td");
        tdPrice.className = "right mono";
        tdPrice.textContent = toFixed(price, 6);
        tr.appendChild(tdPrice);

        const tdVol = document.createElement("td");
        tdVol.className = "right mono";
        tdVol.textContent = toFixed(quoteVol, 0);
        tr.appendChild(tdVol);

        const tdWhy = document.createElement("td");
        tdWhy.className = "muted";
        tdWhy.textContent = reason;
        tr.appendChild(tdWhy);

        // LONG/SHORT 신호가 있는 것들을 위로 오도록 prepend
        const tbody = el.tableBody;
        if (signal === "LONG" || signal === "SHORT") {
            tbody.insertBefore(tr, tbody.firstChild);
        } else {
            tbody.appendChild(tr);
        }
    }
</script>
</body>
</html>
