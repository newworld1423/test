<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>15m EMA50 상방연속 스캐너 (USDT PERP)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { color-scheme: light dark; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 24px; }
        h1 { margin: 0 0 12px; }
        .controls { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end; margin-bottom: 12px; }
        .control { display: grid; gap: 6px; }
        label { font-size: 14px; opacity: .8; }
        input[type="number"], select { padding: 8px 10px; font-size: 14px; }
        button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
        .primary { background: #4f46e5; color: white; }
        .muted { background: #e5e7eb; }
        .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; opacity: .85; margin-top: 8px; }
        .bar-wrap { height: 10px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
        .bar { height: 100%; width: 0%; background: #10b981; transition: width .2s ease; }
        table { width: 100%; border-collapse: collapse; margin-top: 16px; }
        th, td { padding: 10px; border-bottom: 1px solid rgba(0,0,0,.1); text-align: left; font-size: 14px; }
        th { user-select: none; }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; }
        .ok { background: #d1fae5; color: #065f46; }
        .warn { background: #fee2e2; color: #991b1b; }
        .neu { background: #e5e7eb; color: #111827; }
        .hint { font-size: 12px; opacity: .75; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>15분봉 EMA50 상방연속 스캐너 (USDT PERP)</h1>

    <div class="controls">
        <div class="control">
            <label>연속 상방 최소 개수 (기본 2)</label>
            <input id="minAbove" type="number" min="1" value="2" />
        </div>
        <div class="control">
            <label>검사 윈도우 (현재봉 제외, 기본 96)</label>
            <input id="windowLen" type="number" min="10" max="200" value="96" />
        </div>
        <div class="control">
            <label>EMA 기간 (기본 50)</label>
            <input id="emaPeriod" type="number" min="3" max="200" value="50" />
        </div>
        <div class="control">
            <label>동시 요청 (기본 6)</label>
            <input id="concurrency" type="number" min="1" max="20" value="6" />
        </div>
        <div class="control">
            <label>배치 딜레이(ms, 기본 150)</label>
            <input id="delayMs" type="number" min="0" max="5000" value="150" />
        </div>
        <div class="control">
            <label>재시도 (429/5xx, 기본 2)</label>
            <input id="maxRetries" type="number" min="0" max="5" value="2" />
        </div>

        <!-- ✅ 정렬 프리셋 -->
        <div class="control">
            <label>정렬 프리셋</label>
            <select id="sortPreset">
                <option value="streakAvgQuoteDelta" selected>상방연속 ↓ → 평균 거래대금(Quote) ↓ → Δ% ↓</option>
                <option value="streakOnly">상방연속 ↓</option>
                <option value="avgQuoteOnly">평균 거래대금(Quote) ↓</option>
                <option value="deltaOnly">Δ% (종가-EMA50) ↓</option>
                <option value="symbolAZ">심볼 A→Z</option>
            </select>
        </div>

        <div class="control">
            <label>&nbsp;</label>
            <button id="scanBtn" class="primary">스캔 시작</button>
        </div>
        <div class="control">
            <label>&nbsp;</label>
            <button id="exportBtn" class="muted" disabled>CSV 내보내기</button>
        </div>
    </div>

    <div class="bar-wrap"><div id="bar" class="bar"></div></div>
    <div id="status" class="status">준비됨</div>

    <table id="resultTable">
        <thead>
            <tr>
                <th>심볼</th>
                <th>상방연속 개수</th>
                <th>상방연속 평균 거래대금(Quote)</th>
                <th>Δ% (마지막 종료봉 종가-EMA50)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <p class="hint">
        • “현재봉 제외” 처리: 마지막 진행 중 15분봉은 제외하고 그 이전 데이터만 사용합니다.<br>
        • 결과 포함 조건: 마지막 종료봉부터 연속 <strong>종가 &gt; EMA50</strong>이 <strong>2개 이상</strong>.<br>
        • 평균 거래대금(Quote)은 “상방연속으로 잡힌 구간”의 각 캔들 quoteAssetVolume 평균입니다.
    </p>

<script>
    const EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const KLINES_URL = "https://fapi.binance.com/fapi/v1/klines";
    const INTERVAL = "15m";
    const DEFAULT_LIMIT = 200;

    const el = (id) => document.getElementById(id);
    const statusEl = el("status");
    const barEl = el("bar");
    const tbody = document.querySelector("#resultTable tbody");
    const scanBtn = el("scanBtn");
    const exportBtn = el("exportBtn");
    const sortPresetEl = el("sortPreset");

    let lastResults = [];

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchJsonWithRetry(url, maxRetries, attempt = 0) {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return await res.json();
        } catch (e) {
            if (attempt < maxRetries) {
                const backoff = 400 * Math.pow(2, attempt);
                await sleep(backoff);
                return fetchJsonWithRetry(url, maxRetries, attempt + 1);
            }
            throw e;
        }
    }

    async function loadSymbols(maxRetries) {
        const data = await fetchJsonWithRetry(EXCHANGE_INFO_URL, maxRetries);
        const out = [];
        for (const s of data.symbols) {
            if (s.quoteAsset === "USDT" && s.contractType === "PERPETUAL" && s.status === "TRADING") {
                out.push(s.symbol);
            }
        }
        out.sort();
        return out;
    }

    async function fetchKlines(symbol, limit, maxRetries) {
        const url = `${KLINES_URL}?symbol=${symbol}&interval=${INTERVAL}&limit=${limit}`;
        return fetchJsonWithRetry(url, maxRetries);
    }

    function computeEMA(values, period) {
        const k = 2 / (period + 1);
        const ema = new Array(values.length).fill(null);
        if (values.length < period) return ema;
        let sum = 0;
        for (let i = 0; i < period; i++) sum += values[i];
        let prev = sum / period;
        ema[period - 1] = prev;
        for (let i = period; i < values.length; i++) {
            const next = values[i] * k + prev * (1 - k);
            ema[i] = next;
            prev = next;
        }
        return ema;
    }

    function toNum(x) { return typeof x === "string" ? parseFloat(x) : x; }

    // 마지막 종료봉부터 뒤로 연속 "종가 > EMA" 개수 계산 + 그 구간 평균 quote 볼륨 계산
    function streakFromLastClosed(closes, ema, volsQuote, windowLen) {
        const lastClosed = closes.length - 2; // 현재 진행봉 제외
        if (lastClosed < 0) return { aboveLen: 0, lastClosed, avgQuote: 0 };

        const end = lastClosed;
        const start = Math.max(0, end - windowLen + 1);

        // EMA null 구간 건너뛰기
        let s = start;
        while (s <= end && (ema[s] == null)) s++;
        if (s > end) return { aboveLen: 0, lastClosed, avgQuote: 0 };

        let aboveLen = 0;
        let sumQuote = 0;
        for (let i = end; i >= s; i--) {
            if (closes[i] > ema[i]) {
                aboveLen++;
                sumQuote += volsQuote[i];
            } else {
                break; // 연속 끊기면 중단
            }
        }
        const avgQuote = aboveLen > 0 ? (sumQuote / aboveLen) : 0;
        return { aboveLen, lastClosed, avgQuote };
    }

    function buildRow(rec) {
        const signClass = rec.deltaPct > 0 ? "ok" : (rec.deltaPct < 0 ? "warn" : "neu");
        const tr = document.createElement("tr");
        tr.innerHTML = `
            <td><strong>${rec.symbol}</strong></td>
            <td><span class="pill ok">${rec.aboveLen}</span></td>
            <td class="mono">${rec.avgQuote.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
            <td class="mono"><span class="pill ${signClass}">${rec.deltaPct.toFixed(2)}%</span></td>
        `;
        return tr;
    }

    function toCSV(rows) {
        const header = ["symbol","aboveLen","avgQuote","deltaPct"];
        const lines = [header.join(",")];
        for (const r of rows) {
            lines.push([
                r.symbol,
                r.aboveLen,
                r.avgQuote,
                r.deltaPct.toFixed(4)
            ].join(","));
        }
        return lines.join("\n");
    }

    function download(filename, text) {
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
    }

    function sortResults(results, preset) {
        const data = [...results];
        switch (preset) {
            case "streakAvgQuoteDelta":
                data.sort((a, b) => {
                    if (b.aboveLen !== a.aboveLen) return b.aboveLen - a.aboveLen;
                    if (b.avgQuote !== a.avgQuote) return b.avgQuote - a.avgQuote;
                    return b.deltaPct - a.deltaPct;
                });
                break;
            case "streakOnly":
                data.sort((a, b) => b.aboveLen - a.aboveLen);
                break;
            case "avgQuoteOnly":
                data.sort((a, b) => b.avgQuote - a.avgQuote);
                break;
            case "deltaOnly":
                data.sort((a, b) => b.deltaPct - a.deltaPct);
                break;
            case "symbolAZ":
                data.sort((a, b) => a.symbol.localeCompare(b.symbol));
                break;
            default:
                break;
        }
        return data;
    }

    function render(results) {
        tbody.innerHTML = "";
        for (const r of results) tbody.appendChild(buildRow(r));
    }

    async function scanAll() {
        scanBtn.disabled = true;
        exportBtn.disabled = true;
        tbody.innerHTML = "";
        lastResults = [];

        const minAbove = Math.max(1, parseInt(el("minAbove").value, 10)); // 기본 2
        const windowLen = Math.min(200, Math.max(10, parseInt(el("windowLen").value, 10))); // 기본 96
        const emaPeriod = Math.min(200, Math.max(3, parseInt(el("emaPeriod").value, 10)));  // 기본 50
        const concurrency = Math.min(20, Math.max(1, parseInt(el("concurrency").value, 10)));
        const delayMs = Math.min(5000, Math.max(0, parseInt(el("delayMs").value, 10)));
        const maxRetries = Math.min(5, Math.max(0, parseInt(el("maxRetries").value, 10)));

        statusEl.textContent = "심볼 목록 로드 중…";
        let symbols = [];
        try {
            symbols = await loadSymbols(maxRetries);
        } catch (e) {
            statusEl.textContent = "심볼 로드 실패: " + e.message;
            scanBtn.disabled = false;
            return;
        }

        const total = symbols.length;
        let done = 0;
        const results = [];

        statusEl.textContent = `총 ${total}개 심볼 스캔 시작`;
        barEl.style.width = "0%";

        const queue = [...symbols];
        const workers = new Array(concurrency).fill(0).map(async () => {
            while (queue.length) {
                const symbol = queue.shift();
                try {
                    const kl = await fetchKlines(symbol, DEFAULT_LIMIT, maxRetries);
                    // kline: [0]openTime,[1]open,[2]high,[3]low,[4]close,[5]volume(base),[6]closeTime,[7]quoteAssetVolume, ...
                    const closes = kl.map(k => toNum(k[4]));
                    const closeTimes = kl.map(k => k[6]); // (시간은 내부 계산용으로만 사용)
                    const volsQuote = kl.map(k => toNum(k[7]));

                    const ema = computeEMA(closes, emaPeriod);

                    // 마지막 종료봉 기준 상방연속 + 평균 거래대금(Quote)
                    const { aboveLen, lastClosed, avgQuote } = streakFromLastClosed(closes, ema, volsQuote, windowLen);

                    // 조건: 연속 상방 개수 >= 2 (기본)
                    if (aboveLen >= Math.max(2, minAbove)) {
                        const emaLast = ema[lastClosed];
                        if (emaLast == null) throw new Error("EMA 부족");
                        const lastClose = closes[lastClosed];
                        if (!(lastClose > emaLast)) throw new Error("상방 불충족");

                        const deltaPct = ((lastClose - emaLast) / emaLast) * 100;

                        results.push({
                            symbol,
                            aboveLen,
                            avgQuote,
                            deltaPct
                        });
                    }
                } catch (e) {
                    /* 심볼 단위 실패는 건너뜀 */
                } finally {
                    done++;
                    if (done % concurrency === 0 && delayMs > 0) await sleep(delayMs);
                    const pct = Math.round((done / total) * 100);
                    barEl.style.width = pct + "%";
                    statusEl.textContent = `스캔 진행: ${done}/${total} (${pct}%)`;
                }
            }
        });

        await Promise.all(workers);

        // ✅ 프리셋 정렬 후 렌더
        lastResults = results;
        const sorted = sortResults(lastResults, sortPresetEl.value);
        render(sorted);

        statusEl.textContent = `완료: ${results.length}개 심볼이 조건 충족 (${total}개 중)`;
        exportBtn.disabled = results.length === 0;
        exportBtn.onclick = () => {
            const csv = toCSV(sorted);
            const stamp = new Date().toISOString().replace(/[:.]/g, "-");
            download(`scan_15m_ema50_aboveStreak_avgQuote_${stamp}.csv`, csv);
        };

        scanBtn.disabled = false;
    }

    // 프리셋 변경 시 즉시 재정렬
    sortPresetEl.addEventListener("change", () => {
        if (!lastResults.length) return;
        const sorted = sortResults(lastResults, sortPresetEl.value);
        render(sorted);
    });

    el("scanBtn").addEventListener("click", scanAll);
</script>
</body>
</html>
