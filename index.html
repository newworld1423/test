<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT Perp Scanner (Ranking)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; padding: 16px; }
        h1 { margin-top: 0; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap: 12px; margin-bottom: 16px; }
        label { display: block; font-weight: 600; margin-bottom: 4px; }
        input, select, button { width: 100%; padding: 8px 10px; box-sizing: border-box; }
        button { cursor: pointer; }
        .small { font-size: 12px; color: #666; }
        .row { display: flex; gap: 8px; align-items: center; }
        .badge { padding: 2px 6px; border-radius: 6px; font-size: 12px; display: inline-block; }
        .up { background:#e6f7ed; color:#0b8a49; border:1px solid #bce7cf; }
        .down { background:#fdeaea; color:#b60e0e; border:1px solid #f3c1c1; }
        .neutral { background:#eef1f6; color:#364152; border:1px solid #d7dce6; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: left; vertical-align: top; }
        th { position: sticky; top: 0; background: #fff; z-index: 1; }
        .muted { color:#6b7280; }
        .right { text-align: right; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
        .warn { color:#b45309; background:#fffbeb; border:1px solid #fde68a; padding:10px; border-radius:8px; margin:10px 0; }
        .ok { color:#065f46; background:#ecfdf5; border:1px solid #a7f3d0; padding:10px; border-radius:8px; margin:10px 0; }
        .grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
        .footer { margin-top: 16px; font-size: 12px; color:#6b7280; }
        .scoreGood { font-weight: 700; }
    </style>
</head>
<body>
    <h1>Binance USDT 무기한 선물 스캐너 (신호 랭킹)</h1>
    <p class="small">전략: 1시간봉 EMA50·200로 <b>추세 방향 단일</b> 거래 → 15분봉에서 <b>볼린저밴드 & 거래량 스파이크</b>로 진입 신호 탐지 → <b>스코어로 우선순위</b></p>

    <div class="controls">
        <div>
            <label>기본 타임프레임 (추세)</label>
            <select id="tfTrend">
                <option value="1h" selected>1h (권장)</option>
                <option value="4h">4h</option>
                <option value="2h">2h</option>
            </select>
            <div class="small">EMA50 vs EMA200로 추세 판단</div>
        </div>

        <div>
            <label>세부 타임프레임 (진입)</label>
            <select id="tfEntry">
                <option value="15m" selected>15m (권장)</option>
                <option value="5m">5m</option>
                <option value="30m">30m</option>
            </select>
            <div class="small">볼린저밴드·거래량 스파이크 신호</div>
        </div>

        <div>
            <label>볼린저 기간</label>
            <input id="bbPeriod" type="number" min="10" value="20" />
            <div class="small">기본 20</div>
        </div>

        <div>
            <label>볼린저 표준편차</label>
            <input id="bbStd" type="number" step="0.1" value="2" />
        </div>

        <div>
            <label>거래량 스파이크 배수</label>
            <input id="volMult" type="number" step="0.1" value="2.0" />
            <div class="small">최근봉 ≥ 직전 20봉 평균 × 배수</div>
        </div>

        <div>
            <label>최소 24h 거래대금(USDT)</label>
            <input id="minNotional24h" type="number" step="100000" value="5000000" />
            <div class="small">예: 5,000,000</div>
        </div>

        <div>
            <label>스캔 범위</label>
            <select id="scanUniverse">
                <option value="all" selected>USDT Perp 전체</option>
                <option value="top">상위 유동성(상위 50)</option>
            </select>
        </div>

        <div class="row">
            <button id="run">스캔 실행</button>
            <button id="stop">정지</button>
        </div>
    </div>

    <div id="status" class="neutral badge">대기</div>
    <div id="note" class="warn">주의: 본 스캐너는 교육/연구용입니다. 신호=수익 보장 X. 반드시 손절·포지션 크기(1~2% 리스크)를 엄수하세요.</div>

    <table id="result">
        <thead>
            <tr>
                <th>순위</th>
                <th>심볼</th>
                <th>추세(1h)</th>
                <th>신호(15m)</th>
                <th class="right">점수</th>
                <th class="right">최근가</th>
                <th class="right">24h 거래대금</th>
                <th>근거</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div class="footer">
        데이터: Binance Futures API (공용). 과거 성과는 미래 수익을 보장하지 않습니다.
    </div>

<script>
    // ======== 유틸 ========
    async function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
    function ema(values, period) {
        if (values.length < period) return [];
        const k = 2 / (period + 1);
        const out = [];
        let sum = 0;
        for (let i = 0; i < period; i++) sum += values[i];
        let prev = sum / period;
        out.push(prev);
        for (let i = period; i < values.length; i++) {
            const cur = values[i] * k + prev * (1 - k);
            out.push(cur);
            prev = cur;
        }
        return out;
    }
    function sma(values, period) {
        if (values.length < period) return [];
        const out = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
            sum += values[i];
            if (i >= period) sum -= values[i - period];
            if (i >= period - 1) out.push(sum / period);
        }
        return out;
    }
    function stdev(values, period) {
        const m = sma(values, period);
        const out = [];
        for (let i = 0; i < m.length; i++) {
            const start = i, end = i + period;
            let s2 = 0;
            for (let j = start; j < end; j++) {
                const d = values[j] - m[i];
                s2 += d * d;
            }
            out.push(Math.sqrt(s2 / period));
        }
        return out;
    }
    function bollinger(values, period = 20, stdK = 2) {
        const basis = sma(values, period);
        const sd = stdev(values, period);
        const upper = basis.map((b, i) => b + stdK * sd[i]);
        const lower = basis.map((b, i) => b - stdK * sd[i]);
        return { basis, upper, lower };
    }
    function last(arr, n=1) { return arr.slice(-n)[0]; }
    function avg(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0) / arr.length : 0; }
    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
    function toFixed(n, d=4) {
        return (n ?? 0).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: d });
    }
    function pct(a, b) { return b === 0 ? 0 : (a - b) / b; } // (a-b)/b

    // ======== Binance Futures REST ========
    const BASE = "https://fapi.binance.com";
    async function fetchJSON(url) {
        const r = await fetch(url);
        if (!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
        return r.json();
    }
    async function getPerpUSDTUniverse() {
        const info = await fetchJSON(`${BASE}/fapi/v1/exchangeInfo`);
        return info.symbols
            .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
            .map(s => s.symbol);
    }
    async function get24hStats(symbols) {
        const all = await fetchJSON(`${BASE}/fapi/v1/ticker/24hr`);
        const map = new Map();
        for (const t of all) {
            if (symbols.includes(t.symbol)) map.set(t.symbol, t);
        }
        return map;
    }
    async function getKlines(symbol, interval, limit=500) {
        const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        return fetchJSON(url);
    }

    // ======== 전략 로직 ========
    function trendByEMA(closes, periodFast=50, periodSlow=200) {
        if (closes.length < periodSlow + 5) return { trend: "neutral" };
        const ema50 = ema(closes, periodFast);
        const ema200 = ema(closes, periodSlow);
        const shift = ema50.length - ema200.length;
        if (shift < 0) return { trend: "neutral" };
        const e50 = ema50.slice(shift);
        const e200 = ema200;
        const now50 = last(e50);
        const now200 = last(e200);
        const trend = now50 > now200 ? "up" : now50 < now200 ? "down" : "neutral";
        const price = last(closes);
        const gapPct = clamp(Math.abs(now50 - now200) / price, 0, 0.05); // 최대 5%로 캡
        return { trend, now50, now200, gapPct };
    }

    function entrySignalBBVolume(closes, volumes, bbPeriod=20, bbStd=2, volMult=2.0) {
        if (closes.length < Math.max(bbPeriod+2, 30)) return { signal: "none" };
        const bb = bollinger(closes, bbPeriod, bbStd);
        const cNow = last(closes);
        const cPrev = closes[closes.length - 2];
        const uNow = last(bb.upper), lNow = last(bb.lower);
        const uPrev = bb.upper[bb.upper.length - 2], lPrev = bb.lower[bb.lower.length - 2];
        const basisNow = last(bb.basis), basisPrev = bb.basis[bb.basis.length - 2];
        const volWindow = 20;
        const recentVols = volumes.slice(-volWindow-1, -1);
        const vAvg = avg(recentVols);
        const vNow = last(volumes);
        const isVolSpike = vNow >= vAvg * volMult;
        const bandWidth = Math.max(uNow - lNow, 1e-12);

        const longBB = (cPrev < lPrev) && (cNow > lNow);
        const shortBB = (cPrev > uPrev) && (cNow < uNow);
        const longBasis = (cPrev <= basisPrev) && (cNow > basisNow);
        const shortBasis = (cPrev >= basisPrev) && (cNow < basisNow);

        let signal = "none", reason = "-", bbQuality = 0;
        if (longBB && isVolSpike) {
            signal = "long"; reason = "BB 하단 복귀 + 거래량 스파이크";
            bbQuality = clamp((cNow - lNow) / bandWidth, 0, 1);
        } else if (shortBB && isVolSpike) {
            signal = "short"; reason = "BB 상단 복귀 + 거래량 스파이크";
            bbQuality = clamp((uNow - cNow) / bandWidth, 0, 1);
        } else if (longBasis && isVolSpike) {
            signal = "long"; reason = "BB 중단선 상회 + 거래량 스파이크";
            bbQuality = clamp((cNow - basisNow) / bandWidth, 0, 1);
        } else if (shortBasis && isVolSpike) {
            signal = "short"; reason = "BB 중단선 하회 + 거래량 스파이크";
            bbQuality = clamp((basisNow - cNow) / bandWidth, 0, 1);
        }

        // 최근 3봉 모멘텀 (세부 프레임)
        const momBars = 3;
        let momentum = 0;
        for (let i = closes.length - momBars; i < closes.length - 1; i++) {
            momentum += (closes[i+1] - closes[i]) / closes[i];
        }

        return { signal, reason, vNow, vAvg, isVolSpike, bbQuality, bandWidth, momentum, basisNow, lNow, uNow, cNow };
    }

    function combineTrendAndEntry(trend, entry) {
        if (trend === "up" && entry.signal === "long") return "LONG";
        if (trend === "down" && entry.signal === "short") return "SHORT";
        return "NONE";
    }

    // ======== 스코어링 ========
    // 가중치: Trend 30, Volume 25, BB 25, Liquidity 10, Momentum 10 (총 100)
    const WEIGHTS = { trend: 30, volume: 25, bb: 25, liq: 10, mom: 10 };

    function liquidityScore(quoteVolUSDT) {
        // 로그 스케일 정규화: 1e6~1e10 범위 맵핑
        const logV = Math.log10(Math.max(quoteVolUSDT, 1));
        const s = clamp((logV - 6) / (10 - 6), 0, 1);
        return s;
    }

    function volumeSpikeScore(vNow, vAvg, volMult) {
        if (!vAvg || !vNow) return 0;
        const ratio = vNow / vAvg; // 1 → 0점, volMult 이상 → 높은 점수
        const s = clamp((ratio - 1) / (Math.max(volMult, 1.1) - 1), 0, 1);
        return s;
    }

    function momentumScore(momentum, direction) {
        // direction: LONG/SHORT
        const m = direction === "LONG" ? momentum : -momentum;
        // -3%~+3% 범위 정규화
        const s = clamp((m + 0.03) / 0.06, 0, 1);
        return s;
    }

    function trendStrengthScore(gapPct) {
        // gapPct: EMA50-200 괴리(%) 캡 5% → 0~0.05
        return clamp(gapPct / 0.05, 0, 1);
    }

    function computeScore(parts) {
        const { gapPct, vNow, vAvg, volMult, bbQuality, quoteVolUSDT, momentum, direction } = parts;
        const sTrend = trendStrengthScore(gapPct);
        const sVol = volumeSpikeScore(vNow, vAvg, volMult);
        const sBB = clamp(bbQuality, 0, 1);
        const sLiq = liquidityScore(quoteVolUSDT);
        const sMom = momentumScore(momentum, direction);
        const score = (
            sTrend * WEIGHTS.trend +
            sVol   * WEIGHTS.volume +
            sBB    * WEIGHTS.bb +
            sLiq   * WEIGHTS.liq +
            sMom   * WEIGHTS.mom
        );
        return { score, sTrend, sVol, sBB, sLiq, sMom };
    }

    // ======== 앱 로직 ========
    const el = {
        tfTrend: document.getElementById("tfTrend"),
        tfEntry: document.getElementById("tfEntry"),
        bbPeriod: document.getElementById("bbPeriod"),
        bbStd: document.getElementById("bbStd"),
        volMult: document.getElementById("volMult"),
        minNotional24h: document.getElementById("minNotional24h"),
        scanUniverse: document.getElementById("scanUniverse"),
        run: document.getElementById("run"),
        stop: document.getElementById("stop"),
        status: document.getElementById("status"),
        tableBody: document.querySelector("#result tbody"),
        note: document.getElementById("note"),
    };

    let abort = false;
    let rowsBuffer = []; // 순위 정렬용 버퍼

    el.run.addEventListener("click", async () => {
        abort = false;
        rowsBuffer = [];
        el.tableBody.innerHTML = "";
        el.status.textContent = "심볼 목록 로딩중…";
        el.status.className = "badge neutral";

        try {
            // 1) 심볼
            let symbols = await getPerpUSDTUniverse();

            // 2) 유동성 필터
            const statsMap = await get24hStats(symbols);
            const liqRows = [];
            for (const s of symbols) {
                const t = statsMap.get(s);
                if (!t) continue;
                const quoteVol = parseFloat(t.quoteVolume);
                liqRows.push({ symbol: s, quoteVol });
            }
            liqRows.sort((a,b)=>b.quoteVol - a.quoteVol);

            const universeType = el.scanUniverse.value;
            if (universeType === "top") {
                symbols = liqRows.slice(0, 50).map(r => r.symbol);
            } else {
                const minNotional = Number(el.minNotional24h.value || 0);
                if (minNotional > 0) {
                    symbols = liqRows.filter(r => r.quoteVol >= minNotional).map(r => r.symbol);
                }
            }

            el.status.textContent = `스캔 시작: ${symbols.length} 종목`;
            el.status.className = "badge up";

            // 3) 배치 스캔
            const batchSize = 10;
            for (let i = 0; i < symbols.length; i += batchSize) {
                if (abort) throw new Error("중지됨");
                const batch = symbols.slice(i, i + batchSize);
                await Promise.all(batch.map(s => scanSymbolRanked(s, statsMap)));
                await sleep(400);
            }

            // 4) 랭킹 정렬 후 출력
            rowsBuffer.sort((a, b) => {
                if (b.signalScore !== a.signalScore) return b.signalScore - a.signalScore;
                return b.quoteVol - a.quoteVol;
            });

            el.tableBody.innerHTML = "";
            rowsBuffer.forEach((r, idx) => appendRankedRow(r, idx + 1));

            el.status.textContent = `완료: ${symbols.length} 종목 스캔`;
            el.status.className = "badge up";
        } catch (e) {
            el.status.textContent = `오류: ${e.message}`;
            el.status.className = "badge down";
        }
    });

    el.stop.addEventListener("click", () => {
        abort = true;
        el.status.textContent = "정지 요청됨";
        el.status.className = "badge down";
    });

    async function scanSymbolRanked(symbol, statsMap) {
        try {
            const tfTrend = el.tfTrend.value;
            const tfEntry = el.tfEntry.value;
            const bbPeriod = Number(el.bbPeriod.value || 20);
            const bbStd = Number(el.bbStd.value || 2);
            const volMult = Number(el.volMult.value || 2);

            // 추세
            const klTrend = await getKlines(symbol, tfTrend, 500);
            const closes1h = klTrend.map(k => parseFloat(k[4]));
            const t = trendByEMA(closes1h);

            // 유동성
            const stat = statsMap.get(symbol);
            const quoteVolUSDT = stat ? parseFloat(stat.quoteVolume) : 0;

            // 진입 신호(세부)
            const klEntry = await getKlines(symbol, tfEntry, 300);
            const closes15 = klEntry.map(k => parseFloat(k[4]));
            const vols15 = klEntry.map(k => parseFloat(k[5]));
            const e = entrySignalBBVolume(closes15, vols15, bbPeriod, bbStd, volMult);

            const merged = combineTrendAndEntry(t.trend, e);
            const priceNow = last(closes15);

            let signalScore = 0;
            let parts = null;

            if (merged === "LONG" || merged === "SHORT") {
                parts = {
                    gapPct: t.gapPct || 0,
                    vNow: e.vNow || 0,
                    vAvg: e.vAvg || 0,
                    volMult,
                    bbQuality: e.bbQuality || 0,
                    quoteVolUSDT,
                    momentum: e.momentum || 0,
                    direction: merged
                };
                const s = computeScore(parts);
                signalScore = s.score; // 0~100
            }

            rowsBuffer.push({
                symbol,
                trend: t.trend,
                signal: merged,
                signalScore,
                price: priceNow,
                quoteVol: quoteVolUSDT,
                reason: e.reason || "-",
            });
        } catch (err) {
            console.warn(symbol, err.message);
        }
    }

    function appendRankedRow(row, rank) {
        const tr = document.createElement("tr");

        const tdRank = document.createElement("td");
        tdRank.textContent = row.signal === "LONG" || row.signal === "SHORT" ? String(rank) : "-";
        tr.appendChild(tdRank);

        const tdSym = document.createElement("td");
        tdSym.innerHTML = `<span class="mono">${row.symbol}</span>`;
        tr.appendChild(tdSym);

        const tdTrend = document.createElement("td");
        tdTrend.innerHTML =
            row.trend === "up" ? `<span class="badge up">상승(EMA50&gt;200)</span>` :
            row.trend === "down" ? `<span class="badge down">하락(EMA50&lt;200)</span>` :
            `<span class="badge neutral">중립</span>`;
        tr.appendChild(tdTrend);

        const tdSig = document.createElement("td");
        tdSig.innerHTML =
            row.signal === "LONG" ? `<span class="badge up">LONG</span>` :
            row.signal === "SHORT" ? `<span class="badge down">SHORT</span>` :
            `<span class="badge neutral">NONE</span>`;
        tr.appendChild(tdSig);

        const tdScore = document.createElement("td");
        tdScore.className = "right mono";
        if (row.signal === "LONG" || row.signal === "SHORT") {
            const s = row.signalScore.toFixed(1);
            tdScore.innerHTML = Number(s) >= 70 ? `<span class="scoreGood">${s}</span>` : s;
        } else {
            tdScore.textContent = "-";
        }
        tr.appendChild(tdScore);

        const tdPrice = document.createElement("td");
        tdPrice.className = "right mono";
        tdPrice.textContent = toFixed(row.price, 6);
        tr.appendChild(tdPrice);

        const tdVol = document.createElement("td");
        tdVol.className = "right mono";
        tdVol.textContent = toFixed(row.quoteVol, 0);
        tr.appendChild(tdVol);

        const tdWhy = document.createElement("td");
        tdWhy.className = "muted";
        tdWhy.textContent = row.reason;
        tr.appendChild(tdWhy);

        // 신호 있는 종목을 표 상단에, NONE은 하단에
        const tbody = el.tableBody;
        if (row.signal === "LONG" || row.signal === "SHORT") {
            tbody.appendChild(tr);
        } else {
            tbody.appendChild(tr);
        }
    }
</script>
</body>
</html>
