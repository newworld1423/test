<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scanner ssj</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #conditions { background: #eef; padding: 10px; border-radius: 5px; margin-bottom: 15px; }
        #log { white-space: pre-wrap; background: #f5f5f5; padding: 10px; max-height: 400px; overflow-y: scroll; }
        button { padding: 8px 12px; margin-right: 10px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="conditions">
        <strong>스캔 조건 (15분봉 기준):</strong>
        <ul>
            <li>가격 종가가 99MA 위</li>
            <li>7MA > 25MA > 99MA</li>
            <li>골든 크로스: 7MA가 25MA를 아래→위 교차</li>
            <li>캔들 패턴: 단일 강세 양봉 또는 Engulfing 또는 Morning Star</li>
            <li>결과는 스코어 기반으로 내림차순 정렬</li>
        </ul>
    </div>
    <button id="startBtn">스캔 시작</button>
    <button id="stopBtn" disabled>스캔 중지</button>
    <div id="log"></div>

    <script>
        let binanceSymbols = [];
        let upbitMarkets = [];
        let timerId = null;
        const logEl = document.getElementById('log');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');

        function log(message) {
            const time = new Date().toLocaleTimeString('ko-KR');
            logEl.textContent += `[${time}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        function calculateMA(arr, period) {
            return arr.map((_, i, a) => i < period - 1 ? null : a.slice(i - period + 1, i + 1).reduce((acc, v) => acc + v, 0) / period);
        }
        function isStrongBullish(prev, curr) {
            const currBody = curr.close - curr.open;
            const prevBody = Math.abs(prev.close - prev.open);
            const lowerWick = curr.open - curr.low;
            return curr.close > curr.open && currBody > prevBody && lowerWick < currBody * 0.3;
        }
        function isEngulfing(prev, curr) {
            return curr.open < prev.close && curr.close > prev.open;
        }
        function isMorningStar(c1, c2, c3) {
            const first = c1.close < c1.open;
            const secondBody = Math.abs(c2.close - c2.open);
            const firstBody = Math.abs(c1.close - c1.open);
            const second = secondBody < firstBody * 0.5;
            const third = c3.close > c3.open && c3.close > (c1.open + c1.close) / 2;
            return first && second && third;
        }

        async function scanOnce() {
            log('스캔 시작 ↻');
            const scores = [];

            async function process(symbol, candles) {
                const closes = candles.map(c => c.close);
                const highs = candles.map(c => c.high);
                const lows = candles.map(c => c.low);
                const opens = candles.map(c => c.open);
                const ma7 = calculateMA(closes, 7);
                const ma25 = calculateMA(closes, 25);
                const ma99 = calculateMA(closes, 99);
                const len = closes.length;
                if (len < 100) return;

                const Bc = closes[len - 2];
                const m7_B = ma7[len - 2], m25_B = ma25[len - 2], m99_B = ma99[len - 2];
                const m7_C = ma7[len - 3], m25_C = ma25[len - 3];

                if (!(Bc > m99_B && m7_B > m25_B && m25_B > m99_B && m7_C <= m25_C && m7_B > m25_B)) return;

                const prev2 = { open: opens[len - 4], high: highs[len - 4], low: lows[len - 4], close: closes[len - 4] };
                const prev  = { open: opens[len - 3], high: highs[len - 3], low: lows[len - 3], close: closes[len - 3] };
                const curr  = { open: opens[len - 2], high: highs[len - 2], low: lows[len - 2], close: closes[len - 2] };
                if (!(isStrongBullish(prev, curr) || isEngulfing(prev, curr) || isMorningStar(prev2, prev, curr))) return;

                // Score 계산: 교차 강도 + MA 간격 + 캔들 몸통 크기 비율
                const crossStrength = m7_B - m25_B;
                const gapSum = (m7_B - m25_B) + (m25_B - m99_B);
                const bodySize = (curr.close - curr.open) / (curr.high - curr.low);
                const score = crossStrength + gapSum + bodySize;

                scores.push({ symbol, score });
            }

            for (let symbol of binanceSymbols) {
                try {
                    const klines = await fetchBinanceKlines(symbol);
                    const candles = klines.map(k => ({ open: parseFloat(k[1]), high: parseFloat(k[2]), low: parseFloat(k[3]), close: parseFloat(k[4]) }));
                    await process(symbol, candles);
                } catch {};
            }
            for (let market of upbitMarkets) {
                try {
                    const data = await fetchUpbitKlines(market);
                    const rev = data.reverse();
                    const candles = rev.map(c => ({ open: c.opening_price, high: c.high_price, low: c.low_price, close: c.trade_price }));
                    await process(market, candles);
                } catch {};
            }

            if (scores.length) {
                scores.sort((a, b) => b.score - a.score);
                scores.forEach(item => log(`${item.symbol} (Score: ${item.score.toFixed(4)})`));
            } else {
                log('조건 충족 코인 없음');
            }
        }

        async function loadBinanceSymbols() {
            log('B 로드 중...');
            const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            const data = await res.json();
            binanceSymbols = data.symbols.filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL').map(s => s.symbol);
            log(`B ${binanceSymbols.length}개 로드 완료`);
        }
        async function loadUpbitMarkets() {
            log('U 로드 중...');
            const res = await fetch('https://api.upbit.com/v1/market/all');
            const data = await res.json();
            upbitMarkets = data.filter(m => m.market.startsWith('KRW-')).map(m => m.market);
            log(`U ${upbitMarkets.length}개 로드 완료`);
        }
        async function fetchBinanceKlines(symbol) {
            const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=101`);
            if (!res.ok) throw new Error();
            return await res.json();
        }
        async function fetchUpbitKlines(market) {
            const res = await fetch(`https://api.upbit.com/v1/candles/minutes/15?market=${market}&count=101`);
            if (!res.ok) throw new Error();
            return await res.json();
        }
        function scheduleNext() {
            const now = new Date(), m = now.getMinutes(), s = now.getSeconds();
            const offsets = [0,15,30,45];
            let next = offsets.find(o => m < o || (m === o && s === 0));
            if (next === undefined) next = offsets[0] + 60;
            const nd = new Date(now);
            nd.setMinutes(next % 60);
            if (next >= 60) nd.setHours(now.getHours() + 1);
            nd.setSeconds(0); nd.setMilliseconds(0);
            return nd.getTime() - now.getTime();
        }
        async function startSchedule() { await loadBinanceSymbols(); await loadUpbitMarkets(); scanOnce(); timerId = setTimeout(async function tick() { await scanOnce(); timerId = setTimeout(tick, scheduleNext()); }, scheduleNext()); }
        startBtn.addEventListener('click', () => { startBtn.disabled=true; stopBtn.disabled=false; log('스케줄 시작됨'); startSchedule(); });
        stopBtn.addEventListener('click', () => { clearTimeout(timerId); startBtn.disabled=false; stopBtn.disabled=true; log('스케줄 중지됨'); });
    </script>
</body>
</html>