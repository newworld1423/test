<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT-PERP 50EMA 크로스 스캐너 (추세 정렬 포함)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { --bg:#0b1220; --fg:#e8eefc; --muted:#9fb0d0; --accent:#6ab0ff; --ok:#35c46a; --bad:#ff6a6a; }
        body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Helvetica, Arial; background:var(--bg); color:var(--fg); }
        header { padding: 20px; border-bottom: 1px solid #1b2742; }
        h1 { margin:0 0 8px; font-size: 20px; }
        p.note { margin:6px 0 0; color:var(--muted); font-size: 13px; }
        main { padding: 16px 20px 72px; max-width: 1280px; }
        .controls { display: grid; grid-template-columns: repeat(6, minmax(160px, 1fr)); gap: 10px; margin-bottom: 12px; }
        .controls > div { background:#0f1a33; border:1px solid #1b2742; border-radius:12px; padding:12px; }
        label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
        input, select, button { width:100%; box-sizing:border-box; border-radius:8px; border:1px solid #2a3b63; background:#0b172f; color:var(--fg); padding:10px 12px; font-size:14px; }
        button.primary { background:linear-gradient(180deg,#1e86ff,#1063cf); border:0; cursor:pointer; }
        button.secondary { background:#142449; border:1px solid #2a3b63; cursor:pointer; }
        .row { display:flex; gap:10px; align-items:center; margin: 14px 0; flex-wrap: wrap; }
        .progress { height:10px; background:#122043; border-radius:999px; overflow:hidden; border:1px solid #213362; }
        .bar { height:100%; width:0%; background:linear-gradient(90deg,#37a8ff,#6ab0ff); transition:width .2s ease; }
        table { width:100%; border-collapse: collapse; margin-top: 12px; }
        th, td { padding:10px 12px; border-bottom: 1px solid #1b2742; text-align:left; font-size:14px; }
        th { position: sticky; top:0; background:#0f1a33; z-index:1; }
        .ok { color:var(--ok); }
        .bad { color:var(--bad); }
        .small { font-size:12px; color:var(--muted); }
        footer { position:fixed; inset:auto 0 0 0; background:#0f1a33; border-top:1px solid #1b2742; padding:10px 20px; display:flex; gap:10px; align-items:center; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
        .nowrap { white-space: nowrap; }
        .right { margin-left:auto; display:flex; gap:10px; }
        .pill { font-size: 12px; padding:3px 8px; border-radius:999px; border:1px solid #2a3b63; color:var(--muted); }
    </style>
</head>
<body>
<header>
    <h1>Binance USDT-PERP 50EMA 크로스 스캐너</h1>
    <p class="note">조건: ① 2봉 전 종가 &lt; 50EMA ② 1봉 전 종가 &gt; 50EMA (선택 간격). 추가: 오늘(UTC) 일봉 시가 대비 %, 롱 기준 추세율(이격+기울기) 내림차순 정렬.</p>
</header>
<main>
    <section class="controls">
        <div>
            <label>간격(Interval)</label>
            <select id="interval">
                <option value="15m">15분</option>
                <option value="1h">1시간</option>
                <option value="4h">4시간</option>
                <option value="1d" selected>1일</option>
            </select>
            <div class="small">크로스 판정/추세에 사용</div>
        </div>
        <div>
            <label>EMA 길이</label>
            <input id="emaLength" type="number" value="50" min="2" />
            <div class="small">기본 50EMA</div>
        </div>
        <div>
            <label>Kline 개수 (limit)</label>
            <input id="klineLimit" type="number" value="200" min="60" />
            <div class="small">EMA길이 + 6 이상 권장</div>
        </div>
        <div>
            <label>동시 요청 개수</label>
            <input id="concurrency" type="number" value="5" min="1" max="20" />
            <div class="small">레이트 리밋 보호</div>
        </div>
        <div>
            <label>심볼 필터(포함, 선택)</label>
            <input id="symbolFilter" placeholder="예: BTC,ETH,SOL (비워두면 전체)" />
            <div class="small">쉼표로 여러 개</div>
        </div>
        <div>
            <label>추세 정렬</label>
            <select id="trendOrder">
                <option value="desc" selected>롱 강함 ↓ (내림차순)</option>
                <option value="asc">롱 약함 ↑ (오름차순)</option>
            </select>
            <div class="small">표/CSV 모두 적용</div>
        </div>
    </section>

    <div class="row">
        <button id="scanBtn" class="primary">스캔 시작</button>
        <button id="stopBtn" class="secondary" disabled>중지</button>
        <span id="status" class="small">준비됨</span>
        <span class="pill nowrap" id="tfBadge">현재 간격: 1d</span>
    </div>

    <div class="row">
        <div class="progress" style="flex:1;">
            <div class="bar" id="bar"></div>
        </div>
        <span id="progText" class="small nowrap">0 / 0</span>
    </div>

    <table id="resultTable">
        <thead>
            <tr>
                <th>#</th>
                <th>심볼</th>
                <th>간격</th>
                <th>2봉 전 종가</th>
                <th>2봉 전 50EMA</th>
                <th>1봉 전 종가</th>
                <th>1봉 전 50EMA</th>
                <th>조건</th>
                <th>현재가</th>
                <th>오늘(UTC) 시가</th>
                <th>오늘 시가 대비 %</th>
                <th>EMA 이격률%</th>
                <th>EMA 기울기%</th>
                <th>추세율(롱)</th>
                <th>비고</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</main>

<footer>
    <span class="small">출처: Binance Futures API (klines, ticker)</span>
    <div class="right">
        <button id="exportBtn" class="secondary">CSV 내보내기</button>
    </div>
</footer>

<script>
    // ======= 설정값 / DOM =======
    const API = "https://fapi.binance.com";
    const $scanBtn = document.getElementById('scanBtn');
    const $stopBtn = document.getElementById('stopBtn');
    const $interval = document.getElementById('interval');
    const $emaLength = document.getElementById('emaLength');
    const $klineLimit = document.getElementById('klineLimit');
    const $concurrency = document.getElementById('concurrency');
    const $symbolFilter = document.getElementById('symbolFilter');
    const $status = document.getElementById('status');
    const $bar = document.getElementById('bar');
    const $progText = document.getElementById('progText');
    const $tbody = document.querySelector('#resultTable tbody');
    const $exportBtn = document.getElementById('exportBtn');
    const $tfBadge = document.getElementById('tfBadge');
    const $trendOrder = document.getElementById('trendOrder');

    let abortFlag = false;
    let lastResults = [];

    // ======= 유틸 =======
    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

    function fmt(x, d=6) { return (x == null || x === '') ? '' : Number(x).toFixed(d); }
    function pf(x) {
        if (x == null || x === '') return '';
        const n = Number(x);
        const s = n >= 0 ? `+${n.toFixed(2)}%` : `${n.toFixed(2)}%`;
        return s;
    }

    function toCSV(rows) {
        const esc = (v) => {
            if (v == null) return '';
            const s = String(v);
            if (s.includes('"') || s.includes(',') || s.includes('\n')) {
                return `"${s.replace(/"/g, '""')}"`;
            }
            return s;
        };
        const header = [
            "rank","symbol","interval",
            "close_2","ema_2","close_1","ema_1","match",
            "last_price","today_open","pct_from_today_open",
            "ema_distance_pct","ema_slope_pct","trend_score","note"
        ];
        const lines = [header.join(',')];
        for (const r of rows) {
            lines.push([
                r.rank, r.symbol, r.interval,
                r.close2, r.ema2, r.close1, r.ema1, r.match,
                r.lastPrice, r.todayOpen, r.pctFromTodayOpen,
                r.emaDistancePct, r.emaSlopePct, r.trendScore, r.note || ""
            ].map(esc).join(','));
        }
        return lines.join('\n');
    }

    function downloadText(filename, text) {
        const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    function setProgress(done, total) {
        const pct = total ? Math.round(done * 100 / total) : 0;
        $bar.style.width = pct + '%';
        $progText.textContent = `${done} / ${total}`;
    }

    function addRowWithRank(r, idx) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${idx + 1}</td>
            <td class="mono">${r.symbol}</td>
            <td>${r.interval}</td>
            <td>${fmt(r.close2)}</td>
            <td>${fmt(r.ema2)}</td>
            <td>${fmt(r.close1)}</td>
            <td>${fmt(r.ema1)}</td>
            <td class="${r.match ? 'ok' : 'bad'}">${r.match ? '충족' : '불충족'}</td>
            <td>${fmt(r.lastPrice)}</td>
            <td>${fmt(r.todayOpen)}</td>
            <td class="${(r.pctFromTodayOpen ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.pctFromTodayOpen)}</td>
            <td class="${(r.emaDistancePct ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.emaDistancePct)}</td>
            <td class="${(r.emaSlopePct ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.emaSlopePct)}</td>
            <td class="${(r.trendScore ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.trendScore)}</td>
            <td class="small">${r.note || ''}</td>
        `;
        $tbody.appendChild(tr);
    }

    // ======= Binance API =======
    async function fetchUSDTPerpSymbols() {
        const res = await fetch(`${API}/fapi/v1/exchangeInfo`);
        if (!res.ok) throw new Error('exchangeInfo 실패: ' + res.status);
        const data = await res.json();
        return data.symbols
            .filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING')
            .map(s => s.symbol);
    }

    async function fetchKlines(symbol, interval, limit) {
        const url = `${API}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`klines 실패(${symbol} ${interval}): ` + res.status);
        const data = await res.json();
        return data.map(row => ({
            openTime: row[0],
            open: Number(row[1]),
            high: Number(row[2]),
            low: Number(row[3]),
            close: Number(row[4]),
            closeTime: row[6]
        }));
    }

    async function fetchAllLastPricesMap() {
        const res = await fetch(`${API}/fapi/v1/ticker/price`);
        if (!res.ok) throw new Error('ticker/price 실패: ' + res.status);
        const arr = await res.json();
        return new Map(arr.map(o => [o.symbol, Number(o.price)]));
    }

    async function fetchTodayOpen1D(symbol) {
        const kl = await fetchKlines(symbol, '1d', 2);
        if (!kl.length) return null;
        return kl[kl.length - 1].open;
    }

    // ======= EMA =======
    function ema(values, length) {
        if (values.length < length) return [];
        const k = 2 / (length + 1);
        const out = new Array(values.length);
        let sum = 0;
        for (let i = 0; i < length; i++) sum += values[i];
        out[length - 1] = sum / length;
        for (let i = length; i < values.length; i++) {
            out[i] = values[i] * k + out[i - 1] * (1 - k);
        }
        return out;
    }

    // ======= 조건/추세 계산 =======
    function checkConditionAndTrend(candles, length, lastPrice) {
        const closes = candles.map(c => c.close);
        const e = ema(closes, length);
        const lastIdx = candles.length - 1;
        const iPrev = lastIdx - 1;   // 1봉 전 (완료봉)
        const iPrev2 = lastIdx - 2;  // 2봉 전 (완료봉)
        if (iPrev2 < 0 || !e[iPrev] || !e[iPrev2]) {
            return { ok: false, reason: '데이터 부족' };
        }

        // 조건 판정
        const close2 = closes[iPrev2];
        const ema2 = e[iPrev2];
        const close1 = closes[iPrev];
        const ema1 = e[iPrev];

        const cond1 = close2 < ema2;
        const cond2 = close1 > ema1;
        const ok = cond1 && cond2;

        // 추세율(롱): EMA 이격률 + EMA 기울기 (5개 lookback)
        const priceNow = (lastPrice ?? closes[iPrev]); // 실시간가 없으면 최근 완료봉 종가
        const emaNow = ema1;
        let emaDistancePct = null;
        if (emaNow) {
            emaDistancePct = ((priceNow - emaNow) / emaNow) * 100;
        }

        let emaSlopePct = 0;
        const slopeLookback = 5;
        const iSlope = iPrev - slopeLookback;
        if (e[iPrev] && iSlope >= 0 && e[iSlope]) {
            emaSlopePct = ((e[iPrev] - e[iSlope]) / e[iSlope]) * 100;
        } else {
            emaSlopePct = 0;
        }

        const trendScore = (emaDistancePct ?? 0) * 0.6 + (emaSlopePct ?? 0) * 0.4;

        return { ok, close2, ema2, close1, ema1, emaDistancePct, emaSlopePct, trendScore };
    }

    // ======= 스캔 루프 =======
    async function scan() {
        abortFlag = false;
        $tbody.innerHTML = '';
        lastResults = [];

        const interval = $interval.value;
        document.getElementById('tfBadge').textContent = `현재 간격: ${interval}`;
        const emaLen = Math.max(parseInt($emaLength.value, 10) || 50, 2);
        const limit = Math.max(parseInt($klineLimit.value, 10) || 200, emaLen + 6);
        const conc = Math.min(Math.max(parseInt($concurrency.value, 10) || 5, 1), 20);
        const order = $trendOrder.value; // 'desc' or 'asc'

        $status.textContent = '심볼 목록 불러오는 중...';
        let symbols = await fetchUSDTPerpSymbols();

        // 심볼 필터
        const filter = ($symbolFilter.value || '').trim();
        if (filter) {
            const picks = filter.split(',').map(s => s.trim().toUpperCase()).filter(Boolean);
            symbols = symbols.filter(sym => picks.some(p => sym.startsWith(p)));
        }

        const total = symbols.length;
        let done = 0;
        setProgress(0, total);
        $status.textContent = `스캔 시작: ${total} 종목`;

        // 현재가 맵
        let priceMap = new Map();
        try {
            priceMap = await fetchAllLastPricesMap();
        } catch (e) {
            console.warn('현재가 맵 실패:', e);
        }

        // 작업 큐
        const queue = [...symbols];
        const workers = new Array(conc).fill(0).map(() => worker());
        await Promise.all(workers);

        // 조건 충족만 추출 → 추세율 정렬 → 테이블 렌더
        const matched = lastResults.filter(r => r.match);
        matched.sort((a, b) => {
            if (order === 'asc') return (a.trendScore ?? -Infinity) - (b.trendScore ?? -Infinity);
            return (b.trendScore ?? -Infinity) - (a.trendScore ?? -Infinity);
        });

        $tbody.innerHTML = '';
        matched.forEach((r, i) => {
            r.rank = i + 1;
            addRowWithRank(r, i);
        });

        $status.textContent = `완료: ${matched.length} 종목 조건 충족 / 총 ${total} (추세 ${order === 'desc' ? '내림차순' : '오름차순'} 정렬)`;

        async function worker() {
            while (queue.length && !abortFlag) {
                const sym = queue.shift();
                try {
                    const candles = await fetchKlines(sym, interval, limit);
                    const lastPrice = priceMap.get(sym) ?? null;
                    const res = checkConditionAndTrend(candles, emaLen, lastPrice);

                    // 오늘(UTC) 일봉 시가
                    let todayOpen = null;
                    try { todayOpen = await fetchTodayOpen1D(sym); } catch (_) {}

                    let pctFromTodayOpen = null;
                    if (todayOpen && lastPrice) {
                        pctFromTodayOpen = ((lastPrice - todayOpen) / todayOpen) * 100;
                    }

                    const row = {
                        symbol: sym,
                        interval,
                        close2: res.close2,
                        ema2: res.ema2,
                        close1: res.close1,
                        ema1: res.ema1,
                        match: !!res.ok,
                        lastPrice,
                        todayOpen,
                        pctFromTodayOpen,
                        emaDistancePct: res.emaDistancePct,
                        emaSlopePct: res.emaSlopePct,
                        trendScore: res.trendScore,
                        note: res.ok ? '' : (res.reason || '')
                    };
                    lastResults.push(row);
                } catch (e) {
                    lastResults.push({
                        symbol: sym, interval,
                        close2: '', ema2: '', close1: '', ema1: '',
                        match: false, lastPrice: '', todayOpen: '', pctFromTodayOpen: '',
                        emaDistancePct: '', emaSlopePct: '', trendScore: '',
                        note: (e && e.message) ? e.message : '에러'
                    });
                } finally {
                    done += 1;
                    setProgress(done, total);
                    $status.textContent = `스캔 중... ${done}/${total}`;
                    await sleep(50);
                }
            }
        }
    }

    // ======= 이벤트 =======
    $interval.addEventListener('change', () => {
        $tfBadge.textContent = `현재 간격: ${$interval.value}`;
    });

    $scanBtn.addEventListener('click', async () => {
        if ($scanBtn.disabled) return;
        $scanBtn.disabled = true;
        $stopBtn.disabled = false;
        try { await scan(); }
        catch (e) {
            console.error(e);
            $status.textContent = '오류: ' + (e && e.message ? e.message : e);
        } finally {
            $scanBtn.disabled = false;
            $stopBtn.disabled = true;
        }
    });

    $stopBtn.addEventListener('click', () => {
        abortFlag = true;
        $status.textContent = '중지 요청됨';
    });

    $exportBtn.addEventListener('click', () => {
        if (!lastResults.length) {
            alert('내보낼 결과가 없습니다.');
            return;
        }
        const order = $trendOrder.value;
        const matched = lastResults.filter(r => r.match).sort((a, b) => {
            if (order === 'asc') return (a.trendScore ?? -Infinity) - (b.trendScore ?? -Infinity);
            return (b.trendScore ?? -Infinity) - (a.trendScore ?? -Infinity);
        }).map((r, i) => ({ ...r, rank: i + 1 }));

        const csv = toCSV(matched);
        const now = new Date();
        const ts = now.toISOString().slice(0,19).replace(/[:T]/g,'-');
        downloadText(`scanner_${document.getElementById('interval').value}_ema${document.getElementById('emaLength').value}_trend_${order}_${ts}.csv`, csv);
    });
</script>
</body>
</html>
