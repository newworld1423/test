<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>15m EMA50 상방연속 스캐너 (USDT PERP)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 24px; }
  h1 { margin: 0 0 12px; }
  .controls { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end; margin-bottom: 12px; }
  .control { display: grid; gap: 6px; }
  label { font-size: 14px; opacity: .8; }
  input[type="number"], select { padding: 8px 10px; font-size: 14px; }
  button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
  .primary { background: #4f46e5; color: white; }
  .muted { background: #e5e7eb; }
  .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; opacity: .85; margin-top: 8px; }
  .bar-wrap { height: 10px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
  .bar { height: 100%; width: 0%; background: #10b981; transition: width .2s ease; }
  table { width: 100%; border-collapse: collapse; margin-top: 16px; }
  th, td { padding: 10px; border-bottom: 1px solid rgba(0,0,0,.1); text-align: left; font-size: 14px; }
  th { user-select: none; }
  .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; }
  .ok { background: #d1fae5; color: #065f46; }
  .warn { background: #fee2e2; color: #991b1b; }
  .neu { background: #e5e7eb; color: #111827; }
  .hint { font-size: 12px; opacity: .75; margin-top: 10px; }
</style>
</head>
<body>
<h1>15분봉 EMA50 상방연속 스캐너 (USDT PERP)</h1>

<div class="controls">
  <div class="control">
    <label>연속 상방 최소 개수 (기본 2)</label>
    <input id="minAbove" type="number" min="1" value="2" />
  </div>
  <div class="control">
    <label>검사 윈도우 (현재봉 제외, 기본 96)</label>
    <input id="windowLen" type="number" min="10" max="200" value="96" />
  </div>
  <div class="control">
    <label>EMA 기간 (기본 50)</label>
    <input id="emaPeriod" type="number" min="3" max="200" value="50" />
  </div>
  <div class="control">
    <label>동시 요청 (기본 6)</label>
    <input id="concurrency" type="number" min="1" max="20" value="6" />
  </div>
  <div class="control">
    <label>배치 딜레이(ms, 기본 150)</label>
    <input id="delayMs" type="number" min="0" max="5000" value="150" />
  </div>
  <div class="control">
    <label>재시도 (429/5xx, 기본 2)</label>
    <input id="maxRetries" type="number" min="0" max="5" value="2" />
  </div>

  <!-- ✅ 정렬 프리셋 -->
  <div class="control">
    <label>정렬 프리셋</label>
    <select id="sortPreset">
      <option value="streakAvgQuoteDelta" selected>상방연속 ↓ → 평균 거래대금(Quote) ↓ → Δ% ↓</option>
      <option value="streakOnly">상방연속 ↓</option>
      <option value="avgQuoteOnly">평균 거래대금(Quote) ↓</option>
      <option value="startQuoteOnly">시작봉 거래대금(Quote) ↓</option>
      <option value="startPremiumOnly">시작봉 프리미엄(%) ↓</option>
      <option value="deltaOnly">Δ% (종가-EMA50) ↓</option>
      <option value="symbolAZ">심볼 A→Z</option>
    </select>
  </div>

  <div class="control">
    <label>&nbsp;</label>
    <button id="scanBtn" class="primary">스캔 시작</button>
  </div>
  <div class="control">
    <label>&nbsp;</label>
    <button id="exportBtn" class="muted" disabled>CSV 내보내기</button>
  </div>
</div>

<div class="bar-wrap"><div id="bar" class="bar"></div></div>
<div id="status" class="status">준비됨</div>

<table id="resultTable">
  <thead>
    <tr>
      <th>심볼</th>
      <th>상방연속 개수</th>
      <th>상방연속 평균 거래대금(Quote)</th>
      <th>상방연속 시작봉 거래대금(Quote)</th>
      <th>시작봉 거래대금 vs 평균(%)</th>
      <th>Δ% (마지막 종료봉 종가-EMA50)</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<p class="hint">
  • 현재 진행 15분봉은 제외하고 이전 데이터만 계산합니다.<br>
  • 결과 포함: 마지막 종료봉부터 연속 <strong>종가 &gt; EMA50</strong>이 <strong>2개 이상</strong>.<br>
  • “시작봉”은 현재 상방연속 구간의 첫 봉(연속이 1로 카운트된 시점)입니다.
</p>

<script>
const EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo";
const KLINES_URL = "https://fapi.binance.com/fapi/v1/klines";
const INTERVAL = "15m";
const DEFAULT_LIMIT = 200;

const el = (id) => document.getElementById(id);
const statusEl = el("status");
const barEl = el("bar");
const tbody = document.querySelector("#resultTable tbody");
const scanBtn = el("scanBtn");
const exportBtn = el("exportBtn");
const sortPresetEl = el("sortPreset");

let lastResults = [];

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function fetchJsonWithRetry(url, maxRetries, attempt=0){
  try{
    const res = await fetch(url);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  }catch(e){
    if(attempt < maxRetries){
      const backoff = 400 * Math.pow(2, attempt);
      await sleep(backoff);
      return fetchJsonWithRetry(url, maxRetries, attempt+1);
    }
    throw e;
  }
}

async function loadSymbols(maxRetries){
  const data = await fetchJsonWithRetry(EXCHANGE_INFO_URL, maxRetries);
  const out = [];
  for(const s of data.symbols){
    if(s.quoteAsset==="USDT" && s.contractType==="PERPETUAL" && s.status==="TRADING"){
      out.push(s.symbol);
    }
  }
  out.sort();
  return out;
}

async function fetchKlines(symbol, limit, maxRetries){
  const url = `${KLINES_URL}?symbol=${symbol}&interval=${INTERVAL}&limit=${limit}`;
  return fetchJsonWithRetry(url, maxRetries);
}

function computeEMA(values, period){
  const k = 2/(period+1);
  const ema = new Array(values.length).fill(null);
  if(values.length < period) return ema;
  let sum=0;
  for(let i=0;i<period;i++) sum+=values[i];
  let prev = sum/period;
  ema[period-1]=prev;
  for(let i=period;i<values.length;i++){
    const next = values[i]*k + prev*(1-k);
    ema[i]=next; prev=next;
  }
  return ema;
}

function toNum(x){ return typeof x==="string" ? parseFloat(x) : x; }

// 연속 상방 개수 + 평균 Quote + 시작봉 Quote + 시작봉 프리미엄%
function streakFromLastClosed(closes, ema, volsQuote, windowLen){
  const lastClosed = closes.length - 2; // 현재봉 제외
  if(lastClosed < 0) return {aboveLen:0,lastClosed,avgQuote:0,startQuote:0,startPremiumPct:0};
  const end = lastClosed;
  const start = Math.max(0, end - windowLen + 1);

  let s = start;
  while(s<=end && (ema[s]==null)) s++;
  if(s> end) return {aboveLen:0,lastClosed,avgQuote:0,startQuote:0,startPremiumPct:0};

  let aboveLen=0, sumQuote=0;
  for(let i=end;i>=s;i--){
    if(closes[i] > ema[i]){ aboveLen++; sumQuote += volsQuote[i]; }
    else break;
  }
  if(aboveLen===0) return {aboveLen:0,lastClosed,avgQuote:0,startQuote:0,startPremiumPct:0};

  const startIdx = end - aboveLen + 1;
  const avgQuote = sumQuote / aboveLen;
  const startQuote = volsQuote[startIdx];
  const startPremiumPct = avgQuote>0 ? ((startQuote - avgQuote)/avgQuote)*100 : 0;

  return {aboveLen,lastClosed,avgQuote,startQuote,startPremiumPct};
}

function buildRow(rec){
  const deltaClass = rec.deltaPct>0 ? "ok" : (rec.deltaPct<0 ? "warn" : "neu");
  const premClass  = rec.startPremiumPct>0 ? "ok" : (rec.startPremiumPct<0 ? "warn" : "neu");
  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td><strong>${rec.symbol}</strong></td>
    <td><span class="pill ok">${rec.aboveLen}</span></td>
    <td class="mono">${rec.avgQuote.toLocaleString(undefined,{maximumFractionDigits:2})}</td>
    <td class="mono">${rec.startQuote.toLocaleString(undefined,{maximumFractionDigits:2})}</td>
    <td class="mono"><span class="pill ${premClass}">${rec.startPremiumPct.toFixed(2)}%</span></td>
    <td class="mono"><span class="pill ${deltaClass}">${rec.deltaPct.toFixed(2)}%</span></td>
  `;
  return tr;
}

function toCSV(rows){
  const header = ["symbol","aboveLen","avgQuote","startQuote","startPremiumPct","deltaPct"];
  const lines = [header.join(",")];
  for(const r of rows){
    lines.push([
      r.symbol,
      r.aboveLen,
      r.avgQuote,
      r.startQuote,
      r.startPremiumPct.toFixed(4),
      r.deltaPct.toFixed(4)
    ].join(","));
  }
  return lines.join("\n");
}

function download(filename, text){
  const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

function sortResults(results, preset){
  const data = [...results];
  switch(preset){
    case "streakAvgQuoteDelta":
      data.sort((a,b)=>{
        if(b.aboveLen!==a.aboveLen) return b.aboveLen-a.aboveLen;
        if(b.avgQuote!==a.avgQuote) return b.avgQuote-a.avgQuote;
        return b.deltaPct-a.deltaPct;
      }); break;
    case "streakOnly":
      data.sort((a,b)=> b.aboveLen-a.aboveLen ); break;
    case "avgQuoteOnly":
      data.sort((a,b)=> b.avgQuote-a.avgQuote ); break;
    case "startQuoteOnly":
      data.sort((a,b)=> b.startQuote-a.startQuote ); break;               /* ✅ 추가 */
    case "startPremiumOnly":
      data.sort((a,b)=> b.startPremiumPct-a.startPremiumPct ); break;     /* ✅ 추가 */
    case "deltaOnly":
      data.sort((a,b)=> b.deltaPct-a.deltaPct ); break;
    case "symbolAZ":
      data.sort((a,b)=> a.symbol.localeCompare(b.symbol) ); break;
    default: break;
  }
  return data;
}

function render(results){
  tbody.innerHTML="";
  for(const r of results) tbody.appendChild(buildRow(r));
}

async function scanAll(){
  scanBtn.disabled = true;
  exportBtn.disabled = true;
  tbody.innerHTML="";
  lastResults = [];

  const minAbove   = Math.max(1, parseInt(el("minAbove").value,10));   // 기본 2
  const windowLen  = Math.min(200, Math.max(10, parseInt(el("windowLen").value,10))); // 기본 96
  const emaPeriod  = Math.min(200, Math.max(3, parseInt(el("emaPeriod").value,10)));  // 기본 50
  const concurrency= Math.min(20, Math.max(1, parseInt(el("concurrency").value,10)));
  const delayMs    = Math.min(5000, Math.max(0, parseInt(el("delayMs").value,10)));
  const maxRetries = Math.min(5, Math.max(0, parseInt(el("maxRetries").value,10)));

  statusEl.textContent="심볼 목록 로드 중…";
  let symbols=[];
  try{ symbols = await loadSymbols(maxRetries); }
  catch(e){ statusEl.textContent="심볼 로드 실패: "+e.message; scanBtn.disabled=false; return; }

  const total = symbols.length;
  let done=0;
  const results=[];

  statusEl.textContent=`총 ${total}개 심볼 스캔 시작`;
  barEl.style.width="0%";

  const queue=[...symbols];
  const workers = new Array(concurrency).fill(0).map(async()=>{
    while(queue.length){
      const symbol = queue.shift();
      try{
        const kl = await fetchKlines(symbol, DEFAULT_LIMIT, maxRetries);
        // [0]openTime,[1]open,[2]high,[3]low,[4]close,[5]vol(base),[6]closeTime,[7]quoteAssetVolume,...
        const closes    = kl.map(k=> toNum(k[4]));
        const volsQuote = kl.map(k=> toNum(k[7]));
        const ema       = computeEMA(closes, emaPeriod);

        const {aboveLen,lastClosed,avgQuote,startQuote,startPremiumPct} =
          streakFromLastClosed(closes, ema, volsQuote, windowLen);

        if(aboveLen >= Math.max(2,minAbove)){
          const emaLast = ema[lastClosed];
          if(emaLast==null) throw new Error("EMA 부족");
          const lastClose = closes[lastClosed];
          if(!(lastClose>emaLast)) throw new Error("상방 불충족");

          const deltaPct = ((lastClose - emaLast)/emaLast)*100;

          results.push({ symbol, aboveLen, avgQuote, startQuote, startPremiumPct, deltaPct });
        }
      }catch(e){
        /* 심볼 단위 실패는 패스 */
      }finally{
        done++;
        if(done % concurrency === 0 && delayMs>0) await sleep(delayMs);
        const pct = Math.round((done/total)*100);
        barEl.style.width = pct+"%";
        statusEl.textContent = `스캔 진행: ${done}/${total} (${pct}%)`;
      }
    }
  });

  await Promise.all(workers);

  lastResults = results;
  const sorted = sortResults(lastResults, sortPresetEl.value);
  render(sorted);

  statusEl.textContent = `완료: ${results.length}개 심볼이 조건 충족 (${total}개 중)`;
  exportBtn.disabled = results.length===0;
  exportBtn.onclick = ()=>{
    const csv = toCSV(sorted);
    const stamp = new Date().toISOString().replace(/[:.]/g,"-");
    download(`scan_15m_ema50_aboveStreak_startPremium_${stamp}.csv`, csv);
  };

  scanBtn.disabled = false;
}

sortPresetEl.addEventListener("change", ()=>{
  if(!lastResults.length) return;
  const sorted = sortResults(lastResults, sortPresetEl.value);
  render(sorted);
});

el("scanBtn").addEventListener("click", scanAll);
</script>
</body>
</html>