<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT Perp — 15m EMA50 연속 전환 스캐너</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { color-scheme: light dark; }
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Apple SD Gothic Neo, sans-serif;
            margin: 0; padding: 24px; line-height: 1.5;
        }
        header { display: grid; gap: 12px; margin-bottom: 16px; }
        .controls {
            display: grid; gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            align-items: end;
        }
        .control { display: grid; gap: 6px; }
        label { font-size: 14px; opacity: 0.8; }
        input[type="number"] { padding: 8px 10px; font-size: 14px; }
        button {
            padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }
        .primary { background: #4f46e5; color: #fff; }
        .muted { background: #e5e7eb; color: #111; }
        .bar-wrap { height: 10px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
        .bar { height: 100%; width: 0%; background: #10b981; transition: width .2s ease; }
        .status { font-size: 13px; opacity: .8; }
        table { width: 100%; border-collapse: collapse; margin-top: 16px; }
        th, td { padding: 10px; border-bottom: 1px solid rgba(0,0,0,.1); text-align: left; font-size: 14px; }
        th { cursor: pointer; user-select: none; }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; }
        .ok { background: #d1fae5; color: #065f46; }
        .warn { background: #fee2e2; color: #991b1b; }
        .grid { display: grid; gap: 10px; }
        .hint { font-size: 12px; opacity: .75; }
        .row-actions { display:flex; gap:8px; }
    </style>
</head>
<body>
<header class="grid">
    <h1>Binance USDT Perp — 15분봉 EMA50 전환(연속) 스캐너</h1>
    <div class="controls">
        <div class="control">
            <label>연속 하방 구간 최소 캔들 수 (종가 &lt; EMA50)</label>
            <input id="minBelow" type="number" min="1" value="3" />
        </div>
        <div class="control">
            <label>연속 상방 구간 최소 캔들 수 (종가 &gt; EMA50)</label>
            <input id="minAbove" type="number" min="1" value="3" />
        </div>
        <div class="control">
            <label>스캔 범위(이전 캔들 수, 현재봉 제외)</label>
            <input id="windowLen" type="number" min="10" max="200" value="96" />
        </div>
        <div class="control">
            <label>EMA 기간</label>
            <input id="emaPeriod" type="number" min="3" max="200" value="50" />
        </div>
        <div class="control">
            <label>동시 요청 개수 (Concurrency)</label>
            <input id="concurrency" type="number" min="1" max="20" value="6" />
        </div>
        <div class="control">
            <label>요청 간 딜레이 (ms, 각 배치 간)</label>
            <input id="delayMs" type="number" min="0" max="5000" value="150" />
        </div>
        <div class="control">
            <label>재시도 (429/5xx) 최대 횟수</label>
            <input id="maxRetries" type="number" min="0" max="5" value="2" />
        </div>
        <div class="control">
            <label>&nbsp;</label>
            <button id="scanBtn" class="primary">스캔 시작</button>
        </div>
        <div class="control">
            <label>&nbsp;</label>
            <button id="exportBtn" class="muted" disabled>CSV 내보내기</button>
        </div>
    </div>
    <div class="grid">
        <div class="bar-wrap"><div id="bar" class="bar"></div></div>
        <div class="status mono" id="status">준비됨</div>
    </div>
</header>

<table id="resultTable">
    <thead>
    <tr>
        <th data-key="symbol">심볼</th>
        <th data-key="lastCloseTime">최근 종가(종료봉) 시간</th>
        <th data-key="lastClose">최근 종가</th>
        <th data-key="crossoverTime">전환 시작(상방 연속 시작) 시간</th>
        <th data-key="belowLen">이전 하방 연속</th>
        <th data-key="aboveLen">이후 상방 연속</th>
        <th data-key="freshAbove">현재 상방 유지</th>
        <th>동작</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<p class="hint">
    • “현재봉 제외” 처리로 <strong>마지막 미완료 15분봉은 버림</strong> — 분석은 그 이전 봉들로만 수행합니다.<br>
    • 조건: 윈도우(기본 96개) 내부에서 <strong>연속 하방(종가 &lt; EMA50)</strong> 구간이 있고, 그 <strong>이후</strong>에 <strong>연속 상방(종가 &gt; EMA50)</strong> 구간이 이어진 케이스만 표에 표시합니다.<br>
    • 연속 최소 길이(하방/상방)는 기본 3개이며, UI에서 조절 가능합니다.
</p>

<script>
    const EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const KLINES_URL = "https://fapi.binance.com/fapi/v1/klines";
    const INTERVAL = "15m"; // 고정
    const DEFAULT_LIMIT = 200; // EMA 워밍업 + 윈도우 확보용

    const el = (id) => document.getElementById(id);
    const statusEl = el("status");
    const barEl = el("bar");
    const tbody = document.querySelector("#resultTable tbody");
    const scanBtn = el("scanBtn");
    const exportBtn = el("exportBtn");

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchJsonWithRetry(url, maxRetries, attempt = 0) {
        try {
            const res = await fetch(url, { method: "GET" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return await res.json();
        } catch (err) {
            if (attempt < maxRetries) {
                const backoff = 400 * Math.pow(2, attempt);
                await sleep(backoff);
                return fetchJsonWithRetry(url, maxRetries, attempt + 1);
            }
            throw err;
        }
    }

    function computeEMA(values, period) {
        // values: number[]
        const k = 2 / (period + 1);
        const ema = new Array(values.length).fill(null);
        // 첫 SMA로 시작
        if (values.length < period) return ema;
        let sum = 0;
        for (let i = 0; i < period; i++) sum += values[i];
        let prev = sum / period;
        ema[period - 1] = prev;
        for (let i = period; i < values.length; i++) {
            const v = values[i];
            const next = v * k + prev * (1 - k);
            ema[i] = next;
            prev = next;
        }
        return ema;
    }

    function formatTs(ms) {
        const d = new Date(ms);
        // 한국 시간대 가독 출력
        return d.toLocaleString("ko-KR", { hour12: false });
        // 참고: Binance 타임스탬프는 UTC 기준 밀리초
    }

    function toNumber(x) { return typeof x === "string" ? parseFloat(x) : x; }

    function analyzeWindow(closes, ema, windowLen, minBelow, minAbove) {
        // 마지막 요소는 "현재 진행 봉"일 수 있으므로 제외: lastIndex = closes.length - 2
        const lastClosed = closes.length - 2;
        if (lastClosed < 1) return null;

        // 윈도우 시작/끝 인덱스 (둘 다 포함)
        const end = lastClosed;
        const start = Math.max(0, end - windowLen + 1);

        // closes[start..end], ema[start..end] 대상으로 탐색
        // 목표: start..end 내에서
        // 1) 종가<EMA 의 연속 구간 (길이>=minBelow)
        // 2) 그 이후에 종가>EMA 의 연속 구간 (길이>=minAbove)
        // 3) 마지막 종가(= closes[end])가 EMA보다 커서 현재 상방 유지 확인(선택적이지만 보통 원하심)
        const isAbove = (i) => closes[i] > ema[i];
        const isBelow = (i) => closes[i] < ema[i];

        // EMA가 null인 초기 구간은 제외
        let i = start;
        while (i <= end && (ema[i] === null || ema[i] === undefined)) i++;
        if (i > end) return null;

        // 아래→위 전환을 찾되, 전환 직전까지 충분한 하방 연속, 전환 후 충분한 상방 연속
        // 전환 포인트를 "상방 연속 구간이 시작된 첫 인덱스"로 정의
        for (let pivot = i; pivot <= end; pivot++) {
            if (!isAbove(pivot)) continue; // 상방 연속 시작 후보는 above여야 함

            // 뒤로 가며 직전이 below였는지 확인하여 "전환 직전" 경계 확인(엄밀히 직전이 below일 필요는 없지만, 의미상 전환 감지)
            // 대신 보다 명확히: pivot 이전에 minBelow 이상 연속 below 구간이 존재했는지 체크
            let belowRunMax = 0, cur = 0;
            for (let j = i; j < pivot; j++) {
                if (isBelow(j)) { cur++; belowRunMax = Math.max(belowRunMax, cur); }
                else cur = 0;
            }
            if (belowRunMax < minBelow) continue;

            // pivot부터 상방 연속 길이 측정
            let aboveLen = 0;
            let k = pivot;
            while (k <= end && isAbove(k)) { aboveLen++; k++; }
            if (aboveLen < minAbove) continue;

            // 조건 만족: 가장 이른 pivot 반환
            return {
                pivot,                 // 상방 연속 시작 인덱스
                aboveLen,              // 상방 연속 길이 (윈도우 끝에서 끊길 수 있음)
                maxBelowLen: belowRunMax
            };
        }
        return null;
    }

    function buildRow(rec) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
            <td><strong>${rec.symbol}</strong></td>
            <td class="mono">${formatTs(rec.lastCloseTime)}</td>
            <td class="mono">${rec.lastClose.toLocaleString(undefined, { maximumFractionDigits: 6 })}</td>
            <td class="mono">${rec.crossoverTime ? formatTs(rec.crossoverTime) : "-"}</td>
            <td><span class="pill warn">${rec.belowLen}</span></td>
            <td><span class="pill ok">${rec.aboveLen}</span></td>
            <td>${rec.freshAbove ? '<span class="pill ok">상방 유지</span>' : '<span class="pill warn">깨짐</span>'}</td>
            <td class="row-actions">
                <a target="_blank" rel="noopener" href="https://www.binance.com/ko/futures/${rec.symbol}">선물 차트</a>
                <a target="_blank" rel="noopener" href="https://www.tradingview.com/chart/?symbol=BINANCE%3A${rec.symbol.replace('USDT','USDT.P')}"
                   title="TradingView: BINANCE perpetual 표기 주의">TV</a>
            </td>
        `;
        return tr;
    }

    function toCSV(data) {
        const header = [
            "symbol","lastCloseTime","lastClose","crossoverTime","belowLen","aboveLen","freshAbove"
        ];
        const lines = [header.join(",")];
        for (const d of data) {
            lines.push([
                d.symbol,
                new Date(d.lastCloseTime).toISOString(),
                d.lastClose,
                d.crossoverTime ? new Date(d.crossoverTime).toISOString() : "",
                d.belowLen,
                d.aboveLen,
                d.freshAbove ? "1" : "0"
            ].join(","));
        }
        return lines.join("\n");
    }

    function downloadText(filename, text) {
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
    }

    // 심볼 목록 로드 (USDT, PERPETUAL, TRADING)
    async function loadSymbols(maxRetries) {
        const data = await fetchJsonWithRetry(EXCHANGE_INFO_URL, maxRetries);
        const out = [];
        for (const s of data.symbols) {
            if (
                s.quoteAsset === "USDT" &&
                s.contractType === "PERPETUAL" &&
                s.status === "TRADING" &&
                !s.pair?.endsWith("_NEXTQUARTER") // 방어적
            ) {
                out.push(s.symbol);
            }
        }
        out.sort();
        return out;
    }

    async function fetchKlines(symbol, limit, maxRetries) {
        const url = `${KLINES_URL}?symbol=${symbol}&interval=${INTERVAL}&limit=${limit}`;
        return fetchJsonWithRetry(url, maxRetries);
    }

    async function scanAll() {
        scanBtn.disabled = true;
        exportBtn.disabled = true;
        tbody.innerHTML = "";

        const minBelow = Math.max(1, parseInt(el("minBelow").value, 10));
        const minAbove = Math.max(1, parseInt(el("minAbove").value, 10));
        const windowLen = Math.min(200, Math.max(10, parseInt(el("windowLen").value, 10)));
        const emaPeriod = Math.min(200, Math.max(3, parseInt(el("emaPeriod").value, 10)));
        const concurrency = Math.min(20, Math.max(1, parseInt(el("concurrency").value, 10)));
        const delayMs = Math.min(5000, Math.max(0, parseInt(el("delayMs").value, 10)));
        const maxRetries = Math.min(5, Math.max(0, parseInt(el("maxRetries").value, 10)));

        statusEl.textContent = "심볼 목록 불러오는 중…";
        let symbols;
        try {
            symbols = await loadSymbols(maxRetries);
        } catch (e) {
            statusEl.textContent = `심볼 로드 실패: ${e.message}`;
            scanBtn.disabled = false;
            return;
        }

        const total = symbols.length;
        let done = 0;
        const results = [];

        statusEl.textContent = `총 ${total}개 USDT PERP 심볼 스캔 시작`;
        barEl.style.width = "0%";

        // 간단한 작업 풀
        const queue = [...symbols];
        const workers = new Array(concurrency).fill(0).map(async (_, workerIdx) => {
            while (queue.length) {
                const symbol = queue.shift();
                try {
                    const kl = await fetchKlines(symbol, DEFAULT_LIMIT, maxRetries);
                    // kline: [openTime, open, high, low, close, volume, closeTime, ...]
                    // 마지막 요소(인덱스 length-1)는 진행 중 캔들이 포함되므로 나중에 제외
                    const closes = kl.map(k => toNumber(k[4]));
                    const closeTimes = kl.map(k => k[6]); // closeTime ms

                    const ema = computeEMA(closes, emaPeriod);

                    // 현재봉 제외 -> lastClosed = closes.length - 2
                    const lastClosedIdx = closes.length - 2;
                    if (lastClosedIdx < 0) throw new Error("캔들이 부족");

                    const analysis = analyzeWindow(closes, ema, windowLen, minBelow, minAbove);
                    if (analysis) {
                        const freshAbove = closes[lastClosedIdx] > ema[lastClosedIdx];
                        const rec = {
                            symbol,
                            lastCloseTime: closeTimes[lastClosedIdx],
                            lastClose: closes[lastClosedIdx],
                            crossoverTime: closeTimes[analysis.pivot],
                            belowLen: analysis.maxBelowLen,
                            aboveLen: analysis.aboveLen,
                            freshAbove
                        };
                        results.push(rec);
                    }
                } catch (err) {
                    // 심볼 개별 실패는 무시하고 진행
                    // console.warn(symbol, err);
                } finally {
                    done++;
                    if (done % concurrency === 0 && delayMs > 0) {
                        // 배치 간 살짝 쉬어 레이트 리밋 완화
                        await sleep(delayMs);
                    }
                    const pct = Math.round((done / total) * 100);
                    barEl.style.width = pct + "%";
                    statusEl.textContent = `스캔 진행: ${done}/${total} (${pct}%)`;
                }
            }
        });

        await Promise.all(workers);

        // 정렬: 상방 연속 길이 ↓, 전환 최신순 ↓
        results.sort((a, b) => {
            if (b.aboveLen !== a.aboveLen) return b.aboveLen - a.aboveLen;
            return b.crossoverTime - a.crossoverTime;
        });

        for (const r of results) tbody.appendChild(buildRow(r));

        statusEl.textContent = `완료: ${results.length}개 심볼이 조건을 만족 (${total}개 중)`;
        exportBtn.disabled = results.length === 0;
        exportBtn.onclick = () => {
            const csv = toCSV(results);
            const stamp = new Date().toISOString().replace(/[:.]/g, "-");
            downloadText(`scan_15m_ema50_${stamp}.csv`, csv);
        };

        scanBtn.disabled = false;
    }

    // 간단 정렬(헤더 클릭)
    (function initSort() {
        const ths = document.querySelectorAll("#resultTable thead th[data-key]");
        let sortKey = "aboveLen";
        let asc = false;
        ths.forEach(th => {
            th.addEventListener("click", () => {
                const key = th.getAttribute("data-key");
                if (sortKey === key) asc = !asc; else { sortKey = key; asc = false; }

                const rows = Array.from(tbody.querySelectorAll("tr"));
                const idxMap = {
                    symbol: 0, lastCloseTime: 1, lastClose: 2, crossoverTime: 3,
                    belowLen: 4, aboveLen: 5, freshAbove: 6
                };
                const colIdx = idxMap[sortKey] ?? 5;

                rows.sort((ra, rb) => {
                    const a = ra.children[colIdx].textContent.trim();
                    const b = rb.children[colIdx].textContent.trim();
                    let av = a, bv = b;
                    if (colIdx === 1 || colIdx === 3) {
                        // 날짜
                        av = a === "-" ? 0 : new Date(a).getTime();
                        bv = b === "-" ? 0 : new Date(b).getTime();
                    } else if (colIdx === 2 || colIdx === 4 || colIdx === 5) {
                        av = parseFloat(a.replace(/[,]/g, "")) || 0;
                        bv = parseFloat(b.replace(/[,]/g, "")) || 0;
                    } else if (colIdx === 6) {
                        av = a.includes("유지") ? 1 : 0;
                        bv = b.includes("유지") ? 1 : 0;
                    }
                    return asc ? (av > bv ? 1 : av < bv ? -1 : 0) : (av < bv ? 1 : av > bv ? -1 : 0);
                });
                tbody.innerHTML = "";
                rows.forEach(r => tbody.appendChild(r));
            });
        });
    }());

    scanBtn.addEventListener("click", () => { scanAll(); });
</script>
</body>
</html>
