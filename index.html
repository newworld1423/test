<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>15m EMA50 상방연속 스캐너 (USDT PERP)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { color-scheme: light dark; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 24px; }
        h1 { margin: 0 0 12px; }
        .controls { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); align-items: end; margin-bottom: 12px; }
        .control { display: grid; gap: 6px; }
        label { font-size: 14px; opacity: .8; }
        input[type="number"] { padding: 8px 10px; font-size: 14px; }
        button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
        .primary { background: #4f46e5; color: white; }
        .muted { background: #e5e7eb; }
        .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; opacity: .85; margin-top: 8px; }
        .bar-wrap { height: 10px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
        .bar { height: 100%; width: 0%; background: #10b981; transition: width .2s ease; }
        table { width: 100%; border-collapse: collapse; margin-top: 16px; }
        th, td { padding: 10px; border-bottom: 1px solid rgba(0,0,0,.1); text-align: left; font-size: 14px; }
        th { user-select: none; }
        .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; }
        .ok { background: #d1fae5; color: #065f46; }
        .warn { background: #fee2e2; color: #991b1b; }
        .neu { background: #e5e7eb; color: #111827; }
        .row-actions { display: flex; gap: 8px; }
        .hint { font-size: 12px; opacity: .75; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>15분봉 EMA50 상방연속 스캐너 (USDT PERP)</h1>

    <div class="controls">
        <div class="control">
            <label>연속 상방 최소 개수 (기본 2)</label>
            <input id="minAbove" type="number" min="1" value="2" />
        </div>
        <div class="control">
            <label>검사 윈도우 (현재봉 제외, 기본 96)</label>
            <input id="windowLen" type="number" min="10" max="200" value="96" />
        </div>
        <div class="control">
            <label>EMA 기간 (기본 50)</label>
            <input id="emaPeriod" type="number" min="3" max="200" value="50" />
        </div>
        <div class="control">
            <label>동시 요청 (기본 6)</label>
            <input id="concurrency" type="number" min="1" max="20" value="6" />
        </div>
        <div class="control">
            <label>배치 딜레이(ms, 기본 150)</label>
            <input id="delayMs" type="number" min="0" max="5000" value="150" />
        </div>
        <div class="control">
            <label>재시도 (429/5xx, 기본 2)</label>
            <input id="maxRetries" type="number" min="0" max="5" value="2" />
        </div>
        <div class="control">
            <label>&nbsp;</label>
            <button id="scanBtn" class="primary">스캔 시작</button>
        </div>
        <div class="control">
            <label>&nbsp;</label>
            <button id="exportBtn" class="muted" disabled>CSV 내보내기</button>
        </div>
    </div>

    <div class="bar-wrap"><div id="bar" class="bar"></div></div>
    <div id="status" class="status">준비됨</div>

    <table id="resultTable">
        <thead>
            <tr>
                <th>심볼</th>
                <th>마지막 종료봉 시간</th>
                <th>마지막 종가</th>
                <th>상방연속 개수</th>
                <th>거래량(Base)</th>
                <th>거래대금(Quote)</th>
                <th>Δ% (종가-EMA50)</th>
                <th>링크</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <p class="hint">
        • “현재봉 제외” 처리: 마지막 진행 중 15분봉은 제외하고 그 이전 데이터만 사용합니다.<br>
        • 결과 포함 조건: 마지막 종료봉부터 연속 <strong>종가 &gt; EMA50</strong>이 <strong>2개 이상</strong>.<br>
        • 정렬: <strong>상방연속 개수 ↓ → 거래대금(Quote) ↓ → Δ%(종가-EMA50) ↓</strong>.
    </p>

<script>
    const EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const KLINES_URL = "https://fapi.binance.com/fapi/v1/klines";
    const INTERVAL = "15m";
    const DEFAULT_LIMIT = 200; // EMA 워밍업 + 96 윈도우

    const el = (id) => document.getElementById(id);
    const statusEl = el("status");
    const barEl = el("bar");
    const tbody = document.querySelector("#resultTable tbody");
    const scanBtn = el("scanBtn");
    const exportBtn = el("exportBtn");

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchJsonWithRetry(url, maxRetries, attempt = 0) {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return await res.json();
        } catch (e) {
            if (attempt < maxRetries) {
                const backoff = 400 * Math.pow(2, attempt);
                await sleep(backoff);
                return fetchJsonWithRetry(url, maxRetries, attempt + 1);
            }
            throw e;
        }
    }

    async function loadSymbols(maxRetries) {
        const data = await fetchJsonWithRetry(EXCHANGE_INFO_URL, maxRetries);
        const out = [];
        for (const s of data.symbols) {
            if (s.quoteAsset === "USDT" && s.contractType === "PERPETUAL" && s.status === "TRADING") {
                out.push(s.symbol);
            }
        }
        out.sort();
        return out;
    }

    async function fetchKlines(symbol, limit, maxRetries) {
        const url = `${KLINES_URL}?symbol=${symbol}&interval=${INTERVAL}&limit=${limit}`;
        return fetchJsonWithRetry(url, maxRetries);
    }

    function computeEMA(values, period) {
        const k = 2 / (period + 1);
        const ema = new Array(values.length).fill(null);
        if (values.length < period) return ema;
        let sum = 0;
        for (let i = 0; i < period; i++) sum += values[i];
        let prev = sum / period;
        ema[period - 1] = prev;
        for (let i = period; i < values.length; i++) {
            const next = values[i] * k + prev * (1 - k);
            ema[i] = next;
            prev = next;
        }
        return ema;
    }

    function fmtTs(ms) {
        return new Date(ms).toLocaleString("ko-KR", { hour12: false });
    }

    function toNum(x) { return typeof x === "string" ? parseFloat(x) : x; }

    // ✅ 핵심: 마지막 종료봉부터 뒤로 연속 "종가 > EMA" 개수만 계산
    function countAboveFromLastClosed(closes, ema, windowLen) {
        const lastClosed = closes.length - 2; // 현재 진행봉 제외
        if (lastClosed < 0) return { aboveLen: 0, lastClosed };
        const end = lastClosed;
        const start = Math.max(0, end - windowLen + 1);

        // EMA가 null인 구간 지나치기
        let s = start;
        while (s <= end && (ema[s] == null)) s++;
        if (s > end) return { aboveLen: 0, lastClosed };

        let aboveLen = 0;
        for (let i = end; i >= s; i--) {
            if (closes[i] > ema[i]) {
                aboveLen++;
            } else {
                break; // 연속이 끊기면 종료
            }
        }
        return { aboveLen, lastClosed };
    }

    function buildRow(rec) {
        const signClass = rec.deltaPct > 0 ? "ok" : (rec.deltaPct < 0 ? "warn" : "neu");
        const tr = document.createElement("tr");
        tr.innerHTML = `
            <td><strong>${rec.symbol}</strong></td>
            <td class="mono">${fmtTs(rec.lastCloseTime)}</td>
            <td class="mono">${rec.lastClose.toLocaleString(undefined, { maximumFractionDigits: 6 })}</td>
            <td><span class="pill ok">${rec.aboveLen}</span></td>
            <td class="mono">${rec.volBase.toLocaleString(undefined, { maximumFractionDigits: 6 })}</td>
            <td class="mono">${rec.volQuote.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
            <td class="mono"><span class="pill ${signClass}">${rec.deltaPct.toFixed(2)}%</span></td>
            <td class="row-actions">
                <a target="_blank" rel="noopener" href="https://www.binance.com/ko/futures/${rec.symbol}">선물</a>
                <a target="_blank" rel="noopener" href="https://www.tradingview.com/chart/?symbol=BINANCE%3A${rec.symbol.replace('USDT','USDT.P')}">TV</a>
            </td>
        `;
        return tr;
    }

    function toCSV(rows) {
        const header = ["symbol","lastCloseTime","lastClose","aboveLen","volBase","volQuote","deltaPct"];
        const lines = [header.join(",")];
        for (const r of rows) {
            lines.push([
                r.symbol,
                new Date(r.lastCloseTime).toISOString(),
                r.lastClose,
                r.aboveLen,
                r.volBase,
                r.volQuote,
                r.deltaPct.toFixed(4)
            ].join(","));
        }
        return lines.join("\n");
    }

    function download(filename, text) {
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
    }

    async function scanAll() {
        scanBtn.disabled = true;
        exportBtn.disabled = true;
        tbody.innerHTML = "";

        const minAbove = Math.max(1, parseInt(el("minAbove").value, 10)); // 기본 2
        const windowLen = Math.min(200, Math.max(10, parseInt(el("windowLen").value, 10))); // 기본 96
        const emaPeriod = Math.min(200, Math.max(3, parseInt(el("emaPeriod").value, 10)));  // 기본 50
        const concurrency = Math.min(20, Math.max(1, parseInt(el("concurrency").value, 10)));
        const delayMs = Math.min(5000, Math.max(0, parseInt(el("delayMs").value, 10)));
        const maxRetries = Math.min(5, Math.max(0, parseInt(el("maxRetries").value, 10)));

        statusEl.textContent = "심볼 목록 로드 중…";
        let symbols = [];
        try {
            symbols = await loadSymbols(maxRetries);
        } catch (e) {
            statusEl.textContent = "심볼 로드 실패: " + e.message;
            scanBtn.disabled = false;
            return;
        }

        const total = symbols.length;
        let done = 0;
        const results = [];

        statusEl.textContent = `총 ${total}개 심볼 스캔 시작`;
        barEl.style.width = "0%";

        const queue = [...symbols];
        const workers = new Array(concurrency).fill(0).map(async () => {
            while (queue.length) {
                const symbol = queue.shift();
                try {
                    const kl = await fetchKlines(symbol, DEFAULT_LIMIT, maxRetries);
                    // kline: [0]openTime,[1]open,[2]high,[3]low,[4]close,[5]volume(base),[6]closeTime,[7]quoteAssetVolume, ...
                    const closes = kl.map(k => toNum(k[4]));
                    const volsBase = kl.map(k => toNum(k[5]));
                    const closeTimes = kl.map(k => k[6]);
                    const volsQuote = kl.map(k => toNum(k[7]));

                    const ema = computeEMA(closes, emaPeriod);

                    // 마지막 종료봉 인덱스
                    const { aboveLen, lastClosed } = countAboveFromLastClosed(closes, ema, windowLen);

                    // 조건: 연속 상방 개수 >= 2 (기본)
                    if (aboveLen >= Math.max(2, minAbove)) {
                        const emaLast = ema[lastClosed];
                        if (emaLast == null) throw new Error("EMA 부족");
                        const lastClose = closes[lastClosed];

                        // 안전차단: 반드시 위에 있어야 함
                        if (!(lastClose > emaLast)) throw new Error("상방 불충족");

                        const deltaPct = ((lastClose - emaLast) / emaLast) * 100;

                        results.push({
                            symbol,
                            lastCloseTime: closeTimes[lastClosed],
                            lastClose,
                            aboveLen,
                            volBase: volsBase[lastClosed],
                            volQuote: volsQuote[lastClosed],
                            deltaPct
                        });
                    }
                } catch (e) {
                    // 심볼 단위 실패는 무시
                } finally {
                    done++;
                    if (done % concurrency === 0 && delayMs > 0) await sleep(delayMs);
                    const pct = Math.round((done / total) * 100);
                    barEl.style.width = pct + "%";
                    statusEl.textContent = `스캔 진행: ${done}/${total} (${pct}%)`;
                }
            }
        });

        await Promise.all(workers);

        // ✅ 정렬: 상방연속 ↓ → 거래대금(Quote) ↓ → Δ% ↓
        results.sort((a, b) => {
            if (b.aboveLen !== a.aboveLen) return b.aboveLen - a.aboveLen;
            if (b.volQuote !== a.volQuote) return b.volQuote - a.volQuote;
            return b.deltaPct - a.deltaPct;
        });

        for (const r of results) tbody.appendChild(buildRow(r));

        statusEl.textContent = `완료: ${results.length}개 심볼이 조건 충족 (${total}개 중)`;
        exportBtn.disabled = results.length === 0;
        exportBtn.onclick = () => {
            const csv = toCSV(results);
            const stamp = new Date().toISOString().replace(/[:.]/g, "-");
            download(`scan_15m_ema50_aboveStreak_${stamp}.csv`, csv);
        };

        scanBtn.disabled = false;
    }

    el("scanBtn").addEventListener("click", scanAll);
</script>
</body>
</html>
