<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT-PERP 50EMA 크로스 스캐너 (MTF + ADX)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { --bg:#0b1220; --fg:#e8eefc; --muted:#9fb0d0; --accent:#6ab0ff; --ok:#35c46a; --bad:#ff6a6a; }
        body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Helvetica, Arial; background:var(--bg); color:var(--fg); }
        header { padding: 20px; border-bottom: 1px solid #1b2742; }
        h1 { margin:0 0 8px; font-size: 20px; }
        p.note { margin:6px 0 0; color:var(--muted); font-size: 13px; }
        main { padding: 16px 20px 84px; max-width: 1400px; }
        .controls { display: grid; grid-template-columns: repeat(8, minmax(150px, 1fr)); gap: 10px; margin-bottom: 12px; }
        .controls > div { background:#0f1a33; border:1px solid #1b2742; border-radius:12px; padding:12px; }
        label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
        input, select, button { width:100%; box-sizing:border-box; border-radius:8px; border:1px solid #2a3b63; background:#0b172f; color:var(--fg); padding:10px 12px; font-size:14px; }
        button.primary { background:linear-gradient(180deg,#1e86ff,#1063cf); border:0; cursor:pointer; }
        button.secondary { background:#142449; border:1px solid #2a3b63; cursor:pointer; }
        .row { display:flex; gap:10px; align-items:center; margin: 14px 0; flex-wrap: wrap; }
        .progress { height:10px; background:#122043; border-radius:999px; overflow:hidden; border:1px solid #213362; }
        .bar { height:100%; width:0%; background:linear-gradient(90deg,#37a8ff,#6ab0ff); transition:width .2s ease; }
        table { width:100%; border-collapse: collapse; margin-top: 12px; }
        th, td { padding:10px 12px; border-bottom: 1px solid #1b2742; text-align:left; font-size:14px; }
        th { position: sticky; top:0; background:#0f1a33; z-index:1; }
        .small { font-size:12px; color:var(--muted); }
        footer { position:fixed; inset:auto 0 0 0; background:#0f1a33; border-top:1px solid #1b2742; padding:10px 20px; display:flex; gap:10px; align-items:center; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
        .nowrap { white-space: nowrap; }
        .right { margin-left:auto; display:flex; gap:10px; }
        .pill { font-size: 12px; padding:3px 8px; border-radius:999px; border:1px solid #2a3b63; color:var(--muted); }
        .ok { color:var(--ok); }
        .bad { color:var(--bad); }
        .chips { display:flex; gap:8px; flex-wrap:wrap; }
        .chips label { display:flex; gap:8px; align-items:center; margin:0; }
    </style>
</head>
<body>
<header>
    <h1>Binance USDT-PERP 50EMA 크로스 스캐너</h1>
    <p class="note">조건: ① 2봉 전 종가 &lt; 50EMA ② 1봉 전 종가 &gt; 50EMA (선택 간격). 추가: 오늘(UTC) 일봉 시가 대비 %, ADX(14)·±DI, MTF 합성 점수.</p>
</header>
<main>
    <section class="controls">
        <div>
            <label>선택 간격 (조건/ADX 계산)</label>
            <select id="interval">
                <option value="15m">15분</option>
                <option value="1h">1시간</option>
                <option value="4h">4시간</option>
                <option value="1d" selected>1일</option>
            </select>
            <div class="small">크로스/ADX는 여기 기준</div>
        </div>
        <div>
            <label>EMA 길이</label>
            <input id="emaLength" type="number" value="50" min="2" />
            <div class="small">기본 50EMA</div>
        </div>
        <div>
            <label>Kline 개수 (limit)</label>
            <input id="klineLimit" type="number" value="300" min="80" />
            <div class="small">MTF/ADX용 여유 권장</div>
        </div>
        <div>
            <label>동시 요청 개수</label>
            <input id="concurrency" type="number" value="5" min="1" max="20" />
            <div class="small">레이트 리밋 보호</div>
        </div>
        <div>
            <label>심볼 필터(포함)</label>
            <input id="symbolFilter" placeholder="예: BTC,ETH,SOL (비워두면 전체)" />
            <div class="small">쉼표로 여러 개</div>
        </div>

        <div>
            <label>MTF 사용 간격</label>
            <div class="chips">
                <label><input type="checkbox" class="mtf" value="15m" checked />15m</label>
                <label><input type="checkbox" class="mtf" value="1h" checked />1h</label>
                <label><input type="checkbox" class="mtf" value="4h" checked />4h</label>
                <label><input type="checkbox" class="mtf" value="1d" checked />1d</label>
            </div>
            <div class="small">합성 점수 계산에 사용</div>
        </div>

        <div>
            <label>MTF 가중 프리셋</label>
            <select id="mtfPreset">
                <option value="balanced" selected>균형 (15m:25, 1h:25, 4h:25, 1d:25)</option>
                <option value="scalp">단타 (15m:40, 1h:30, 4h:20, 1d:10)</option>
                <option value="swing">스윙 (15m:10, 1h:20, 4h:35, 1d:35)</option>
            </select>
            <div class="small" id="weightsView">현재 가중치: 25/25/25/25</div>
        </div>

        <div>
            <label>정렬 기준</label>
            <select id="sortMetric">
                <option value="mtf" selected>MTF 합성 점수</option>
                <option value="single">단일 추세율(선택 간격)</option>
            </select>
            <div class="small">표/CSV 모두 적용</div>
        </div>

        <div>
            <label>정렬 방향</label>
            <select id="trendOrder">
                <option value="desc" selected>내림차순 (강한 순)</option>
                <option value="asc">오름차순 (약한 순)</option>
            </select>
            <div class="small">롱 관점</div>
        </div>

        <div>
            <label>ADX 부스트</label>
            <div class="chips">
                <label><input type="checkbox" id="adxBoost" />선택 간격 ADX로 가산</label>
            </div>
            <div class="small">보정식: base × (1 + max(0, ADX−20)/100)</div>
        </div>
    </section>

    <div class="row">
        <button id="scanBtn" class="primary">스캔 시작</button>
        <button id="stopBtn" class="secondary" disabled>중지</button>
        <span id="status" class="small">준비됨</span>
        <span class="pill nowrap" id="tfBadge">현재 간격: 1d</span>
    </div>

    <div class="row">
        <div class="progress" style="flex:1;">
            <div class="bar" id="bar"></div>
        </div>
        <span id="progText" class="small nowrap">0 / 0</span>
    </div>

    <table id="resultTable">
        <thead>
            <tr>
                <th>#</th>
                <th>심볼</th>
                <th>선택 간격</th>
                <th>2봉 전 종가</th>
                <th>2봉 전 50EMA</th>
                <th>1봉 전 종가</th>
                <th>1봉 전 50EMA</th>
                <th>조건</th>
                <th>현재가</th>
                <th>오늘(UTC) 시가</th>
                <th>오늘 시가 대비 %</th>
                <th>ADX(14)</th>
                <th>+DI</th>
                <th>−DI</th>
                <th>단일 추세율</th>
                <th>MTF 합성 점수</th>
                <th>최종 점수</th>
                <th>비고</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</main>

<footer>
    <span class="small">출처: Binance Futures API (klines, ticker)</span>
    <div class="right">
        <button id="exportBtn" class="secondary">CSV 내보내기</button>
    </div>
</footer>

<script>
    // ======= DOM & 상태 =======
    const API = "https://fapi.binance.com";
    const $scanBtn = document.getElementById('scanBtn');
    const $stopBtn = document.getElementById('stopBtn');
    const $interval = document.getElementById('interval');
    const $emaLength = document.getElementById('emaLength');
    const $klineLimit = document.getElementById('klineLimit');
    const $concurrency = document.getElementById('concurrency');
    const $symbolFilter = document.getElementById('symbolFilter');
    const $status = document.getElementById('status');
    const $bar = document.getElementById('bar');
    const $progText = document.getElementById('progText');
    const $tbody = document.querySelector('#resultTable tbody');
    const $exportBtn = document.getElementById('exportBtn');
    const $tfBadge = document.getElementById('tfBadge');
    const $mtfPreset = document.getElementById('mtfPreset');
    const $weightsView = document.getElementById('weightsView');
    const $sortMetric = document.getElementById('sortMetric');
    const $trendOrder = document.getElementById('trendOrder');
    const $adxBoost = document.getElementById('adxBoost');

    let abortFlag = false;
    let lastResults = [];

    // ======= 유틸 =======
    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
    function fmt(x, d=6) { return (x == null || x === '') ? '' : Number(x).toFixed(d); }
    function pf(x) {
        if (x == null || x === '') return '';
        const n = Number(x);
        const s = n >= 0 ? `+${n.toFixed(2)}%` : `${n.toFixed(2)}%`;
        return s;
    }
    function setProgress(done, total) {
        const pct = total ? Math.round(done * 100 / total) : 0;
        $bar.style.width = pct + '%';
        $progText.textContent = `${done} / ${total}`;
    }
    function toCSV(rows) {
        const esc = (v) => {
            if (v == null) return '';
            const s = String(v);
            if (s.includes('"') || s.includes(',') || s.includes('\n')) {
                return `"${s.replace(/"/g, '""')}"`;
            }
            return s;
        };
        const header = [
            "rank","symbol","interval",
            "close_2","ema_2","close_1","ema_1","match",
            "last_price","today_open","pct_from_today_open",
            "adx14","+di14","-di14",
            "single_trend","mtf_score","final_score","note"
        ];
        const lines = [header.join(',')];
        for (const r of rows) {
            lines.push([
                r.rank, r.symbol, r.interval,
                r.close2, r.ema2, r.close1, r.ema1, r.match,
                r.lastPrice, r.todayOpen, r.pctFromTodayOpen,
                r.adx14, r.plusDI14, r.minusDI14,
                r.singleTrend, r.mtfScore, r.finalScore, r.note || ""
            ].map(esc).join(','));
        }
        return lines.join('\n');
    }
    function downloadText(filename, text) {
        const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    // ======= Binance API =======
    async function fetchUSDTPerpSymbols() {
        const res = await fetch(`${API}/fapi/v1/exchangeInfo`);
        if (!res.ok) throw new Error('exchangeInfo 실패: ' + res.status);
        const data = await res.json();
        return data.symbols
            .filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING')
            .map(s => s.symbol);
    }
    async function fetchKlines(symbol, interval, limit) {
        const url = `${API}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`klines 실패(${symbol} ${interval}): ` + res.status);
        const data = await res.json();
        return data.map(row => ({
            openTime: row[0],
            open: Number(row[1]),
            high: Number(row[2]),
            low: Number(row[3]),
            close: Number(row[4]),
            closeTime: row[6]
        }));
    }
    async function fetchAllLastPricesMap() {
        const res = await fetch(`${API}/fapi/v1/ticker/price`);
        if (!res.ok) throw new Error('ticker/price 실패: ' + res.status);
        const arr = await res.json();
        return new Map(arr.map(o => [o.symbol, Number(o.price)]));
    }
    async function fetchTodayOpen1D(symbol) {
        const kl = await fetchKlines(symbol, '1d', 2);
        if (!kl.length) return null;
        return kl[kl.length - 1].open;
    }

    // ======= EMA =======
    function ema(values, length) {
        if (values.length < length) return [];
        const k = 2 / (length + 1);
        const out = new Array(values.length);
        let sum = 0;
        for (let i = 0; i < length; i++) sum += values[i];
        out[length - 1] = sum / length;
        for (let i = length; i < values.length; i++) {
            out[i] = values[i] * k + out[i - 1] * (1 - k);
        }
        return out;
    }

    // ======= ADX(14) 계산 (Wilder) =======
    function computeADX14(candles, period = 14) {
        if (!candles || candles.length < period + 20) return { adx: null, plusDI: null, minusDI: null };
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        const closes = candles.map(c => c.close);
        const len = candles.length;

        const TR = new Array(len).fill(0);
        const plusDM = new Array(len).fill(0);
        const minusDM = new Array(len).fill(0);

        for (let i = 1; i < len; i++) {
            const upMove = highs[i] - highs[i - 1];
            const downMove = lows[i - 1] - lows[i];
            plusDM[i] = (upMove > downMove && upMove > 0) ? upMove : 0;
            minusDM[i] = (downMove > upMove && downMove > 0) ? downMove : 0;

            const highLow = highs[i] - lows[i];
            const highClose = Math.abs(highs[i] - closes[i - 1]);
            const lowClose = Math.abs(lows[i] - closes[i - 1]);
            TR[i] = Math.max(highLow, highClose, lowClose);
        }

        // 초기 합
        let atr = 0, pDM = 0, mDM = 0;
        for (let i = 1; i <= period; i++) {
            atr += TR[i];
            pDM += plusDM[i];
            mDM += minusDM[i];
        }
        atr /= period; pDM /= period; mDM /= period;

        let plusDI = 100 * (pDM / atr);
        let minusDI = 100 * (mDM / atr);
        let dx = 100 * Math.abs(plusDI - minusDI) / Math.max(1e-12, (plusDI + minusDI));

        // ADX 평활
        let adx = dx;
        for (let i = period + 1; i < len; i++) {
            atr = (atr * (period - 1) + TR[i]) / period;
            pDM = (pDM * (period - 1) + plusDM[i]) / period;
            mDM = (mDM * (period - 1) + minusDM[i]) / period;

            plusDI = 100 * (pDM / Math.max(1e-12, atr));
            minusDI = 100 * (mDM / Math.max(1e-12, atr));
            dx = 100 * Math.abs(plusDI - minusDI) / Math.max(1e-12, (plusDI + minusDI));
            adx = (adx * (period - 1) + dx) / period;
        }

        return { adx, plusDI, minusDI };
    }

    // ======= 조건/추세 계산 =======
    function singleTrendFromCandles(candles, emaLen, lastPrice) {
        const closes = candles.map(c => c.close);
        const e = ema(closes, emaLen);
        const lastIdx = candles.length - 1;
        const iPrev = lastIdx - 1;   // 1봉 전 완료봉
        const iPrev2 = lastIdx - 2;  // 2봉 전 완료봉
        if (iPrev2 < 0 || !e[iPrev] || !e[iPrev2]) {
            return { ok: false, reason: '데이터 부족' };
        }

        const close2 = closes[iPrev2];
        const ema2 = e[iPrev2];
        const close1 = closes[iPrev];
        const ema1 = e[iPrev];

        const cond1 = close2 < ema2;
        const cond2 = close1 > ema1;
        const ok = cond1 && cond2;

        // 추세율(롱): 이격 60% + 기울기 40% (lookback=5)
        const priceNow = (lastPrice ?? closes[iPrev]);
        const emaNow = ema1;
        let emaDistancePct = ((priceNow - emaNow) / emaNow) * 100;

        const slopeLookback = 5;
        const iSlope = iPrev - slopeLookback;
        let emaSlopePct = 0;
        if (iSlope >= 0 && e[iSlope]) {
            emaSlopePct = ((e[iPrev] - e[iSlope]) / e[iSlope]) * 100;
        }

        const trendScore = (emaDistancePct * 0.6) + (emaSlopePct * 0.4);

        return { ok, close2, ema2, close1, ema1, trendScore };
    }

    // ======= MTF 가중 =======
    function getWeights(preset) {
        // 반환: { '15m': w, '1h': w, '4h': w, '1d': w } 합계=100
        if (preset === 'scalp') return { '15m': 40, '1h': 30, '4h': 20, '1d': 10 };
        if (preset === 'swing') return { '15m': 10, '1h': 20, '4h': 35, '1d': 35 };
        return { '15m': 25, '1h': 25, '4h': 25, '1d': 25 }; // balanced
    }
    function weightsText(w) {
        return `${w['15m']}/${w['1h']}/${w['4h']}/${w['1d']}`;
    }

    // ======= UI 렌더 =======
    function addRowWithRank(r, idx) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${idx + 1}</td>
            <td class="mono">${r.symbol}</td>
            <td>${r.interval}</td>
            <td>${fmt(r.close2)}</td>
            <td>${fmt(r.ema2)}</td>
            <td>${fmt(r.close1)}</td>
            <td>${fmt(r.ema1)}</td>
            <td class="${r.match ? 'ok' : 'bad'}">${r.match ? '충족' : '불충족'}</td>
            <td>${fmt(r.lastPrice)}</td>
            <td>${fmt(r.todayOpen)}</td>
            <td class="${(r.pctFromTodayOpen ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.pctFromTodayOpen)}</td>
            <td>${r.adx14 == null ? '' : r.adx14.toFixed(2)}</td>
            <td>${r.plusDI14 == null ? '' : r.plusDI14.toFixed(2)}</td>
            <td>${r.minusDI14 == null ? '' : r.minusDI14.toFixed(2)}</td>
            <td class="${(r.singleTrend ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.singleTrend)}</td>
            <td class="${(r.mtfScore ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.mtfScore)}</td>
            <td class="${(r.finalScore ?? 0) >= 0 ? 'ok' : 'bad'}">${pf(r.finalScore)}</td>
            <td class="small">${r.note || ''}</td>
        `;
        $tbody.appendChild(tr);
    }

    // ======= 스캔 =======
    async function scan() {
        abortFlag = false;
        $tbody.innerHTML = '';
        lastResults = [];

        const selectedInterval = $interval.value;
        $tfBadge.textContent = `현재 간격: ${selectedInterval}`;
        const emaLen = Math.max(parseInt($emaLength.value, 10) || 50, 2);
        const limit = Math.max(parseInt($klineLimit.value, 10) || 300, emaLen + 20);
        const conc = Math.min(Math.max(parseInt($concurrency.value, 10) || 5, 1), 20);
        const sortMetric = $sortMetric.value;   // 'mtf' | 'single'
        const order = $trendOrder.value;        // 'desc' | 'asc'
        const adxBoost = $adxBoost.checked;

        // 사용 MTF 간격
        const mtfChecks = Array.from(document.querySelectorAll('.mtf'))
            .filter(el => el.checked)
            .map(el => el.value);
        if (!mtfChecks.length) {
            alert('MTF 사용 간격을 최소 1개 이상 선택하세요.');
            return;
        }
        const weights = getWeights($mtfPreset.value);
        $weightsView.textContent = `현재 가중치: ${weightsText(weights)}`;

        $status.textContent = '심볼 목록 불러오는 중...';
        let symbols = await fetchUSDTPerpSymbols();

        // 심볼 필터
        const filter = ($symbolFilter.value || '').trim();
        if (filter) {
            const picks = filter.split(',').map(s => s.trim().toUpperCase()).filter(Boolean);
            symbols = symbols.filter(sym => picks.some(p => sym.startsWith(p)));
        }

        const total = symbols.length;
        let done = 0;
        setProgress(0, total);
        $status.textContent = `스캔 시작: ${total} 종목`;

        // 현재가 맵
        let priceMap = new Map();
        try {
            priceMap = await fetchAllLastPricesMap();
        } catch (e) {
            console.warn('현재가 맵 실패:', e);
        }

        // 작업 큐
        const queue = [...symbols];
        const workers = new Array(conc).fill(0).map(() => worker());
        await Promise.all(workers);

        // 조건 충족만 추출 → 정렬
        const matched = lastResults.filter(r => r.match);
        matched.sort((a, b) => {
            const key = (sortMetric === 'mtf') ? 'finalScore' : 'singleTrend';
            const aa = a[key] ?? -Infinity, bb = b[key] ?? -Infinity;
            return (order === 'asc') ? (aa - bb) : (bb - aa);
        });

        $tbody.innerHTML = '';
        matched.forEach((r, i) => {
            r.rank = i + 1;
            addRowWithRank(r, i);
        });

        $status.textContent = `완료: ${matched.length} 종목 조건 충족 / 총 ${total} (${sortMetric.toUpperCase()} 기준 ${order === 'desc' ? '내림차순' : '오름차순'})`;

        async function worker() {
            while (queue.length && !abortFlag) {
                const sym = queue.shift();
                try {
                    // 1) 선택 간격: 조건/단일 추세/ADX 계산
                    const candlesSel = await fetchKlines(sym, selectedInterval, limit);
                    const lastPrice = priceMap.get(sym) ?? null;

                    const single = singleTrendFromCandles(candlesSel, emaLen, lastPrice);
                    let adxPack = { adx: null, plusDI: null, minusDI: null };
                    try {
                        adxPack = computeADX14(candlesSel, 14);
                    } catch (_) {}

                    // 오늘(UTC) 일봉 시가 & % 변화
                    let todayOpen = null, pctFromTodayOpen = null;
                    try { todayOpen = await fetchTodayOpen1D(sym); } catch (_) {}
                    if (todayOpen && lastPrice) {
                        pctFromTodayOpen = ((lastPrice - todayOpen) / todayOpen) * 100;
                    }

                    // 2) MTF 합성 점수: 선택된 각 TF에서 trendScore 계산 후 가중 평균
                    const tfSet = new Set(mtfChecks);
                    const tfCandles = new Map();
                    // 선택 간격은 이미 있음
                    if (tfSet.has(selectedInterval)) tfCandles.set(selectedInterval, candlesSel);
                    // 나머지 간격 불러오기
                    for (const tf of tfSet) {
                        if (tf === selectedInterval) continue;
                        try {
                            const c = await fetchKlines(sym, tf, limit);
                            tfCandles.set(tf, c);
                            await sleep(20); // 살짝 휴지
                        } catch (_) {}
                    }

                    let mtfSum = 0, wSum = 0;
                    const trendByTf = {};
                    for (const tf of tfSet) {
                        const c = tfCandles.get(tf);
                        if (!c) continue;
                        const one = singleTrendFromCandles(c, emaLen, lastPrice);
                        if (one && Number.isFinite(one.trendScore)) {
                            const w = weights[tf] ?? 0;
                            mtfSum += one.trendScore * w;
                            wSum += w;
                            trendByTf[tf] = one.trendScore;
                        }
                    }
                    const mtfScore = wSum > 0 ? (mtfSum / wSum) : null;

                    // 3) 최종 점수: (선택) ADX 부스트 적용
                    const base = ( (sortMetric === 'mtf') ? (mtfScore ?? -Infinity) : (single.trendScore ?? -Infinity) );
                    const adx = adxPack.adx ?? 0;
                    const boost = adxBoost ? (1 + Math.max(0, adx - 20) / 100) : 1;
                    const finalScore = (Number.isFinite(base) ? base : -Infinity) * boost;

                    const row = {
                        symbol: sym,
                        interval: selectedInterval,
                        close2: single.close2,
                        ema2: single.ema2,
                        close1: single.close1,
                        ema1: single.ema1,
                        match: !!single.ok,
                        lastPrice,
                        todayOpen,
                        pctFromTodayOpen,
                        adx14: adxPack.adx,
                        plusDI14: adxPack.plusDI,
                        minusDI14: adxPack.minusDI,
                        singleTrend: single.trendScore,
                        mtfScore,
                        finalScore,
                        note: single.ok ? '' : (single.reason || '')
                    };

                    lastResults.push(row);
                } catch (e) {
                    lastResults.push({
                        symbol: sym, interval: selectedInterval,
                        close2: '', ema2: '', close1: '', ema1: '',
                        match: false, lastPrice: '', todayOpen: '', pctFromTodayOpen: '',
                        adx14: '', plusDI14: '', minusDI14: '',
                        singleTrend: '', mtfScore: '', finalScore: '',
                        note: (e && e.message) ? e.message : '에러'
                    });
                } finally {
                    done += 1;
                    setProgress(done, total);
                    $status.textContent = `스캔 중... ${done}/${total}`;
                    await sleep(40);
                }
            }
        }
    }

    // ======= 이벤트 =======
    $interval.addEventListener('change', () => {
        $tfBadge.textContent = `현재 간격: ${$interval.value}`;
    });
    $mtfPreset.addEventListener('change', () => {
        const w = getWeights($mtfPreset.value);
        $weightsView.textContent = `현재 가중치: ${weightsText(w)}`;
    });

    $scanBtn.addEventListener('click', async () => {
        if ($scanBtn.disabled) return;
        $scanBtn.disabled = true;
        $stopBtn.disabled = false;
        try { await scan(); }
        catch (e) {
            console.error(e);
            $status.textContent = '오류: ' + (e && e.message ? e.message : e);
        } finally {
            $scanBtn.disabled = false;
            $stopBtn.disabled = true;
        }
    });

    $stopBtn.addEventListener('click', () => {
        abortFlag = true;
        $status.textContent = '중지 요청됨';
    });

    $exportBtn.addEventListener('click', () => {
        if (!lastResults.length) {
            alert('내보낼 결과가 없습니다.');
            return;
        }
        const sortMetric = $sortMetric.value;
        const order = $trendOrder.value;
        const matched = lastResults.filter(r => r.match).sort((a, b) => {
            const key = (sortMetric === 'mtf') ? 'finalScore' : 'singleTrend';
            const aa = a[key] ?? -Infinity, bb = b[key] ?? -Infinity;
            return (order === 'asc') ? (aa - bb) : (bb - aa);
        }).map((r, i) => ({ ...r, rank: i + 1 }));

        const csv = toCSV(matched);
        const now = new Date();
        const ts = now.toISOString().slice(0,19).replace(/[:T]/g,'-');
        downloadText(`scanner_${document.getElementById('interval').value}_ema${document.getElementById('emaLength').value}_mtf_${sortMetric}_${order}_${ts}.csv`, csv);
    });
</script>
</body>
</html>
