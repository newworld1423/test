<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT-PERP 15m — EMA50 연속성 스캐너</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif; }
        body { margin: 20px; }
        .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
        label { font-size: 14px; }
        input, select, button { padding: 8px 10px; font-size: 14px; }
        button { cursor: pointer; }
        .muted { color: #666; font-size: 13px; }
        .log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; border: 1px solid #ddd; padding: 10px; border-radius: 8px; max-height: 180px; overflow: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 12px; }
        th, td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: right; }
        th:nth-child(1), td:nth-child(1) { text-align: left; position: sticky; left: 0; background: #fff; }
        tr:hover { background: #fafafa; }
        .badge { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #f1f5f9; font-size: 12px; }
        .ok { color: #0a7; }
        .warn { color: #b60; }
        .err { color: #c00; }
        .controls { display: grid; grid-template-columns: repeat(6, minmax(120px, 1fr)); gap: 10px; margin-top: 12px; }
        @media (max-width: 900px) { .controls { grid-template-columns: 1fr 1fr; } }
    </style>
</head>
<body>
    <h1>USDT-PERP 15분봉 — “종가&lt;EMA50 연속 → 종가&gt;EMA50 연속” 스캐너</h1>
    <div class="muted">현재봉은 자동 제외, 직전 200개 봉으로만 분석합니다.</div>

    <div class="controls">
        <label>EMA 기간
            <input id="emaPeriod" type="number" value="50" min="2">
        </label>
        <label>분석 봉 수
            <input id="lookback" type="number" value="200" min="50" max="500">
        </label>
        <label>최소 ‘상단 연속’(A)
            <input id="minAbove" type="number" value="1" min="1" max="200">
        </label>
        <label>최소 ‘하단 연속’(B)
            <input id="minBelow" type="number" value="1" min="1" max="200">
        </label>
        <label>동시 요청(Throttle)
            <input id="concurrency" type="number" value="8" min="1" max="20">
        </label>
        <label>정렬
            <select id="sortBy">
                <option value="aboveDesc">상단 연속 ↓</option>
                <option value="belowDesc">하단 연속 ↓</option>
                <option value="recentCrossDesc">최근 교차시간 ↓</option>
                <option value="symbolAsc">심볼 ↑</option>
            </select>
        </label>
    </div>

    <div class="row" style="margin-top:10px;">
        <button id="scanBtn">스캔 시작</button>
        <button id="stopBtn">중지</button>
        <button id="exportBtn">CSV 저장</button>
        <span id="status" class="badge">대기</span>
    </div>

    <div class="log" id="log" style="margin-top:10px;"></div>

    <table id="resultTable">
        <thead>
            <tr>
                <th>심볼</th>
                <th>상단 연속(A)</th>
                <th>하단 연속(B)</th>
                <th>교차시각(KST)</th>
                <th>최근 종가</th>
                <th>최근 EMA</th>
                <th>괴리(%)</th>
                <th>데이터(봉)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

<script>
    const FAPI = 'https://fapi.binance.com';
    const logEl = document.getElementById('log');
    const tableBody = document.querySelector('#resultTable tbody');
    const statusEl = document.getElementById('status');
    let abortFlag = false;
    let lastResults = [];

    function log(msg, type = 'info') {
        const prefix = type === 'error' ? '[ERR] ' : type === 'warn' ? '[WARN] ' : '';
        logEl.textContent += prefix + msg + '\n';
        logEl.scrollTop = logEl.scrollHeight;
    }

    function fmtNum(n, d = 4) {
        if (!isFinite(n)) return '-';
        return Number(n).toLocaleString(undefined, { maximumFractionDigits: d });
    }

    function toKST(ts) {
        // ts: ms
        const date = new Date(ts + (9 * 60 * 60 * 1000)); // KST offset
        return date.toISOString().replace('T', ' ').replace('.000Z', '');
    }

    async function fetchUSDTPerpSymbols() {
        const url = `${FAPI}/fapi/v1/exchangeInfo`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('exchangeInfo 요청 실패');
        const json = await res.json();
        const symbols = json.symbols
            .filter(s =>
                s.quoteAsset === 'USDT' &&
                s.contractType === 'PERPETUAL' &&
                s.status === 'TRADING'
            )
            .map(s => s.symbol)
            .sort();
        return symbols;
    }

    async function fetchKlines(symbol, interval = '15m', limit = 230) {
        const url = `${FAPI}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`${symbol} klines 실패`);
        const data = await res.json();
        return data; // [ [openTime, open, high, low, close, volume, closeTime, ...], ... ]
    }

    function computeEMA(closes, period) {
        const ema = new Array(closes.length).fill(null);
        if (closes.length < period) return ema;

        // seed with SMA(period)
        let sum = 0;
        for (let i = 0; i < period; i++) sum += closes[i];
        let prev = sum / period;
        ema[period - 1] = prev;

        const k = 2 / (period + 1);
        for (let i = period; i < closes.length; i++) {
            const cur = closes[i] * k + prev * (1 - k);
            ema[i] = cur;
            prev = cur;
        }
        return ema;
    }

    function analyzeRuns(times, closes, ema, minAbove = 1, minBelow = 1) {
        // 마지막 인덱스 = 현재봉 제외한 가장 최근 봉
        const n = closes.length;
        if (n < 5) return null;

        // 상태: 1(above), -1(below), 0(equal or no ema)
        const state = (i) => {
            if (ema[i] == null) return 0;
            if (closes[i] > ema[i]) return 1;
            if (closes[i] < ema[i]) return -1;
            return 0;
        };

        let i = n - 1;
        // 뒤에서부터 동등(0) 스킵
        while (i >= 0 && state(i) === 0) i--;
        if (i < 0) return null;

        // 1) 상단 연속 A
        const lastSign = state(i);
        if (lastSign !== 1) return null; // 마지막 상태가 상단 연속이어야 함

        let aboveLen = 0;
        const endAboveIdx = i;
        while (i >= 0 && state(i) === 1) { aboveLen++; i--; }

        // 2) 직전 하단 연속 B
        while (i >= 0 && state(i) === 0) i--; // 동등 구간 스킵
        let belowLen = 0;
        const startBelowIdx = i;
        while (i >= 0 && state(i) === -1) { belowLen++; i--; }

        if (aboveLen >= minAbove && belowLen >= minBelow) {
            const crossIdx = startBelowIdx + 1; // 하단 구간 끝난 직후 = 교차 발생 추정 지점
            return {
                aboveLen,
                belowLen,
                crossTime: times[crossIdx] ?? times[0],
                lastClose: closes[endAboveIdx],
                lastEma: ema[endAboveIdx],
                gapPct: ((closes[endAboveIdx] - ema[endAboveIdx]) / ema[endAboveIdx]) * 100,
                dataPoints: n
            };
        }
        return null;
    }

    function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
    }

    async function runWithConcurrency(items, limit, worker) {
        const results = [];
        let idx = 0;
        let active = 0;

        return new Promise((resolve) => {
            const launchNext = () => {
                if (abortFlag) return resolve(results);
                while (active < limit && idx < items.length) {
                    const curIndex = idx++;
                    const item = items[curIndex];
                    active++;
                    (async () => {
                        try {
                            const out = await worker(item, curIndex);
                            results[curIndex] = out;
                        } catch (e) {
                            results[curIndex] = { error: e.message };
                        } finally {
                            active--;
                            if (idx >= items.length && active === 0) {
                                resolve(results);
                            } else {
                                launchNext();
                            }
                        }
                    })();
                }
            };
            launchNext();
        });
    }

    function render(results) {
        lastResults = results.filter(Boolean);
        const sortBy = document.getElementById('sortBy').value;
        const arr = [...lastResults];
        if (sortBy === 'aboveDesc') {
            arr.sort((a, b) => (b.aboveLen - a.aboveLen) || (b.belowLen - a.belowLen));
        } else if (sortBy === 'belowDesc') {
            arr.sort((a, b) => (b.belowLen - a.belowLen) || (b.aboveLen - a.aboveLen));
        } else if (sortBy === 'recentCrossDesc') {
            arr.sort((a, b) => (b.crossTime - a.crossTime));
        } else if (sortBy === 'symbolAsc') {
            arr.sort((a, b) => a.symbol.localeCompare(b.symbol));
        }

        tableBody.innerHTML = '';
        for (const r of arr) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td><strong>${r.symbol}</strong></td>
                <td>${r.aboveLen}</td>
                <td>${r.belowLen}</td>
                <td>${toKST(r.crossTime)}</td>
                <td>${fmtNum(r.lastClose, 6)}</td>
                <td>${fmtNum(r.lastEma, 6)}</td>
                <td>${fmtNum(r.gapPct, 3)}</td>
                <td>${r.dataPoints}</td>
            `;
            tableBody.appendChild(tr);
        }
        statusEl.textContent = `결과: ${arr.length}개`;
    }

    function exportCSV() {
        if (!lastResults.length) {
            alert('내보낼 결과가 없습니다.');
            return;
        }
        const header = ['symbol','aboveLen','belowLen','crossTime(KST)','lastClose','lastEMA','gapPct','dataPoints'];
        const lines = [header.join(',')];
        for (const r of lastResults) {
            lines.push([
                r.symbol,
                r.aboveLen,
                r.belowLen,
                toKST(r.crossTime),
                r.lastClose,
                r.lastEma,
                r.gapPct,
                r.dataPoints
            ].join(','));
        }
        const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ema50_sequence_scan.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    async function scan() {
        abortFlag = false;
        tableBody.innerHTML = '';
        logEl.textContent = '';
        statusEl.textContent = '심볼 수집 중...';

        const emaPeriod = parseInt(document.getElementById('emaPeriod').value, 10);
        const lookback = parseInt(document.getElementById('lookback').value, 10);
        const minAbove = parseInt(document.getElementById('minAbove').value, 10);
        const minBelow = parseInt(document.getElementById('minBelow').value, 10);
        const concurrency = parseInt(document.getElementById('concurrency').value, 10);

        if (lookback < emaPeriod + 5) {
            alert('분석 봉 수는 EMA 기간보다 충분히 커야 합니다.');
            return;
        }

        try {
            const symbols = await fetchUSDTPerpSymbols();
            log(`심볼 ${symbols.length}개 수집 완료`, 'info');
            statusEl.textContent = `클라인 로딩 중... (총 ${symbols.length}개)`;

            const limit = Math.max(lookback + 20, emaPeriod + 60); // 여유분
            const worker = async (symbol, i) => {
                if (abortFlag) return null;

                // klines 불러오기
                const raw = await fetchKlines(symbol, '15m', Math.min(1000, limit));
                if (!Array.isArray(raw) || raw.length < lookback + 1) {
                    log(`${symbol} 데이터 부족(${raw.length})`, 'warn');
                    return null;
                }

                // 현재봉(마지막 1개) 제외
                const sliced = raw.slice(0, -1);
                // 뒤에서 200개만 분석
                const tail = sliced.slice(-lookback);

                const times = tail.map(k => k[0]);
                const closes = tail.map(k => Number(k[4]));

                // EMA 계산 (tail 전체 기준)
                // EMA는 tail 내에서 계산하되, 초기 시드가 부족하지 않도록 tail 길이와 period를 체크
                const ema = computeEMA(closes, emaPeriod);

                const hit = analyzeRuns(times, closes, ema, minAbove, minBelow);
                if (hit) {
                    return {
                        symbol,
                        ...hit
                    };
                }
                return null;
            };

            const results = await runWithConcurrency(symbols, concurrency, worker);
            const hits = results.filter(x => x && !x.error);
            const errors = results.filter(x => x && x.error);

            log(`히트: ${hits.length}개`);
            if (errors.length) log(`오류 발생: ${errors.length}건`, 'warn');

            render(hits);
        } catch (e) {
            log(e.message, 'error');
            statusEl.textContent = '오류';
        }
    }

    document.getElementById('scanBtn').addEventListener('click', scan);
    document.getElementById('stopBtn').addEventListener('click', () => { abortFlag = true; statusEl.textContent = '중지 요청'; });
    document.getElementById('exportBtn').addEventListener('click', exportCSV);
    document.getElementById('sortBy').addEventListener('change', () => render(lastResults));
</script>
</body>
</html>
