<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <title>Binance Perp USDT — 4H/1H 방향 + 15m 반대봉 스캐너</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --bg: #05060a;
            --card: #12131a;
            --muted: #9aa0a6;
            --text: #e8eaed;
            --accent: #3ea6ff;
            --good: #00c853;
            --bad: #ff5252;
            --border: #2a2e36;
            --row-alt: #181924;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 16px;
            background: radial-gradient(circle at top, #181b25 0, #05060a 55%, #020308 100%);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
            "Noto Sans KR", sans-serif;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            margin: 0 0 4px;
            font-size: 20px;
        }

        .subtitle {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 16px;
        }

        .panel {
            background: rgba(10, 12, 20, 0.85);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
            margin-bottom: 12px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px 12px;
        }

        button {
            border: none;
            border-radius: 999px;
            padding: 8px 18px;
            font-size: 13px;
            cursor: pointer;
            background: linear-gradient(135deg, #3ea6ff, #6b8bff);
            color: #000;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
            transition: transform 0.08s ease, box-shadow 0.08s ease,
            filter 0.08s ease, opacity 0.15s ease;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            filter: brightness(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
            box-shadow: none;
        }

        .status-text {
            font-size: 12px;
            color: var(--muted);
        }

        .status-text strong {
            color: var(--accent);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: 6px 16px;
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
        }

        .meta span.label {
            color: var(--text);
            font-weight: 500;
        }

        .table-wrap {
            margin-top: 10px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: rgba(5, 6, 10, 0.9);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        thead {
            background: linear-gradient(90deg, rgba(62, 166, 255, 0.1), rgba(107, 139, 255, 0.05));
        }

        th, td {
            padding: 6px 8px;
            text-align: right;
            white-space: nowrap;
        }

        th:first-child,
        td:first-child {
            text-align: center;
        }

        th:nth-child(2),
        td:nth-child(2) {
            text-align: left;
        }

        th {
            border-bottom: 1px solid var(--border);
            color: var(--muted);
            font-weight: 500;
        }

        tbody tr:nth-child(odd) {
            background: rgba(12, 13, 22, 0.9);
        }

        tbody tr:nth-child(even) {
            background: var(--row-alt);
        }

        tbody tr:hover {
            background: rgba(45, 55, 72, 0.7);
        }

        .dir-bull {
            color: var(--good);
            font-weight: 600;
        }

        .dir-bear {
            color: var(--bad);
            font-weight: 600;
        }

        .chg-pos {
            color: var(--good);
        }

        .chg-neg {
            color: var(--bad);
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 16px;
            }

            .panel {
                padding: 10px;
            }

            th, td {
                padding: 5px 6px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
<div class="app">
    <h1>Binance Perp USDT — 4H/1H 방향 + 직전 15m 반대봉 스캐너</h1>
    <div class="subtitle">
        모든 USDT 선물 페어 중에서
        <strong>현재 4H·1H 방향이 같고, 직전 15m 봉이 그 반대인 심볼</strong>만 추려서
        <strong>4H 기반 24h 가격 증감률 순</strong>으로 정렬합니다.
        (각 심볼당 15m 데이터 한 번만 요청)
    </div>

    <div class="panel">
        <div class="controls">
            <button id="scanBtn">스캔 시작</button>
            <div class="status-text" id="statusText">대기 중</div>
        </div>

        <div class="meta">
            <div><span class="label">USDT Perp 심볼 수:</span> <span id="symbolCount">-</span>개</div>
            <div><span class="label">마지막 스캔:</span> <span id="lastScan">-</span></div>
            <div><span class="label">다음 자동 스캔(00/15/30/45분):</span> <span id="nextScan">-</span></div>
        </div>
    </div>

    <div class="table-wrap">
        <table id="resultTable">
            <thead>
            <tr>
                <th>#</th>
                <th>심볼</th>
                <th>4H</th>
                <th>1H</th>
                <th>직전 15m</th>
                <th>4H 기반 24h 증감률</th>
            </tr>
            </thead>
            <tbody>
            <!-- 결과 행 -->
            </tbody>
        </table>
    </div>
</div>

<script>
    const BASE_URL = "https://fapi.binance.com";

    // 요청 튜닝: 1분 안에 끝나도록 + 레이트리밋(2400/min) 안 넘도록
    const CONCURRENCY = 4;             // 동시에 처리할 심볼 수
    const PER_REQUEST_DELAY_MS = 120;  // 심볼 하나 처리 후 딜레이(ms)

    // 15m만 써서 4H/1H/직전15m/24h증감률 전부 계산
    const HOUR = 60 * 60 * 1000;
    const FOUR_HOUR = 4 * HOUR;

    let allSymbols = [];
    let isScanning = false;
    let autoScanActive = false;
    let autoScanTimeoutId = null;
    let autoScanScheduledOnce = false;

    const els = {
        scanBtn: document.getElementById("scanBtn"),
        statusText: document.getElementById("statusText"),
        symbolCount: document.getElementById("symbolCount"),
        lastScan: document.getElementById("lastScan"),
        nextScan: document.getElementById("nextScan"),
        tableBody: document.querySelector("#resultTable tbody")
    };

    function setStatus(msg, isBusy = false) {
        els.statusText.innerHTML = msg;
        els.scanBtn.disabled = isBusy;
    }

    function formatNumber(value, decimals = 2) {
        if (value === null || value === undefined || isNaN(value)) return "-";
        const num = Number(value);
        const fixed = num.toFixed(decimals);
        const parts = fixed.split(".");
        parts[0] = Number(parts[0]).toLocaleString("en-US");
        return parts.join(".");
    }

    function formatTime(date) {
        return date.toLocaleString("ko-KR", {
            hour12: false,
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        });
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function fetchJson(url, context) {
        const res = await fetch(url);
        if (res.status === 418 || res.status === 429) {
            const text = await res.text().catch(() => "");
            throw new Error(
                `Binance ${res.status} (레이트리밋/IP 밴 가능성) · ${context || ""} · ${text}`
            );
        }
        if (!res.ok) {
            const text = await res.text().catch(() => "");
            throw new Error(`HTTP ${res.status} · ${context || ""} · ${text}`);
        }
        return res.json();
    }

    async function loadExchangeInfo() {
        if (allSymbols.length > 0) return allSymbols;

        setStatus("심볼 정보 불러오는 중...", true);
        const url = BASE_URL + "/fapi/v1/exchangeInfo";
        const data = await fetchJson(url, "exchangeInfo");

        allSymbols = data.symbols
            .filter(s =>
                s.contractType === "PERPETUAL" &&
                s.quoteAsset === "USDT" &&
                s.status === "TRADING"
            )
            .map(s => s.symbol);

        els.symbolCount.textContent = allSymbols.length;
        return allSymbols;
    }

    async function fetchKlines15m(symbol, limit) {
        const url =
            BASE_URL +
            "/fapi/v1/klines?symbol=" +
            symbol +
            "&interval=15m&limit=" +
            limit;
        return await fetchJson(url, `klines 15m ${symbol}`);
    }

    function candleDir(open, close) {
        if (close > open) return "bull"; // 양봉
        if (close < open) return "bear"; // 음봉
        return "doji";
    }

    function dirLabel(dir) {
        if (dir === "bull") return "양봉 ▲";
        if (dir === "bear") return "음봉 ▼";
        return "중립";
    }

    function createRow(row, idx) {
        const tr = document.createElement("tr");

        const rankTd = document.createElement("td");
        rankTd.textContent = idx + 1;
        tr.appendChild(rankTd);

        const symTd = document.createElement("td");
        symTd.textContent = row.symbol;
        tr.appendChild(symTd);

        const h4Td = document.createElement("td");
        h4Td.textContent = dirLabel(row.dir4h);
        h4Td.className = row.dir4h === "bull" ? "dir-bull" : "dir-bear";
        tr.appendChild(h4Td);

        const h1Td = document.createElement("td");
        h1Td.textContent = dirLabel(row.dir1h);
        h1Td.className = row.dir1h === "bull" ? "dir-bull" : "dir-bear";
        tr.appendChild(h1Td);

        const m15Td = document.createElement("td");
        m15Td.textContent = dirLabel(row.dir15mPrev);
        m15Td.className =
            row.dir15mPrev === "bull" ? "dir-bull" : "dir-bear";
        tr.appendChild(m15Td);

        const chgTd = document.createElement("td");
        const chgCls = row.change24hPct >= 0 ? "chg-pos" : "chg-neg";
        chgTd.className = chgCls;
        chgTd.textContent = formatNumber(row.change24hPct, 2) + "%";
        tr.appendChild(chgTd);

        return tr;
    }

    function appendRow(row, idx) {
        const tr = createRow(row, idx);
        els.tableBody.appendChild(tr);
    }

    function renderTable(rows) {
        const tbody = els.tableBody;
        tbody.innerHTML = "";

        if (!rows || rows.length === 0) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 6;
            td.style.textAlign = "center";
            td.style.padding = "14px 8px";
            td.style.color = "var(--muted)";
            td.textContent = "조건을 만족하는 심볼이 없습니다.";
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }

        rows.forEach((row, idx) => {
            tbody.appendChild(createRow(row, idx));
        });
    }

    async function scanSymbol(symbol) {
        // 한 번만 요청: 15m 120개 (약 30시간 분량)
        const klines = await fetchKlines15m(symbol, 120);
        const len = klines.length;
        if (len < 10) return null;

        // --- 직전 15m 방향 ---
        const prev15 = klines[len - 2];
        if (!prev15) return null;

        const open15 = parseFloat(prev15[1]);
        const close15 = parseFloat(prev15[4]);
        const dir15 = candleDir(open15, close15);

        // --- 1H / 4H 묶기 (15m에서 직접 집계) ---
        let curHourId = null;
        let hourOpen = null, hourClose = null;
        let curFourId = null;
        let curFour = null;
        const fourGroups = [];

        for (let i = 0; i < len; i++) {
            const k = klines[i];
            const t = Number(k[0]);
            const o = parseFloat(k[1]);
            const h = parseFloat(k[2]);
            const l = parseFloat(k[3]);
            const c = parseFloat(k[4]);

            const hourId = Math.floor(t / HOUR);
            const fourId = Math.floor(t / FOUR_HOUR);

            // 1H 집계 (마지막 그룹만 필요)
            if (curHourId === null || hourId !== curHourId) {
                curHourId = hourId;
                hourOpen = o;
                hourClose = c;
            } else {
                hourClose = c;
            }

            // 4H 집계 (여러 그룹 → 배열에 저장)
            if (curFourId === null || fourId !== curFourId) {
                if (curFour !== null) {
                    fourGroups.push(curFour);
                }
                curFourId = fourId;
                curFour = {
                    id: fourId,
                    open: o,
                    high: h,
                    low: l,
                    close: c
                };
            } else {
                if (h > curFour.high) curFour.high = h;
                if (l < curFour.low) curFour.low = l;
                curFour.close = c;
            }
        }

        if (curFour !== null) {
            fourGroups.push(curFour);
        }

        const lastFour = fourGroups[fourGroups.length - 1] || null;
        if (!lastFour || hourOpen === null || hourClose === null) {
            return null;
        }

        const dir4 = candleDir(lastFour.open, lastFour.close);
        const dir1 = candleDir(hourOpen, hourClose);

        // 조건 1: 4H/1H 둘 다 양/음봉 & 같은 방향
        if (dir4 === "doji" || dir1 === "doji") return null;
        if (dir4 !== dir1) return null;

        // 조건 2: 직전 15m 봉이 4H/1H와 반대 방향
        if (dir15 === "doji") return null;
        if (dir4 === "bull" && dir15 !== "bear") return null;
        if (dir4 === "bear" && dir15 !== "bull") return null;

        // --- 4H 기반 24h 증감률 계산 ---
        let change24hPct = 0;
        if (fourGroups.length > 1) {
            // 24h 전 ≈ 6개의 4H 캔들 전 → 총 7개 필요
            const idx24 = fourGroups.length - 7;
            let open24 = fourGroups[0].open;
            if (idx24 >= 0) {
                open24 = fourGroups[idx24].open;
            }
            if (open24 > 0) {
                change24hPct = (lastFour.close - open24) / open24 * 100;
            }
        }

        return {
            symbol,
            dir4h: dir4,
            dir1h: dir1,
            dir15mPrev: dir15,
            change24hPct
        };
    }

    async function scanOnce() {
        if (isScanning) {
            console.log("스캔 중 중복 요청 방지");
            return;
        }

        isScanning = true;
        const startedAt = new Date();
        setStatus("스캔 준비중...", true);

        try {
            await loadExchangeInfo();

            const symbols = allSymbols.slice();
            const results = [];
            let index = 0;

            // 새 스캔 시작할 때 테이블 싹 비우기
            els.tableBody.innerHTML = "";

            async function worker() {
                while (true) {
                    const myIndex = index++;
                    if (myIndex >= symbols.length) break;

                    const symbol = symbols[myIndex];

                    try {
                        const row = await scanSymbol(symbol);
                        if (row) {
                            results.push(row);
                            // 스캔되자마자 바로 테이블에 한 줄 추가
                            appendRow(row, results.length - 1);
                        }
                    } catch (err) {
                        console.error("심볼 스캔 실패:", symbol, err);
                        if (
                            String(err.message).includes("레이트리밋") ||
                            String(err.message).includes("IP 밴") ||
                            String(err.message).includes("418") ||
                            String(err.message).includes("429")
                        ) {
                            throw err;
                        }
                    }

                    if (PER_REQUEST_DELAY_MS > 0) {
                        await sleep(PER_REQUEST_DELAY_MS);
                    }
                }
            }

            const workers = [];
            for (let i = 0; i <= CONCURRENCY - 1; i++) {
                workers.push(worker());
            }

            setStatus(
                `심볼 스캔 중... (동시 ${CONCURRENCY}개, 심볼 ${symbols.length}개, 딜레이 ${PER_REQUEST_DELAY_MS}ms, 심볼당 요청 1회)`,
                true
            );
            await Promise.all(workers);

            // 전체 스캔 끝난 후: 24h 증감률 기준으로 다시 정렬해서 테이블 재렌더
            results.sort((a, b) => b.change24hPct - a.change24hPct);
            renderTable(results);

            const finishedAt = new Date();
            els.lastScan.textContent = formatTime(finishedAt);

            const diffSec = Math.round(
                (finishedAt.getTime() - startedAt.getTime()) / 1000
            );

            setStatus(
                `<strong>완료</strong> · 결과 ${results.length}개 · 소요 ${diffSec}초`,
                false
            );
        } catch (err) {
            console.error(err);
            setStatus("에러: " + err.message, false);

            if (
                String(err.message).includes("레이트리밋") ||
                String(err.message).includes("IP 밴") ||
                String(err.message).includes("418") ||
                String(err.message).includes("429")
            ) {
                autoScanActive = false;
                if (autoScanTimeoutId) {
                    clearTimeout(autoScanTimeoutId);
                    autoScanTimeoutId = null;
                }
                els.nextScan.textContent = "중지됨 (레이트리밋/IP 밴 감지)";
            }
        } finally {
            isScanning = false;
        }
    }

    function scheduleNextAutoScan() {
        if (!autoScanActive) return;

        if (autoScanTimeoutId) {
            clearTimeout(autoScanTimeoutId);
            autoScanTimeoutId = null;
        }

        const now = new Date();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        const ms = now.getMilliseconds();

        const quarters = [0, 15, 30, 45];
        let targetMinute = 0;
        let addHour = 0;

        let found = false;
        for (const q of quarters) {
            if (minutes < q || (minutes === q && (seconds > 0 || ms > 0))) {
                targetMinute = q;
                found = true;
                break;
            }
        }

        if (!found) {
            targetMinute = 0;
            addHour = 1;
        }

        const next = new Date(now);
        next.setHours(now.getHours() + addHour);
        next.setMinutes(targetMinute, 0, 0);

        const delay = next.getTime() - now.getTime();
        els.nextScan.textContent = formatTime(next);

        autoScanTimeoutId = setTimeout(async () => {
            await scanOnce();
            scheduleNextAutoScan();
        }, delay);
    }

    function init() {
        els.scanBtn.addEventListener("click", async () => {
            if (!autoScanActive) {
                autoScanActive = true;
            }

            await scanOnce();

            if (!autoScanScheduledOnce && autoScanActive) {
                autoScanScheduledOnce = true;
                scheduleNextAutoScan();
            }
        });

        setStatus("대기 중 (스캔 시작 버튼을 눌러주세요)", false);
    }

    document.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
