<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT Perp MTF Pullback Long Scanner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: dark light;
        }
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif;
            margin: 0;
            padding: 24px;
            background: #0b0c10;
            color: #eaf1ff;
        }
        h1 {
            margin: 0 0 12px 0;
            font-size: 20px;
        }
        .panel {
            border: 1px solid #1f2430;
            background: #11131a;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 8px 24px rgba(0,0,0,.25);
        }
        .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
        .row > label {
            display: flex; gap: 6px; align-items: center;
            background: #0e1117; border: 1px solid #232a35; border-radius: 10px; padding: 8px 10px;
        }
        select, input {
            background: transparent; border: none; color: inherit; font-size: 14px; outline: none;
        }
        button {
            padding: 10px 14px; border-radius: 10px; border: 1px solid #293246; background: #0e4fff;
            color: #fff; font-weight: 600; cursor: pointer;
        }
        button.secondary { background: #131a27; color: #cfe0ff; border-color: #293246; }
        .muted { color: #9fb1cc; font-size: 12px; }
        .progress {
            height: 8px; background: #141824; border-radius: 999px; overflow: hidden;
            border: 1px solid #1f2430;
        }
        .bar { height: 100%; width: 0%; background: #2ea043; transition: width .2s ease; }
        table {
            width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px;
        }
        th, td {
            padding: 10px; border-bottom: 1px solid #1c2230; text-align: left;
            white-space: nowrap;
        }
        th { position: sticky; top: 0; background: #0d1017; z-index: 1; }
        td.symbol { font-weight: 700; }
        .right { text-align: right; }
        .green { color: #21d07a; }
        .red { color: #ff6b6b; }
        .dim { color: #93a1bb; }
        .wrap { overflow: auto; max-height: 64vh; border: 1px solid #1f2430; border-radius: 12px; }
        .hint { font-size: 12px; color: #93a1bb; margin-top: 6px; }
        .badge { font-size: 12px; padding: 2px 8px; border: 1px solid #2b3346; border-radius: 999px; background: #151a25; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 8px; }
    </style>
</head>
<body>
    <h1>USDT Perp 스캐너 · MTF Pullback Long (EMA50 재돌파)</h1>
    <div class="panel">
        <div class="row">
            <label>하위TF
                <select id="ltf">
                    <option value="1m">1m</option>
                    <option value="3m">3m</option>
                    <option value="5m">5m</option>
                    <option value="15m" selected>15m</option>
                    <option value="30m">30m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                </select>
            </label>
            <label>상위TF
                <select id="htf">
                    <option value="5m">5m</option>
                    <option value="15m">15m</option>
                    <option value="30m">30m</option>
                    <option value="1h" selected>1h</option>
                    <option value="2h">2h</option>
                    <option value="4h">4h</option>
                    <option value="12h">12h</option>
                    <option value="1d">1d</option>
                </select>
            </label>
            <label>EMA50(하위) 하회 연속
                <input id="minBelow" type="number" value="3" min="1" style="width:64px" />
                <span class="dim">봉 이상</span>
            </label>
            <label>최소 캔들수
                <input id="limit" type="number" value="600" min="200" max="1500" style="width:80px" />
            </label>
            <label>스캔 대상 제한
                <input id="maxSymbols" type="number" value="300" min="10" max="1500" style="width:80px" />
            </label>
            <button id="scanBtn">스캔 시작</button>
            <button id="csvBtn" class="secondary">CSV 저장</button>
        </div>
        <div class="grid" style="margin-top:10px">
            <div><span class="badge">전략</span> <span class="muted">상TF EMA200 강세 + 하TF EMA50 연속 하회 → 재돌파 롱(직전 봉)</span></div>
            <div><span class="badge">판정봉</span> <span class="muted">최신 진행중 봉 제외, 직전 확정봉 사용</span></div>
            <div><span class="badge">거래소</span> <span class="muted">Binance USDT-M Futures (퍼블릭 API)</span></div>
        </div>
        <div class="hint">과도한 요청을 피하기 위해 내부적으로 동시 요청 수를 제한(기본 6)합니다.</div>
        <div class="progress" style="margin-top:12px"><div class="bar" id="bar"></div></div>
        <div class="muted" id="status" style="margin-top:8px">대기 중…</div>
    </div>

    <div class="panel">
        <div class="row" style="justify-content: space-between">
            <div>
                <span class="badge">결과</span>
                <span class="muted" id="resultInfo">0 symbols</span>
            </div>
            <div class="muted">정렬: 시그널시간 ↓, 24h 거래대금 ↓</div>
        </div>
        <div class="wrap">
            <table id="table">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>시그널 시간(KST)</th>
                        <th class="right">연속 하회</th>
                        <th class="right">24h 변동%</th>
                        <th class="right">24h 거래대금(USDT)</th>
                        <th class="right">최근 봉 거래량</th>
                    </tr>
                </thead>
                <tbody id="tbody"></tbody>
            </table>
        </div>
    </div>

<script>
/* ==============================
   유틸 (4-space indentation 고정)
============================== */
const API = {
    exchangeInfo: 'https://fapi.binance.com/fapi/v1/exchangeInfo',
    klines:       'https://fapi.binance.com/fapi/v1/klines',
    ticker24h:    'https://fapi.binance.com/fapi/v1/ticker/24hr'
};

function sleep(ms) {
    return new Promise(res => setTimeout(res, ms));
}

function ema(values, period) {
    if (values.length === 0) return [];
    const k = 2 / (period + 1);
    const out = new Array(values.length);
    let prev = values[0];
    out[0] = prev;
    for (let i = 1; i < values.length; i++) {
        const v = values[i];
        prev = v * k + prev * (1 - k);
        out[i] = prev;
    }
    return out;
}

function toISO(ts) {
    // Binance는 ms, UTC 기준
    return new Date(ts).toISOString();
}

function toKSTString(ts) {
    const d = new Date(ts);
    return d.toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
}

function parseKlines(arr) {
    // [ openTime, open, high, low, close, volume, closeTime, ... ]
    return arr.map(x => ({
        t: x[0],
        o: parseFloat(x[1]),
        h: parseFloat(x[2]),
        l: parseFloat(x[3]),
        c: parseFloat(x[4]),
        v: parseFloat(x[5]),
        ct: x[6]
    }));
}

function lastClosedIndex(bars) {
    return Math.max(0, bars.length - 2); // 최신 진행중 봉 제외
}

function rollingBelowLengths(closes, emaArr) {
    const n = closes.length;
    const below = new Array(n).fill(false);
    const seq = new Array(n).fill(0);
    let run = 0;
    for (let i = 0; i < n; i++) {
        below[i] = (closes[i] < emaArr[i]);
        if (below[i]) {
            run += 1;
            seq[i] = run;
        } else {
            run = 0;
            seq[i] = 0;
        }
    }
    return { below, seq };
}

/* ==============================
   상/하위TF 데이터 로딩
============================== */
async function fetchUSDTPerpSymbols(maxSymbols) {
    const res = await fetch(API.exchangeInfo);
    const json = await res.json();
    const symbols = json.symbols
        .filter(s =>
            s.contractType === 'PERPETUAL' &&
            s.quoteAsset === 'USDT' &&
            s.status === 'TRADING'
        )
        .map(s => s.symbol);
    symbols.sort();
    return symbols.slice(0, maxSymbols || symbols.length);
}

async function fetchKlines(symbol, interval, limit) {
    const url = `${API.klines}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`klines ${symbol} ${interval} ${res.status}`);
    const data = await res.json();
    return parseKlines(data);
}

async function fetch24hTickerMap(symbols) {
    // API가 심볼 미지정시 전체 반환 → 로컬에서 매핑
    const res = await fetch(API.ticker24h);
    const list = await res.json();
    const map = new Map();
    for (const t of list) {
        if (symbols.includes(t.symbol)) {
            map.set(t.symbol, t);
        }
    }
    return map;
}

/* ==============================
   스캐너 핵심 로직
============================== */
async function scanOnce(params, onProgress) {
    const {
        ltf, htf, minBelow, limit, maxSymbols, concurrency
    } = params;

    const symbols = await fetchUSDTPerpSymbols(maxSymbols);
    const tickerMap = await fetch24hTickerMap(symbols);

    let done = 0;
    const results = [];
    const queue = [...symbols];

    async function worker() {
        while (queue.length) {
            const sym = queue.shift();
            try {
                // 1) 하위TF
                const ltfBars = await fetchKlines(sym, ltf, limit);
                if (ltfBars.length < 60) { done++; onProgress(done, symbols.length); continue; }

                // 2) 상위TF
                const htfBars = await fetchKlines(sym, htf, Math.min(500, Math.max(200, Math.floor(limit/4))));
                if (htfBars.length < 60) { done++; onProgress(done, symbols.length); continue; }

                // 3) 상위TF EMA200 강세 필터 (직전 확정봉)
                const htfCloses = htfBars.map(b => b.c);
                const ema200 = ema(htfCloses, 200);
                const j = lastClosedIndex(htfBars);
                const htfBull = (htfCloses[j] > ema200[j]);

                if (!htfBull) { done++; onProgress(done, symbols.length); continue; }

                // 4) 하위TF EMA50 연속 하회 후 재돌파 (직전 확정봉에서 발생)
                const closes = ltfBars.map(b => b.c);
                const ema50 = ema(closes, 50);
                const k = lastClosedIndex(ltfBars);

                const { below, seq } = rollingBelowLengths(closes, ema50);

                // 재돌파 조건: 직전-1 까지 아래, 직전은 종가>EMA50
                const wasBelow = below[k - 1] === true;
                const reclaim  = closes[k] > ema50[k];

                const belowLen = seq[k - 1] || 0;
                const ok = wasBelow && reclaim && (belowLen >= minBelow);

                if (ok) {
                    const tkr = tickerMap.get(sym);
                    const priceChangePercent = tkr ? parseFloat(tkr.priceChangePercent) : NaN;
                    const quoteVolume = tkr ? parseFloat(tkr.quoteVolume || '0') : 0;

                    results.push({
                        symbol: sym,
                        signalTime: ltfBars[k].t,
                        belowLen,
                        priceChangePercent,
                        quoteVolume,
                        lastVol: ltfBars[k].v
                    });
                }
            } catch (e) {
                // 무시하고 진행
            } finally {
                done++;
                onProgress(done, symbols.length);
                // 가벼운 딜레이로 글로벌 레이트 제한 완화
                await sleep(60);
            }
        }
    }

    const workers = [];
    for (let i = 0; i < concurrency; i++) {
        workers.push(worker());
    }
    await Promise.all(workers);

    // 정렬: 시그널 시간 ↓, 거래대금 ↓
    results.sort((a, b) => {
        if (a.signalTime !== b.signalTime) return b.signalTime - a.signalTime;
        return (b.quoteVolume || 0) - (a.quoteVolume || 0);
    });

    return results;
}

/* ==============================
   UI 핸들러
============================== */
const tbody = document.getElementById('tbody');
const bar = document.getElementById('bar');
const statusEl = document.getElementById('status');
const infoEl = document.getElementById('resultInfo');

function setProgress(done, total) {
    const pct = total ? Math.floor(done * 100 / total) : 0;
    bar.style.width = pct + '%';
    statusEl.textContent = `스캔 중… ${done} / ${total} (${pct}%)`;
}

function fmtNumber(n) {
    if (n === null || n === undefined || isNaN(n)) return '-';
    if (n >= 1_000_000_000) return (n / 1_000_000_000).toFixed(2) + 'B';
    if (n >= 1_000_000) return (n / 1_000_000).toFixed(2) + 'M';
    if (n >= 1_000) return (n / 1_000).toFixed(2) + 'K';
    return String(Math.round(n));
}

function renderRows(rows) {
    tbody.innerHTML = '';
    for (const r of rows) {
        const tr = document.createElement('tr');

        const tdSym = document.createElement('td');
        tdSym.className = 'symbol';
        tdSym.textContent = r.symbol;
        tr.appendChild(tdSym);

        const tdTime = document.createElement('td');
        tdTime.textContent = toKSTString(r.signalTime);
        tr.appendChild(tdTime);

        const tdBelow = document.createElement('td');
        tdBelow.className = 'right';
        tdBelow.textContent = r.belowLen;
        tr.appendChild(tdBelow);

        const tdChg = document.createElement('td');
        tdChg.className = 'right';
        const chg = r.priceChangePercent;
        tdChg.textContent = isNaN(chg) ? '-' : chg.toFixed(2) + '%';
        if (!isNaN(chg)) tdChg.classList.add(chg >= 0 ? 'green' : 'red');
        tr.appendChild(tdChg);

        const tdVol = document.createElement('td');
        tdVol.className = 'right';
        tdVol.textContent = fmtNumber(r.quoteVolume);
        tr.appendChild(tdVol);

        const tdLastV = document.createElement('td');
        tdLastV.className = 'right';
        tdLastV.textContent = fmtNumber(r.lastVol);
        tr.appendChild(tdLastV);

        tbody.appendChild(tr);
    }
    infoEl.textContent = `${rows.length} symbols`;
}

function getParamsFromUI() {
    const ltf = document.getElementById('ltf').value;
    const htf = document.getElementById('htf').value;
    const minBelow = Math.max(1, parseInt(document.getElementById('minBelow').value || '3', 10));
    const limit = Math.max(200, Math.min(1500, parseInt(document.getElementById('limit').value || '600', 10)));
    const maxSymbols = Math.max(10, Math.min(1500, parseInt(document.getElementById('maxSymbols').value || '300', 10)));
    return { ltf, htf, minBelow, limit, maxSymbols, concurrency: 6 };
}

let lastResults = [];

document.getElementById('scanBtn').addEventListener('click', async () => {
    tbody.innerHTML = '';
    bar.style.width = '0%';
    statusEl.textContent = '심볼 목록 로딩 중…';

    const params = getParamsFromUI();
    try {
        const rows = await scanOnce(params, setProgress);
        lastResults = rows;
        renderRows(rows);
        statusEl.textContent = '완료';
    } catch (e) {
        console.error(e);
        statusEl.textContent = '오류가 발생했습니다. 콘솔을 확인하세요.';
    }
});

document.getElementById('csvBtn').addEventListener('click', () => {
    if (!lastResults.length) {
        alert('저장할 결과가 없습니다. 먼저 스캔을 실행하세요.');
        return;
    }
    const header = ['symbol', 'signalTime(KST)', 'belowLen', 'priceChangePercent', 'quoteVolume', 'lastVolume'];
    const lines = [header.join(',')];
    for (const r of lastResults) {
        lines.push([
            r.symbol,
            toKSTString(r.signalTime).replace(/,/g, ' '),
            r.belowLen,
            isNaN(r.priceChangePercent) ? '' : r.priceChangePercent.toFixed(2),
            r.quoteVolume,
            r.lastVol
        ].join(','));
    }
    const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `mtf_pullback_long_scan_${Date.now()}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
});
</script>
</body>
</html>
