<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT Perp 15m Scanner (User Symbols)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { color-scheme: light dark; }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif; margin: 0; padding: 24px; }
        h1 { margin: 0 0 12px; font-size: 20px; }
        .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-end; }
        label { display: block; font-weight: 600; margin-bottom: 6px; }
        input, select, button, textarea { font: inherit; padding: 8px 12px; border-radius: 8px; border: 1px solid #9993; }
        textarea { width: 460px; height: 88px; }
        .card { border: 1px solid #9993; border-radius: 16px; padding: 16px; margin-top: 16px; box-shadow: 0 4px 10px #0000000a; }
        .grid { overflow: auto; max-height: 70vh; }
        table { border-collapse: collapse; width: 100%; min-width: 980px; }
        th, td { padding: 10px 12px; border-bottom: 1px solid #00000014; text-align: right; }
        th:nth-child(1), td:nth-child(1) { text-align: left; position: sticky; left: 0; background: canvas; }
        .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; display: inline-block; }
        .pill.long { background: #16a34a22; color: #16a34a; border: 1px solid #16a34a55; }
        .pill.short { background: #dc262622; color: #dc2626; border: 1px solid #dc262655; }
        .pill.wait { background: #6b728022; color: #6b7280; border: 1px solid #6b728055; }
        .muted { color: #6b7280; font-size: 12px; }
        .row .field { display: flex; flex-direction: column; }
        .actions { display: flex; gap: 8px; align-items: center; }
        .badge { font-size: 12px; border: 1px dashed #9995; padding: 2px 8px; border-radius: 999px; }
        .ok { color: #16a34a; }
        .warn { color: #ca8a04; }
        .err { color: #dc2626; }
        .progress { height: 8px; background: #0001; border-radius: 999px; overflow: hidden; }
        .bar { height: 100%; width: 0%; background: #3b82f6; }
        .small { font-size: 12px; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    </style>
</head>
<body>
    <h1>Binance 무기한 선물 15분 스캐너 (직접 지정 심볼)</h1>
    <p class="muted">마지막 완료 봉(현재 진행 중 봉 제외) 기준으로 진입 신호를 평가합니다. 주문 실행 기능은 포함하지 않으며, 교육/리서치 용도입니다.</p>

    <div class="card">
        <div class="row">
            <div class="field">
                <label for="symbols">심볼 목록 (쉼표/공백 구분, 예: <span class="mono">BTCUSDT, ETHUSDT, SOLUSDT</span>)</label>
                <textarea id="symbols" placeholder="BTCUSDT, ETHUSDT, SOLUSDT"></textarea>
            </div>
            <div class="field">
                <label>전략 파라미터</label>
                <div class="row">
                    <div class="field">
                        <label for="emaFast">EMA 빠른선</label>
                        <input id="emaFast" type="number" value="50" min="3" />
                    </div>
                    <div class="field">
                        <label for="emaSlow">EMA 느린선</label>
                        <input id="emaSlow" type="number" value="200" min="5" />
                    </div>
                    <div class="field">
                        <label for="rsiLen">RSI 길이</label>
                        <input id="rsiLen" type="number" value="14" min="5" />
                    </div>
                    <div class="field">
                        <label for="consecMin">연속 종가 &gt; EMA빠른선</label>
                        <input id="consecMin" type="number" value="3" min="0" />
                    </div>
                    <div class="field">
                        <label for="limitCandles">불러올 캔들 수</label>
                        <input id="limitCandles" type="number" value="300" min="100" max="1000" />
                    </div>
                </div>
                <div class="row" style="margin-top:8px;">
                    <div class="field">
                        <label for="delayMs">요청 간격(ms)</label>
                        <input id="delayMs" type="number" value="150" min="0" />
                    </div>
                    <div class="field">
                        <label for="sortBy">정렬</label>
                        <select id="sortBy">
                            <option value="score">점수(내림차순)</option>
                            <option value="rsi">RSI</option>
                            <option value="consec">연속봉 수</option>
                            <option value="atrp">ATR%</option>
                            <option value="symbol">심볼</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div class="row" style="margin-top:12px; align-items:center;">
            <div class="actions">
                <button id="runBtn">지금 스캔</button>
                <button id="autoBtn">15분 자동 스캔 시작</button>
                <button id="stopBtn">자동 중지</button>
                <button id="exportBtn">CSV 내보내기</button>
            </div>
            <div id="nextTick" class="badge"></div>
        </div>
        <div style="margin-top:12px; display:flex; gap:16px; align-items:center;">
            <div class="progress" style="flex:1;">
                <div class="bar" id="bar"></div>
            </div>
            <div class="small" id="progressText">대기</div>
        </div>
    </div>

    <div class="card">
        <div class="grid">
            <table id="table">
                <thead>
                    <tr>
                        <th>심볼</th>
                        <th>신호</th>
                        <th>점수</th>
                        <th>종가</th>
                        <th>EMA<span id="emaFastHdr">50</span></th>
                        <th>EMA<span id="emaSlowHdr">200</span></th>
                        <th>RSI</th>
                        <th>연속(종가&gt;EMA빠른)</th>
                        <th>ATR%</th>
                        <th>봉 시간(UTC)</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <p class="muted small" style="margin-top:8px;">* 신호는 마지막 완료 봉 기준. RSI는 14 기본, ATR%는 변동성 참고용. 점수는 트렌드/모멘텀을 종합한 휴리스틱(0~100).</p>
    </div>

<script>
    // ===== Utilities =====
    function parseSymbols(input) {
        return Array.from(new Set(
            input.split(/[^A-Z0-9]+/i)
                .map(s => s.trim().toUpperCase())
                .filter(Boolean)
        ));
    }

    function ema(values, length) {
        if (values.length === 0) return [];
        const k = 2 / (length + 1);
        const out = new Array(values.length).fill(null);
        let prev = values[0];
        out[0] = prev;
        for (let i = 1; i < values.length; i++) {
            prev = values[i] * k + prev * (1 - k);
            out[i] = prev;
        }
        return out;
    }

    function rsi(closes, length = 14) {
        const out = new Array(closes.length).fill(null);
        if (closes.length <= length) return out;
        let gains = 0, losses = 0;
        for (let i = 1; i <= length; i++) {
            const ch = closes[i] - closes[i - 1];
            gains += Math.max(0, ch);
            losses += Math.max(0, -ch);
        }
        let avgGain = gains / length;
        let avgLoss = losses / length;
        out[length] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
        for (let i = length + 1; i < closes.length; i++) {
            const ch = closes[i] - closes[i - 1];
            const gain = Math.max(0, ch), loss = Math.max(0, -ch);
            avgGain = (avgGain * (length - 1) + gain) / length;
            avgLoss = (avgLoss * (length - 1) + loss) / length;
            out[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
        }
        return out;
    }

    function atr(highs, lows, closes, length = 14) {
        const tr = new Array(closes.length).fill(null);
        for (let i = 1; i < closes.length; i++) {
            const hl = highs[i] - lows[i];
            const hc = Math.abs(highs[i] - closes[i - 1]);
            const lc = Math.abs(lows[i] - closes[i - 1]);
            tr[i] = Math.max(hl, hc, lc);
        }
        // Wilder's smoothing
        const out = new Array(closes.length).fill(null);
        let sum = 0;
        for (let i = 1; i <= length; i++) sum += tr[i] ?? 0;
        out[length] = sum / length;
        for (let i = length + 1; i < tr.length; i++) {
            out[i] = (out[i - 1] * (length - 1) + (tr[i] ?? 0)) / length;
        }
        return out;
    }

    function countConsecutiveAbove(closes, series, uptoIndex) {
        let c = 0;
        for (let i = uptoIndex; i >= 0; i--) {
            if (closes[i] > series[i]) c++; else break;
        }
        return c;
    }

    function msUntilNextQuarterHour() {
        const now = new Date();
        const minutes = now.getUTCMinutes();
        const nextQuarter = Math.ceil((minutes + 0.001) / 15) * 15; // avoid boundary
        const target = new Date(now);
        if (nextQuarter >= 60) {
            target.setUTCHours(now.getUTCHours() + 1, 0, 0, 0);
        } else {
            target.setUTCMinutes(nextQuarter, 0, 0);
        }
        return target.getTime() - now.getTime();
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ===== API =====
    const BASE = "https://fapi.binance.com"; // Binance Futures
    async function fetchKlines(symbol, interval = "15m", limit = 300) {
        const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`${symbol} HTTP ${res.status}`);
        const data = await res.json();
        // kline: [openTime, open, high, low, close, volume, closeTime, ...]
        return data.map(k => ({
            openTime: k[0],
            open: +k[1], high: +k[2], low: +k[3], close: +k[4], volume: +k[5],
            closeTime: k[6]
        }));
    }

    // ===== Strategy (heuristic scoring) =====
    function evaluateSignal(klines, cfg) {
        // Exclude current building candle: use last CLOSED = index length-2
        if (klines.length < 100) return null;
        const closes = klines.map(k => k.close);
        const highs = klines.map(k => k.high);
        const lows = klines.map(k => k.low);
        const lastIdx = klines.length - 2; // last closed candle

        const emaFastArr = ema(closes, cfg.emaFast);
        const emaSlowArr = ema(closes, cfg.emaSlow);
        const rsiArr = rsi(closes, cfg.rsiLen);
        const atrArr = atr(highs, lows, closes, 14);

        const C = closes[lastIdx];
        const EF = emaFastArr[lastIdx];
        const ES = emaSlowArr[lastIdx];
        const RSI = rsiArr[lastIdx];
        const ATR = atrArr[lastIdx];

        const consecUp = countConsecutiveAbove(closes, emaFastArr, lastIdx);
        const atrPct = ATR ? (ATR / C) * 100 : null;

        // Scoring 0~100
        let scoreLong = 0, scoreShort = 0;
        // Trend alignment
        if (C > EF) scoreLong += 15; else scoreShort += 15;
        if (EF > ES) scoreLong += 20; else scoreShort += 20;
        // Momentum via RSI
        if (RSI != null) {
            if (RSI >= 52 && RSI <= 75) scoreLong += 20;
            if (RSI <= 48 && RSI >= 25) scoreShort += 20;
            if (RSI > 75) scoreLong += 5; // extended
            if (RSI < 25) scoreShort += 5;
        }
        // Persistence above/below EMA Fast
        if (consecUp >= cfg.consecMin) scoreLong += Math.min(20, consecUp * 2);
        const consecDn = countConsecutiveAbove(emaFastArr, closes, lastIdx); // inverse
        if (consecDn >= cfg.consecMin) scoreShort += Math.min(20, consecDn * 2);
        // Volatility sweet-spot (optional)
        if (atrPct != null) {
            // prefer 0.5% ~ 3% range
            if (atrPct >= 0.5 && atrPct <= 3) { scoreLong += 10; scoreShort += 10; }
        }

        let side = "WAIT", score = 0;
        if (scoreLong - scoreShort >= 10) { side = "LONG"; score = Math.min(100, scoreLong); }
        else if (scoreShort - scoreLong >= 10) { side = "SHORT"; score = Math.min(100, scoreShort); }
        else { score = Math.max(scoreLong, scoreShort) / 2; }

        return {
            side,
            score: Math.round(score),
            close: C,
            emaFast: EF,
            emaSlow: ES,
            rsi: RSI != null ? +RSI.toFixed(1) : null,
            consec: side === 'LONG' ? consecUp : consecDn,
            atrp: atrPct != null ? +atrPct.toFixed(2) : null,
            closeTime: klines[lastIdx].closeTime
        };
    }

    // ===== UI glue =====
    const els = {
        symbols: document.getElementById('symbols'),
        emaFast: document.getElementById('emaFast'),
        emaSlow: document.getElementById('emaSlow'),
        rsiLen: document.getElementById('rsiLen'),
        consecMin: document.getElementById('consecMin'),
        limitCandles: document.getElementById('limitCandles'),
        delayMs: document.getElementById('delayMs'),
        sortBy: document.getElementById('sortBy'),
        runBtn: document.getElementById('runBtn'),
        autoBtn: document.getElementById('autoBtn'),
        stopBtn: document.getElementById('stopBtn'),
        exportBtn: document.getElementById('exportBtn'),
        nextTick: document.getElementById('nextTick'),
        bar: document.getElementById('bar'),
        progressText: document.getElementById('progressText'),
        tbody: document.querySelector('#table tbody'),
        emaFastHdr: document.getElementById('emaFastHdr'),
        emaSlowHdr: document.getElementById('emaSlowHdr'),
    };

    function getCfg() {
        return {
            emaFast: +els.emaFast.value,
            emaSlow: +els.emaSlow.value,
            rsiLen: +els.rsiLen.value,
            consecMin: +els.consecMin.value,
            limitCandles: +els.limitCandles.value,
            delayMs: +els.delayMs.value,
            sortBy: els.sortBy.value,
        };
    }

    function render(rows, cfg) {
        els.emaFastHdr.textContent = cfg.emaFast;
        els.emaSlowHdr.textContent = cfg.emaSlow;
        // sort
        const sorted = [...rows];
        sorted.sort((a, b) => {
            switch (cfg.sortBy) {
                case 'rsi': return (b.rsi ?? -1) - (a.rsi ?? -1);
                case 'consec': return (b.consec ?? 0) - (a.consec ?? 0);
                case 'atrp': return (b.atrp ?? -1) - (a.atrp ?? -1);
                case 'symbol': return a.symbol.localeCompare(b.symbol);
                default: return (b.score ?? 0) - (a.score ?? 0);
            }
        });
        els.tbody.innerHTML = sorted.map(r => `
            <tr>
                <td class="mono">${r.symbol}</td>
                <td>${badge(r.side)}</td>
                <td>${num(r.score)}</td>
                <td>${num(r.close)}</td>
                <td>${num(r.emaFast)}</td>
                <td>${num(r.emaSlow)}</td>
                <td>${r.rsi != null ? r.rsi.toFixed(1) : '-'}</td>
                <td>${r.consec ?? '-'}</td>
                <td>${r.atrp != null ? r.atrp.toFixed(2) + '%' : '-'}</td>
                <td class="mono small">${utcTs(r.closeTime)}</td>
            </tr>
        `).join('');
    }

    function badge(side) {
        if (side === 'LONG') return '<span class="pill long">LONG</span>';
        if (side === 'SHORT') return '<span class="pill short">SHORT</span>';
        return '<span class="pill wait">WAIT</span>';
    }

    function num(n) {
        if (n == null || Number.isNaN(n)) return '-';
        if (n >= 1000) return n.toLocaleString(undefined, { maximumFractionDigits: 6 });
        return n.toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
    }

    function utcTs(ms) {
        const d = new Date(ms);
        return d.toISOString().replace('T', ' ').replace('.000Z', 'Z');
    }

    async function scanOnce() {
        const cfg = getCfg();
        const symbols = parseSymbols(els.symbols.value);
        if (symbols.length === 0) { alert('심볼을 입력하세요. 예: BTCUSDT, ETHUSDT'); return; }
        const rows = [];
        els.bar.style.width = '0%';
        els.progressText.textContent = `스캔 시작 (0/${symbols.length})`;
        let i = 0;
        for (const sym of symbols) {
            try {
                const ks = await fetchKlines(sym, '15m', cfg.limitCandles);
                const evald = evaluateSignal(ks, cfg);
                if (evald) rows.push({ symbol: sym, ...evald });
            } catch (e) {
                rows.push({ symbol: sym, side: 'WAIT', score: 0, close: null, emaFast: null, emaSlow: null, rsi: null, consec: null, atrp: null, closeTime: null, error: String(e) });
            }
            i++;
            const pct = Math.round((i / symbols.length) * 100);
            els.bar.style.width = pct + '%';
            els.progressText.textContent = `스캔 중 ${i}/${symbols.length}`;
            if (cfg.delayMs > 0) await sleep(cfg.delayMs);
        }
        render(rows, cfg);
        els.progressText.textContent = `완료 (${symbols.length}/${symbols.length})`;
        lastRows = rows; // for CSV export
    }

    function msToHHMMSS(ms) {
        const s = Math.max(0, Math.floor(ms / 1000));
        const hh = String(Math.floor(s / 3600)).padStart(2, '0');
        const mm = String(Math.floor((s % 3600) / 60)).padStart(2, '0');
        const ss = String(s % 60).padStart(2, '0');
        return `${hh}:${mm}:${ss}`;
    }

    let autoTimer = null, tickTimer = null;
    function scheduleAuto() {
        clearTimeout(autoTimer); clearInterval(tickTimer);
        const wait = msUntilNextQuarterHour();
        const target = Date.now() + wait;
        els.nextTick.textContent = `다음 스캔까지 ${msToHHMMSS(wait)} (분봉 마감 동기화)`;
        tickTimer = setInterval(() => {
            const left = target - Date.now();
            if (left <= 0) { clearInterval(tickTimer); }
            else { els.nextTick.textContent = `다음 스캔까지 ${msToHHMMSS(left)} (분봉 마감 동기화)`; }
        }, 500);
        autoTimer = setTimeout(async () => {
            await scanOnce();
            scheduleAuto(); // reschedule next 15m boundary
        }, wait + 500); // small buffer after close
    }

    function stopAuto() { clearTimeout(autoTimer); clearInterval(tickTimer); els.nextTick.textContent = '자동 스캔 꺼짐'; }

    function exportCSV() {
        if (!lastRows || lastRows.length === 0) { alert('내보낼 데이터가 없습니다. 먼저 스캔을 실행하세요.'); return; }
        const header = ['symbol','side','score','close','emaFast','emaSlow','rsi','consec','atrp','closeTimeUTC'];
        const lines = [header.join(',')];
        for (const r of lastRows) {
            lines.push([
                r.symbol,
                r.side,
                r.score,
                r.close ?? '',
                r.emaFast ?? '',
                r.emaSlow ?? '',
                r.rsi ?? '',
                r.consec ?? '',
                r.atrp ?? '',
                r.closeTime ? new Date(r.closeTime).toISOString() : ''
            ].join(','));
        }
        const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'scanner_15m.csv'; a.click();
        URL.revokeObjectURL(url);
    }

    let lastRows = [];

    // ===== Bindings =====
    els.runBtn.addEventListener('click', scanOnce);
    els.autoBtn.addEventListener('click', scheduleAuto);
    els.stopBtn.addEventListener('click', stopAuto);
    els.exportBtn.addEventListener('click', exportCSV);

    // Demo defaults
    els.symbols.value = 'BTCUSDT, ETHUSDT, SOLUSDT, BNBUSDT, XRPUSDT';
</script>
</body>
</html>
