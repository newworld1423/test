<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Binance USDT Perp MTF Pullback Long Scanner (No-Proxy, Full Universe)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif; margin:0; padding:24px; background:#0b0c10; color:#eaf1ff; }
    h1 { margin:0 0 12px 0; font-size:20px; }
    .panel { border:1px solid #1f2430; background:#11131a; border-radius:12px; padding:16px; margin-bottom:16px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .row > label { display:flex; gap:6px; align-items:center; background:#0e1117; border:1px solid #232a35; border-radius:10px; padding:8px 10px; }
    select, input { background:transparent; border:none; color:inherit; font-size:14px; outline:none; }
    button { padding:10px 14px; border-radius:10px; border:1px solid #293246; background:#0e4fff; color:#fff; font-weight:600; cursor:pointer; }
    button.secondary { background:#131a27; color:#cfe0ff; border-color:#293246; }
    .muted { color:#9fb1cc; font-size:12px; }
    .progress { height:8px; background:#141824; border-radius:999px; overflow:hidden; border:1px solid #1f2430; }
    .bar { height:100%; width:0%; background:#2ea043; transition:width .2s ease; }
    table { width:100%; border-collapse:collapse; margin-top:10px; font-size:14px; }
    th, td { padding:10px; border-bottom:1px solid #1c2230; text-align:left; white-space:nowrap; }
    th { position:sticky; top:0; background:#0d1017; z-index:1; }
    td.symbol { font-weight:700; }
    .right { text-align:right; }
    .green { color:#21d07a; }
    .red { color:#ff6b6b; }
    .dim { color:#93a1bb; }
    .wrap { overflow:auto; max-height:64vh; border:1px solid #1f2430; border-radius:12px; }
    .badge { font-size:12px; padding:2px 8px; border:1px solid #2b3346; border-radius:999px; background:#151a25; }
    .grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(240px, 1fr)); gap:8px; }
  </style>
</head>
<body>
  <h1>USDT Perp 스캐너 · MTF Pullback Long (EMA50 재돌파, No-Proxy Safe)</h1>

  <div class="panel">
    <div class="row">
      <label>하위TF
        <select id="ltf">
          <option value="1m">1m</option>
          <option value="3m">3m</option>
          <option value="5m">5m</option>
          <option value="15m" selected>15m</option>
          <option value="30m">30m</option>
          <option value="1h">1h</option>
          <option value="4h">4h</option>
        </select>
      </label>
      <label>상위TF
        <select id="htf">
          <option value="5m">5m</option>
          <option value="15m">15m</option>
          <option value="30m">30m</option>
          <option value="1h" selected>1h</option>
          <option value="2h">2h</option>
          <option value="4h">4h</option>
          <option value="12h">12h</option>
          <option value="1d">1d</option>
        </select>
      </label>
      <label>EMA50(하위) 하회 연속
        <input id="minBelow" type="number" value="3" min="1" style="width:64px" />
        <span class="dim">봉 이상</span>
      </label>
      <label>최소 캔들수
        <input id="limit" type="number" value="600" min="200" max="1500" style="width:80px" />
      </label>
      <label>스캔 대상 제한
        <input id="maxSymbols" type="number" value="9999" min="10" max="99999" style="width:90px" />
      </label>
      <button id="scanBtn">스캔 시작</button>
      <button id="csvBtn" class="secondary">CSV 저장</button>
    </div>

    <div class="grid" style="margin-top:10px">
      <div><span class="badge">전략</span> <span class="muted">상TF EMA200 강세 + 하TF EMA50 연속 하회 → 재돌파 롱(직전 봉)</span></div>
      <div><span class="badge">판정봉</span> <span class="muted">최신 진행중 봉 제외, 직전 확정봉 사용</span></div>
      <div><span class="badge">API 사용</span> <span class="muted">상위TF, 24h 티커 추가 호출 없음 — 요청량 최소화</span></div>
    </div>
    <div class="muted" style="margin-top:6px">
      전 종목 스캔을 유지하면서도 요청량을 줄이기 위해 <b>청크 처리 + 적응형 레이트리밋 + 쿨다운</b>이 적용됩니다.
    </div>
    <div class="progress" style="margin-top:12px"><div class="bar" id="bar"></div></div>
    <div class="muted" id="status" style="margin-top:8px">대기 중…</div>
  </div>

  <div class="panel">
    <div class="row" style="justify-content:space-between">
      <div><span class="badge">결과</span> <span class="muted" id="resultInfo">0 symbols</span></div>
      <div class="muted">정렬: 시그널시간 ↓, 24h 추정 거래대금 ↓</div>
    </div>
    <div class="wrap">
      <table id="table">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>시그널 시간(KST)</th>
            <th class="right">연속 하회</th>
            <th class="right">24h 변동%(추정)</th>
            <th class="right">24h 거래대금(USDT, 추정)</th>
            <th class="right">최근 봉 거래량</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
/* ==============================
   상수 & 유틸
============================== */
const API = {
  exchangeInfo: 'https://fapi.binance.com/fapi/v1/exchangeInfo',
  klines:       'https://fapi.binance.com/fapi/v1/klines'
};

// 전 종목 스캔을 유지하면서도 차단을 피하기 위한 운영 파라미터
const SETTINGS = {
  // 동시요청(적응형 시작값)
  initConcurrency: 6,
  // 청크 단위(각 청크 사이 쿨다운)
  chunkSize: 120,
  // 각 심볼 처리 후 소량 지연(ms)
  perSymbolDelayMs: 90,
  // 청크 사이 쿨다운 범위(ms)
  chunkCooldownMinMs: 2000,
  chunkCooldownMaxMs: 5000,
  // 재시도 횟수 및 백오프
  maxRetries: 2,
  backoffBaseMs: 250
};

// 실행 상태
let dynConcurrency = SETTINGS.initConcurrency;
let cooldownUntil = 0;

/* ==============================
   보조 함수들
============================== */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function backoffDelay(attempt, baseMs = SETTINGS.backoffBaseMs){
  const expo = baseMs * Math.pow(2, attempt);
  const jitter = Math.floor(Math.random()*150);
  return expo + jitter;
}

function toKSTString(ts) {
  return new Date(ts).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
}

function ema(values, period) {
  if (!values || values.length === 0) return [];
  const k = 2 / (period + 1);
  const out = new Array(values.length);
  let prev = values[0];
  out[0] = prev;
  for (let i=1;i<values.length;i++){
    const v = values[i];
    prev = v * k + prev * (1 - k);
    out[i] = prev;
  }
  return out;
}

function parseKlines(arr) {
  return arr.map(x => ({
    t: x[0],
    o: parseFloat(x[1]),
    h: parseFloat(x[2]),
    l: parseFloat(x[3]),
    c: parseFloat(x[4]),
    v: parseFloat(x[5]),
    ct: x[6]
  }));
}

function lastClosedIndex(bars) {
  return Math.max(0, bars.length - 2);
}

function rollingBelowLengths(closes, emaArr) {
  const n = closes.length;
  const below = new Array(n).fill(false);
  const seq = new Array(n).fill(0);
  let run = 0;
  for (let i=0;i<n;i++) {
    below[i] = (closes[i] < (emaArr[i] || 0));
    if (below[i]) { run += 1; seq[i] = run; }
    else { run = 0; seq[i] = 0; }
  }
  return { below, seq };
}

// 하위TF → 상위TF 리샘플 (예: 15m → 1h = ratio 4)
function resampleOHLCV(bars, ratio) {
  if (!Number.isInteger(ratio) || ratio < 1) return bars;
  const out = [];
  for (let i = 0; i < bars.length; i += ratio) {
    const chunk = bars.slice(i, i + ratio);
    if (chunk.length < ratio) break; // 마지막 불완전 묶음 제외(확정봉 기준)
    const o = chunk[0].o;
    const h = Math.max(...chunk.map(b => b.h));
    const l = Math.min(...chunk.map(b => b.l));
    const c = chunk[chunk.length - 1].c;
    const v = chunk.reduce((s,b)=>s+b.v,0);
    out.push({ t: chunk[0].t, o, h, l, c, v });
  }
  return out;
}

function minutesOf(tf){
  const n = parseInt(tf,10);
  if (tf.endsWith('m')) return n;
  if (tf.endsWith('h')) return n*60;
  if (tf.endsWith('d')) return n*60*24;
  return NaN;
}

function ratioFromTf(ltf, htf) {
  const a = minutesOf(ltf), b = minutesOf(htf);
  if (!a || !b) return null;
  const r = b / a;
  return Number.isInteger(r) ? r : null;
}

// LTF 캔들로 24h 변동% & 추정 거래대금(USDT) 계산
function estimate24hFromLTF(ltfBars, ltf) {
  const perMin = minutesOf(ltf) || 15;
  const need = Math.floor((24*60) / perMin); // 15m -> 96봉
  if (ltfBars.length < need + 1) return { changePct: NaN, quoteVol: 0 };

  const recent = ltfBars.slice(-need - 1);
  const open = recent[0].c;
  const close = recent[recent.length - 1].c;
  const changePct = ((close / open) - 1) * 100;

  const quoteVol = recent.reduce((s,b)=> s + (b.c * b.v), 0);
  return { changePct, quoteVol };
}

function fmtNumber(n) {
  if (n === null || n === undefined || isNaN(n)) return '-';
  if (n >= 1_000_000_000) return (n/1_000_000_000).toFixed(2) + 'B';
  if (n >= 1_000_000) return (n/1_000_000).toFixed(2) + 'M';
  if (n >= 1_000) return (n/1_000).toFixed(2) + 'K';
  return String(Math.round(n));
}

/* ==============================
   적응형 레이트리밋 fetch
============================== */
function nowMs(){ return Date.now(); }

async function guardedFetch(url) {
  // 쿨다운 중이면 잠깐 대기
  if (nowMs() < cooldownUntil) await sleep(250);

  let attempt = 0;
  while (true) {
    try {
      const r = await fetch(url);
      if (!r.ok) {
        if (r.status === 418 || r.status === 429) {
          // 적응형: 동시요청 낮추고, 쿨다운 설정
          dynConcurrency = Math.max(2, Math.floor(dynConcurrency * 0.7));
          cooldownUntil = nowMs() + 3000 + Math.floor(Math.random()*7000);
        }
        if (attempt < SETTINGS.maxRetries && [418,429,502,503,504].includes(r.status)) {
          attempt++;
          await sleep(backoffDelay(attempt));
          continue;
        }
      }
      return r;
    } catch (e) {
      if (attempt < SETTINGS.maxRetries) {
        attempt++;
        await sleep(backoffDelay(attempt));
        continue;
      }
      // fetch 자체 실패
      return { ok:false, status:0, text: async()=>String(e) };
    }
  }
}

/* ==============================
   데이터 로딩
============================== */
async function fetchUSDTPerpSymbols(maxSymbols) {
  const res = await guardedFetch(API.exchangeInfo);
  if (!res.ok) throw new Error('exchangeInfo ' + res.status);
  const json = await res.json();
  const symbols = (json.symbols || [])
    .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT' && s.status === 'TRADING')
    .map(s => s.symbol);
  const unique = Array.from(new Set(symbols)).sort();
  return unique.slice(0, maxSymbols || unique.length);
}

async function fetchKlinesLTF(symbol, interval, limit) {
  const url = `${API.klines}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const res = await guardedFetch(url);
  if (!res.ok) throw new Error(`klines ${symbol} ${interval} ${res.status}`);
  const data = await res.json();
  return parseKlines(data);
}

/* ==============================
   스캔 본체 (No-Proxy, 요청절감)
============================== */
async function scanOnce(params, onProgress){
  const { ltf, htf, minBelow, limit, maxSymbols } = params;

  // 1) 심볼 목록 (1회 요청)
  const symbols = await fetchUSDTPerpSymbols(maxSymbols);
  const total = symbols.length;

  let done = 0;
  const results = [];

  // 2) 청크로 나눠서 처리
  const chunks = [];
  for (let i=0; i<symbols.length; i+=SETTINGS.chunkSize){
    chunks.push(symbols.slice(i, i + SETTINGS.chunkSize));
  }

  for (let ci = 0; ci < chunks.length; ci++) {
    const queue = [...chunks[ci]];
    const workers = [];
    const useConc = Math.min(dynConcurrency, SETTINGS.initConcurrency);

    function updateProgress(){
      const clamped = Math.max(0, Math.min(done, total));
      const pct = total ? Math.floor(clamped * 100 / total) : 0;
      onProgress(clamped, total, pct);
    }

    function workerFactory(){
      return (async function worker(){
        while (queue.length){
          const sym = queue.shift();
          try {
            // LTF 캔들 1회만 호출
            const ltfBars = await fetchKlinesLTF(sym, ltf, limit);
            if (ltfBars.length < 60) { done++; updateProgress(); await sleep(SETTINGS.perSymbolDelayMs); continue; }

            // HTF는 LTF 리샘플로 대체
            const ratio = ratioFromTf(ltf, htf);
            let htfBars = [];
            if (ratio) {
              htfBars = resampleOHLCV(ltfBars, ratio);
              if (htfBars.length < 60) { done++; updateProgress(); await sleep(SETTINGS.perSymbolDelayMs); continue; }
            } else {
              // 비정수배면 상위TF 필터를 생략(또는 필요시 근사 처리)
              htfBars = [];
            }

            // 상위TF EMA200 강세(직전 확정봉)
            let htfBull = true; // 기본 true로 두고, ratio 있으면 체크
            if (ratio) {
              const htfCloses = htfBars.map(b => b.c);
              const ema200 = ema(htfCloses, 200);
              const j = lastClosedIndex(htfBars);
              htfBull = (htfCloses[j] > (ema200[j] || 0));
            }
            if (!htfBull) { done++; updateProgress(); await sleep(SETTINGS.perSymbolDelayMs); continue; }

            // 하위TF EMA50 재돌파(직전 확정봉)
            const closes = ltfBars.map(b => b.c);
            const ema50 = ema(closes, 50);
            const k = lastClosedIndex(ltfBars);
            const { below, seq } = rollingBelowLengths(closes, ema50);

            const wasBelow = (k-1 >= 0) ? (below[k-1] === true) : false;
            const reclaim  = closes[k] > (ema50[k] || 0);
            const belowLen = seq[k-1] || 0;

            if (wasBelow && reclaim && (belowLen >= minBelow)) {
              const { changePct, quoteVol } = estimate24hFromLTF(ltfBars, ltf);
              results.push({
                symbol: sym,
                signalTime: ltfBars[k].t,
                belowLen,
                priceChangePercent: changePct,
                quoteVolume: quoteVol,
                lastVol: ltfBars[k].v
              });
            }
          } catch(e){
            console.debug('symbol error', sym, e?.message || e);
          } finally {
            done++;
            updateProgress();
            await sleep(SETTINGS.perSymbolDelayMs);
          }
        }
      });
    }

    for (let i=0;i<useConc;i++) workers.push(workerFactory()());
    await Promise.all(workers);

    // 다음 청크 전 쿨다운
    if (ci < chunks.length - 1){
      const pause = SETTINGS.chunkCooldownMinMs + Math.floor(Math.random()*(SETTINGS.chunkCooldownMaxMs - SETTINGS.chunkCooldownMinMs));
      statusEl.textContent = `쿨다운 중… ${Math.round(pause/1000)}s (진행 ${done}/${total})`;
      await sleep(pause);
    }
  }

  // 정렬: 최근 시그널 ↓, 24h 추정 거래대금 ↓
  results.sort((a,b)=>{
    if (a.signalTime !== b.signalTime) return b.signalTime - a.signalTime;
    return (b.quoteVolume || 0) - (a.quoteVolume || 0);
  });

  return results;
}

/* ==============================
   UI & 실행 제어 (중복 실행 방지 포함)
============================== */
const tbody = document.getElementById('tbody');
const bar = document.getElementById('bar');
const statusEl = document.getElementById('status');
const infoEl = document.getElementById('resultInfo');

function renderRows(rows){
  tbody.innerHTML = '';
  for (const r of rows){
    const tr = document.createElement('tr');

    const tdSym = document.createElement('td');
    tdSym.className = 'symbol';
    tdSym.textContent = r.symbol;
    tr.appendChild(tdSym);

    const tdTime = document.createElement('td');
    tdTime.textContent = toKSTString(r.signalTime);
    tr.appendChild(tdTime);

    const tdBelow = document.createElement('td');
    tdBelow.className = 'right';
    tdBelow.textContent = r.belowLen;
    tr.appendChild(tdBelow);

    const tdChg = document.createElement('td');
    tdChg.className = 'right';
    const chg = r.priceChangePercent;
    tdChg.textContent = isNaN(chg) ? '-' : chg.toFixed(2) + '%';
    if (!isNaN(chg)) tdChg.classList.add(chg >= 0 ? 'green' : 'red');
    tr.appendChild(tdChg);

    const tdVol = document.createElement('td');
    tdVol.className = 'right';
    tdVol.textContent = fmtNumber(r.quoteVolume);
    tr.appendChild(tdVol);

    const tdLastV = document.createElement('td');
    tdLastV.className = 'right';
    tdLastV.textContent = fmtNumber(r.lastVol);
    tr.appendChild(tdLastV);

    tbody.appendChild(tr);
  }
  infoEl.textContent = `${rows.length} symbols`;
}

function getParamsFromUI(){
  const ltf = document.getElementById('ltf').value;
  const htf = document.getElementById('htf').value;
  const minBelow = Math.max(1, parseInt(document.getElementById('minBelow').value || '3', 10));
  const limit = Math.max(200, Math.min(1500, parseInt(document.getElementById('limit').value || '600', 10)));
  const maxSymbols = Math.max(10, Math.min(99999, parseInt(document.getElementById('maxSymbols').value || '9999', 10)));
  return { ltf, htf, minBelow, limit, maxSymbols };
}

// 진행 표시(클램핑)
function setProgressFactory(myRunId){
  return (done, total, pct) => {
    if (myRunId !== runId) return;
    const d = Math.max(0, Math.min(done, total));
    const p = total ? Math.floor(d * 100 / total) : (pct || 0);
    bar.style.width = p + '%';
    statusEl.textContent = `스캔 중… ${d} / ${total} (${p}%)`;
  };
}

// 중복 실행 방지
let running = false;
let runId = 0;
let lastResults = [];

document.getElementById('scanBtn').addEventListener('click', async ()=>{
  if (running) return;
  running = true;
  runId += 1;
  const myRunId = runId;

  // 초기화
  dynConcurrency = SETTINGS.initConcurrency;
  cooldownUntil = 0;

  const btn = document.getElementById('scanBtn');
  btn.disabled = true; btn.textContent = '스캔 중…';
  tbody.innerHTML = ''; bar.style.width = '0%';
  statusEl.textContent = '심볼 목록 로딩 중…';

  const params = getParamsFromUI();
  const onProgress = setProgressFactory(myRunId);

  try{
    const rows = await scanOnce(params, onProgress);
    if (myRunId !== runId) return;
    lastResults = rows;
    renderRows(rows);
    statusEl.textContent = '완료';
  } catch(e){
    console.error(e);
    if (myRunId === runId) statusEl.textContent = '오류가 발생했습니다. 콘솔을 확인하세요.';
  } finally {
    if (myRunId === runId) {
      running = false;
      btn.disabled = false; btn.textContent = '스캔 시작';
    }
  }
});

document.getElementById('csvBtn').addEventListener('click', ()=>{
  if (!lastResults.length) { alert('저장할 결과가 없습니다. 먼저 스캔을 실행하세요.'); return; }
  const header = ['symbol','signalTime(KST)','belowLen','priceChangePercent_est','quoteVolume_est','lastVolume'];
  const lines = [header.join(',')];
  for (const r of lastResults){
    lines.push([
      r.symbol,
      toKSTString(r.signalTime).replace(/,/g,' '),
      r.belowLen,
      isNaN(r.priceChangePercent) ? '' : r.priceChangePercent.toFixed(2),
      r.quoteVolume,
      r.lastVol
    ].join(','));
  }
  const blob = new Blob([lines.join('\n')], { type:'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `mtf_pullback_long_scan_${Date.now()}.csv`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>
