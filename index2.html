<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>USDT Perp 전심볼 스캐너 (배치/레이트리밋 대응 · 승률 중심)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; }
    h1 { margin: 0 0 8px; }
    .cfg, .log { margin: 12px 0; font-size: 14px; }
    .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .muted { color: #666; }
    .btn { padding: 8px 12px; border: 1px solid #ccc; background: #fafafa; cursor: pointer; border-radius: 6px; }
    .btn:active { transform: translateY(1px); }
    progress { width: 320px; height: 16px; }
    table { border-collapse: collapse; width: 100%; margin: 12px 0; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; font-size: 13px; }
    th { background: #f6f6f6; position: sticky; top: 0; }
    .best { background: #f0fff4; }
    .small { font-size: 12px; }
    code { background: #f6f6f6; padding: 0 4px; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>바이낸스 USDT Perp 일봉 스캐너 (배치 스캔 / 승률 중심)</h1>

  <div class="cfg">
    <div class="row">
      <button id="runNow" class="btn">지금 스캔 실행</button>
      <span class="muted">매일 오전 09:00(Asia/Seoul)에 자동 실행</span>
    </div>
    <div class="row small">
      <div>배치 크기: <code id="cfgBatch"></code></div>
      <div>배치 간 대기: <code id="cfgDelay"></code> ms</div>
      <div>동시성: <code id="cfgConc"></code></div>
      <div>강제 1회 진입(FORCE_TRADE): <code id="cfgForce"></code></div>
      <div>표시: <code id="cfgShowOnly"></code> (LONG/SHORT만 표에 표시 여부)</div>
    </div>
  </div>

  <div id="progressWrap" class="row">
    <progress id="prog" max="100" value="0"></progress>
    <span id="progText" class="muted">대기 중…</span>
  </div>

  <div id="summary"></div>

  <table id="result">
    <thead>
      <tr>
        <th>심볼</th>
        <th>히스토릭 승률</th>
        <th>표본(N)</th>
        <th>전일 RSI(2)</th>
        <th>시그널</th>
        <th>진입가</th>
        <th>TP</th>
        <th>SL</th>
        <th>비고</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <pre class="log" id="log"></pre>

<script>
/** ===== 설정 ===== */
const CONFIG = {
  RSI_LEN: 2,
  ATR_LEN: 14,
  LOOKBACK_DAYS: 220,     // 히스토릭 시뮬 길이
  MIN_TRADES: 40,         // 표본 최소치 (작으면 통계적 의미 약함)
  TP_ATR: 0.5,
  SL_ATR: 1.0,

  // 배치 처리/레이트리밋 대응
  BATCH_SIZE: 100,        // 심볼을 100개 단위로 분할
  BATCH_DELAY_MS: 3000,   // 배치 사이 대기 (ms)
  CONCURRENCY: 6,         // 배치 내 동시 요청 수

  // “RSI 극단 없을 때도 하루 1회 반드시 진입”을 원하면 true
  FORCE_TRADE: false,     // true면 prevRSI<50=LONG, >=50=SHORT

  // 표에 LONG/SHORT만 표시하고 싶으면 true
  SHOW_ONLY_SIGNALED_IN_TABLE: true,
};

document.getElementById('cfgBatch').textContent = CONFIG.BATCH_SIZE;
document.getElementById('cfgDelay').textContent = CONFIG.BATCH_DELAY_MS;
document.getElementById('cfgConc').textContent = CONFIG.CONCURRENCY;
document.getElementById('cfgForce').textContent = CONFIG.FORCE_TRADE;
document.getElementById('cfgShowOnly').textContent = CONFIG.SHOW_ONLY_SIGNALED_IN_TABLE;

/** ===== 공통 유틸 ===== */
const BASE = 'https://fapi.binance.com'; // USDⓈ-M Futures
const log = (m) => { const el = document.getElementById('log'); el.textContent += m + '\n'; console.log(m); };
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const fmt = (x) => x==null ? '-' : Number(x).toLocaleString('en-US', {maximumFractionDigits: 6});

function isNineAMSeoulNow() {
  const now = new Date();
  const fmtKR = new Intl.DateTimeFormat('ko-KR', { timeZone: 'Asia/Seoul', hour: '2-digit', minute: '2-digit', hour12: false, minute: '2-digit' });
  const parts = fmtKR.formatToParts(now);
  const hh = Number(parts.find(p => p.type === 'hour').value);
  const mm = Number(parts.find(p => p.type === 'minute').value);
  return hh === 9 && mm === 0;
}

async function fetchJSON(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`HTTP ${r.status} @ ${url}`);
  return r.json();
}

/** ===== 지표 ===== */
function rsi(values, period) {
  if (values.length < period + 1) return Array(values.length).fill(NaN);
  const out = Array(values.length).fill(NaN);
  let gains = 0, losses = 0;
  for (let i = 1; i <= period; i++) {
    const ch = values[i] - values[i-1];
    gains += Math.max(0, ch);
    losses += Math.max(0, -ch);
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;
  out[period] = 100 - (100 / (1 + (avgGain / (avgLoss || 1e-12))));
  for (let i = period + 1; i < values.length; i++) {
    const ch = values[i] - values[i-1];
    const gain = Math.max(0, ch);
    const loss = Math.max(0, -ch);
    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;
    const rs = avgGain / (avgLoss || 1e-12);
    out[i] = 100 - (100 / (1 + rs));
  }
  return out;
}

function atr(ohlc, period) {
  if (ohlc.length < period + 1) return Array(ohlc.length).fill(NaN);
  const tr = Array(ohlc.length).fill(NaN);
  for (let i = 1; i < ohlc.length; i++) {
    const {h, l} = ohlc[i];
    const prevClose = ohlc[i-1].c;
    const t = Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));
    tr[i] = t;
  }
  const out = Array(ohlc.length).fill(NaN);
  let sum = 0;
  for (let i = 1; i <= period; i++) sum += tr[i] || 0;
  out[period] = sum / period;
  for (let i = period + 1; i < ohlc.length; i++) {
    out[i] = ((out[i-1] * (period - 1)) + tr[i]) / period;
  }
  return out;
}

/** ===== 데이터 ===== */
async function getUSDTPerpSymbols() {
  const info = await fetchJSON(`${BASE}/fapi/v1/exchangeInfo`);
  return info.symbols
    .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT' && s.status === 'TRADING')
    .map(s => s.symbol);
}

async function getDailyKlines(symbol, limit=300) {
  const arr = await fetchJSON(`${BASE}/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=${limit}`);
  return arr.map(k => ({ t:k[0], o:+k[1], h:+k[2], l:+k[3], c:+k[4], v:+k[5] }));
}

async function getPrice(symbol) {
  const { price } = await fetchJSON(`${BASE}/fapi/v1/ticker/price?symbol=${symbol}`);
  return +price;
}

/** ===== 전략/백테스트 ===== */
function backtestOnceADay(ohlc, rsiArr, atrArr, cfg) {
  let wins = 0, trades = 0;
  for (let i = 1; i < ohlc.length; i++) {
    const prevRsi = rsiArr[i-1], prevAtr = atrArr[i-1];
    if (!isFinite(prevRsi) || !isFinite(prevAtr)) continue;

    let dir = 0; // +1 long, -1 short
    if (prevRsi <= 5) dir = +1;
    else if (prevRsi >= 95) dir = -1;
    else if (cfg.FORCE_TRADE) dir = (prevRsi < 50) ? +1 : -1; // 폴백

    if (dir === 0) continue;

    const entry = ohlc[i].o;
    const tp = dir === 1 ? entry + cfg.TP_ATR * prevAtr : entry - cfg.TP_ATR * prevAtr;
    const sl = dir === 1 ? entry - cfg.SL_ATR * prevAtr : entry + cfg.SL_ATR * prevAtr;

    const H = ohlc[i].h, L = ohlc[i].l;
    const hitTP = dir === 1 ? (H >= tp) : (L <= tp);
    const hitSL = dir === 1 ? (L <= sl) : (H >= sl);

    let win;
    if (hitTP && !hitSL) win = true;
    else if (!hitTP && hitSL) win = false;
    else if (hitTP && hitSL) win = false; // 보수적: SL 우선
    else {
      const pnl = dir === 1 ? (ohlc[i].c - entry) : (entry - ohlc[i].c);
      win = pnl > 0;
    }

    trades++;
    if (win) wins++;
  }
  return { wins, trades, winRate: trades ? (wins / trades) : 0 };
}

function computeIndicators(ohlc, cfg) {
  const closes = ohlc.map(x => x.c);
  return { r: rsi(closes, cfg.RSI_LEN), a: atr(ohlc, cfg.ATR_LEN) };
}

async function analyzeSymbol(symbol, cfg) {
  try {
    const kl = await getDailyKlines(symbol, cfg.LOOKBACK_DAYS + 20);
    // 데이터 부족 → SKIP으로 반환(표에 보이게)
    if (kl.length < cfg.ATR_LEN + 10) {
      return { symbol, winRate: 0, trades: 0, prevRsi: NaN, signal: 'SKIP', entry: null, tp: null, sl: null, reason: '캔들 데이터 부족' };
    }

    const ohlc = kl.map(k => ({ o:k.o, h:k.h, l:k.l, c:k.c }));
    const { r, a } = computeIndicators(ohlc, cfg);
    const bt = backtestOnceADay(ohlc, r, a, cfg);

    // 표본 부족 → SKIP으로 반환(표에 보이게)
    if (bt.trades < cfg.MIN_TRADES) {
      return { symbol, winRate: 0, trades: bt.trades, prevRsi: NaN, signal: 'SKIP', entry: null, tp: null, sl: null, reason: `표본 부족(MIN_TRADES=${cfg.MIN_TRADES})` };
    }

    const prevRsi = r[r.length - 2];
    const prevAtr = a[a.length - 2];
    let signal = 'NONE', reason = '';
    if (isFinite(prevRsi) && isFinite(prevAtr)) {
      if (prevRsi <= 5) { signal = 'LONG'; reason = 'RSI<=5'; }
      else if (prevRsi >= 95) { signal = 'SHORT'; reason = 'RSI>=95'; }
      else if (cfg.FORCE_TRADE) {
        signal = (prevRsi < 50) ? 'LONG' : 'SHORT';
        reason = 'FORCE_TRADE';
      } else {
        reason = 'RSI 5~95 (미진입)';
      }
    } else {
      signal = 'SKIP';
      reason = '지표 계산 불가(데이터 부족)';
    }

    // 오늘 진입가(현 시세)
    const priceNow = await getPrice(symbol);
    let entry = priceNow, tp = null, sl = null;
    if (signal === 'LONG') { tp = entry + cfg.TP_ATR * prevAtr; sl = entry - cfg.SL_ATR * prevAtr; }
    if (signal === 'SHORT'){ tp = entry - cfg.TP_ATR * prevAtr; sl = entry + cfg.SL_ATR * prevAtr; }

    return { symbol, winRate: bt.winRate, trades: bt.trades, prevRsi, signal, entry, tp, sl, reason };
  } catch (e) {
    console.warn(symbol, e);
    // 오류도 표에서 볼 수 있게 표시
    return { symbol, winRate: 0, trades: 0, prevRsi: NaN, signal: 'SKIP', entry: null, tp: null, sl: null, reason: `오류: ${e.message}` };
  }
}

/** ===== UI 렌더링 ===== */
function renderRow(r) {
  const tr = document.createElement('tr');
  tr.id = `row-${r.symbol}`;
  tr.innerHTML = `
    <td>${r.symbol}</td>
    <td>${(r.winRate*100).toFixed(1)}%</td>
    <td>${r.trades}</td>
    <td>${isFinite(r.prevRsi) ? r.prevRsi.toFixed(1) : '-'}</td>
    <td>${r.signal}</td>
    <td>${fmt(r.entry)}</td>
    <td>${fmt(r.tp)}</td>
    <td>${fmt(r.sl)}</td>
    <td>${r.reason||''}</td>
  `;
  document.querySelector('#result tbody').appendChild(tr);
}
function maybeRenderRow(r) {
  if (CONFIG.SHOW_ONLY_SIGNALED_IN_TABLE) {
    if (r.signal !== 'LONG' && r.signal !== 'SHORT') return; // NONE/SKIP 숨김
  }
  renderRow(r);
}

function highlightBest(symbol){
  if(!symbol) return;
  document.querySelectorAll('#result tbody tr').forEach(tr => tr.classList.remove('best'));
  const el = document.getElementById(`row-${symbol}`);
  if (el) el.classList.add('best');
}

function setProgress(done, total, batchIdx, batchTotal, symbolText='') {
  const pct = total ? Math.round((done / total) * 100) : 0;
  const prog = document.getElementById('prog');
  const txt = document.getElementById('progText');
  prog.value = pct;
  txt.textContent = `전체 ${done}/${total} (${pct}%) · 배치 ${batchIdx}/${batchTotal} 처리 중… ${symbolText}`;
}

/** ===== 배치 스캔 실행 ===== */
async function runScan() {
  document.querySelector('#summary').innerHTML = '스캔 준비 중…';
  document.querySelector('#result tbody').innerHTML = '';
  document.getElementById('log').textContent = '';

  log('USDT Perp 심볼 가져오는 중…');
  const allSymbols = await getUSDTPerpSymbols();
  const total = allSymbols.length;
  log(`대상 심볼 수: ${total}`);

  // 배치 분할
  const batches = [];
  for (let i = 0; i < total; i += CONFIG.BATCH_SIZE) {
    batches.push(allSymbols.slice(i, i + CONFIG.BATCH_SIZE));
  }

  const results = [];
  let processed = 0;

  for (let b = 0; b < batches.length; b++) {
    const batch = batches[b];
    const batchIdx = b + 1;
    const batchTotal = batches.length;
    log(`배치 ${batchIdx}/${batchTotal} 시작 (심볼 ${batch.length}개)…`);

    // 동시성 제어
    let idx = 0;
    async function worker() {
      while (idx < batch.length) {
        const s = batch[idx++];
        setProgress(processed, total, batchIdx, batchTotal, s);
        const r = await analyzeSymbol(s, CONFIG);
        processed++;
        if (r) { results.push(r); maybeRenderRow(r); }
        await sleep(120); // 호출 간 간격(레이트리밋 여유)
      }
    }
    const workers = Array.from({length: CONFIG.CONCURRENCY}, worker);
    await Promise.all(workers);

    log(`배치 ${batchIdx}/${batchTotal} 완료. ${CONFIG.BATCH_DELAY_MS}ms 대기…`);
    if (b < batches.length - 1) await sleep(CONFIG.BATCH_DELAY_MS);
  }

  // 후보 선택: 시그널이 있는 것(LONG/SHORT)만에서 승률 Top 1
  const ranked = [...results].sort((a,b) => b.winRate - a.winRate);
  const candidates = ranked.filter(r => r.signal === 'LONG' || r.signal === 'SHORT');
  const best = candidates[0];

  highlightBest(best?.symbol);
  const sum = document.querySelector('#summary');
  if (best) {
    sum.innerHTML =
      `<strong>오늘의 후보:</strong> <b>${best.symbol}</b> · 승률 ${(best.winRate*100).toFixed(1)}% · ` +
      `${best.signal} 진입가 ${fmt(best.entry)} / TP ${fmt(best.tp)} / SL ${fmt(best.sl)} ` +
      `<span class="muted">(표본 N=${best.trades})</span>`;
  } else {
    sum.textContent = '오늘 시그널(LONG/SHORT) 발생 심볼이 없습니다. (모두 NONE 또는 SKIP)';
  }

  setProgress(total, total, batches.length, batches.length);
  log('스캔 완료.');
}

/** ===== 자동 실행(매일 09:00 KST) & 버튼 ===== */
setInterval(() => {
  if (isNineAMSeoulNow()) runScan();
}, 30 * 1000);

document.getElementById('runNow').addEventListener('click', runScan);
</script>
</body>
</html>
