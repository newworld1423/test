<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Binance USDT Perp MTF Pullback Long Scanner (Safe Requests)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: dark light;
        }
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple SD Gothic Neo, sans-serif;
            margin: 0;
            padding: 24px;
            background: #0b0c10;
            color: #eaf1ff;
        }
        h1 {
            margin: 0 0 12px 0;
            font-size: 20px;
        }
        .panel {
            border: 1px solid #1f2430;
            background: #11131a;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 8px 24px rgba(0,0,0,.25);
        }
        .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
        .row > label {
            display: flex; gap: 6px; align-items: center;
            background: #0e1117; border: 1px solid #232a35; border-radius: 10px; padding: 8px 10px;
        }
        select, input {
            background: transparent; border: none; color: inherit; font-size: 14px; outline: none;
        }
        button {
            padding: 10px 14px; border-radius: 10px; border: 1px solid #293246; background: #0e4fff;
            color: #fff; font-weight: 600; cursor: pointer;
        }
        button.secondary { background: #131a27; color: #cfe0ff; border-color: #293246; }
        .muted { color: #9fb1cc; font-size: 12px; }
        .progress {
            height: 8px; background: #141824; border-radius: 999px; overflow: hidden;
            border: 1px solid #1f2430;
        }
        .bar { height: 100%; width: 0%; background: #2ea043; transition: width .2s ease; }
        table {
            width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px;
        }
        th, td {
            padding: 10px; border-bottom: 1px solid #1c2230; text-align: left;
            white-space: nowrap;
        }
        th { position: sticky; top: 0; background: #0d1017; z-index: 1; }
        td.symbol { font-weight: 700; }
        .right { text-align: right; }
        .green { color: #21d07a; }
        .red { color: #ff6b6b; }
        .dim { color: #93a1bb; }
        .wrap { overflow: auto; max-height: 64vh; border: 1px solid #1f2430; border-radius: 12px; }
        .hint { font-size: 12px; color: #93a1bb; margin-top: 6px; }
        .badge { font-size: 12px; padding: 2px 8px; border: 1px solid #2b3346; border-radius: 999px; background: #151a25; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 8px; }
    </style>
</head>
<body>
    <h1>USDT Perp 스캐너 · MTF Pullback Long (EMA50 재돌파)</h1>
    <div class="panel">
        <div class="row">
            <label>하위TF
                <select id="ltf">
                    <option value="1m">1m</option>
                    <option value="3m">3m</option>
                    <option value="5m">5m</option>
                    <option value="15m" selected>15m</option>
                    <option value="30m">30m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                </select>
            </label>
            <label>상위TF
                <select id="htf">
                    <option value="5m">5m</option>
                    <option value="15m">15m</option>
                    <option value="30m">30m</option>
                    <option value="1h" selected>1h</option>
                    <option value="2h">2h</option>
                    <option value="4h">4h</option>
                    <option value="12h">12h</option>
                    <option value="1d">1d</option>
                </select>
            </label>
            <label>EMA50(하위) 하회 연속
                <input id="minBelow" type="number" value="3" min="1" style="width:64px" />
                <span class="dim">봉 이상</span>
            </label>
            <label>최소 캔들수
                <input id="limit" type="number" value="600" min="200" max="1500" style="width:80px" />
            </label>
            <label>스캔 대상 제한
                <input id="maxSymbols" type="number" value="300" min="10" max="1500" style="width:80px" />
            </label>
        </div>

        <div class="row" style="margin-top:8px">
            <label>동시요청(concurrency)
                <input id="concurrency" type="number" value="6" min="1" max="20" style="width:64px" />
            </label>
            <label>요청간 지연(ms)
                <input id="reqDelay" type="number" value="120" min="0" max="2000" style="width:80px" />
            </label>
            <label>최대 재시도
                <input id="maxRetries" type="number" value="3" min="0" max="8" style="width:64px" />
            </label>
            <label>프록시(옵션)
                <input id="proxyBase" type="text" placeholder="/api/binance-proxy" style="width:220px" />
            </label>

            <button id="scanBtn">스캔 시작</button>
            <button id="csvBtn" class="secondary">CSV 저장</button>
        </div>

        <div class="grid" style="margin-top:10px">
            <div><span class="badge">전략</span> <span class="muted">상TF EMA200 강세 + 하TF EMA50 연속 하회 → 재돌파 롱(직전 봉)</span></div>
            <div><span class="badge">판정봉</span> <span class="muted">최신 진행중 봉 제외, 직전 확정봉 사용</span></div>
            <div><span class="badge">거래소</span> <span class="muted">Binance USDT-M Futures (퍼블릭 API) — 프록시 권장</span></div>
        </div>
        <div class="hint">프록시가 없으면 심볼별로 개별 요청을 하므로 느릴 수 있습니다. 프록시(`/api/binance-proxy`)를 권장합니다.</div>
        <div class="progress" style="margin-top:12px"><div class="bar" id="bar"></div></div>
        <div class="muted" id="status" style="margin-top:8px">대기 중…</div>
    </div>

    <div class="panel">
        <div class="row" style="justify-content: space-between">
            <div>
                <span class="badge">결과</span>
                <span class="muted" id="resultInfo">0 symbols</span>
            </div>
            <div class="muted">정렬: 시그널시간 ↓, 24h 거래대금 ↓</div>
        </div>
        <div class="wrap">
            <table id="table">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>시그널 시간(KST)</th>
                        <th class="right">연속 하회</th>
                        <th class="right">24h 변동%</th>
                        <th class="right">24h 거래대금(USDT)</th>
                        <th class="right">최근 봉 거래량</th>
                    </tr>
                </thead>
                <tbody id="tbody"></tbody>
            </table>
        </div>
    </div>

<script>
/* ==============================
   안전 요청 레이어 + 유틸 (4-space indentation)
   - 동시요청(세마포어), 토큰버킷(초당), 재시도(지수 백오프 + 지터)
   - 프록시 지원: proxyBase 값이 있으면 전체 조회를 프록시로 시도
============================== */
const ORIGIN = {
    EXCHANGE_INFO: 'https://fapi.binance.com/fapi/v1/exchangeInfo',
    KLINES:        'https://fapi.binance.com/fapi/v1/klines',
    TICKER24H:     'https://fapi.binance.com/fapi/v1/ticker/24hr'
};

function sleep(ms) {
    return new Promise(res => setTimeout(res, ms));
}

function backoffDelay(attempt, baseMs = 300) {
    const expo = baseMs * Math.pow(2, attempt);
    const jitter = Math.floor(Math.random() * 150);
    return expo + jitter;
}

function createSemaphore(max) {
    let active = 0;
    const queue = [];
    async function acquire() {
        if (active < max) { active++; return; }
        await new Promise(res => queue.push(res));
        active++;
    }
    function release() {
        active--;
        const next = queue.shift();
        if (next) next();
    }
    return { acquire, release };
}

// 간단 토큰버킷: 초당 ratePerSec 토큰 생성, capacity = ratePerSec
function createTokenBucket(ratePerSec = 8) {
    let tokens = ratePerSec;
    let last = performance.now();
    return {
        async take() {
            while (true) {
                const now = performance.now();
                const delta = (now - last) / 1000;
                last = now;
                tokens = Math.min(ratePerSec, tokens + ratePerSec * delta);
                if (tokens >= 1) { tokens -= 1; return; }
                const waitMs = Math.ceil((1 - tokens) / ratePerSec * 1000);
                await sleep(Math.max(waitMs, 20));
            }
        }
    };
}

function proxiedURL(proxyBase, originURL) {
    if (!proxyBase) return originURL;
    try {
        const u = new URL(originURL);
        const endpoint = u.pathname.replace(/^\//, '') + (u.search ? ('&' + u.search.replace(/^\?/, '')) : '');
        return proxyBase + '?endpoint=' + encodeURIComponent(endpoint);
    } catch (e) {
        return originURL;
    }
}

function createRequester({ concurrency = 6, reqDelay = 120, ratePerSec = 8 }) {
    const sem = createSemaphore(concurrency);
    const bucket = createTokenBucket(ratePerSec);

    return async function binanceRequest(url, { proxyBase = '', maxRetries = 3 } = {}) {
        const finalURL = proxiedURL(proxyBase, url);
        await bucket.take();
        await sem.acquire();
        try {
            let attempt = 0;
            while (true) {
                try {
                    const res = await fetch(finalURL, { headers: { 'User-Agent': 'scanner' } });
                    const ct = res.headers.get ? res.headers.get('content-type') || '' : '';

                    if (!res.ok) {
                        // 재시도 가능한 상태코드인 경우 재시도
                        if ([418, 429, 502, 503, 504].includes(res.status) && attempt < maxRetries) {
                            attempt++;
                            await sleep(backoffDelay(attempt));
                            continue;
                        }
                        // 실패시 텍스트로 얻어 에러 반환
                        const txt = await res.text().catch(() => '');
                        throw new Error(`HTTP ${res.status} ${txt.slice(0, 200)}`);
                    }

                    // 정상 응답
                    if (ct.includes('application/json')) {
                        return await res.json();
                    } else {
                        // JSON 아닌 경우 (Cloudflare 에러 HTML 등) → 텍스트로 반환 시도
                        const txt = await res.text();
                        try { return JSON.parse(txt); } catch { return txt; }
                    }
                } catch (e) {
                    if (attempt < maxRetries) {
                        attempt++;
                        await sleep(backoffDelay(attempt));
                        continue;
                    }
                    throw e;
                }
            }
        } finally {
            // 요청간 지연(서버 보호)
            if (reqDelay > 0) await sleep(reqDelay);
            sem.release();
        }
    };
}

/* ==============================
   기존 유틸 (EMA 등)
============================== */
function ema(values, period) {
    if (!values || values.length === 0) return [];
    const k = 2 / (period + 1);
    const out = new Array(values.length);
    let prev = values[0];
    out[0] = prev;
    for (let i = 1; i < values.length; i++) {
        const v = values[i];
        prev = v * k + prev * (1 - k);
        out[i] = prev;
    }
    return out;
}

function parseKlines(arr) {
    return arr.map(x => ({
        t: x[0],
        o: parseFloat(x[1]),
        h: parseFloat(x[2]),
        l: parseFloat(x[3]),
        c: parseFloat(x[4]),
        v: parseFloat(x[5]),
        ct: x[6]
    }));
}

function lastClosedIndex(bars) {
    return Math.max(0, bars.length - 2);
}

function rollingBelowLengths(closes, emaArr) {
    const n = closes.length;
    const below = new Array(n).fill(false);
    const seq = new Array(n).fill(0);
    let run = 0;
    for (let i = 0; i < n; i++) {
        below[i] = (closes[i] < (emaArr[i] || 0));
        if (below[i]) { run += 1; seq[i] = run; } else { run = 0; seq[i] = 0; }
    }
    return { below, seq };
}

function toKSTString(ts) {
    const d = new Date(ts);
    return d.toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
}

/* ==============================
   안전한 데이터 로딩 함수들 (프록시 지원)
============================== */

async function fetchUSDTPerpSymbols(request, proxyBase, maxSymbols) {
    const data = await request(ORIGIN.EXCHANGE_INFO, { proxyBase, maxRetries: 3 });
    const list = (data && data.symbols) ? data.symbols : [];
    const symbols = list
        .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT' && s.status === 'TRADING')
        .map(s => s.symbol)
        .sort();
    return symbols.slice(0, maxSymbols || symbols.length);
}

async function fetchKlines(request, proxyBase, symbol, interval, limit) {
    const url = `${ORIGIN.KLINES}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    const data = await request(url, { proxyBase, maxRetries: 3 });
    if (!Array.isArray(data)) throw new Error('Klines not array for ' + symbol);
    return parseKlines(data);
}

/*
 fetch24hTickerMap:
  - proxyBase가 있으면 전체 호출(프록시가 허용하면 안전)
  - proxyBase 없으면 심볼별 호출(동시요청/제한 적용) — MAX_PER_SYMBOLS로 상한
*/
async function fetch24hTickerMap(request, proxyBase, symbols, concurrency) {
    const map = new Map();
    if (proxyBase) {
        // 전체 호출 (프록시 경유)
        const data = await request(ORIGIN.TICKER24H, { proxyBase, maxRetries: 3 });
        if (Array.isArray(data)) {
            for (const t of data) {
                if (symbols.includes(t.symbol)) map.set(t.symbol, t);
            }
        }
        return map;
    }

    // 프록시 없으면 심볼별로 요청. 과도한 요청 방지를 위해 상한을 둠.
    const MAX_PER_SYMBOLS = Math.min(symbols.length, 120); // 브라우저 환경에서 너무 많이 호출하면 위험
    const toFetch = symbols.slice(0, MAX_PER_SYMBOLS);
    const sem = createSemaphore(concurrency);
    const tasks = toFetch.map(sym => (async () => {
        await sem.acquire();
        try {
            const url = `${ORIGIN.TICKER24H}?symbol=${sym}`;
            const t = await request(url, { proxyBase: '', maxRetries: 2 });
            if (t && t.symbol) map.set(sym, t);
        } catch (e) {
            // 개별 실패는 무시
        } finally {
            sem.release();
        }
    })());
    await Promise.all(tasks);
    return map;
}

/* ==============================
   스캔 본체 (요청 안전장치 적용)
============================== */
async function scanOnce(params, onProgress) {
    const { ltf, htf, minBelow, limit, maxSymbols, concurrency, reqDelay, maxRetries, proxyBase } = params;

    // ratePerSec 은 concurrency 기반으로 보수적으로 설정
    const ratePerSec = Math.max(4, Math.min(12, concurrency * 2));
    const request = createRequester({ concurrency, reqDelay, ratePerSec });

    const symbols = await fetchUSDTPerpSymbols(request, proxyBase, maxSymbols);
    const tickerMap = await fetch24hTickerMap(request, proxyBase, symbols, Math.max(2, Math.min(12, concurrency)));

    let done = 0;
    const results = [];
    const queue = [...symbols];

    async function worker() {
        while (queue.length) {
            const sym = queue.shift();
            try {
                const ltfBars = await fetchKlines(request, proxyBase, sym, ltf, limit);
                if (ltfBars.length < 60) { done++; onProgress(done, symbols.length); continue; }

                const htfBars = await fetchKlines(request, proxyBase, sym, htf, Math.min(500, Math.max(200, Math.floor(limit/4))));
                if (htfBars.length < 60) { done++; onProgress(done, symbols.length); continue; }

                const htfCloses = htfBars.map(b => b.c);
                const ema200 = ema(htfCloses, 200);
                const j = lastClosedIndex(htfBars);
                const htfBull = (htfCloses[j] > (ema200[j] || 0));
                if (!htfBull) { done++; onProgress(done, symbols.length); continue; }

                const closes = ltfBars.map(b => b.c);
                const ema50 = ema(closes, 50);
                const k = lastClosedIndex(ltfBars);
                const { below, seq } = rollingBelowLengths(closes, ema50);

                const wasBelow = (k - 1 >= 0) ? (below[k - 1] === true) : false;
                const reclaim  = closes[k] > (ema50[k] || 0);
                const belowLen = seq[k - 1] || 0;

                if (wasBelow && reclaim && (belowLen >= minBelow)) {
                    const tkr = tickerMap.get(sym);
                    const priceChangePercent = tkr ? parseFloat(tkr.priceChangePercent || 'NaN') : NaN;
                    const quoteVolume = tkr ? parseFloat(tkr.quoteVolume || '0') : 0;

                    results.push({
                        symbol: sym,
                        signalTime: ltfBars[k].t,
                        belowLen,
                        priceChangePercent,
                        quoteVolume,
                        lastVol: ltfBars[k].v
                    });
                }
            } catch (e) {
                // 개별 심볼 처리 실패는 무시(로그는 콘솔에 남김)
                console.debug('symbol error', sym, e && e.message ? e.message : e);
            } finally {
                done++;
                onProgress(done, symbols.length);
            }
        }
    }

    const workers = [];
    for (let i = 0; i < Math.max(1, concurrency); i++) workers.push(worker());
    await Promise.all(workers);

    // 정렬: 최근 시그널 ↓, 거래대금 ↓
    results.sort((a, b) => {
        if (a.signalTime !== b.signalTime) return b.signalTime - a.signalTime;
        return (b.quoteVolume || 0) - (a.quoteVolume || 0);
    });

    return results;
}

/* ==============================
   UI 핸들러 (기존과 호환)
============================== */
const tbody = document.getElementById('tbody');
const bar = document.getElementById('bar');
const statusEl = document.getElementById('status');
const infoEl = document.getElementById('resultInfo');

function setProgress(done, total) {
    const pct = total ? Math.floor(done * 100 / total) : 0;
    bar.style.width = pct + '%';
    statusEl.textContent = `스캔 중… ${done} / ${total} (${pct}%)`;
}

function fmtNumber(n) {
    if (n === null || n === undefined || isNaN(n)) return '-';
    if (n >= 1_000_000_000) return (n / 1_000_000_000).toFixed(2) + 'B';
    if (n >= 1_000_000) return (n / 1_000_000).toFixed(2) + 'M';
    if (n >= 1_000) return (n / 1_000).toFixed(2) + 'K';
    return String(Math.round(n));
}

function renderRows(rows) {
    tbody.innerHTML = '';
    for (const r of rows) {
        const tr = document.createElement('tr');

        const tdSym = document.createElement('td');
        tdSym.className = 'symbol';
        tdSym.textContent = r.symbol;
        tr.appendChild(tdSym);

        const tdTime = document.createElement('td');
        tdTime.textContent = toKSTString(r.signalTime);
        tr.appendChild(tdTime);

        const tdBelow = document.createElement('td');
        tdBelow.className = 'right';
        tdBelow.textContent = r.belowLen;
        tr.appendChild(tdBelow);

        const tdChg = document.createElement('td');
        tdChg.className = 'right';
        const chg = r.priceChangePercent;
        tdChg.textContent = isNaN(chg) ? '-' : chg.toFixed(2) + '%';
        if (!isNaN(chg)) tdChg.classList.add(chg >= 0 ? 'green' : 'red');
        tr.appendChild(tdChg);

        const tdVol = document.createElement('td');
        tdVol.className = 'right';
        tdVol.textContent = fmtNumber(r.quoteVolume);
        tr.appendChild(tdVol);

        const tdLastV = document.createElement('td');
        tdLastV.className = 'right';
        tdLastV.textContent = fmtNumber(r.lastVol);
        tr.appendChild(tdLastV);

        tbody.appendChild(tr);
    }
    infoEl.textContent = `${rows.length} symbols`;
}

function getParamsFromUI() {
    const ltf = document.getElementById('ltf').value;
    const htf = document.getElementById('htf').value;
    const minBelow = Math.max(1, parseInt(document.getElementById('minBelow').value || '3', 10));
    const limit = Math.max(200, Math.min(1500, parseInt(document.getElementById('limit').value || '600', 10)));
    const maxSymbols = Math.max(10, Math.min(1500, parseInt(document.getElementById('maxSymbols').value || '300', 10)));
    const concurrency = Math.max(1, Math.min(20, parseInt(document.getElementById('concurrency').value || '6', 10)));
    const reqDelay = Math.max(0, Math.min(2000, parseInt(document.getElementById('reqDelay').value || '120', 10)));
    const maxRetries = Math.max(0, Math.min(8, parseInt(document.getElementById('maxRetries').value || '3', 10)));
    const proxyBase = (document.getElementById('proxyBase').value || '').trim();
    return { ltf, htf, minBelow, limit, maxSymbols, concurrency, reqDelay, maxRetries, proxyBase };
}

let lastResults = [];

document.getElementById('scanBtn').addEventListener('click', async () => {
    tbody.innerHTML = '';
    bar.style.width = '0%';
    statusEl.textContent = '심볼 목록 로딩 중…';

    const params = getParamsFromUI();
    try {
        const rows = await scanOnce(params, setProgress);
        lastResults = rows;
        renderRows(rows);
        statusEl.textContent = '완료';
    } catch (e) {
        console.error(e);
        statusEl.textContent = '오류가 발생했습니다. 콘솔을 확인하세요.';
    }
});

document.getElementById('csvBtn').addEventListener('click', () => {
    if (!lastResults.length) {
        alert('저장할 결과가 없습니다. 먼저 스캔을 실행하세요.');
        return;
    }
    const header = ['symbol', 'signalTime(KST)', 'belowLen', 'priceChangePercent', 'quoteVolume', 'lastVolume'];
    const lines = [header.join(',')];
    for (const r of lastResults) {
        lines.push([
            r.symbol,
            toKSTString(r.signalTime).replace(/,/g, ' '),
            r.belowLen,
            isNaN(r.priceChangePercent) ? '' : r.priceChangePercent.toFixed(2),
            r.quoteVolume,
            r.lastVol
        ].join(','));
    }
    const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `mtf_pullback_long_scan_${Date.now()}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
});
</script>
</body>
</html>
