<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KRW 상장 예측 스캐너</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #f4f4f4; }
        #scanBtn { padding: 10px 20px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>바이낸스 무기한 선물 KRW 상장 예측 스캐너</h1>
    <button id="scanBtn">스캔 시작</button>
    <table id="resultTable">
        <thead>
            <tr>
                <th>심볼</th>
                <th>24h 거래량 변화(%)</th>
                <th>미결제약정 변화(%)</th>
                <th>종합 점수</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        const exchangeInfoUrl = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const tickerUrl = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
        let perpetualSymbols = [];
        let baselineData = {};

        // 영구 계약(symbols) 로드 및 기준 데이터 설정
        async function loadBaseline() {
            try {
                // 1) 영구 계약 목록 가져오기
                const infoRes = await fetch(exchangeInfoUrl);
                const infoData = await infoRes.json();
                perpetualSymbols = infoData.symbols
                    .filter(s => s.contractType === 'PERPETUAL')
                    .map(s => s.symbol);

                // 2) 해당 심볼들의 24hr ticker 데이터 가져오기
                const tickerRes = await fetch(tickerUrl);
                const tickerData = await tickerRes.json();

                // 3) baseline 저장
                baselineData = {};
                tickerData.forEach(item => {
                    if (perpetualSymbols.includes(item.symbol)) {
                        baselineData[item.symbol] = {
                            volume: parseFloat(item.volume),
                            openInterest: parseFloat(item.openInterest)
                        };
                    }
                });
                console.log('Baseline loaded for', Object.keys(baselineData).length, 'symbols');
            } catch (err) {
                console.error('Baseline load error:', err);
            }
        }

        // 스캔 실행
        async function scan() {
            try {
                const res = await fetch(tickerUrl);
                const data = await res.json();
                const results = [];

                data.forEach(item => {
                    const symbol = item.symbol;
                    if (!baselineData[symbol]) return;

                    const curVolume = parseFloat(item.volume);
                    const curOI = parseFloat(item.openInterest);
                    const base = baselineData[symbol];

                    const volChange = ((curVolume - base.volume) / base.volume) * 100;
                    const oiChange = ((curOI - base.openInterest) / base.openInterest) * 100;
                    const score = volChange * 0.6 + oiChange * 0.4;

                    if (isFinite(score)) {
                        results.push({ symbol, volChange, oiChange, score });
                    }
                });

                results.sort((a, b) => b.score - a.score);
                displayResults(results.slice(0, 20));
                console.log('Scan completed', results.length, 'results');
            } catch (err) {
                console.error('Scan error:', err);
                alert('스캔 중 오류가 발생했습니다. 콘솔을 확인하세요.');
            }
        }

        // 결과 렌더
        function displayResults(list) {
            const tbody = document.querySelector('#resultTable tbody');
            tbody.innerHTML = '';
            list.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${item.symbol}</td>
                    <td>${item.volChange.toFixed(2)}</td>
                    <td>${item.oiChange.toFixed(2)}</td>
                    <td>${item.score.toFixed(2)}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        document.getElementById('scanBtn').addEventListener('click', async () => {
            document.getElementById('scanBtn').disabled = true;
            document.getElementById('scanBtn').innerText = '스캔 중...';
            await scan();
            // 스캔 후 기준 데이터도 업데이트
            await loadBaseline();
            document.getElementById('scanBtn').disabled = false;
            document.getElementById('scanBtn').innerText = '스캔 시작';
        });

        // 페이지 로드 시 초기 baseline 설정
        window.onload = loadBaseline;
    </script>
</body>
</html>