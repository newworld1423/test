<!doctype html>
<html lang="ko">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>USDT Perp — YTD 1H Funding Interval Scanner</title>
        <style>
            :root {
                --bg: #0b0f17;
                --panel: #121a28;
                --text: #e8eefc;
                --muted: #9db0d0;
                --line: rgba(255, 255, 255, 0.08);
                --good: rgba(76, 175, 80, 0.18);
                --bad: rgba(244, 67, 54, 0.18);
                --warn: rgba(255, 193, 7, 0.18);
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
                background: var(--bg);
                color: var(--text);
            }

            header {
                position: sticky;
                top: 0;
                z-index: 10;
                background: linear-gradient(180deg, rgba(11, 15, 23, 0.98), rgba(11, 15, 23, 0.86));
                border-bottom: 1px solid var(--line);
                padding: 14px 16px;
            }

            .row {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                align-items: center;
            }

            h1 {
                font-size: 16px;
                margin: 0 12px 0 0;
                letter-spacing: 0.2px;
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid var(--line);
                border-radius: 999px;
                color: var(--muted);
                font-size: 12px;
            }

            .controls {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-top: 10px;
            }

            .control {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: var(--panel);
                border: 1px solid var(--line);
                border-radius: 10px;
            }

            label {
                font-size: 12px;
                color: var(--muted);
                white-space: nowrap;
            }

            input[type="text"],
            input[type="number"],
            input[type="datetime-local"],
            select {
                background: rgba(255, 255, 255, 0.06);
                border: 1px solid var(--line);
                border-radius: 8px;
                color: var(--text);
                padding: 6px 8px;
                outline: none;
                font-size: 12px;
            }

            input[type="checkbox"] {
                transform: translateY(1px);
            }

            button {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid var(--line);
                color: var(--text);
                border-radius: 10px;
                padding: 8px 10px;
                font-size: 12px;
                cursor: pointer;
            }

            button:hover {
                background: rgba(255, 255, 255, 0.12);
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            main {
                padding: 14px 16px 40px;
            }

            #status {
                color: var(--muted);
                font-size: 12px;
                margin-bottom: 10px;
                line-height: 1.5;
                white-space: pre-line;
            }

            .table-wrap {
                background: var(--panel);
                border: 1px solid var(--line);
                border-radius: 14px;
                overflow: hidden;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 12px;
            }

            thead th {
                text-align: left;
                padding: 10px 10px;
                background: rgba(255, 255, 255, 0.04);
                border-bottom: 1px solid var(--line);
                color: var(--muted);
                position: sticky;
                top: 178px;
                z-index: 5;
            }

            tbody td {
                padding: 9px 10px;
                border-bottom: 1px solid var(--line);
                vertical-align: top;
            }

            tbody tr:hover {
                background: rgba(255, 255, 255, 0.04);
            }

            .mono {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            }

            .right {
                text-align: right;
            }

            .badge {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.05);
                color: var(--muted);
            }

            .pos {
                background: var(--bad);
                color: #ffd6d6;
                border-color: rgba(244, 67, 54, 0.35);
            }

            .neg {
                background: var(--good);
                color: #d6ffe0;
                border-color: rgba(76, 175, 80, 0.35);
            }

            .warn {
                background: var(--warn);
                border-color: rgba(255, 193, 7, 0.35);
                color: #fff3c4;
            }

            .small {
                font-size: 11px;
                color: var(--muted);
            }

            .nowrap {
                white-space: nowrap;
            }

            details {
                margin-top: 4px;
            }

            summary {
                cursor: pointer;
                color: var(--text);
            }

            .seg {
                margin: 6px 0 0;
                padding-left: 14px;
                color: var(--muted);
            }

            @media (max-width: 900px) {
                thead th {
                    top: 238px;
                }
            }
        </style>
    </head>
    <body>
        <header>
            <div class="row">
                <h1>USDT 무기한 — 올해(YTD) “1시간 정산” 발생 심볼 스캐너</h1>
                <div id="summary" class="pill">로딩 전</div>
            </div>

            <div class="controls">
                <div class="control">
                    <label for="startUtc">범위 시작(UTC)</label>
                    <input id="startUtc" type="datetime-local" />
                </div>

                <div class="control">
                    <label for="endUtc">범위 끝(UTC)</label>
                    <input id="endUtc" type="datetime-local" />
                </div>

                <div class="control">
                    <label for="concurrency">동시성</label>
                    <input id="concurrency" type="number" min="1" max="6" step="1" value="2" style="width: 70px;" />
                    <label for="delayMs">딜레이(ms)</label>
                    <input id="delayMs" type="number" min="0" max="2000" step="50" value="200" style="width: 90px;" />
                </div>

                <div class="control">
                    <label for="mode">스캔 모드</label>
                    <select id="mode">
                        <option value="full" selected>전체 구간 추출(정확, 느림)</option>
                        <option value="first">최초 1H 구간 발견 시 중지(빠름)</option>
                    </select>
                </div>

                <div class="control">
                    <label for="minVol">최소 24h 거래대금(USDT)</label>
                    <input id="minVol" type="number" min="0" step="1000000" value="0" style="width: 140px;" />
                    <label class="nowrap"><input id="with24h" type="checkbox" checked /> 24h필터 사용</label>
                </div>

                <div class="control">
                    <label for="q">검색</label>
                    <input id="q" type="text" placeholder="예: BTC, XAU…" />
                </div>

                <button id="btnStart" type="button">스캔 시작</button>
                <button id="btnStop" type="button" disabled>중단</button>
                <button id="btnReset" type="button">결과/진행 초기화</button>
                <button id="btnCopyCsv" type="button">표 CSV 복사</button>
            </div>
        </header>

        <main>
            <div id="status">준비됨</div>

            <div class="table-wrap">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 110px;">심볼</th>
                            <th style="width: 110px;">24h 거래대금</th>
                            <th style="width: 120px;">1H 구간 수</th>
                            <th style="width: 140px;">총 1H 시간(추정)</th>
                            <th style="width: 220px;">첫 1H(UTC)</th>
                            <th style="width: 220px;">마지막 1H(UTC)</th>
                            <th>1H 구간 상세(UTC/로컬)</th>
                        </tr>
                    </thead>
                    <tbody id="tbody">
                        <tr>
                            <td colspan="7" class="small">아직 결과가 없습니다. “스캔 시작”을 누르세요.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="small" style="margin-top: 10px;">
                * 판별 방식: fundingRate 히스토리의 연속 fundingTime 간격이 1시간인 구간을 “1H 정산 구간”으로 추정합니다.<br />
                * API 레이트리밋에 걸리면 동시성/딜레이를 낮춰주세요. (권장: 동시성 1~2, 딜레이 200~400ms)
            </div>
        </main>

        <script>
            (() => {
                "use strict";

                const API_BASE = "https://fapi.binance.com";
                const HOUR_MS = 60 * 60 * 1000;
                const LS_KEY = "ytd_1h_funding_scanner_v1";

                const els = {
                    summary: document.getElementById("summary"),
                    status: document.getElementById("status"),
                    tbody: document.getElementById("tbody"),

                    startUtc: document.getElementById("startUtc"),
                    endUtc: document.getElementById("endUtc"),

                    concurrency: document.getElementById("concurrency"),
                    delayMs: document.getElementById("delayMs"),
                    mode: document.getElementById("mode"),

                    minVol: document.getElementById("minVol"),
                    with24h: document.getElementById("with24h"),

                    q: document.getElementById("q"),

                    btnStart: document.getElementById("btnStart"),
                    btnStop: document.getElementById("btnStop"),
                    btnReset: document.getElementById("btnReset"),
                    btnCopyCsv: document.getElementById("btnCopyCsv"),
                };

                const state = {
                    running: false,
                    abort: null,

                    symbolsAll: [],
                    symbolsQueue: [],
                    symbolsDone: 0,
                    symbolsTotal: 0,

                    exchangeMap: new Map(),  // symbol -> { quoteAsset, contractType, status }
                    volMap: new Map(),       // symbol -> quoteVolume

                    results: new Map(),      // symbol -> result

                    lastError: "",
                    startedAt: 0,
                    finishedAt: 0,
                };

                function pad2(n) {
                    return String(n).padStart(2, "0");
                }

                function toDatetimeLocalUTC(ms) {
                    const d = new Date(ms);
                    const y = d.getUTCFullYear();
                    const mo = pad2(d.getUTCMonth() + 1);
                    const da = pad2(d.getUTCDate());
                    const hh = pad2(d.getUTCHours());
                    const mm = pad2(d.getUTCMinutes());
                    return `${y}-${mo}-${da}T${hh}:${mm}`;
                }

                function fmtUtc(ms) {
                    if (!Number.isFinite(ms)) return "-";
                    return new Date(ms).toISOString().replace("T", " ").replace(".000Z", "Z");
                }

                function fmtLocal(ms) {
                    if (!Number.isFinite(ms)) return "-";
                    const d = new Date(ms);
                    return new Intl.DateTimeFormat(undefined, {
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit",
                    }).format(d);
                }

                function fmtNumber(n, digits = 0) {
                    if (!Number.isFinite(n)) return "-";
                    return n.toLocaleString(undefined, { maximumFractionDigits: digits });
                }

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                async function fetchJson(path, { timeoutMs = 15000, signal = null } = {}) {
                    const url = `${API_BASE}${path}${path.includes("?") ? "&" : "?"}_=${Date.now()}`;
                    const ctrl = new AbortController();
                    const timer = setTimeout(() => ctrl.abort(), timeoutMs);

                    const combinedSignal = signal
                        ? anySignal([signal, ctrl.signal])
                        : ctrl.signal;

                    try {
                        const res = await fetch(url, { cache: "no-store", signal: combinedSignal });
                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            throw new Error(`HTTP ${res.status} ${res.statusText} :: ${text.slice(0, 200)}`);
                        }
                        return await res.json();
                    } finally {
                        clearTimeout(timer);
                    }
                }

                function anySignal(signals) {
                    const ctrl = new AbortController();
                    const onAbort = () => ctrl.abort();
                    for (const s of signals) {
                        if (!s) continue;
                        if (s.aborted) {
                            ctrl.abort();
                            break;
                        }
                        s.addEventListener("abort", onAbort, { once: true });
                    }
                    return ctrl.signal;
                }

                async function loadExchangeInfo(signal) {
                    const data = await fetchJson("/fapi/v1/exchangeInfo", { signal });
                    const arr = Array.isArray(data?.symbols) ? data.symbols : [];
                    const map = new Map();

                    for (const s of arr) {
                        const symbol = String(s?.symbol || "");
                        if (!symbol) continue;
                        map.set(symbol, {
                            quoteAsset: String(s?.quoteAsset || ""),
                            contractType: String(s?.contractType || ""),
                            status: String(s?.status || ""),
                        });
                    }

                    state.exchangeMap = map;

                    const symbols = [];
                    for (const [symbol, info] of map.entries()) {
                        if (info.quoteAsset !== "USDT") continue;
                        if (info.contractType !== "PERPETUAL") continue;
                        if (info.status !== "TRADING") continue;
                        symbols.push(symbol);
                    }

                    symbols.sort((a, b) => a.localeCompare(b));
                    state.symbolsAll = symbols;
                }

                async function load24hTickerIfNeeded(signal) {
                    if (!els.with24h.checked) {
                        state.volMap = new Map();
                        return;
                    }

                    const data = await fetchJson("/fapi/v1/ticker/24hr", { timeoutMs: 20000, signal });
                    const arr = Array.isArray(data) ? data : [];
                    const map = new Map();

                    for (const r of arr) {
                        const symbol = String(r?.symbol || "");
                        if (!symbol) continue;
                        const qv = Number(r?.quoteVolume);
                        if (Number.isFinite(qv)) map.set(symbol, qv);
                    }

                    state.volMap = map;
                }

                function getRangeMsFromInputs() {
                    const startVal = els.startUtc.value;
                    const endVal = els.endUtc.value;

                    const startMs = startVal ? Date.parse(startVal + "Z") : NaN;
                    const endMs = endVal ? Date.parse(endVal + "Z") : NaN;

                    if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) {
                        throw new Error("범위(UTC) 입력이 올바르지 않습니다. 시작 < 끝 이어야 합니다.");
                    }

                    return { startMs, endMs };
                }

                function filterSymbols(symbols) {
                    const q = String(els.q.value || "").trim().toUpperCase();
                    const useVol = Boolean(els.with24h.checked);
                    const minVol = Number(els.minVol.value || 0);

                    let out = symbols;

                    if (q) out = out.filter(s => s.includes(q));

                    if (useVol && Number.isFinite(minVol) && minVol > 0) {
                        out = out.filter(s => {
                            const v = state.volMap.get(s);
                            return Number.isFinite(v) && v >= minVol;
                        });
                    }

                    return out;
                }

                async function fetchFundingHistoryPaged(symbol, startMs, endMs, mode, signal) {
                    // 페이지네이션: endTime을 뒤로 당기면서 limit=1000씩 누적
                    const limit = 1000;
                    let cursorEnd = endMs;
                    const all = [];
                    let safety = 0;

                    while (true) {
                        safety += 1;
                        if (safety > 200) break; // 무한루프 방지

                        const path = `/fapi/v1/fundingRate?symbol=${encodeURIComponent(symbol)}&startTime=${startMs}&endTime=${cursorEnd}&limit=${limit}`;
                        const chunk = await fetchJson(path, { signal });

                        if (!Array.isArray(chunk) || chunk.length === 0) break;

                        all.push(...chunk);

                        const times = chunk
                            .map(x => Number(x?.fundingTime))
                            .filter(t => Number.isFinite(t));

                        if (times.length === 0) break;

                        const minT = Math.min(...times);

                        // mode=first: chunk 안에서라도 1H가 나오면 더 안 땡겨도 됨 (빠른 모드)
                        if (mode === "first") {
                            const seg = extract1hSegmentsFromFundingTimes(times);
                            if (seg.segments.length > 0) return { items: all, earlyStop: true };
                        }

                        if (chunk.length < limit) break;
                        if (minT <= startMs) break;

                        const nextEnd = minT - 1;
                        if (!Number.isFinite(nextEnd) || nextEnd <= startMs) break;

                        cursorEnd = nextEnd;

                        // 레이트리밋 완화
                        const delayMs = Math.max(0, Number(els.delayMs.value || 0));
                        if (delayMs > 0) await sleep(delayMs);
                    }

                    return { items: all, earlyStop: false };
                }

                function extract1hSegmentsFromFundingTimes(times) {
                    // times: 밀리초 배열 (정렬되지 않았을 수도)
                    const uniq = Array.from(new Set(times)).sort((a, b) => a - b);

                    const segments = [];
                    let inSeg = false;
                    let segStart = NaN;
                    let segEnd = NaN;

                    for (let i = 1; i < uniq.length; i += 1) {
                        const prev = uniq[i - 1];
                        const cur = uniq[i];
                        const diff = cur - prev;

                        if (diff === HOUR_MS) {
                            if (!inSeg) {
                                inSeg = true;
                                segStart = prev;
                                segEnd = cur;
                            } else {
                                segEnd = cur;
                            }
                        } else {
                            if (inSeg) {
                                segments.push({ start: segStart, end: segEnd });
                                inSeg = false;
                                segStart = NaN;
                                segEnd = NaN;
                            }
                        }
                    }

                    if (inSeg) segments.push({ start: segStart, end: segEnd });

                    // 총 시간(추정): 각 세그먼트의 (end-start)/1h
                    let totalHours = 0;
                    for (const s of segments) {
                        const h = (s.end - s.start) / HOUR_MS;
                        if (Number.isFinite(h) && h > 0) totalHours += h;
                    }

                    const first = segments.length ? segments[0].start : NaN;
                    const last = segments.length ? segments[segments.length - 1].end : NaN;

                    return { segments, totalHours, first, last, uniqCount: uniq.length };
                }

                function buildResult(symbol, segmentsInfo) {
                    const vol = state.volMap.get(symbol);
                    return {
                        symbol,
                        quoteVolume: Number.isFinite(vol) ? vol : NaN,
                        segments: segmentsInfo.segments,
                        segmentsCount: segmentsInfo.segments.length,
                        totalHours: segmentsInfo.totalHours,
                        firstUtc: segmentsInfo.first,
                        lastUtc: segmentsInfo.last,
                    };
                }

                function saveState() {
                    const payload = {
                        symbolsDone: state.symbolsDone,
                        symbolsTotal: state.symbolsTotal,
                        symbolsQueue: state.symbolsQueue,
                        results: Array.from(state.results.entries()),
                        startedAt: state.startedAt,
                        finishedAt: state.finishedAt,
                        inputs: {
                            startUtc: els.startUtc.value,
                            endUtc: els.endUtc.value,
                            concurrency: els.concurrency.value,
                            delayMs: els.delayMs.value,
                            mode: els.mode.value,
                            minVol: els.minVol.value,
                            with24h: els.with24h.checked,
                            q: els.q.value,
                        },
                    };
                    localStorage.setItem(LS_KEY, JSON.stringify(payload));
                }

                function loadState() {
                    const raw = localStorage.getItem(LS_KEY);
                    if (!raw) return false;

                    try {
                        const parsed = JSON.parse(raw);
                        if (!parsed || typeof parsed !== "object") return false;

                        if (parsed.inputs) {
                            if (typeof parsed.inputs.startUtc === "string") els.startUtc.value = parsed.inputs.startUtc;
                            if (typeof parsed.inputs.endUtc === "string") els.endUtc.value = parsed.inputs.endUtc;
                            if (parsed.inputs.concurrency != null) els.concurrency.value = String(parsed.inputs.concurrency);
                            if (parsed.inputs.delayMs != null) els.delayMs.value = String(parsed.inputs.delayMs);
                            if (typeof parsed.inputs.mode === "string") els.mode.value = parsed.inputs.mode;
                            if (parsed.inputs.minVol != null) els.minVol.value = String(parsed.inputs.minVol);
                            if (typeof parsed.inputs.with24h === "boolean") els.with24h.checked = parsed.inputs.with24h;
                            if (typeof parsed.inputs.q === "string") els.q.value = parsed.inputs.q;
                        }

                        state.symbolsDone = Number(parsed.symbolsDone || 0);
                        state.symbolsTotal = Number(parsed.symbolsTotal || 0);
                        state.symbolsQueue = Array.isArray(parsed.symbolsQueue) ? parsed.symbolsQueue : [];
                        state.results = new Map(Array.isArray(parsed.results) ? parsed.results : []);

                        state.startedAt = Number(parsed.startedAt || 0);
                        state.finishedAt = Number(parsed.finishedAt || 0);

                        return true;
                    } catch {
                        return false;
                    }
                }

                function resetState() {
                    state.running = false;
                    state.abort = null;
                    state.symbolsQueue = [];
                    state.symbolsDone = 0;
                    state.symbolsTotal = 0;
                    state.results = new Map();
                    state.startedAt = 0;
                    state.finishedAt = 0;
                    state.lastError = "";
                    localStorage.removeItem(LS_KEY);
                    render();
                }

                function render() {
                    const resultsArr = Array.from(state.results.values())
                        .sort((a, b) => {
                            // 총 1H 시간 내림차순 -> 세그먼트 수 내림차순 -> 거래대금 내림차순
                            const ah = Number(a.totalHours || 0);
                            const bh = Number(b.totalHours || 0);
                            if (bh !== ah) return bh - ah;

                            const as = Number(a.segmentsCount || 0);
                            const bs = Number(b.segmentsCount || 0);
                            if (bs !== as) return bs - as;

                            const av = Number(a.quoteVolume || 0);
                            const bv = Number(b.quoteVolume || 0);
                            return bv - av;
                        });

                    const totalSymbols = state.symbolsTotal || 0;
                    const done = state.symbolsDone || 0;
                    const found = resultsArr.length;

                    const started = state.startedAt ? fmtLocal(state.startedAt) : "-";
                    const finished = state.finishedAt ? fmtLocal(state.finishedAt) : "-";

                    els.summary.textContent = `진행 ${done}/${totalSymbols} · 발견 ${found}개`;

                    const lines = [];
                    lines.push(`상태: ${state.running ? "스캔 중" : "대기"}`);
                    lines.push(`시작: ${started} / 종료: ${finished}`);
                    lines.push(`큐 남음: ${state.symbolsQueue.length}개`);
                    if (state.lastError) lines.push(`최근 오류: ${state.lastError}`);
                    els.status.textContent = lines.join("\n");

                    if (resultsArr.length === 0) {
                        els.tbody.innerHTML = `
                            <tr>
                                <td colspan="7" class="small">
                                    ${state.running ? "스캔 중… (아직 1H 구간 발견 없음)" : "아직 결과가 없습니다."}
                                </td>
                            </tr>
                        `;
                        return;
                    }

                    const html = resultsArr
                        .map(r => {
                            const vol = Number.isFinite(r.quoteVolume) ? fmtNumber(r.quoteVolume, 0) : "-";
                            const segCount = r.segmentsCount;
                            const totalHours = fmtNumber(r.totalHours, 0);

                            const firstUtc = Number.isFinite(r.firstUtc) ? fmtUtc(r.firstUtc) : "-";
                            const lastUtc = Number.isFinite(r.lastUtc) ? fmtUtc(r.lastUtc) : "-";

                            const segList = (r.segments || [])
                                .map(s => {
                                    const hours = (s.end - s.start) / HOUR_MS;
                                    const htxt = Number.isFinite(hours) ? `${fmtNumber(hours, 0)}h` : "-";
                                    return `
                                        <li class="mono">
                                            UTC: ${fmtUtc(s.start)} ~ ${fmtUtc(s.end)} (${htxt})
                                            <div class="small">Local: ${fmtLocal(s.start)} ~ ${fmtLocal(s.end)}</div>
                                        </li>
                                    `;
                                })
                                .join("");

                            const summaryLine = `${segCount}구간 · ${totalHours}h`;

                            return `
                                <tr>
                                    <td class="mono nowrap">${r.symbol}</td>
                                    <td class="right mono">${vol}</td>
                                    <td class="mono">${segCount}</td>
                                    <td class="mono">${totalHours}</td>
                                    <td class="mono nowrap">${firstUtc}</td>
                                    <td class="mono nowrap">${lastUtc}</td>
                                    <td>
                                        <details>
                                            <summary class="mono">${summaryLine} (펼치기)</summary>
                                            <ol class="seg">${segList}</ol>
                                        </details>
                                    </td>
                                </tr>
                            `;
                        })
                        .join("");

                    els.tbody.innerHTML = html;
                }

                function resultsToCsv() {
                    const rows = Array.from(state.results.values())
                        .sort((a, b) => (b.totalHours || 0) - (a.totalHours || 0));

                    const header = [
                        "symbol",
                        "quoteVolume24h",
                        "segmentsCount",
                        "totalHoursEstimated",
                        "first1H_UTC",
                        "last1H_UTC",
                        "segments_UTC",
                    ];

                    const lines = [header.join(",")];

                    for (const r of rows) {
                        const segText = (r.segments || [])
                            .map(s => `${fmtUtc(s.start)}~${fmtUtc(s.end)}`)
                            .join(" | ");

                        const line = [
                            r.symbol,
                            Number.isFinite(r.quoteVolume) ? String(r.quoteVolume) : "",
                            String(r.segmentsCount || 0),
                            String(r.totalHours || 0),
                            Number.isFinite(r.firstUtc) ? fmtUtc(r.firstUtc) : "",
                            Number.isFinite(r.lastUtc) ? fmtUtc(r.lastUtc) : "",
                            segText,
                        ].map(v => `"${String(v).replaceAll('"', '""')}"`);

                        lines.push(line.join(","));
                    }

                    return lines.join("\n");
                }

                async function copyCsv() {
                    const csv = resultsToCsv();
                    try {
                        await navigator.clipboard.writeText(csv);
                        els.btnCopyCsv.textContent = "복사 완료!";
                        setTimeout(() => (els.btnCopyCsv.textContent = "표 CSV 복사"), 1000);
                    } catch {
                        alert("클립보드 복사가 차단되었습니다(HTTPS/권한).");
                    }
                }

                async function workerLoop(workerId, startMs, endMs, mode, signal) {
                    while (state.running && !signal.aborted) {
                        const symbol = state.symbolsQueue.shift();
                        if (!symbol) break;

                        try {
                            const delayMs = Math.max(0, Number(els.delayMs.value || 0));
                            if (delayMs > 0) await sleep(delayMs);

                            const { items } = await fetchFundingHistoryPaged(symbol, startMs, endMs, mode, signal);

                            const times = (Array.isArray(items) ? items : [])
                                .map(x => Number(x?.fundingTime))
                                .filter(t => Number.isFinite(t));

                            const segInfo = extract1hSegmentsFromFundingTimes(times);
                            if (segInfo.segments.length > 0) {
                                state.results.set(symbol, buildResult(symbol, segInfo));
                            }

                            state.symbolsDone += 1;

                            // 진행 저장 + 화면 갱신 (너무 잦은 저장 방지로 10개마다)
                            if (state.symbolsDone % 10 === 0) saveState();
                            render();
                        } catch (err) {
                            state.lastError = err?.message ? String(err.message) : String(err);

                            // 429/418 류면 조금 쉬어주기
                            const msg = String(state.lastError);
                            if (msg.includes("HTTP 429") || msg.includes("HTTP 418")) {
                                await sleep(1200);
                            } else {
                                await sleep(300);
                            }

                            // 실패해도 해당 심볼은 "처리됨"으로 간주하지 않고 뒤로 보내 재시도(최대 1회)
                            // 간단하게: 한 번만 재큐잉
                            const retryKey = `__retry__${symbol}`;
                            if (!state.results.has(retryKey)) {
                                state.results.set(retryKey, { symbol: retryKey, totalHours: 0 }); // 마커
                                state.symbolsQueue.push(symbol);
                            } else {
                                // 두 번째 실패면 포기하고 진행 카운트 증가
                                state.symbolsDone += 1;
                            }

                            render();
                        }
                    }
                }

                async function startScan() {
                    if (state.running) return;

                    state.lastError = "";
                    state.finishedAt = 0;

                    const { startMs, endMs } = getRangeMsFromInputs();
                    const mode = String(els.mode.value || "full");

                    const concurrency = Math.max(1, Math.min(6, Number(els.concurrency.value || 1)));

                    state.running = true;
                    state.startedAt = Date.now();
                    state.abort = new AbortController();

                    els.btnStart.disabled = true;
                    els.btnStop.disabled = false;

                    try {
                        // 심볼/거래대금 로딩
                        await loadExchangeInfo(state.abort.signal);
                        await load24hTickerIfNeeded(state.abort.signal);

                        // 필터 적용 + 큐 구성
                        const symbols = filterSymbols(state.symbolsAll);
                        state.symbolsQueue = symbols.slice();
                        state.symbolsTotal = symbols.length;
                        state.symbolsDone = 0;

                        // 결과는 유지하고 싶으면 reset 버튼을 안 누르면 됨
                        // 새 스캔 시작 시 결과를 비우고 싶다면 아래 주석 해제:
                        // state.results = new Map();

                        render();
                        saveState();

                        const workers = [];
                        for (let i = 0; i < concurrency; i += 1) {
                            workers.push(workerLoop(i + 1, startMs, endMs, mode, state.abort.signal));
                        }

                        await Promise.all(workers);
                    } catch (err) {
                        state.lastError = err?.message ? String(err.message) : String(err);
                    } finally {
                        state.running = false;
                        state.finishedAt = Date.now();
                        els.btnStart.disabled = false;
                        els.btnStop.disabled = true;
                        saveState();
                        render();
                    }
                }

                function stopScan() {
                    if (!state.running) return;
                    if (state.abort) state.abort.abort();
                    state.running = false;
                    els.btnStart.disabled = false;
                    els.btnStop.disabled = true;
                    saveState();
                    render();
                }

                function initDefaultRange() {
                    const now = new Date();
                    const year = now.getUTCFullYear();
                    const start = Date.UTC(year, 0, 1, 0, 0, 0);
                    const end = Date.now();

                    if (!els.startUtc.value) els.startUtc.value = toDatetimeLocalUTC(start);
                    if (!els.endUtc.value) els.endUtc.value = toDatetimeLocalUTC(end);
                }

                function bindEvents() {
                    els.btnStart.addEventListener("click", () => startScan().catch(() => {}));
                    els.btnStop.addEventListener("click", stopScan);
                    els.btnReset.addEventListener("click", resetState);
                    els.btnCopyCsv.addEventListener("click", () => copyCsv().catch(() => {}));

                    // 필터 입력 바뀌면 렌더만 갱신(큐는 스캔 시작 때 재구성)
                    els.q.addEventListener("input", render);
                    els.minVol.addEventListener("input", render);
                    els.with24h.addEventListener("change", render);
                }

                function boot() {
                    initDefaultRange();

                    const restored = loadState();
                    bindEvents();

                    if (restored) {
                        // 복원된 상태로 표시
                        render();
                    } else {
                        render();
                    }
                }

                boot();
            })();
        </script>
    </body>
</html>
