<!doctype html>
<html lang="ko-KR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Binance USDT Perp — Trend Breakout Scanner + YTD Backtest (Educational)</title>
        <style>
            :root {
                --bg: #0b0f19;
                --panel: #101826;
                --panel2: #0f1624;
                --text: #e7eefc;
                --muted: #9ab0d0;
                --line: rgba(255, 255, 255, 0.08);
                --good: #32d583;
                --bad: #f97066;
                --warn: #fdb022;
                --accent: #7c3aed;
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;
                background: radial-gradient(1200px 600px at 20% 0%, rgba(124, 58, 237, 0.22), transparent 55%),
                    radial-gradient(900px 500px at 85% 20%, rgba(50, 213, 131, 0.12), transparent 55%),
                    var(--bg);
                color: var(--text);
            }

            .wrap {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }

            h1 {
                margin: 0 0 10px 0;
                font-size: 20px;
                letter-spacing: -0.2px;
            }

            .sub {
                margin: 0 0 16px 0;
                color: var(--muted);
                line-height: 1.45;
                font-size: 13px;
            }

            .grid {
                display: grid;
                grid-template-columns: 1.2fr 1fr;
                gap: 14px;
                align-items: start;
            }

            @media (max-width: 980px) {
                .grid {
                    grid-template-columns: 1fr;
                }
            }

            .card {
                background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
                border: 1px solid var(--line);
                border-radius: 14px;
                padding: 14px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            }

            .card h2 {
                margin: 0 0 10px 0;
                font-size: 14px;
                color: #f2f6ff;
            }

            .row {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-bottom: 10px;
            }

            .row3 {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 10px;
                margin-bottom: 10px;
            }

            @media (max-width: 700px) {
                .row,
                .row3 {
                    grid-template-columns: 1fr;
                }
            }

            label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin-bottom: 6px;
            }

            input,
            select,
            textarea {
                width: 100%;
                background: var(--panel2);
                border: 1px solid var(--line);
                color: var(--text);
                border-radius: 10px;
                padding: 10px 10px;
                font-size: 13px;
                outline: none;
            }

            input:focus,
            select:focus,
            textarea:focus {
                border-color: rgba(124, 58, 237, 0.7);
                box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.18);
            }

            .btns {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-top: 10px;
            }

            button {
                border: 1px solid var(--line);
                background: rgba(124, 58, 237, 0.2);
                color: var(--text);
                padding: 10px 12px;
                border-radius: 12px;
                font-size: 13px;
                cursor: pointer;
            }

            button:hover {
                background: rgba(124, 58, 237, 0.28);
            }

            button.secondary {
                background: rgba(255, 255, 255, 0.06);
            }

            button.secondary:hover {
                background: rgba(255, 255, 255, 0.08);
            }

            button.danger {
                background: rgba(249, 112, 102, 0.18);
            }

            button.danger:hover {
                background: rgba(249, 112, 102, 0.24);
            }

            button:disabled {
                opacity: 0.55;
                cursor: not-allowed;
            }

            .note {
                font-size: 12px;
                color: var(--muted);
                line-height: 1.5;
                margin-top: 10px;
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 6px 10px;
                border-radius: 999px;
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.04);
                font-size: 12px;
                color: var(--muted);
            }

            .pill b {
                color: var(--text);
                font-weight: 600;
            }

            .status {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-top: 10px;
            }

            .log {
                margin-top: 12px;
                max-height: 220px;
                overflow: auto;
                padding: 10px;
                border-radius: 12px;
                border: 1px solid var(--line);
                background: rgba(0, 0, 0, 0.22);
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
                font-size: 12px;
                line-height: 1.45;
                white-space: pre-wrap;
            }

            .toolbar {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                align-items: center;
                justify-content: space-between;
                margin: 12px 0 10px 0;
            }

            .toolbar .left,
            .toolbar .right {
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
            }

            .table {
                width: 100%;
                border-collapse: collapse;
                border: 1px solid var(--line);
                border-radius: 14px;
                overflow: hidden;
            }

            .table th,
            .table td {
                padding: 10px 10px;
                border-bottom: 1px solid var(--line);
                font-size: 13px;
                text-align: right;
                white-space: nowrap;
            }

            .table th {
                position: sticky;
                top: 0;
                z-index: 1;
                background: rgba(16, 24, 38, 0.96);
                color: #f2f6ff;
                font-weight: 600;
                cursor: pointer;
                user-select: none;
            }

            .table th:first-child,
            .table td:first-child {
                text-align: left;
            }

            .table tr:hover td {
                background: rgba(255, 255, 255, 0.03);
            }

            .good {
                color: var(--good);
                font-weight: 700;
            }

            .bad {
                color: var(--bad);
                font-weight: 700;
            }

            .warn {
                color: var(--warn);
                font-weight: 700;
            }

            details {
                border: 1px solid var(--line);
                border-radius: 14px;
                padding: 10px 12px;
                background: rgba(255, 255, 255, 0.03);
            }

            summary {
                cursor: pointer;
                color: #f2f6ff;
                font-weight: 600;
                font-size: 13px;
            }

            .small {
                font-size: 12px;
                color: var(--muted);
                line-height: 1.55;
                margin-top: 8px;
            }

            .mono {
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            }

            .kpi {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
                margin-top: 10px;
            }

            @media (max-width: 980px) {
                .kpi {
                    grid-template-columns: repeat(2, 1fr);
                }
            }

            .k {
                border: 1px solid var(--line);
                background: rgba(255, 255, 255, 0.03);
                border-radius: 14px;
                padding: 10px;
            }

            .k .t {
                font-size: 12px;
                color: var(--muted);
                margin-bottom: 4px;
            }

            .k .v {
                font-size: 16px;
                font-weight: 800;
                letter-spacing: -0.2px;
            }

            .muted {
                color: var(--muted);
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <h1>Binance USDT Perp — 현재 스캔 + 올해(YTD) 백테스트 스캐너 (교육용 예시)</h1>
            <p class="sub">
                “결과 0개”를 막기 위해 <b>필터(생존) + 랭킹(Top-N)</b> 구조로 설계했습니다.
                백테스트는 <b>2026-01-01 ~ 현재</b> 구간을 기본으로 하며, 진입/손절/익절 규칙을 코드로 고정해
                최종 수익률을 계산합니다.
            </p>

            <div class="grid">
                <div class="card">
                    <h2>설정</h2>

                    <div class="row">
                        <div>
                            <label>모드</label>
                            <select id="mode">
                                <option value="scan">현재 스캔 (상위 후보 출력)</option>
                                <option value="backtest">히스토리 모드 (YTD 백테스트)</option>
                            </select>
                        </div>
                        <div>
                            <label>타임프레임</label>
                            <select id="interval">
                                <option value="1h" selected>1h (권장, 호출 적음)</option>
                                <option value="15m">15m (호출 많아질 수 있음)</option>
                                <option value="4h">4h</option>
                                <option value="1d">1d</option>
                            </select>
                        </div>
                    </div>

                    <div class="row3">
                        <div>
                            <label>Top-N 출력 (현재 스캔)</label>
                            <input id="topN" type="number" min="1" step="1" value="20" />
                        </div>
                        <div>
                            <label>최소 24h 거래대금 (USDT)</label>
                            <input id="minQuoteVol" type="number" min="0" step="1000000" value="30000000" />
                        </div>
                        <div>
                            <label>동시 요청(Concurrency)</label>
                            <input id="concurrency" type="number" min="1" max="6" step="1" value="3" />
                        </div>
                    </div>

                    <div class="row3">
                        <div>
                            <label>EMA50</label>
                            <input id="emaFast" type="number" min="1" step="1" value="50" />
                        </div>
                        <div>
                            <label>EMA200</label>
                            <input id="emaSlow" type="number" min="1" step="1" value="200" />
                        </div>
                        <div>
                            <label>돌파 lookback</label>
                            <input id="breakoutLookback" type="number" min="5" step="1" value="20" />
                        </div>
                    </div>

                    <div class="row3">
                        <div>
                            <label>볼륨 SMA 길이</label>
                            <input id="volLen" type="number" min="5" step="1" value="20" />
                        </div>
                        <div>
                            <label>볼륨 배수(volMult)</label>
                            <input id="volMult" type="number" min="1" step="0.1" value="1.3" />
                        </div>
                        <div>
                            <label>최소 ATR% (너무 죽은 장 제외)</label>
                            <input id="minAtrPct" type="number" min="0" step="0.1" value="0.4" />
                        </div>
                    </div>

                    <div class="row3">
                        <div>
                            <label>ATR 길이</label>
                            <input id="atrLen" type="number" min="5" step="1" value="14" />
                        </div>
                        <div>
                            <label>손절 ATR 배수</label>
                            <input id="stopAtrMult" type="number" min="0.5" step="0.1" value="1.8" />
                        </div>
                        <div>
                            <label>익절 R 배수 (TP = R * 리스크)</label>
                            <input id="tpR" type="number" min="0.5" step="0.1" value="1.5" />
                        </div>
                    </div>

                    <div class="row3">
                        <div>
                            <label>스윙 lookback (보수 손절용)</label>
                            <input id="swingLookback" type="number" min="3" step="1" value="10" />
                        </div>
                        <div>
                            <label>최대 보유 캔들 수(시간청산)</label>
                            <input id="maxHoldBars" type="number" min="1" step="1" value="48" />
                        </div>
                        <div>
                            <label>최소 트레이드 수 (백테스트)</label>
                            <input id="minTrades" type="number" min="0" step="1" value="30" />
                        </div>
                    </div>

                    <div class="row">
                        <div>
                            <label>수수료(왕복, 비율) — 기본 0.08% = 0.0008</label>
                            <input id="feeRoundTrip" type="number" min="0" step="0.0001" value="0.0008" />
                        </div>
                        <div>
                            <label>백테스트 포트폴리오: 최대 노출(배) (예: 2 = 자본의 2배 notional)</label>
                            <input id="maxNotionalMult" type="number" min="0.5" step="0.1" value="2.0" />
                        </div>
                    </div>

                    <div class="row">
                        <div>
                            <label>백테스트 리스크(1회 손절 시 자본 대비) (예: 0.005 = 0.5%)</label>
                            <input id="riskPct" type="number" min="0.0005" step="0.0005" value="0.005" />
                        </div>
                        <div>
                            <label>백테스트 시작일 (YYYY-MM-DD)</label>
                            <input id="startDate" type="text" value="2026-01-01" class="mono" />
                        </div>
                    </div>

                    <div class="btns">
                        <button id="runBtn">실행</button>
                        <button id="stopBtn" class="danger" disabled>중지</button>
                        <button id="exportBtn" class="secondary" disabled>트레이드 CSV 내보내기</button>
                        <button id="clearBtn" class="secondary">로그/결과 지우기</button>
                    </div>

                    <div class="status">
                        <span class="pill">상태: <b id="stateText">대기</b></span>
                        <span class="pill">심볼: <b id="symText">-</b></span>
                        <span class="pill">진행: <b id="progText">0 / 0</b></span>
                    </div>

                    <details style="margin-top: 12px;">
                        <summary>중요: 이 스캐너/백테스트의 한계(꼭 읽기)</summary>
                        <div class="small">
                            <ul>
                                <li>백테스트는 캔들 OHLC만 사용합니다. 같은 캔들에서 TP/SL 동시 터치 시 <b>보수적으로 손절 우선</b> 처리합니다.</li>
                                <li>펀딩비, 슬리피지, 유동성 부족, 급격한 갭, 체결 방식(메이커/테이커) 등은 단순화되어 있습니다.</li>
                                <li>전략은 “정답”이 아니라 <b>예시 템플릿</b>이며, 시장 국면(추세/횡보)에 따라 성과가 크게 달라질 수 있습니다.</li>
                                <li>실전 투입 전엔 반드시 <b>소액/모의</b>로 충분히 검증하세요.</li>
                            </ul>
                        </div>
                    </details>

                    <div class="log" id="log"></div>
                </div>

                <div class="card">
                    <h2>백테스트 요약 / 결과</h2>

                    <div class="kpi">
                        <div class="k">
                            <div class="t">포트폴리오 최종 수익률</div>
                            <div class="v" id="kpiPortRet">-</div>
                        </div>
                        <div class="k">
                            <div class="t">트레이드 수</div>
                            <div class="v" id="kpiTrades">-</div>
                        </div>
                        <div class="k">
                            <div class="t">승률</div>
                            <div class="v" id="kpiWin">-</div>
                        </div>
                        <div class="k">
                            <div class="t">최대 낙폭(MDD)</div>
                            <div class="v" id="kpiMdd">-</div>
                        </div>
                    </div>

                    <div class="toolbar">
                        <div class="left">
                            <span class="pill">정렬: <b id="sortLabel">score ↓</b></span>
                            <span class="pill">검색</span>
                            <input id="search" type="text" placeholder="예: BTC, ETH, SOL..." style="width: 220px;" />
                        </div>
                        <div class="right">
                            <span class="pill">표시: <b id="rowCount">0</b></span>
                        </div>
                    </div>

                    <table class="table" id="table">
                        <thead>
                            <tr>
                                <th data-key="symbol">심볼</th>
                                <th data-key="side">방향</th>
                                <th data-key="score">score</th>
                                <th data-key="price">가격(기준)</th>
                                <th data-key="stop">손절</th>
                                <th data-key="tp">익절</th>
                                <th data-key="riskPct">리스크%</th>
                                <th data-key="atrPct">ATR%</th>
                                <th data-key="quoteVol">24h 거래대금</th>
                                <th data-key="note">비고</th>
                            </tr>
                        </thead>
                        <tbody id="tbody"></tbody>
                    </table>

                    <div class="note">
                        <b>현재 스캔</b>은 “조건 만족 + 상위 score” 후보를 보여줍니다.  
                        <b>히스토리 모드</b>는 같은 규칙으로 트레이드를 만들고, 수수료(왕복)를 적용해 최종 수익률을 계산합니다.
                    </div>
                </div>
            </div>
        </div>

        <script>
            "use strict";

            // =========================
            // Binance Futures REST (USDT-M)
            // =========================
            const BASE = "https://fapi.binance.com";
            const ENDPOINTS = {
                exchangeInfo: BASE + "/fapi/v1/exchangeInfo",
                klines: BASE + "/fapi/v1/klines",
                ticker24h: BASE + "/fapi/v1/ticker/24hr",
            };

            // =========================
            // UI
            // =========================
            const el = (id) => document.getElementById(id);

            const modeEl = el("mode");
            const intervalEl = el("interval");
            const topNEl = el("topN");
            const minQuoteVolEl = el("minQuoteVol");
            const concurrencyEl = el("concurrency");

            const emaFastEl = el("emaFast");
            const emaSlowEl = el("emaSlow");
            const breakoutLookbackEl = el("breakoutLookback");
            const volLenEl = el("volLen");
            const volMultEl = el("volMult");
            const minAtrPctEl = el("minAtrPct");
            const atrLenEl = el("atrLen");
            const stopAtrMultEl = el("stopAtrMult");
            const tpREl = el("tpR");
            const swingLookbackEl = el("swingLookback");
            const maxHoldBarsEl = el("maxHoldBars");
            const minTradesEl = el("minTrades");

            const feeRoundTripEl = el("feeRoundTrip");
            const maxNotionalMultEl = el("maxNotionalMult");
            const riskPctEl = el("riskPct");
            const startDateEl = el("startDate");

            const runBtn = el("runBtn");
            const stopBtn = el("stopBtn");
            const exportBtn = el("exportBtn");
            const clearBtn = el("clearBtn");

            const stateText = el("stateText");
            const symText = el("symText");
            const progText = el("progText");
            const logEl = el("log");

            const tbody = el("tbody");
            const searchEl = el("search");
            const rowCountEl = el("rowCount");

            const kpiPortRet = el("kpiPortRet");
            const kpiTrades = el("kpiTrades");
            const kpiWin = el("kpiWin");
            const kpiMdd = el("kpiMdd");

            const sortLabel = el("sortLabel");
            const table = el("table");

            // =========================
            // State
            // =========================
            let abortFlag = false;
            let latestRows = [];
            let latestTrades = [];
            let sortKey = "score";
            let sortDir = "desc"; // asc | desc

            // =========================
            // Utils
            // =========================
            function log(msg) {
                const ts = new Date().toLocaleTimeString("ko-KR", { hour12: false });
                logEl.textContent += `[${ts}] ${msg}\n`;
                logEl.scrollTop = logEl.scrollHeight;
            }

            function setState(s) {
                stateText.textContent = s;
            }

            function setSymbol(s) {
                symText.textContent = s || "-";
            }

            function setProgress(done, total) {
                progText.textContent = `${done} / ${total}`;
            }

            function clamp(x, lo, hi) {
                return Math.min(hi, Math.max(lo, x));
            }

            function fmt(n, digits = 4) {
                if (!Number.isFinite(n)) return "-";
                return n.toLocaleString("en-US", { maximumFractionDigits: digits });
            }

            function fmtPct(x, digits = 2) {
                if (!Number.isFinite(x)) return "-";
                return (x * 100).toFixed(digits) + "%";
            }

            function parseNum(v, fallback) {
                const x = Number(v);
                return Number.isFinite(x) ? x : fallback;
            }

            function toMs(dateStr) {
                // dateStr: YYYY-MM-DD (interpreted as UTC 00:00)
                const [y, m, d] = dateStr.split("-").map((x) => parseInt(x, 10));
                if (!y || !m || !d) return NaN;
                return Date.UTC(y, m - 1, d, 0, 0, 0, 0);
            }

            function intervalToMs(interval) {
                const map = {
                    "15m": 15 * 60 * 1000,
                    "1h": 60 * 60 * 1000,
                    "4h": 4 * 60 * 60 * 1000,
                    "1d": 24 * 60 * 60 * 1000,
                };
                return map[interval] || 60 * 60 * 1000;
            }

            function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function createLimiter(concurrency, minDelayMs) {
                let active = 0;
                let last = 0;
                const queue = [];

                const runNext = () => {
                    if (active >= concurrency) return;
                    if (queue.length === 0) return;

                    const now = Date.now();
                    const wait = Math.max(0, last + minDelayMs - now);

                    active += 1;
                    const item = queue.shift();

                    setTimeout(async () => {
                        last = Date.now();
                        try {
                            const res = await item.fn();
                            item.resolve(res);
                        } catch (err) {
                            item.reject(err);
                        } finally {
                            active -= 1;
                            runNext();
                        }
                    }, wait);
                };

                return (fn) =>
                    new Promise((resolve, reject) => {
                        queue.push({ fn, resolve, reject });
                        runNext();
                    });
            }

            async function fetchJSON(url, tries = 3) {
                let lastErr = null;
                for (let i = 0; i < tries; i += 1) {
                    if (abortFlag) throw new Error("ABORTED");
                    try {
                        const res = await fetch(url, { cache: "no-store" });
                        if (!res.ok) {
                            const text = await res.text().catch(() => "");
                            // 간단 리트라이(429/418 등)
                            if ((res.status === 429 || res.status === 418) && i < tries - 1) {
                                await sleep(300 * (i + 1));
                                continue;
                            }
                            throw new Error(`HTTP ${res.status} ${text}`);
                        }
                        return res.json();
                    } catch (err) {
                        lastErr = err;
                        if (i < tries - 1) {
                            await sleep(250 * (i + 1));
                            continue;
                        }
                    }
                }
                throw lastErr || new Error("fetchJSON failed");
            }

            // =========================
            // Indicators
            // =========================
            function ema(values, length) {
                const n = values.length;
                const out = new Array(n).fill(NaN);
                if (length <= 1 || n === 0) return out;

                const alpha = 2 / (length + 1);

                // seed with SMA
                let sum = 0;
                for (let i = 0; i < n; i += 1) {
                    const v = values[i];
                    sum += v;
                    if (i === length - 1) {
                        out[i] = sum / length;
                        break;
                    }
                }

                for (let i = length; i < n; i += 1) {
                    out[i] = alpha * values[i] + (1 - alpha) * out[i - 1];
                }

                return out;
            }

            function atr(bars, length) {
                // Wilder's ATR
                const n = bars.length;
                const out = new Array(n).fill(NaN);
                if (length <= 1 || n === 0) return out;

                const tr = new Array(n).fill(NaN);
                for (let i = 0; i < n; i += 1) {
                    const h = bars[i].h;
                    const l = bars[i].l;
                    const prevC = i > 0 ? bars[i - 1].c : bars[i].c;
                    const a = h - l;
                    const b = Math.abs(h - prevC);
                    const c = Math.abs(l - prevC);
                    tr[i] = Math.max(a, b, c);
                }

                // seed with SMA of TR
                let sum = 0;
                for (let i = 0; i < n; i += 1) {
                    sum += tr[i];
                    if (i === length - 1) {
                        out[i] = sum / length;
                        break;
                    }
                }

                for (let i = length; i < n; i += 1) {
                    out[i] = (out[i - 1] * (length - 1) + tr[i]) / length;
                }

                return out;
            }

            function sma(values, length) {
                const n = values.length;
                const out = new Array(n).fill(NaN);
                if (length <= 0) return out;

                let sum = 0;
                for (let i = 0; i < n; i += 1) {
                    sum += values[i];
                    if (i >= length) sum -= values[i - length];
                    if (i >= length - 1) out[i] = sum / length;
                }
                return out;
            }

            function rollingMax(values, lookback, endIndexExclusive) {
                // max of values[endIndexExclusive-lookback ... endIndexExclusive-1]
                let m = -Infinity;
                const start = Math.max(0, endIndexExclusive - lookback);
                for (let i = start; i < endIndexExclusive; i += 1) {
                    const v = values[i];
                    if (v > m) m = v;
                }
                return m;
            }

            function rollingMin(values, lookback, endIndexExclusive) {
                let m = Infinity;
                const start = Math.max(0, endIndexExclusive - lookback);
                for (let i = start; i < endIndexExclusive; i += 1) {
                    const v = values[i];
                    if (v < m) m = v;
                }
                return m;
            }

            // =========================
            // Strategy
            // =========================
            function calcScore(ctx) {
                // score는 "정렬/우선순위"용. 수익 보장 의미 없음.
                // 구성(가벼움):
                // - 돌파 강도 (돌파폭/ATR)
                // - 볼륨 스파이크 정도
                // - 추세 기울기(emaFast - emaSlow)/price
                const {
                    side,
                    close,
                    prevLevel,
                    atrValue,
                    volume,
                    volSma,
                    emaFast,
                    emaSlow,
                } = ctx;

                const breakoutStrength = atrValue > 0 ? Math.abs(close - prevLevel) / atrValue : 0;
                const volStrength = volSma > 0 ? volume / volSma : 0;
                const trendStrength = close > 0 ? Math.abs(emaFast - emaSlow) / close : 0;

                let s = 0;
                s += 0.55 * breakoutStrength;
                s += 0.30 * clamp(volStrength, 0, 5);
                s += 0.15 * clamp(trendStrength * 50, 0, 5);

                // 약간의 방향 보정(동일)
                if (side === "LONG") s += 0.02;
                if (side === "SHORT") s += 0.01;

                return s;
            }

            function buildSignalForIndex(bars, i, config) {
                // i: signal candle index (closed)
                // entry: next candle open -> i+1 exists
                if (i < 1 || i + 1 >= bars.length) return null;

                const closes = config._closes;
                const highs = config._highs;
                const lows = config._lows;
                const vols = config._vols;

                const emaFastArr = config._emaFast;
                const emaSlowArr = config._emaSlow;
                const atrArr = config._atr;
                const volSmaArr = config._volSma;

                const close = closes[i];
                const eFast = emaFastArr[i];
                const eSlow = emaSlowArr[i];
                const atrValue = atrArr[i];
                const vol = vols[i];
                const volSma = volSmaArr[i];

                if (!Number.isFinite(eFast) || !Number.isFinite(eSlow) || !Number.isFinite(atrValue) || !Number.isFinite(volSma)) {
                    return null;
                }

                const atrPct = close > 0 ? (atrValue / close) * 100 : 0;
                if (atrPct < config.minAtrPct) return null;

                const prevHigh = rollingMax(highs, config.breakoutLookback, i);
                const prevLow = rollingMin(lows, config.breakoutLookback, i);

                const volOk = vol > volSma * config.volMult;

                const longTrendOk = close > eSlow && eFast > eSlow;
                const shortTrendOk = close < eSlow && eFast < eSlow;

                const longBreakoutOk = close > prevHigh;
                const shortBreakoutOk = close < prevLow;

                let side = null;
                let prevLevel = NaN;

                if (volOk && longTrendOk && longBreakoutOk) {
                    side = "LONG";
                    prevLevel = prevHigh;
                } else if (volOk && shortTrendOk && shortBreakoutOk) {
                    side = "SHORT";
                    prevLevel = prevLow;
                } else {
                    return null;
                }

                const entry = bars[i + 1].o;

                // 스윙 기반(보수)
                const swingStart = Math.max(0, i - config.swingLookback + 1);
                let swingLow = Infinity;
                let swingHigh = -Infinity;
                for (let k = swingStart; k <= i; k += 1) {
                    if (lows[k] < swingLow) swingLow = lows[k];
                    if (highs[k] > swingHigh) swingHigh = highs[k];
                }

                let stop = NaN;
                let tp = NaN;

                if (side === "LONG") {
                    const atrStop = entry - atrValue * config.stopAtrMult;
                    stop = Math.min(atrStop, swingLow);
                    const risk = entry - stop;
                    if (risk <= 0) return null;
                    tp = entry + risk * config.tpR;
                } else {
                    const atrStop = entry + atrValue * config.stopAtrMult;
                    stop = Math.max(atrStop, swingHigh);
                    const risk = stop - entry;
                    if (risk <= 0) return null;
                    tp = entry - risk * config.tpR;
                }

                const riskPct = entry > 0 ? Math.abs(entry - stop) / entry : NaN;

                const score = calcScore({
                    side,
                    close,
                    prevLevel,
                    atrValue,
                    volume: vol,
                    volSma,
                    emaFast: eFast,
                    emaSlow: eSlow,
                });

                return {
                    side,
                    entryTime: bars[i + 1].t,
                    signalTime: bars[i].t,
                    entry,
                    stop,
                    tp,
                    riskPct,
                    atrPct: atrValue / close,
                    score,
                    note: "",
                };
            }

            function simulateTradeExit(bars, entryIndex, trade, config) {
                // entryIndex: index of entry candle (i+1)
                const side = trade.side;
                const entry = trade.entry;
                const stop = trade.stop;
                const tp = trade.tp;

                const last = Math.min(bars.length - 1, entryIndex + config.maxHoldBars - 1);

                let exitPrice = NaN;
                let exitTime = NaN;
                let exitReason = "TIME";

                for (let j = entryIndex; j <= last; j += 1) {
                    const h = bars[j].h;
                    const l = bars[j].l;

                    if (side === "LONG") {
                        const hitStop = l <= stop;
                        const hitTp = h >= tp;

                        if (hitStop || hitTp) {
                            // 같은 캔들 동시 터치: 보수적으로 손절 우선
                            if (hitStop && hitTp) {
                                exitPrice = stop;
                                exitReason = "SL";
                            } else if (hitStop) {
                                exitPrice = stop;
                                exitReason = "SL";
                            } else {
                                exitPrice = tp;
                                exitReason = "TP";
                            }
                            exitTime = bars[j].t;
                            break;
                        }
                    } else {
                        const hitStop = h >= stop;
                        const hitTp = l <= tp;

                        if (hitStop || hitTp) {
                            if (hitStop && hitTp) {
                                exitPrice = stop;
                                exitReason = "SL";
                            } else if (hitStop) {
                                exitPrice = stop;
                                exitReason = "SL";
                            } else {
                                exitPrice = tp;
                                exitReason = "TP";
                            }
                            exitTime = bars[j].t;
                            break;
                        }
                    }
                }

                if (!Number.isFinite(exitPrice)) {
                    exitPrice = bars[last].c;
                    exitTime = bars[last].t;
                }

                const rawMove = side === "LONG" ? (exitPrice - entry) / entry : (entry - exitPrice) / entry;

                return {
                    exitPrice,
                    exitTime,
                    exitReason,
                    rawMove,
                };
            }

            // =========================
            // Data Fetch
            // =========================
            async function getExchangeSymbols(limiter) {
                const cacheKey = "binance_fapi_exchangeInfo_v1";
                const cached = tryLoadCache(cacheKey, 12 * 60 * 60 * 1000);
                if (cached) return cached;

                const info = await limiter(() => fetchJSON(ENDPOINTS.exchangeInfo));
                const symbols = (info.symbols || [])
                    .filter((s) => s.contractType === "PERPETUAL")
                    .filter((s) => s.quoteAsset === "USDT")
                    .filter((s) => s.status === "TRADING")
                    .map((s) => s.symbol);

                saveCache(cacheKey, symbols);
                return symbols;
            }

            async function getTicker24hMap(limiter) {
                const cacheKey = "binance_fapi_ticker24h_v1";
                const cached = tryLoadCache(cacheKey, 2 * 60 * 1000);
                if (cached) return cached;

                const data = await limiter(() => fetchJSON(ENDPOINTS.ticker24h));
                const map = {};
                for (const row of data) {
                    map[row.symbol] = {
                        quoteVolume: parseFloat(row.quoteVolume),
                        lastPrice: parseFloat(row.lastPrice),
                    };
                }

                saveCache(cacheKey, map);
                return map;
            }

            async function fetchKlinesPaged(limiter, symbol, interval, startTime, endTime) {
                const all = [];
                let cursor = startTime;

                while (cursor < endTime) {
                    if (abortFlag) throw new Error("ABORTED");

                    const url =
                        ENDPOINTS.klines +
                        `?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&startTime=${cursor}&endTime=${endTime}&limit=1500`;

                    const data = await limiter(() => fetchJSON(url));

                    if (!Array.isArray(data) || data.length === 0) break;

                    for (const k of data) {
                        all.push({
                            t: Number(k[0]),
                            o: parseFloat(k[1]),
                            h: parseFloat(k[2]),
                            l: parseFloat(k[3]),
                            c: parseFloat(k[4]),
                            v: parseFloat(k[5]),
                        });
                    }

                    const lastT = Number(data[data.length - 1][0]);
                    const nextCursor = lastT + 1;

                    if (nextCursor <= cursor) break;
                    cursor = nextCursor;

                    if (data.length < 1500) break;
                }

                // 정렬/중복 제거(안전)
                all.sort((a, b) => a.t - b.t);
                const dedup = [];
                let prev = -1;
                for (const b of all) {
                    if (b.t !== prev) {
                        dedup.push(b);
                        prev = b.t;
                    }
                }
                return dedup;
            }

            function tryLoadCache(key, ttlMs) {
                try {
                    const raw = localStorage.getItem(key);
                    if (!raw) return null;
                    const obj = JSON.parse(raw);
                    if (!obj || typeof obj !== "object") return null;
                    if (!Number.isFinite(obj.ts)) return null;
                    if (Date.now() - obj.ts > ttlMs) return null;
                    return obj.data;
                } catch {
                    return null;
                }
            }

            function saveCache(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify({ ts: Date.now(), data }));
                } catch {
                    // ignore
                }
            }

            // =========================
            // Rendering
            // =========================
            function clearResults() {
                latestRows = [];
                latestTrades = [];
                tbody.innerHTML = "";
                rowCountEl.textContent = "0";
                exportBtn.disabled = true;

                kpiPortRet.textContent = "-";
                kpiTrades.textContent = "-";
                kpiWin.textContent = "-";
                kpiMdd.textContent = "-";
            }

            function renderTable() {
                const q = (searchEl.value || "").trim().toUpperCase();

                let rows = latestRows.slice();
                if (q) {
                    rows = rows.filter((r) => r.symbol.includes(q));
                }

                rows.sort((a, b) => {
                    const av = a[sortKey];
                    const bv = b[sortKey];

                    let cmp = 0;
                    if (typeof av === "number" && typeof bv === "number") {
                        cmp = av - bv;
                    } else {
                        cmp = String(av).localeCompare(String(bv));
                    }
                    return sortDir === "asc" ? cmp : -cmp;
                });

                rowCountEl.textContent = String(rows.length);

                tbody.innerHTML = rows
                    .map((r) => {
                        const sideClass = r.side === "LONG" ? "good" : r.side === "SHORT" ? "bad" : "muted";
                        const sideTxt = r.side === "LONG" ? "LONG" : r.side === "SHORT" ? "SHORT" : "-";

                        const quoteVolTxt = Number.isFinite(r.quoteVol) ? fmt(r.quoteVol, 0) : "-";
                        const riskTxt = Number.isFinite(r.riskPct) ? fmtPct(r.riskPct, 2) : "-";
                        const atrTxt = Number.isFinite(r.atrPct) ? fmtPct(r.atrPct, 2) : "-";

                        return `
                            <tr>
                                <td class="mono">${r.symbol}</td>
                                <td class="${sideClass}">${sideTxt}</td>
                                <td class="mono">${fmt(r.score, 3)}</td>
                                <td class="mono">${fmt(r.price, 6)}</td>
                                <td class="mono">${fmt(r.stop, 6)}</td>
                                <td class="mono">${fmt(r.tp, 6)}</td>
                                <td class="mono">${riskTxt}</td>
                                <td class="mono">${atrTxt}</td>
                                <td class="mono">${quoteVolTxt}</td>
                                <td class="muted">${r.note || ""}</td>
                            </tr>
                        `;
                    })
                    .join("");
            }

            function setSort(key) {
                if (sortKey === key) {
                    sortDir = sortDir === "desc" ? "asc" : "desc";
                } else {
                    sortKey = key;
                    sortDir = "desc";
                }
                sortLabel.textContent = `${sortKey} ${sortDir === "desc" ? "↓" : "↑"}`;
                renderTable();
            }

            table.querySelectorAll("th").forEach((th) => {
                th.addEventListener("click", () => {
                    const key = th.getAttribute("data-key");
                    if (!key) return;
                    setSort(key);
                });
            });

            searchEl.addEventListener("input", () => renderTable());

            // =========================
            // Backtest Portfolio
            // =========================
            function simulatePortfolio(trades, config) {
                // trades: { entryTime, exitTime, rawMove, riskPct, score, symbol, side, exitReason }
                const feeRoundTrip = config.feeRoundTrip;
                const riskPct = config.riskPct;
                const maxNotionalMult = config.maxNotionalMult;

                let equity = 1.0;
                let peak = 1.0;
                let mdd = 0.0;

                let win = 0;
                let taken = 0;

                let cursorTime = -Infinity;

                // entryTime 순 정렬
                const sorted = trades.slice().sort((a, b) => a.entryTime - b.entryTime);

                let i = 0;
                while (i < sorted.length) {
                    if (abortFlag) throw new Error("ABORTED");

                    // 다음 가능한 entryTime 찾기
                    while (i < sorted.length && sorted[i].entryTime <= cursorTime) {
                        i += 1;
                    }
                    if (i >= sorted.length) break;

                    const t0 = sorted[i].entryTime;

                    // 같은 entryTime 그룹에서 score 최상 선택
                    let j = i;
                    let best = null;
                    while (j < sorted.length && sorted[j].entryTime === t0) {
                        const cand = sorted[j];
                        if (cand.entryTime > cursorTime) {
                            if (!best || cand.score > best.score) best = cand;
                        }
                        j += 1;
                    }

                    if (!best) {
                        i = j;
                        continue;
                    }

                    // 포지션 사이징: 손절폭(riskPctOfPrice)로 riskPct(자본) 맞추되, maxNotionalMult 제한
                    const stopDistPct = best.riskPct;
                    if (!Number.isFinite(stopDistPct) || stopDistPct <= 0) {
                        i = j;
                        continue;
                    }

                    let notional = equity * (riskPct / stopDistPct);
                    const maxNotional = equity * maxNotionalMult;
                    notional = Math.min(notional, maxNotional);

                    // 수익률 적용: rawMove는 방향 반영된 % (예: +0.01 = +1%)
                    const grossPnl = notional * best.rawMove;
                    const fee = notional * feeRoundTrip;

                    equity = equity + grossPnl - fee;

                    taken += 1;
                    if (best.rawMove > 0) win += 1;

                    if (equity > peak) peak = equity;
                    const dd = peak > 0 ? (peak - equity) / peak : 0;
                    if (dd > mdd) mdd = dd;

                    cursorTime = best.exitTime;

                    i = j;
                }

                const ret = equity - 1.0;
                const winRate = taken > 0 ? win / taken : 0;

                return { ret, equity, taken, winRate, mdd };
            }

            // =========================
            // Main logic
            // =========================
            function readConfig() {
                const mode = modeEl.value;
                const interval = intervalEl.value;
                const topN = clamp(parseNum(topNEl.value, 20), 1, 200);
                const minQuoteVol = Math.max(0, parseNum(minQuoteVolEl.value, 0));
                const concurrency = clamp(parseNum(concurrencyEl.value, 3), 1, 6);

                const emaFast = clamp(parseNum(emaFastEl.value, 50), 5, 400);
                const emaSlow = clamp(parseNum(emaSlowEl.value, 200), 10, 800);
                const breakoutLookback = clamp(parseNum(breakoutLookbackEl.value, 20), 5, 200);
                const volLen = clamp(parseNum(volLenEl.value, 20), 5, 200);
                const volMult = clamp(parseNum(volMultEl.value, 1.3), 1.0, 10.0);
                const minAtrPct = clamp(parseNum(minAtrPctEl.value, 0.4), 0, 100);
                const atrLen = clamp(parseNum(atrLenEl.value, 14), 5, 200);
                const stopAtrMult = clamp(parseNum(stopAtrMultEl.value, 1.8), 0.3, 10);
                const tpR = clamp(parseNum(tpREl.value, 1.5), 0.3, 10);
                const swingLookback = clamp(parseNum(swingLookbackEl.value, 10), 3, 100);
                const maxHoldBars = clamp(parseNum(maxHoldBarsEl.value, 48), 1, 10000);
                const minTrades = clamp(parseNum(minTradesEl.value, 30), 0, 100000);

                const feeRoundTrip = clamp(parseNum(feeRoundTripEl.value, 0.0008), 0, 0.01);
                const maxNotionalMult = clamp(parseNum(maxNotionalMultEl.value, 2.0), 0.2, 20.0);
                const riskPct = clamp(parseNum(riskPctEl.value, 0.005), 0.0001, 0.2);
                const startDate = (startDateEl.value || "2026-01-01").trim();

                return {
                    mode,
                    interval,
                    topN,
                    minQuoteVol,
                    concurrency,
                    emaFast,
                    emaSlow,
                    breakoutLookback,
                    volLen,
                    volMult,
                    minAtrPct,
                    atrLen,
                    stopAtrMult,
                    tpR,
                    swingLookback,
                    maxHoldBars,
                    minTrades,
                    feeRoundTrip,
                    maxNotionalMult,
                    riskPct,
                    startDate,
                };
            }

            async function run() {
                abortFlag = false;
                stopBtn.disabled = false;
                runBtn.disabled = true;
                exportBtn.disabled = true;

                clearResults();
                logEl.textContent = "";

                const cfg = readConfig();

                setState(cfg.mode === "scan" ? "현재 스캔" : "백테스트");
                setSymbol("-");
                setProgress(0, 0);

                log(`모드=${cfg.mode} interval=${cfg.interval} minQuoteVol=${fmt(cfg.minQuoteVol, 0)} TopN=${cfg.topN}`);

                const limiter = createLimiter(cfg.concurrency, 120);

                const [symbols, tickerMap] = await Promise.all([
                    getExchangeSymbols(limiter),
                    getTicker24hMap(limiter),
                ]);

                const filtered = symbols.filter((sym) => {
                    const t = tickerMap[sym];
                    if (!t || !Number.isFinite(t.quoteVolume)) return false;
                    return t.quoteVolume >= cfg.minQuoteVol;
                });

                log(`심볼 수: 전체=${symbols.length}, 거래대금 필터 통과=${filtered.length}`);

                setProgress(0, filtered.length);

                if (cfg.mode === "scan") {
                    await runScan(cfg, limiter, filtered, tickerMap);
                } else {
                    await runBacktest(cfg, limiter, filtered, tickerMap);
                }

                setState("완료");
                stopBtn.disabled = true;
                runBtn.disabled = false;
                setSymbol("-");
            }

            async function runScan(cfg, limiter, symbols, tickerMap) {
                setState("현재 스캔 실행");
                latestRows = [];

                const intervalMs = intervalToMs(cfg.interval);

                let done = 0;

                const tasks = symbols.map((symbol) => async () => {
                    if (abortFlag) return;

                    setSymbol(symbol);

                    // 최근 데이터(충분한 워밍업)
                    const needBars = Math.max(cfg.emaSlow, cfg.breakoutLookback, cfg.atrLen, cfg.volLen) + 60;
                    const endTime = Date.now();
                    const startTime = endTime - needBars * intervalMs * 2;

                    let bars = [];
                    try {
                        bars = await fetchKlinesPaged(limiter, symbol, cfg.interval, startTime, endTime);
                    } catch (err) {
                        log(`FAIL ${symbol}: ${String(err.message || err)}`);
                        return;
                    }

                    if (bars.length < Math.max(cfg.emaSlow, cfg.breakoutLookback) + 5) return;

                    const closes = bars.map((b) => b.c);
                    const highs = bars.map((b) => b.h);
                    const lows = bars.map((b) => b.l);
                    const vols = bars.map((b) => b.v);

                    const emaFastArr = ema(closes, cfg.emaFast);
                    const emaSlowArr = ema(closes, cfg.emaSlow);
                    const atrArr = atr(bars, cfg.atrLen);
                    const volSmaArr = sma(vols, cfg.volLen);

                    const warm = Math.max(cfg.emaSlow, cfg.breakoutLookback, cfg.atrLen, cfg.volLen) + 2;
                    const i = bars.length - 2; // 마지막 닫힌 캔들
                    if (i < warm) return;

                    const signalConfig = {
                        ...cfg,
                        _closes: closes,
                        _highs: highs,
                        _lows: lows,
                        _vols: vols,
                        _emaFast: emaFastArr,
                        _emaSlow: emaSlowArr,
                        _atr: atrArr,
                        _volSma: volSmaArr,
                    };

                    const sig = buildSignalForIndex(bars, i, signalConfig);
                    if (!sig) return;

                    // 현재 스캔은 "기준 가격"을 마지막 종가로 표시(진입은 next open이 아닌 제안)
                    const refPrice = closes[i];

                    latestRows.push({
                        symbol,
                        side: sig.side,
                        score: sig.score,
                        price: refPrice,
                        stop: sig.stop,
                        tp: sig.tp,
                        riskPct: sig.riskPct,
                        atrPct: sig.atrPct,
                        quoteVol: tickerMap[symbol]?.quoteVolume ?? NaN,
                        note: "신호캔들 종가 기준(진입은 규칙상 다음 시가)",
                    });
                });

                // 간단 병렬 실행(리미터가 실제 요청 속도 제어)
                const runners = tasks.map((fn) => fn().finally(() => {
                    done += 1;
                    setProgress(done, symbols.length);
                }));

                await Promise.all(runners);

                // Top-N
                latestRows.sort((a, b) => b.score - a.score);
                latestRows = latestRows.slice(0, cfg.topN);

                renderTable();
                log(`현재 스캔 후보=${latestRows.length} (TopN 적용)`);

                // KPI는 스캔 모드에서는 "-" 유지
                kpiPortRet.textContent = "-";
                kpiTrades.textContent = "-";
                kpiWin.textContent = "-";
                kpiMdd.textContent = "-";
            }

            async function runBacktest(cfg, limiter, symbols, tickerMap) {
                setState("백테스트 실행");

                const startMs = toMs(cfg.startDate);
                const endMs = Date.now();

                if (!Number.isFinite(startMs)) {
                    log("시작일 형식이 올바르지 않습니다. 예: 2026-01-01");
                    return;
                }

                log(`백테스트 구간: ${cfg.startDate} (UTC 00:00) ~ 현재`);
                latestTrades = [];
                latestRows = [];

                let done = 0;

                const intervalMs = intervalToMs(cfg.interval);

                const tasks = symbols.map((symbol) => async () => {
                    if (abortFlag) return;

                    setSymbol(symbol);

                    let bars = [];
                    try {
                        bars = await fetchKlinesPaged(limiter, symbol, cfg.interval, startMs, endMs);
                    } catch (err) {
                        log(`FAIL ${symbol}: ${String(err.message || err)}`);
                        return;
                    }

                    // 워밍업+신호 생성
                    const warm = Math.max(cfg.emaSlow, cfg.breakoutLookback, cfg.atrLen, cfg.volLen) + 3;
                    if (bars.length < warm + 10) return;

                    const closes = bars.map((b) => b.c);
                    const highs = bars.map((b) => b.h);
                    const lows = bars.map((b) => b.l);
                    const vols = bars.map((b) => b.v);

                    const emaFastArr = ema(closes, cfg.emaFast);
                    const emaSlowArr = ema(closes, cfg.emaSlow);
                    const atrArr = atr(bars, cfg.atrLen);
                    const volSmaArr = sma(vols, cfg.volLen);

                    const signalConfig = {
                        ...cfg,
                        _closes: closes,
                        _highs: highs,
                        _lows: lows,
                        _vols: vols,
                        _emaFast: emaFastArr,
                        _emaSlow: emaSlowArr,
                        _atr: atrArr,
                        _volSma: volSmaArr,
                    };

                    const perSymbolTrades = [];

                    for (let i = warm; i < bars.length - 2; i += 1) {
                        const sig = buildSignalForIndex(bars, i, signalConfig);
                        if (!sig) continue;

                        const entryIndex = i + 1;
                        const exit = simulateTradeExit(bars, entryIndex, sig, cfg);

                        perSymbolTrades.push({
                            symbol,
                            side: sig.side,
                            score: sig.score,
                            entryTime: sig.entryTime,
                            entry: sig.entry,
                            stop: sig.stop,
                            tp: sig.tp,
                            riskPct: sig.riskPct,
                            atrPct: sig.atrPct,
                            exitTime: exit.exitTime,
                            exitPrice: exit.exitPrice,
                            exitReason: exit.exitReason,
                            rawMove: exit.rawMove, // 방향 반영 수익률 (수수료 전)
                            quoteVol: tickerMap[symbol]?.quoteVolume ?? NaN,
                        });
                    }

                    // 표본 너무 적으면 심볼을 "랭킹"에서는 제외(트레이드는 포트폴리오 후보로는 남겨둘 수도 있지만, 여기선 동일 처리)
                    if (perSymbolTrades.length < cfg.minTrades) {
                        return;
                    }

                    // 심볼 요약을 rows에 넣기(기댓값 느낌: 평균 rawMove - 수수료)
                    let sum = 0;
                    let win = 0;
                    for (const t of perSymbolTrades) {
                        const net = t.rawMove - cfg.feeRoundTrip;
                        sum += net;
                        if (net > 0) win += 1;
                    }
                    const avg = perSymbolTrades.length > 0 ? sum / perSymbolTrades.length : 0;
                    const winRate = perSymbolTrades.length > 0 ? win / perSymbolTrades.length : 0;

                    latestRows.push({
                        symbol,
                        side: "-",
                        score: avg, // 여기서는 "평균 net"을 score처럼 사용
                        price: tickerMap[symbol]?.lastPrice ?? NaN,
                        stop: NaN,
                        tp: NaN,
                        riskPct: NaN,
                        atrPct: NaN,
                        quoteVol: tickerMap[symbol]?.quoteVolume ?? NaN,
                        note: `심볼평균(net): ${fmtPct(avg, 2)} / 승률: ${(winRate * 100).toFixed(1)}% / 트레이드: ${perSymbolTrades.length}`,
                    });

                    // 포트폴리오 후보(trades)에 추가
                    for (const t of perSymbolTrades) {
                        latestTrades.push(t);
                    }
                });

                const runners = tasks.map((fn) => fn().finally(() => {
                    done += 1;
                    setProgress(done, symbols.length);
                }));

                await Promise.all(runners);

                // 포트폴리오 시뮬레이션(동일 entryTime 그룹 중 score 최고만 선택, 1포지션)
                const port = simulatePortfolio(latestTrades, cfg);

                // KPI
                kpiPortRet.textContent = port.taken > 0 ? fmtPct(port.ret, 2) : "-";
                kpiTrades.textContent = String(port.taken);
                kpiWin.textContent = port.taken > 0 ? (port.winRate * 100).toFixed(1) + "%" : "-";
                kpiMdd.textContent = port.taken > 0 ? (port.mdd * 100).toFixed(1) + "%" : "-";

                // 테이블에는 심볼 요약(평균 net 기준) 상위로 보여주기
                latestRows.sort((a, b) => b.score - a.score);
                renderTable();

                log(`백테스트 trades(표본필터 적용 후 포함): ${latestTrades.length}`);
                log(`포트폴리오(1포지션) taken=${port.taken} 최종수익률=${fmtPct(port.ret, 2)} MDD=${(port.mdd * 100).toFixed(1)}%`);

                exportBtn.disabled = latestTrades.length === 0;
            }

            // =========================
            // CSV Export
            // =========================
            function downloadCSV(filename, rows) {
                const esc = (s) => {
                    const t = String(s ?? "");
                    if (t.includes(",") || t.includes('"') || t.includes("\n")) {
                        return `"${t.replaceAll('"', '""')}"`;
                    }
                    return t;
                };

                const header = [
                    "symbol",
                    "side",
                    "score",
                    "entryTime",
                    "entry",
                    "stop",
                    "tp",
                    "riskPct",
                    "exitTime",
                    "exitPrice",
                    "exitReason",
                    "rawMove",
                    "feeRoundTrip",
                ];

                const lines = [];
                lines.push(header.join(","));

                const fee = parseNum(feeRoundTripEl.value, 0.0008);

                for (const r of rows) {
                    const line = [
                        r.symbol,
                        r.side,
                        r.score,
                        new Date(r.entryTime).toISOString(),
                        r.entry,
                        r.stop,
                        r.tp,
                        r.riskPct,
                        new Date(r.exitTime).toISOString(),
                        r.exitPrice,
                        r.exitReason,
                        r.rawMove,
                        fee,
                    ].map(esc).join(",");
                    lines.push(line);
                }

                const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            }

            // =========================
            // Events
            // =========================
            runBtn.addEventListener("click", async () => {
                try {
                    await run();
                } catch (err) {
                    if (String(err.message || err) === "ABORTED") {
                        log("중지됨.");
                        setState("중지됨");
                    } else {
                        log(`에러: ${String(err.message || err)}`);
                        setState("에러");
                    }
                    stopBtn.disabled = true;
                    runBtn.disabled = false;
                    setSymbol("-");
                }
            });

            stopBtn.addEventListener("click", () => {
                abortFlag = true;
                stopBtn.disabled = true;
                setState("중지 요청");
                log("중지 요청됨(진행 중 요청 완료 후 종료).");
            });

            exportBtn.addEventListener("click", () => {
                if (!latestTrades || latestTrades.length === 0) return;
                downloadCSV("binance_perp_backtest_trades.csv", latestTrades);
            });

            clearBtn.addEventListener("click", () => {
                abortFlag = false;
                logEl.textContent = "";
                clearResults();
                setState("대기");
                setSymbol("-");
                setProgress(0, 0);
            });

            // 초기 정렬 라벨
            sortLabel.textContent = `${sortKey} ${sortDir === "desc" ? "↓" : "↑"}`;

            log("준비 완료. 실행을 누르세요.");
        </script>
    </body>
</html>
